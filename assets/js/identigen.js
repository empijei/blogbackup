"use strict";
(function() {

Error.stackTraceLimit = Infinity;

var $global, $module;
if (typeof window !== "undefined") { /* web page */
  $global = window;
} else if (typeof self !== "undefined") { /* web worker */
  $global = self;
} else if (typeof global !== "undefined") { /* Node.js */
  $global = global;
  $global.require = require;
} else { /* others (e.g. Nashorn) */
  $global = this;
}

if ($global === undefined || $global.Array === undefined) {
  throw new Error("no global object found");
}
if (typeof module !== "undefined") {
  $module = module;
}

var $packages = {}, $idCounter = 0;
var $keys = function(m) { return m ? Object.keys(m) : []; };
var $flushConsole = function() {};
var $throwRuntimeError; /* set by package "runtime" */
var $throwNilPointerError = function() { $throwRuntimeError("invalid memory address or nil pointer dereference"); };
var $call = function(fn, rcvr, args) { return fn.apply(rcvr, args); };
var $makeFunc = function(fn) { return function() { return $externalize(fn(this, new ($sliceType($jsObjectPtr))($global.Array.prototype.slice.call(arguments, []))), $emptyInterface); }; };
var $unused = function(v) {};

var $mapArray = function(array, f) {
  var newArray = new array.constructor(array.length);
  for (var i = 0; i < array.length; i++) {
    newArray[i] = f(array[i]);
  }
  return newArray;
};

var $methodVal = function(recv, name) {
  var vals = recv.$methodVals || {};
  recv.$methodVals = vals; /* noop for primitives */
  var f = vals[name];
  if (f !== undefined) {
    return f;
  }
  var method = recv[name];
  f = function() {
    $stackDepthOffset--;
    try {
      return method.apply(recv, arguments);
    } finally {
      $stackDepthOffset++;
    }
  };
  vals[name] = f;
  return f;
};

var $methodExpr = function(typ, name) {
  var method = typ.prototype[name];
  if (method.$expr === undefined) {
    method.$expr = function() {
      $stackDepthOffset--;
      try {
        if (typ.wrapped) {
          arguments[0] = new typ(arguments[0]);
        }
        return Function.call.apply(method, arguments);
      } finally {
        $stackDepthOffset++;
      }
    };
  }
  return method.$expr;
};

var $ifaceMethodExprs = {};
var $ifaceMethodExpr = function(name) {
  var expr = $ifaceMethodExprs["$" + name];
  if (expr === undefined) {
    expr = $ifaceMethodExprs["$" + name] = function() {
      $stackDepthOffset--;
      try {
        return Function.call.apply(arguments[0][name], arguments);
      } finally {
        $stackDepthOffset++;
      }
    };
  }
  return expr;
};

var $subslice = function(slice, low, high, max) {
  if (low < 0 || high < low || max < high || high > slice.$capacity || max > slice.$capacity) {
    $throwRuntimeError("slice bounds out of range");
  }
  var s = new slice.constructor(slice.$array);
  s.$offset = slice.$offset + low;
  s.$length = slice.$length - low;
  s.$capacity = slice.$capacity - low;
  if (high !== undefined) {
    s.$length = high - low;
  }
  if (max !== undefined) {
    s.$capacity = max - low;
  }
  return s;
};

var $substring = function(str, low, high) {
  if (low < 0 || high < low || high > str.length) {
    $throwRuntimeError("slice bounds out of range");
  }
  return str.substring(low, high);
};

var $sliceToArray = function(slice) {
  if (slice.$array.constructor !== Array) {
    return slice.$array.subarray(slice.$offset, slice.$offset + slice.$length);
  }
  return slice.$array.slice(slice.$offset, slice.$offset + slice.$length);
};

var $decodeRune = function(str, pos) {
  var c0 = str.charCodeAt(pos);

  if (c0 < 0x80) {
    return [c0, 1];
  }

  if (c0 !== c0 || c0 < 0xC0) {
    return [0xFFFD, 1];
  }

  var c1 = str.charCodeAt(pos + 1);
  if (c1 !== c1 || c1 < 0x80 || 0xC0 <= c1) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xE0) {
    var r = (c0 & 0x1F) << 6 | (c1 & 0x3F);
    if (r <= 0x7F) {
      return [0xFFFD, 1];
    }
    return [r, 2];
  }

  var c2 = str.charCodeAt(pos + 2);
  if (c2 !== c2 || c2 < 0x80 || 0xC0 <= c2) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xF0) {
    var r = (c0 & 0x0F) << 12 | (c1 & 0x3F) << 6 | (c2 & 0x3F);
    if (r <= 0x7FF) {
      return [0xFFFD, 1];
    }
    if (0xD800 <= r && r <= 0xDFFF) {
      return [0xFFFD, 1];
    }
    return [r, 3];
  }

  var c3 = str.charCodeAt(pos + 3);
  if (c3 !== c3 || c3 < 0x80 || 0xC0 <= c3) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xF8) {
    var r = (c0 & 0x07) << 18 | (c1 & 0x3F) << 12 | (c2 & 0x3F) << 6 | (c3 & 0x3F);
    if (r <= 0xFFFF || 0x10FFFF < r) {
      return [0xFFFD, 1];
    }
    return [r, 4];
  }

  return [0xFFFD, 1];
};

var $encodeRune = function(r) {
  if (r < 0 || r > 0x10FFFF || (0xD800 <= r && r <= 0xDFFF)) {
    r = 0xFFFD;
  }
  if (r <= 0x7F) {
    return String.fromCharCode(r);
  }
  if (r <= 0x7FF) {
    return String.fromCharCode(0xC0 | r >> 6, 0x80 | (r & 0x3F));
  }
  if (r <= 0xFFFF) {
    return String.fromCharCode(0xE0 | r >> 12, 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));
  }
  return String.fromCharCode(0xF0 | r >> 18, 0x80 | (r >> 12 & 0x3F), 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));
};

var $stringToBytes = function(str) {
  var array = new Uint8Array(str.length);
  for (var i = 0; i < str.length; i++) {
    array[i] = str.charCodeAt(i);
  }
  return array;
};

var $bytesToString = function(slice) {
  if (slice.$length === 0) {
    return "";
  }
  var str = "";
  for (var i = 0; i < slice.$length; i += 10000) {
    str += String.fromCharCode.apply(undefined, slice.$array.subarray(slice.$offset + i, slice.$offset + Math.min(slice.$length, i + 10000)));
  }
  return str;
};

var $stringToRunes = function(str) {
  var array = new Int32Array(str.length);
  var rune, j = 0;
  for (var i = 0; i < str.length; i += rune[1], j++) {
    rune = $decodeRune(str, i);
    array[j] = rune[0];
  }
  return array.subarray(0, j);
};

var $runesToString = function(slice) {
  if (slice.$length === 0) {
    return "";
  }
  var str = "";
  for (var i = 0; i < slice.$length; i++) {
    str += $encodeRune(slice.$array[slice.$offset + i]);
  }
  return str;
};

var $copyString = function(dst, src) {
  var n = Math.min(src.length, dst.$length);
  for (var i = 0; i < n; i++) {
    dst.$array[dst.$offset + i] = src.charCodeAt(i);
  }
  return n;
};

var $copySlice = function(dst, src) {
  var n = Math.min(src.$length, dst.$length);
  $copyArray(dst.$array, src.$array, dst.$offset, src.$offset, n, dst.constructor.elem);
  return n;
};

var $copyArray = function(dst, src, dstOffset, srcOffset, n, elem) {
  if (n === 0 || (dst === src && dstOffset === srcOffset)) {
    return;
  }

  if (src.subarray) {
    dst.set(src.subarray(srcOffset, srcOffset + n), dstOffset);
    return;
  }

  switch (elem.kind) {
  case $kindArray:
  case $kindStruct:
    if (dst === src && dstOffset > srcOffset) {
      for (var i = n - 1; i >= 0; i--) {
        elem.copy(dst[dstOffset + i], src[srcOffset + i]);
      }
      return;
    }
    for (var i = 0; i < n; i++) {
      elem.copy(dst[dstOffset + i], src[srcOffset + i]);
    }
    return;
  }

  if (dst === src && dstOffset > srcOffset) {
    for (var i = n - 1; i >= 0; i--) {
      dst[dstOffset + i] = src[srcOffset + i];
    }
    return;
  }
  for (var i = 0; i < n; i++) {
    dst[dstOffset + i] = src[srcOffset + i];
  }
};

var $clone = function(src, type) {
  var clone = type.zero();
  type.copy(clone, src);
  return clone;
};

var $pointerOfStructConversion = function(obj, type) {
  if(obj.$proxies === undefined) {
    obj.$proxies = {};
    obj.$proxies[obj.constructor.string] = obj;
  }
  var proxy = obj.$proxies[type.string];
  if (proxy === undefined) {
    var properties = {};
    for (var i = 0; i < type.elem.fields.length; i++) {
      (function(fieldProp) {
        properties[fieldProp] = {
          get: function() { return obj[fieldProp]; },
          set: function(value) { obj[fieldProp] = value; }
        };
      })(type.elem.fields[i].prop);
    }
    proxy = Object.create(type.prototype, properties);
    proxy.$val = proxy;
    obj.$proxies[type.string] = proxy;
    proxy.$proxies = obj.$proxies;
  }
  return proxy;
};

var $append = function(slice) {
  return $internalAppend(slice, arguments, 1, arguments.length - 1);
};

var $appendSlice = function(slice, toAppend) {
  if (toAppend.constructor === String) {
    var bytes = $stringToBytes(toAppend);
    return $internalAppend(slice, bytes, 0, bytes.length);
  }
  return $internalAppend(slice, toAppend.$array, toAppend.$offset, toAppend.$length);
};

var $internalAppend = function(slice, array, offset, length) {
  if (length === 0) {
    return slice;
  }

  var newArray = slice.$array;
  var newOffset = slice.$offset;
  var newLength = slice.$length + length;
  var newCapacity = slice.$capacity;

  if (newLength > newCapacity) {
    newOffset = 0;
    newCapacity = Math.max(newLength, slice.$capacity < 1024 ? slice.$capacity * 2 : Math.floor(slice.$capacity * 5 / 4));

    if (slice.$array.constructor === Array) {
      newArray = slice.$array.slice(slice.$offset, slice.$offset + slice.$length);
      newArray.length = newCapacity;
      var zero = slice.constructor.elem.zero;
      for (var i = slice.$length; i < newCapacity; i++) {
        newArray[i] = zero();
      }
    } else {
      newArray = new slice.$array.constructor(newCapacity);
      newArray.set(slice.$array.subarray(slice.$offset, slice.$offset + slice.$length));
    }
  }

  $copyArray(newArray, array, newOffset + slice.$length, offset, length, slice.constructor.elem);

  var newSlice = new slice.constructor(newArray);
  newSlice.$offset = newOffset;
  newSlice.$length = newLength;
  newSlice.$capacity = newCapacity;
  return newSlice;
};

var $equal = function(a, b, type) {
  if (type === $jsObjectPtr) {
    return a === b;
  }
  switch (type.kind) {
  case $kindComplex64:
  case $kindComplex128:
    return a.$real === b.$real && a.$imag === b.$imag;
  case $kindInt64:
  case $kindUint64:
    return a.$high === b.$high && a.$low === b.$low;
  case $kindArray:
    if (a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!$equal(a[i], b[i], type.elem)) {
        return false;
      }
    }
    return true;
  case $kindStruct:
    for (var i = 0; i < type.fields.length; i++) {
      var f = type.fields[i];
      if (!$equal(a[f.prop], b[f.prop], f.typ)) {
        return false;
      }
    }
    return true;
  case $kindInterface:
    return $interfaceIsEqual(a, b);
  default:
    return a === b;
  }
};

var $interfaceIsEqual = function(a, b) {
  if (a === $ifaceNil || b === $ifaceNil) {
    return a === b;
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a.constructor === $jsObjectPtr) {
    return a.object === b.object;
  }
  if (!a.constructor.comparable) {
    $throwRuntimeError("comparing uncomparable type " + a.constructor.string);
  }
  return $equal(a.$val, b.$val, a.constructor);
};

var $min = Math.min;
var $mod = function(x, y) { return x % y; };
var $parseInt = parseInt;
var $parseFloat = function(f) {
  if (f !== undefined && f !== null && f.constructor === Number) {
    return f;
  }
  return parseFloat(f);
};

var $froundBuf = new Float32Array(1);
var $fround = Math.fround || function(f) {
  $froundBuf[0] = f;
  return $froundBuf[0];
};

var $imul = Math.imul || function(a, b) {
  var ah = (a >>> 16) & 0xffff;
  var al = a & 0xffff;
  var bh = (b >>> 16) & 0xffff;
  var bl = b & 0xffff;
  return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) >> 0);
};

var $floatKey = function(f) {
  if (f !== f) {
    $idCounter++;
    return "NaN$" + $idCounter;
  }
  return String(f);
};

var $flatten64 = function(x) {
  return x.$high * 4294967296 + x.$low;
};

var $shiftLeft64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high << y | x.$low >>> (32 - y), (x.$low << y) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(x.$low << (y - 32), 0);
  }
  return new x.constructor(0, 0);
};

var $shiftRightInt64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high >> y, (x.$low >>> y | x.$high << (32 - y)) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(x.$high >> 31, (x.$high >> (y - 32)) >>> 0);
  }
  if (x.$high < 0) {
    return new x.constructor(-1, 4294967295);
  }
  return new x.constructor(0, 0);
};

var $shiftRightUint64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high >>> y, (x.$low >>> y | x.$high << (32 - y)) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(0, x.$high >>> (y - 32));
  }
  return new x.constructor(0, 0);
};

var $mul64 = function(x, y) {
  var high = 0, low = 0;
  if ((y.$low & 1) !== 0) {
    high = x.$high;
    low = x.$low;
  }
  for (var i = 1; i < 32; i++) {
    if ((y.$low & 1<<i) !== 0) {
      high += x.$high << i | x.$low >>> (32 - i);
      low += (x.$low << i) >>> 0;
    }
  }
  for (var i = 0; i < 32; i++) {
    if ((y.$high & 1<<i) !== 0) {
      high += x.$low << i;
    }
  }
  return new x.constructor(high, low);
};

var $div64 = function(x, y, returnRemainder) {
  if (y.$high === 0 && y.$low === 0) {
    $throwRuntimeError("integer divide by zero");
  }

  var s = 1;
  var rs = 1;

  var xHigh = x.$high;
  var xLow = x.$low;
  if (xHigh < 0) {
    s = -1;
    rs = -1;
    xHigh = -xHigh;
    if (xLow !== 0) {
      xHigh--;
      xLow = 4294967296 - xLow;
    }
  }

  var yHigh = y.$high;
  var yLow = y.$low;
  if (y.$high < 0) {
    s *= -1;
    yHigh = -yHigh;
    if (yLow !== 0) {
      yHigh--;
      yLow = 4294967296 - yLow;
    }
  }

  var high = 0, low = 0, n = 0;
  while (yHigh < 2147483648 && ((xHigh > yHigh) || (xHigh === yHigh && xLow > yLow))) {
    yHigh = (yHigh << 1 | yLow >>> 31) >>> 0;
    yLow = (yLow << 1) >>> 0;
    n++;
  }
  for (var i = 0; i <= n; i++) {
    high = high << 1 | low >>> 31;
    low = (low << 1) >>> 0;
    if ((xHigh > yHigh) || (xHigh === yHigh && xLow >= yLow)) {
      xHigh = xHigh - yHigh;
      xLow = xLow - yLow;
      if (xLow < 0) {
        xHigh--;
        xLow += 4294967296;
      }
      low++;
      if (low === 4294967296) {
        high++;
        low = 0;
      }
    }
    yLow = (yLow >>> 1 | yHigh << (32 - 1)) >>> 0;
    yHigh = yHigh >>> 1;
  }

  if (returnRemainder) {
    return new x.constructor(xHigh * rs, xLow * rs);
  }
  return new x.constructor(high * s, low * s);
};

var $divComplex = function(n, d) {
  var ninf = n.$real === Infinity || n.$real === -Infinity || n.$imag === Infinity || n.$imag === -Infinity;
  var dinf = d.$real === Infinity || d.$real === -Infinity || d.$imag === Infinity || d.$imag === -Infinity;
  var nnan = !ninf && (n.$real !== n.$real || n.$imag !== n.$imag);
  var dnan = !dinf && (d.$real !== d.$real || d.$imag !== d.$imag);
  if(nnan || dnan) {
    return new n.constructor(NaN, NaN);
  }
  if (ninf && !dinf) {
    return new n.constructor(Infinity, Infinity);
  }
  if (!ninf && dinf) {
    return new n.constructor(0, 0);
  }
  if (d.$real === 0 && d.$imag === 0) {
    if (n.$real === 0 && n.$imag === 0) {
      return new n.constructor(NaN, NaN);
    }
    return new n.constructor(Infinity, Infinity);
  }
  var a = Math.abs(d.$real);
  var b = Math.abs(d.$imag);
  if (a <= b) {
    var ratio = d.$real / d.$imag;
    var denom = d.$real * ratio + d.$imag;
    return new n.constructor((n.$real * ratio + n.$imag) / denom, (n.$imag * ratio - n.$real) / denom);
  }
  var ratio = d.$imag / d.$real;
  var denom = d.$imag * ratio + d.$real;
  return new n.constructor((n.$imag * ratio + n.$real) / denom, (n.$imag - n.$real * ratio) / denom);
};

var $kindBool = 1;
var $kindInt = 2;
var $kindInt8 = 3;
var $kindInt16 = 4;
var $kindInt32 = 5;
var $kindInt64 = 6;
var $kindUint = 7;
var $kindUint8 = 8;
var $kindUint16 = 9;
var $kindUint32 = 10;
var $kindUint64 = 11;
var $kindUintptr = 12;
var $kindFloat32 = 13;
var $kindFloat64 = 14;
var $kindComplex64 = 15;
var $kindComplex128 = 16;
var $kindArray = 17;
var $kindChan = 18;
var $kindFunc = 19;
var $kindInterface = 20;
var $kindMap = 21;
var $kindPtr = 22;
var $kindSlice = 23;
var $kindString = 24;
var $kindStruct = 25;
var $kindUnsafePointer = 26;

var $methodSynthesizers = [];
var $addMethodSynthesizer = function(f) {
  if ($methodSynthesizers === null) {
    f();
    return;
  }
  $methodSynthesizers.push(f);
};
var $synthesizeMethods = function() {
  $methodSynthesizers.forEach(function(f) { f(); });
  $methodSynthesizers = null;
};

var $ifaceKeyFor = function(x) {
  if (x === $ifaceNil) {
    return 'nil';
  }
  var c = x.constructor;
  return c.string + '$' + c.keyFor(x.$val);
};

var $identity = function(x) { return x; };

var $typeIDCounter = 0;

var $idKey = function(x) {
  if (x.$id === undefined) {
    $idCounter++;
    x.$id = $idCounter;
  }
  return String(x.$id);
};

var $newType = function(size, kind, string, named, pkg, exported, constructor) {
  var typ;
  switch(kind) {
  case $kindBool:
  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8:
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindUnsafePointer:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = $identity;
    break;

  case $kindString:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = function(x) { return "$" + x; };
    break;

  case $kindFloat32:
  case $kindFloat64:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = function(x) { return $floatKey(x); };
    break;

  case $kindInt64:
    typ = function(high, low) {
      this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >> 0;
      this.$low = low >>> 0;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$high + "$" + x.$low; };
    break;

  case $kindUint64:
    typ = function(high, low) {
      this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >>> 0;
      this.$low = low >>> 0;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$high + "$" + x.$low; };
    break;

  case $kindComplex64:
    typ = function(real, imag) {
      this.$real = $fround(real);
      this.$imag = $fround(imag);
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$real + "$" + x.$imag; };
    break;

  case $kindComplex128:
    typ = function(real, imag) {
      this.$real = real;
      this.$imag = imag;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$real + "$" + x.$imag; };
    break;

  case $kindArray:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.ptr = $newType(4, $kindPtr, "*" + string, false, "", false, function(array) {
      this.$get = function() { return array; };
      this.$set = function(v) { typ.copy(this, v); };
      this.$val = array;
    });
    typ.init = function(elem, len) {
      typ.elem = elem;
      typ.len = len;
      typ.comparable = elem.comparable;
      typ.keyFor = function(x) {
        return Array.prototype.join.call($mapArray(x, function(e) {
          return String(elem.keyFor(e)).replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
        }), "$");
      };
      typ.copy = function(dst, src) {
        $copyArray(dst, src, 0, 0, src.length, elem);
      };
      typ.ptr.init(typ);
      Object.defineProperty(typ.ptr.nil, "nilCheck", { get: $throwNilPointerError });
    };
    break;

  case $kindChan:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = $idKey;
    typ.init = function(elem, sendOnly, recvOnly) {
      typ.elem = elem;
      typ.sendOnly = sendOnly;
      typ.recvOnly = recvOnly;
    };
    break;

  case $kindFunc:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.init = function(params, results, variadic) {
      typ.params = params;
      typ.results = results;
      typ.variadic = variadic;
      typ.comparable = false;
    };
    break;

  case $kindInterface:
    typ = { implementedBy: {}, missingMethodFor: {} };
    typ.keyFor = $ifaceKeyFor;
    typ.init = function(methods) {
      typ.methods = methods;
      methods.forEach(function(m) {
        $ifaceNil[m.prop] = $throwNilPointerError;
      });
    };
    break;

  case $kindMap:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.init = function(key, elem) {
      typ.key = key;
      typ.elem = elem;
      typ.comparable = false;
    };
    break;

  case $kindPtr:
    typ = constructor || function(getter, setter, target) {
      this.$get = getter;
      this.$set = setter;
      this.$target = target;
      this.$val = this;
    };
    typ.keyFor = $idKey;
    typ.init = function(elem) {
      typ.elem = elem;
      typ.wrapped = (elem.kind === $kindArray);
      typ.nil = new typ($throwNilPointerError, $throwNilPointerError);
    };
    break;

  case $kindSlice:
    typ = function(array) {
      if (array.constructor !== typ.nativeArray) {
        array = new typ.nativeArray(array);
      }
      this.$array = array;
      this.$offset = 0;
      this.$length = array.length;
      this.$capacity = array.length;
      this.$val = this;
    };
    typ.init = function(elem) {
      typ.elem = elem;
      typ.comparable = false;
      typ.nativeArray = $nativeArray(elem.kind);
      typ.nil = new typ([]);
    };
    break;

  case $kindStruct:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.ptr = $newType(4, $kindPtr, "*" + string, false, pkg, exported, constructor);
    typ.ptr.elem = typ;
    typ.ptr.prototype.$get = function() { return this; };
    typ.ptr.prototype.$set = function(v) { typ.copy(this, v); };
    typ.init = function(pkgPath, fields) {
      typ.pkgPath = pkgPath;
      typ.fields = fields;
      fields.forEach(function(f) {
        if (!f.typ.comparable) {
          typ.comparable = false;
        }
      });
      typ.keyFor = function(x) {
        var val = x.$val;
        return $mapArray(fields, function(f) {
          return String(f.typ.keyFor(val[f.prop])).replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
        }).join("$");
      };
      typ.copy = function(dst, src) {
        for (var i = 0; i < fields.length; i++) {
          var f = fields[i];
          switch (f.typ.kind) {
          case $kindArray:
          case $kindStruct:
            f.typ.copy(dst[f.prop], src[f.prop]);
            continue;
          default:
            dst[f.prop] = src[f.prop];
            continue;
          }
        }
      };
      /* nil value */
      var properties = {};
      fields.forEach(function(f) {
        properties[f.prop] = { get: $throwNilPointerError, set: $throwNilPointerError };
      });
      typ.ptr.nil = Object.create(constructor.prototype, properties);
      typ.ptr.nil.$val = typ.ptr.nil;
      /* methods for embedded fields */
      $addMethodSynthesizer(function() {
        var synthesizeMethod = function(target, m, f) {
          if (target.prototype[m.prop] !== undefined) { return; }
          target.prototype[m.prop] = function() {
            var v = this.$val[f.prop];
            if (f.typ === $jsObjectPtr) {
              v = new $jsObjectPtr(v);
            }
            if (v.$val === undefined) {
              v = new f.typ(v);
            }
            return v[m.prop].apply(v, arguments);
          };
        };
        fields.forEach(function(f) {
          if (f.anonymous) {
            $methodSet(f.typ).forEach(function(m) {
              synthesizeMethod(typ, m, f);
              synthesizeMethod(typ.ptr, m, f);
            });
            $methodSet($ptrType(f.typ)).forEach(function(m) {
              synthesizeMethod(typ.ptr, m, f);
            });
          }
        });
      });
    };
    break;

  default:
    $panic(new $String("invalid kind: " + kind));
  }

  switch (kind) {
  case $kindBool:
  case $kindMap:
    typ.zero = function() { return false; };
    break;

  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8 :
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindUnsafePointer:
  case $kindFloat32:
  case $kindFloat64:
    typ.zero = function() { return 0; };
    break;

  case $kindString:
    typ.zero = function() { return ""; };
    break;

  case $kindInt64:
  case $kindUint64:
  case $kindComplex64:
  case $kindComplex128:
    var zero = new typ(0, 0);
    typ.zero = function() { return zero; };
    break;

  case $kindPtr:
  case $kindSlice:
    typ.zero = function() { return typ.nil; };
    break;

  case $kindChan:
    typ.zero = function() { return $chanNil; };
    break;

  case $kindFunc:
    typ.zero = function() { return $throwNilPointerError; };
    break;

  case $kindInterface:
    typ.zero = function() { return $ifaceNil; };
    break;

  case $kindArray:
    typ.zero = function() {
      var arrayClass = $nativeArray(typ.elem.kind);
      if (arrayClass !== Array) {
        return new arrayClass(typ.len);
      }
      var array = new Array(typ.len);
      for (var i = 0; i < typ.len; i++) {
        array[i] = typ.elem.zero();
      }
      return array;
    };
    break;

  case $kindStruct:
    typ.zero = function() { return new typ.ptr(); };
    break;

  default:
    $panic(new $String("invalid kind: " + kind));
  }

  typ.id = $typeIDCounter;
  $typeIDCounter++;
  typ.size = size;
  typ.kind = kind;
  typ.string = string;
  typ.named = named;
  typ.pkg = pkg;
  typ.exported = exported;
  typ.methods = [];
  typ.methodSetCache = null;
  typ.comparable = true;
  return typ;
};

var $methodSet = function(typ) {
  if (typ.methodSetCache !== null) {
    return typ.methodSetCache;
  }
  var base = {};

  var isPtr = (typ.kind === $kindPtr);
  if (isPtr && typ.elem.kind === $kindInterface) {
    typ.methodSetCache = [];
    return [];
  }

  var current = [{typ: isPtr ? typ.elem : typ, indirect: isPtr}];

  var seen = {};

  while (current.length > 0) {
    var next = [];
    var mset = [];

    current.forEach(function(e) {
      if (seen[e.typ.string]) {
        return;
      }
      seen[e.typ.string] = true;

      if (e.typ.named) {
        mset = mset.concat(e.typ.methods);
        if (e.indirect) {
          mset = mset.concat($ptrType(e.typ).methods);
        }
      }

      switch (e.typ.kind) {
      case $kindStruct:
        e.typ.fields.forEach(function(f) {
          if (f.anonymous) {
            var fTyp = f.typ;
            var fIsPtr = (fTyp.kind === $kindPtr);
            next.push({typ: fIsPtr ? fTyp.elem : fTyp, indirect: e.indirect || fIsPtr});
          }
        });
        break;

      case $kindInterface:
        mset = mset.concat(e.typ.methods);
        break;
      }
    });

    mset.forEach(function(m) {
      if (base[m.name] === undefined) {
        base[m.name] = m;
      }
    });

    current = next;
  }

  typ.methodSetCache = [];
  Object.keys(base).sort().forEach(function(name) {
    typ.methodSetCache.push(base[name]);
  });
  return typ.methodSetCache;
};

var $Bool          = $newType( 1, $kindBool,          "bool",           true, "", false, null);
var $Int           = $newType( 4, $kindInt,           "int",            true, "", false, null);
var $Int8          = $newType( 1, $kindInt8,          "int8",           true, "", false, null);
var $Int16         = $newType( 2, $kindInt16,         "int16",          true, "", false, null);
var $Int32         = $newType( 4, $kindInt32,         "int32",          true, "", false, null);
var $Int64         = $newType( 8, $kindInt64,         "int64",          true, "", false, null);
var $Uint          = $newType( 4, $kindUint,          "uint",           true, "", false, null);
var $Uint8         = $newType( 1, $kindUint8,         "uint8",          true, "", false, null);
var $Uint16        = $newType( 2, $kindUint16,        "uint16",         true, "", false, null);
var $Uint32        = $newType( 4, $kindUint32,        "uint32",         true, "", false, null);
var $Uint64        = $newType( 8, $kindUint64,        "uint64",         true, "", false, null);
var $Uintptr       = $newType( 4, $kindUintptr,       "uintptr",        true, "", false, null);
var $Float32       = $newType( 4, $kindFloat32,       "float32",        true, "", false, null);
var $Float64       = $newType( 8, $kindFloat64,       "float64",        true, "", false, null);
var $Complex64     = $newType( 8, $kindComplex64,     "complex64",      true, "", false, null);
var $Complex128    = $newType(16, $kindComplex128,    "complex128",     true, "", false, null);
var $String        = $newType( 8, $kindString,        "string",         true, "", false, null);
var $UnsafePointer = $newType( 4, $kindUnsafePointer, "unsafe.Pointer", true, "", false, null);

var $nativeArray = function(elemKind) {
  switch (elemKind) {
  case $kindInt:
    return Int32Array;
  case $kindInt8:
    return Int8Array;
  case $kindInt16:
    return Int16Array;
  case $kindInt32:
    return Int32Array;
  case $kindUint:
    return Uint32Array;
  case $kindUint8:
    return Uint8Array;
  case $kindUint16:
    return Uint16Array;
  case $kindUint32:
    return Uint32Array;
  case $kindUintptr:
    return Uint32Array;
  case $kindFloat32:
    return Float32Array;
  case $kindFloat64:
    return Float64Array;
  default:
    return Array;
  }
};
var $toNativeArray = function(elemKind, array) {
  var nativeArray = $nativeArray(elemKind);
  if (nativeArray === Array) {
    return array;
  }
  return new nativeArray(array);
};
var $arrayTypes = {};
var $arrayType = function(elem, len) {
  var typeKey = elem.id + "$" + len;
  var typ = $arrayTypes[typeKey];
  if (typ === undefined) {
    typ = $newType(12, $kindArray, "[" + len + "]" + elem.string, false, "", false, null);
    $arrayTypes[typeKey] = typ;
    typ.init(elem, len);
  }
  return typ;
};

var $chanType = function(elem, sendOnly, recvOnly) {
  var string = (recvOnly ? "<-" : "") + "chan" + (sendOnly ? "<- " : " ") + elem.string;
  var field = sendOnly ? "SendChan" : (recvOnly ? "RecvChan" : "Chan");
  var typ = elem[field];
  if (typ === undefined) {
    typ = $newType(4, $kindChan, string, false, "", false, null);
    elem[field] = typ;
    typ.init(elem, sendOnly, recvOnly);
  }
  return typ;
};
var $Chan = function(elem, capacity) {
  if (capacity < 0 || capacity > 2147483647) {
    $throwRuntimeError("makechan: size out of range");
  }
  this.$elem = elem;
  this.$capacity = capacity;
  this.$buffer = [];
  this.$sendQueue = [];
  this.$recvQueue = [];
  this.$closed = false;
};
var $chanNil = new $Chan(null, 0);
$chanNil.$sendQueue = $chanNil.$recvQueue = { length: 0, push: function() {}, shift: function() { return undefined; }, indexOf: function() { return -1; } };

var $funcTypes = {};
var $funcType = function(params, results, variadic) {
  var typeKey = $mapArray(params, function(p) { return p.id; }).join(",") + "$" + $mapArray(results, function(r) { return r.id; }).join(",") + "$" + variadic;
  var typ = $funcTypes[typeKey];
  if (typ === undefined) {
    var paramTypes = $mapArray(params, function(p) { return p.string; });
    if (variadic) {
      paramTypes[paramTypes.length - 1] = "..." + paramTypes[paramTypes.length - 1].substr(2);
    }
    var string = "func(" + paramTypes.join(", ") + ")";
    if (results.length === 1) {
      string += " " + results[0].string;
    } else if (results.length > 1) {
      string += " (" + $mapArray(results, function(r) { return r.string; }).join(", ") + ")";
    }
    typ = $newType(4, $kindFunc, string, false, "", false, null);
    $funcTypes[typeKey] = typ;
    typ.init(params, results, variadic);
  }
  return typ;
};

var $interfaceTypes = {};
var $interfaceType = function(methods) {
  var typeKey = $mapArray(methods, function(m) { return m.pkg + "," + m.name + "," + m.typ.id; }).join("$");
  var typ = $interfaceTypes[typeKey];
  if (typ === undefined) {
    var string = "interface {}";
    if (methods.length !== 0) {
      string = "interface { " + $mapArray(methods, function(m) {
        return (m.pkg !== "" ? m.pkg + "." : "") + m.name + m.typ.string.substr(4);
      }).join("; ") + " }";
    }
    typ = $newType(8, $kindInterface, string, false, "", false, null);
    $interfaceTypes[typeKey] = typ;
    typ.init(methods);
  }
  return typ;
};
var $emptyInterface = $interfaceType([]);
var $ifaceNil = {};
var $error = $newType(8, $kindInterface, "error", true, "", false, null);
$error.init([{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}]);

var $mapTypes = {};
var $mapType = function(key, elem) {
  var typeKey = key.id + "$" + elem.id;
  var typ = $mapTypes[typeKey];
  if (typ === undefined) {
    typ = $newType(4, $kindMap, "map[" + key.string + "]" + elem.string, false, "", false, null);
    $mapTypes[typeKey] = typ;
    typ.init(key, elem);
  }
  return typ;
};
var $makeMap = function(keyForFunc, entries) {
  var m = {};
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    m[keyForFunc(e.k)] = e;
  }
  return m;
};

var $ptrType = function(elem) {
  var typ = elem.ptr;
  if (typ === undefined) {
    typ = $newType(4, $kindPtr, "*" + elem.string, false, "", elem.exported, null);
    elem.ptr = typ;
    typ.init(elem);
  }
  return typ;
};

var $newDataPointer = function(data, constructor) {
  if (constructor.elem.kind === $kindStruct) {
    return data;
  }
  return new constructor(function() { return data; }, function(v) { data = v; });
};

var $indexPtr = function(array, index, constructor) {
  array.$ptr = array.$ptr || {};
  return array.$ptr[index] || (array.$ptr[index] = new constructor(function() { return array[index]; }, function(v) { array[index] = v; }));
};

var $sliceType = function(elem) {
  var typ = elem.slice;
  if (typ === undefined) {
    typ = $newType(12, $kindSlice, "[]" + elem.string, false, "", false, null);
    elem.slice = typ;
    typ.init(elem);
  }
  return typ;
};
var $makeSlice = function(typ, length, capacity) {
  capacity = capacity || length;
  if (length < 0 || length > 2147483647) {
    $throwRuntimeError("makeslice: len out of range");
  }
  if (capacity < 0 || capacity < length || capacity > 2147483647) {
    $throwRuntimeError("makeslice: cap out of range");
  }
  var array = new typ.nativeArray(capacity);
  if (typ.nativeArray === Array) {
    for (var i = 0; i < capacity; i++) {
      array[i] = typ.elem.zero();
    }
  }
  var slice = new typ(array);
  slice.$length = length;
  return slice;
};

var $structTypes = {};
var $structType = function(pkgPath, fields) {
  var typeKey = $mapArray(fields, function(f) { return f.name + "," + f.typ.id + "," + f.tag; }).join("$");
  var typ = $structTypes[typeKey];
  if (typ === undefined) {
    var string = "struct { " + $mapArray(fields, function(f) {
      return f.name + " " + f.typ.string + (f.tag !== "" ? (" \"" + f.tag.replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + "\"") : "");
    }).join("; ") + " }";
    if (fields.length === 0) {
      string = "struct {}";
    }
    typ = $newType(0, $kindStruct, string, false, "", false, function() {
      this.$val = this;
      for (var i = 0; i < fields.length; i++) {
        var f = fields[i];
        var arg = arguments[i];
        this[f.prop] = arg !== undefined ? arg : f.typ.zero();
      }
    });
    $structTypes[typeKey] = typ;
    typ.init(pkgPath, fields);
  }
  return typ;
};

var $assertType = function(value, type, returnTuple) {
  var isInterface = (type.kind === $kindInterface), ok, missingMethod = "";
  if (value === $ifaceNil) {
    ok = false;
  } else if (!isInterface) {
    ok = value.constructor === type;
  } else {
    var valueTypeString = value.constructor.string;
    ok = type.implementedBy[valueTypeString];
    if (ok === undefined) {
      ok = true;
      var valueMethodSet = $methodSet(value.constructor);
      var interfaceMethods = type.methods;
      for (var i = 0; i < interfaceMethods.length; i++) {
        var tm = interfaceMethods[i];
        var found = false;
        for (var j = 0; j < valueMethodSet.length; j++) {
          var vm = valueMethodSet[j];
          if (vm.name === tm.name && vm.pkg === tm.pkg && vm.typ === tm.typ) {
            found = true;
            break;
          }
        }
        if (!found) {
          ok = false;
          type.missingMethodFor[valueTypeString] = tm.name;
          break;
        }
      }
      type.implementedBy[valueTypeString] = ok;
    }
    if (!ok) {
      missingMethod = type.missingMethodFor[valueTypeString];
    }
  }

  if (!ok) {
    if (returnTuple) {
      return [type.zero(), false];
    }
    $panic(new $packages["runtime"].TypeAssertionError.ptr("", (value === $ifaceNil ? "" : value.constructor.string), type.string, missingMethod));
  }

  if (!isInterface) {
    value = value.$val;
  }
  if (type === $jsObjectPtr) {
    value = value.object;
  }
  return returnTuple ? [value, true] : value;
};

var $stackDepthOffset = 0;
var $getStackDepth = function() {
  var err = new Error();
  if (err.stack === undefined) {
    return undefined;
  }
  return $stackDepthOffset + err.stack.split("\n").length;
};

var $panicStackDepth = null, $panicValue;
var $callDeferred = function(deferred, jsErr, fromPanic) {
  if (!fromPanic && deferred !== null && deferred.index >= $curGoroutine.deferStack.length) {
    throw jsErr;
  }
  if (jsErr !== null) {
    var newErr = null;
    try {
      $curGoroutine.deferStack.push(deferred);
      $panic(new $jsErrorPtr(jsErr));
    } catch (err) {
      newErr = err;
    }
    $curGoroutine.deferStack.pop();
    $callDeferred(deferred, newErr);
    return;
  }
  if ($curGoroutine.asleep) {
    return;
  }

  $stackDepthOffset--;
  var outerPanicStackDepth = $panicStackDepth;
  var outerPanicValue = $panicValue;

  var localPanicValue = $curGoroutine.panicStack.pop();
  if (localPanicValue !== undefined) {
    $panicStackDepth = $getStackDepth();
    $panicValue = localPanicValue;
  }

  try {
    while (true) {
      if (deferred === null) {
        deferred = $curGoroutine.deferStack[$curGoroutine.deferStack.length - 1];
        if (deferred === undefined) {
          /* The panic reached the top of the stack. Clear it and throw it as a JavaScript error. */
          $panicStackDepth = null;
          if (localPanicValue.Object instanceof Error) {
            throw localPanicValue.Object;
          }
          var msg;
          if (localPanicValue.constructor === $String) {
            msg = localPanicValue.$val;
          } else if (localPanicValue.Error !== undefined) {
            msg = localPanicValue.Error();
          } else if (localPanicValue.String !== undefined) {
            msg = localPanicValue.String();
          } else {
            msg = localPanicValue;
          }
          throw new Error(msg);
        }
      }
      var call = deferred.pop();
      if (call === undefined) {
        $curGoroutine.deferStack.pop();
        if (localPanicValue !== undefined) {
          deferred = null;
          continue;
        }
        return;
      }
      var r = call[0].apply(call[2], call[1]);
      if (r && r.$blk !== undefined) {
        deferred.push([r.$blk, [], r]);
        if (fromPanic) {
          throw null;
        }
        return;
      }

      if (localPanicValue !== undefined && $panicStackDepth === null) {
        throw null; /* error was recovered */
      }
    }
  } finally {
    if (localPanicValue !== undefined) {
      if ($panicStackDepth !== null) {
        $curGoroutine.panicStack.push(localPanicValue);
      }
      $panicStackDepth = outerPanicStackDepth;
      $panicValue = outerPanicValue;
    }
    $stackDepthOffset++;
  }
};

var $panic = function(value) {
  $curGoroutine.panicStack.push(value);
  $callDeferred(null, null, true);
};
var $recover = function() {
  if ($panicStackDepth === null || ($panicStackDepth !== undefined && $panicStackDepth !== $getStackDepth() - 2)) {
    return $ifaceNil;
  }
  $panicStackDepth = null;
  return $panicValue;
};
var $throw = function(err) { throw err; };

var $noGoroutine = { asleep: false, exit: false, deferStack: [], panicStack: [] };
var $curGoroutine = $noGoroutine, $totalGoroutines = 0, $awakeGoroutines = 0, $checkForDeadlock = true;
var $mainFinished = false;
var $go = function(fun, args, direct) {
  $totalGoroutines++;
  $awakeGoroutines++;
  var $goroutine = function() {
    try {
      $curGoroutine = $goroutine;
      var r = fun.apply(undefined, args);
      if (r && r.$blk !== undefined) {
        fun = function() { return r.$blk(); };
        args = [];
        return;
      }
      $goroutine.exit = true;
    } catch (err) {
      if (!$goroutine.exit) {
        throw err;
      }
    } finally {
      $curGoroutine = $noGoroutine;
      if ($goroutine.exit) { /* also set by runtime.Goexit() */
        $totalGoroutines--;
        $goroutine.asleep = true;
      }
      if ($goroutine.asleep) {
        $awakeGoroutines--;
        if (!$mainFinished && $awakeGoroutines === 0 && $checkForDeadlock) {
          console.error("fatal error: all goroutines are asleep - deadlock!");
          if ($global.process !== undefined) {
            $global.process.exit(2);
          }
        }
      }
    }
  };
  $goroutine.asleep = false;
  $goroutine.exit = false;
  $goroutine.deferStack = [];
  $goroutine.panicStack = [];
  $schedule($goroutine);
};

var $scheduled = [];
var $runScheduled = function() {
  try {
    var r;
    while ((r = $scheduled.shift()) !== undefined) {
      r();
    }
  } finally {
    if ($scheduled.length > 0) {
      setTimeout($runScheduled, 0);
    }
  }
};

var $schedule = function(goroutine) {
  if (goroutine.asleep) {
    goroutine.asleep = false;
    $awakeGoroutines++;
  }
  $scheduled.push(goroutine);
  if ($curGoroutine === $noGoroutine) {
    $runScheduled();
  }
};

var $setTimeout = function(f, t) {
  $awakeGoroutines++;
  return setTimeout(function() {
    $awakeGoroutines--;
    f();
  }, t);
};

var $block = function() {
  if ($curGoroutine === $noGoroutine) {
    $throwRuntimeError("cannot block in JavaScript callback, fix by wrapping code in goroutine");
  }
  $curGoroutine.asleep = true;
};

var $send = function(chan, value) {
  if (chan.$closed) {
    $throwRuntimeError("send on closed channel");
  }
  var queuedRecv = chan.$recvQueue.shift();
  if (queuedRecv !== undefined) {
    queuedRecv([value, true]);
    return;
  }
  if (chan.$buffer.length < chan.$capacity) {
    chan.$buffer.push(value);
    return;
  }

  var thisGoroutine = $curGoroutine;
  var closedDuringSend;
  chan.$sendQueue.push(function(closed) {
    closedDuringSend = closed;
    $schedule(thisGoroutine);
    return value;
  });
  $block();
  return {
    $blk: function() {
      if (closedDuringSend) {
        $throwRuntimeError("send on closed channel");
      }
    }
  };
};
var $recv = function(chan) {
  var queuedSend = chan.$sendQueue.shift();
  if (queuedSend !== undefined) {
    chan.$buffer.push(queuedSend(false));
  }
  var bufferedValue = chan.$buffer.shift();
  if (bufferedValue !== undefined) {
    return [bufferedValue, true];
  }
  if (chan.$closed) {
    return [chan.$elem.zero(), false];
  }

  var thisGoroutine = $curGoroutine;
  var f = { $blk: function() { return this.value; } };
  var queueEntry = function(v) {
    f.value = v;
    $schedule(thisGoroutine);
  };
  chan.$recvQueue.push(queueEntry);
  $block();
  return f;
};
var $close = function(chan) {
  if (chan.$closed) {
    $throwRuntimeError("close of closed channel");
  }
  chan.$closed = true;
  while (true) {
    var queuedSend = chan.$sendQueue.shift();
    if (queuedSend === undefined) {
      break;
    }
    queuedSend(true); /* will panic */
  }
  while (true) {
    var queuedRecv = chan.$recvQueue.shift();
    if (queuedRecv === undefined) {
      break;
    }
    queuedRecv([chan.$elem.zero(), false]);
  }
};
var $select = function(comms) {
  var ready = [];
  var selection = -1;
  for (var i = 0; i < comms.length; i++) {
    var comm = comms[i];
    var chan = comm[0];
    switch (comm.length) {
    case 0: /* default */
      selection = i;
      break;
    case 1: /* recv */
      if (chan.$sendQueue.length !== 0 || chan.$buffer.length !== 0 || chan.$closed) {
        ready.push(i);
      }
      break;
    case 2: /* send */
      if (chan.$closed) {
        $throwRuntimeError("send on closed channel");
      }
      if (chan.$recvQueue.length !== 0 || chan.$buffer.length < chan.$capacity) {
        ready.push(i);
      }
      break;
    }
  }

  if (ready.length !== 0) {
    selection = ready[Math.floor(Math.random() * ready.length)];
  }
  if (selection !== -1) {
    var comm = comms[selection];
    switch (comm.length) {
    case 0: /* default */
      return [selection];
    case 1: /* recv */
      return [selection, $recv(comm[0])];
    case 2: /* send */
      $send(comm[0], comm[1]);
      return [selection];
    }
  }

  var entries = [];
  var thisGoroutine = $curGoroutine;
  var f = { $blk: function() { return this.selection; } };
  var removeFromQueues = function() {
    for (var i = 0; i < entries.length; i++) {
      var entry = entries[i];
      var queue = entry[0];
      var index = queue.indexOf(entry[1]);
      if (index !== -1) {
        queue.splice(index, 1);
      }
    }
  };
  for (var i = 0; i < comms.length; i++) {
    (function(i) {
      var comm = comms[i];
      switch (comm.length) {
      case 1: /* recv */
        var queueEntry = function(value) {
          f.selection = [i, value];
          removeFromQueues();
          $schedule(thisGoroutine);
        };
        entries.push([comm[0].$recvQueue, queueEntry]);
        comm[0].$recvQueue.push(queueEntry);
        break;
      case 2: /* send */
        var queueEntry = function() {
          if (comm[0].$closed) {
            $throwRuntimeError("send on closed channel");
          }
          f.selection = [i];
          removeFromQueues();
          $schedule(thisGoroutine);
          return comm[1];
        };
        entries.push([comm[0].$sendQueue, queueEntry]);
        comm[0].$sendQueue.push(queueEntry);
        break;
      }
    })(i);
  }
  $block();
  return f;
};

var $jsObjectPtr, $jsErrorPtr;

var $needsExternalization = function(t) {
  switch (t.kind) {
    case $kindBool:
    case $kindInt:
    case $kindInt8:
    case $kindInt16:
    case $kindInt32:
    case $kindUint:
    case $kindUint8:
    case $kindUint16:
    case $kindUint32:
    case $kindUintptr:
    case $kindFloat32:
    case $kindFloat64:
      return false;
    default:
      return t !== $jsObjectPtr;
  }
};

var $externalize = function(v, t) {
  if (t === $jsObjectPtr) {
    return v;
  }
  switch (t.kind) {
  case $kindBool:
  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8:
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindFloat32:
  case $kindFloat64:
    return v;
  case $kindInt64:
  case $kindUint64:
    return $flatten64(v);
  case $kindArray:
    if ($needsExternalization(t.elem)) {
      return $mapArray(v, function(e) { return $externalize(e, t.elem); });
    }
    return v;
  case $kindFunc:
    return $externalizeFunction(v, t, false);
  case $kindInterface:
    if (v === $ifaceNil) {
      return null;
    }
    if (v.constructor === $jsObjectPtr) {
      return v.$val.object;
    }
    return $externalize(v.$val, v.constructor);
  case $kindMap:
    var m = {};
    var keys = $keys(v);
    for (var i = 0; i < keys.length; i++) {
      var entry = v[keys[i]];
      m[$externalize(entry.k, t.key)] = $externalize(entry.v, t.elem);
    }
    return m;
  case $kindPtr:
    if (v === t.nil) {
      return null;
    }
    return $externalize(v.$get(), t.elem);
  case $kindSlice:
    if ($needsExternalization(t.elem)) {
      return $mapArray($sliceToArray(v), function(e) { return $externalize(e, t.elem); });
    }
    return $sliceToArray(v);
  case $kindString:
    if ($isASCII(v)) {
      return v;
    }
    var s = "", r;
    for (var i = 0; i < v.length; i += r[1]) {
      r = $decodeRune(v, i);
      var c = r[0];
      if (c > 0xFFFF) {
        var h = Math.floor((c - 0x10000) / 0x400) + 0xD800;
        var l = (c - 0x10000) % 0x400 + 0xDC00;
        s += String.fromCharCode(h, l);
        continue;
      }
      s += String.fromCharCode(c);
    }
    return s;
  case $kindStruct:
    var timePkg = $packages["time"];
    if (timePkg !== undefined && v.constructor === timePkg.Time.ptr) {
      var milli = $div64(v.UnixNano(), new $Int64(0, 1000000));
      return new Date($flatten64(milli));
    }

    var noJsObject = {};
    var searchJsObject = function(v, t) {
      if (t === $jsObjectPtr) {
        return v;
      }
      switch (t.kind) {
      case $kindPtr:
        if (v === t.nil) {
          return noJsObject;
        }
        return searchJsObject(v.$get(), t.elem);
      case $kindStruct:
        var f = t.fields[0];
        return searchJsObject(v[f.prop], f.typ);
      case $kindInterface:
        return searchJsObject(v.$val, v.constructor);
      default:
        return noJsObject;
      }
    };
    var o = searchJsObject(v, t);
    if (o !== noJsObject) {
      return o;
    }

    o = {};
    for (var i = 0; i < t.fields.length; i++) {
      var f = t.fields[i];
      if (!f.exported) {
        continue;
      }
      o[f.name] = $externalize(v[f.prop], f.typ);
    }
    return o;
  }
  $throwRuntimeError("cannot externalize " + t.string);
};

var $externalizeFunction = function(v, t, passThis) {
  if (v === $throwNilPointerError) {
    return null;
  }
  if (v.$externalizeWrapper === undefined) {
    $checkForDeadlock = false;
    v.$externalizeWrapper = function() {
      var args = [];
      for (var i = 0; i < t.params.length; i++) {
        if (t.variadic && i === t.params.length - 1) {
          var vt = t.params[i].elem, varargs = [];
          for (var j = i; j < arguments.length; j++) {
            varargs.push($internalize(arguments[j], vt));
          }
          args.push(new (t.params[i])(varargs));
          break;
        }
        args.push($internalize(arguments[i], t.params[i]));
      }
      var canBlock = $curGoroutine.canBlock;
      $curGoroutine.canBlock = false;
      try {
        var result = v.apply(passThis ? this : undefined, args);
      } finally {
        $curGoroutine.canBlock = canBlock;
      }
      switch (t.results.length) {
      case 0:
        return;
      case 1:
        return $externalize(result, t.results[0]);
      default:
        for (var i = 0; i < t.results.length; i++) {
          result[i] = $externalize(result[i], t.results[i]);
        }
        return result;
      }
    };
  }
  return v.$externalizeWrapper;
};

var $internalize = function(v, t, recv) {
  if (t === $jsObjectPtr) {
    return v;
  }
  if (t === $jsObjectPtr.elem) {
    $throwRuntimeError("cannot internalize js.Object, use *js.Object instead");
  }
  if (v && v.__internal_object__ !== undefined) {
    return $assertType(v.__internal_object__, t, false);
  }
  var timePkg = $packages["time"];
  if (timePkg !== undefined && t === timePkg.Time) {
    if (!(v !== null && v !== undefined && v.constructor === Date)) {
      $throwRuntimeError("cannot internalize time.Time from " + typeof v + ", must be Date");
    }
    return timePkg.Unix(new $Int64(0, 0), new $Int64(0, v.getTime() * 1000000));
  }
  switch (t.kind) {
  case $kindBool:
    return !!v;
  case $kindInt:
    return parseInt(v);
  case $kindInt8:
    return parseInt(v) << 24 >> 24;
  case $kindInt16:
    return parseInt(v) << 16 >> 16;
  case $kindInt32:
    return parseInt(v) >> 0;
  case $kindUint:
    return parseInt(v);
  case $kindUint8:
    return parseInt(v) << 24 >>> 24;
  case $kindUint16:
    return parseInt(v) << 16 >>> 16;
  case $kindUint32:
  case $kindUintptr:
    return parseInt(v) >>> 0;
  case $kindInt64:
  case $kindUint64:
    return new t(0, v);
  case $kindFloat32:
  case $kindFloat64:
    return parseFloat(v);
  case $kindArray:
    if (v.length !== t.len) {
      $throwRuntimeError("got array with wrong size from JavaScript native");
    }
    return $mapArray(v, function(e) { return $internalize(e, t.elem); });
  case $kindFunc:
    return function() {
      var args = [];
      for (var i = 0; i < t.params.length; i++) {
        if (t.variadic && i === t.params.length - 1) {
          var vt = t.params[i].elem, varargs = arguments[i];
          for (var j = 0; j < varargs.$length; j++) {
            args.push($externalize(varargs.$array[varargs.$offset + j], vt));
          }
          break;
        }
        args.push($externalize(arguments[i], t.params[i]));
      }
      var result = v.apply(recv, args);
      switch (t.results.length) {
      case 0:
        return;
      case 1:
        return $internalize(result, t.results[0]);
      default:
        for (var i = 0; i < t.results.length; i++) {
          result[i] = $internalize(result[i], t.results[i]);
        }
        return result;
      }
    };
  case $kindInterface:
    if (t.methods.length !== 0) {
      $throwRuntimeError("cannot internalize " + t.string);
    }
    if (v === null) {
      return $ifaceNil;
    }
    if (v === undefined) {
      return new $jsObjectPtr(undefined);
    }
    switch (v.constructor) {
    case Int8Array:
      return new ($sliceType($Int8))(v);
    case Int16Array:
      return new ($sliceType($Int16))(v);
    case Int32Array:
      return new ($sliceType($Int))(v);
    case Uint8Array:
      return new ($sliceType($Uint8))(v);
    case Uint16Array:
      return new ($sliceType($Uint16))(v);
    case Uint32Array:
      return new ($sliceType($Uint))(v);
    case Float32Array:
      return new ($sliceType($Float32))(v);
    case Float64Array:
      return new ($sliceType($Float64))(v);
    case Array:
      return $internalize(v, $sliceType($emptyInterface));
    case Boolean:
      return new $Bool(!!v);
    case Date:
      if (timePkg === undefined) {
        /* time package is not present, internalize as &js.Object{Date} so it can be externalized into original Date. */
        return new $jsObjectPtr(v);
      }
      return new timePkg.Time($internalize(v, timePkg.Time));
    case Function:
      var funcType = $funcType([$sliceType($emptyInterface)], [$jsObjectPtr], true);
      return new funcType($internalize(v, funcType));
    case Number:
      return new $Float64(parseFloat(v));
    case String:
      return new $String($internalize(v, $String));
    default:
      if ($global.Node && v instanceof $global.Node) {
        return new $jsObjectPtr(v);
      }
      var mapType = $mapType($String, $emptyInterface);
      return new mapType($internalize(v, mapType));
    }
  case $kindMap:
    var m = {};
    var keys = $keys(v);
    for (var i = 0; i < keys.length; i++) {
      var k = $internalize(keys[i], t.key);
      m[t.key.keyFor(k)] = { k: k, v: $internalize(v[keys[i]], t.elem) };
    }
    return m;
  case $kindPtr:
    if (t.elem.kind === $kindStruct) {
      return $internalize(v, t.elem);
    }
  case $kindSlice:
    return new t($mapArray(v, function(e) { return $internalize(e, t.elem); }));
  case $kindString:
    v = String(v);
    if ($isASCII(v)) {
      return v;
    }
    var s = "";
    var i = 0;
    while (i < v.length) {
      var h = v.charCodeAt(i);
      if (0xD800 <= h && h <= 0xDBFF) {
        var l = v.charCodeAt(i + 1);
        var c = (h - 0xD800) * 0x400 + l - 0xDC00 + 0x10000;
        s += $encodeRune(c);
        i += 2;
        continue;
      }
      s += $encodeRune(h);
      i++;
    }
    return s;
  case $kindStruct:
    var noJsObject = {};
    var searchJsObject = function(t) {
      if (t === $jsObjectPtr) {
        return v;
      }
      if (t === $jsObjectPtr.elem) {
        $throwRuntimeError("cannot internalize js.Object, use *js.Object instead");
      }
      switch (t.kind) {
      case $kindPtr:
        return searchJsObject(t.elem);
      case $kindStruct:
        var f = t.fields[0];
        var o = searchJsObject(f.typ);
        if (o !== noJsObject) {
          var n = new t.ptr();
          n[f.prop] = o;
          return n;
        }
        return noJsObject;
      default:
        return noJsObject;
      }
    };
    var o = searchJsObject(t);
    if (o !== noJsObject) {
      return o;
    }
  }
  $throwRuntimeError("cannot internalize " + t.string);
};

/* $isASCII reports whether string s contains only ASCII characters. */
var $isASCII = function(s) {
  for (var i = 0; i < s.length; i++) {
    if (s.charCodeAt(i) >= 128) {
      return false;
    }
  }
  return true;
};

$packages["github.com/gopherjs/gopherjs/js"] = (function() {
	var $pkg = {}, $init, Object, Error, sliceType, ptrType, sliceType$2, funcType, ptrType$1, MakeFunc, MakeWrapper, init;
	Object = $pkg.Object = $newType(0, $kindStruct, "js.Object", true, "github.com/gopherjs/gopherjs/js", true, function(object_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.object = null;
			return;
		}
		this.object = object_;
	});
	Error = $pkg.Error = $newType(0, $kindStruct, "js.Error", true, "github.com/gopherjs/gopherjs/js", true, function(Object_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Object = null;
			return;
		}
		this.Object = Object_;
	});
	sliceType = $sliceType($emptyInterface);
	ptrType = $ptrType(Object);
	sliceType$2 = $sliceType(ptrType);
	funcType = $funcType([sliceType$2], [ptrType], true);
	ptrType$1 = $ptrType(Error);
	Object.ptr.prototype.Get = function(key) {
		var key, o;
		o = this;
		return o.object[$externalize(key, $String)];
	};
	Object.prototype.Get = function(key) { return this.$val.Get(key); };
	Object.ptr.prototype.Set = function(key, value) {
		var key, o, value;
		o = this;
		o.object[$externalize(key, $String)] = $externalize(value, $emptyInterface);
	};
	Object.prototype.Set = function(key, value) { return this.$val.Set(key, value); };
	Object.ptr.prototype.Delete = function(key) {
		var key, o;
		o = this;
		delete o.object[$externalize(key, $String)];
	};
	Object.prototype.Delete = function(key) { return this.$val.Delete(key); };
	Object.ptr.prototype.Length = function() {
		var o;
		o = this;
		return $parseInt(o.object.length);
	};
	Object.prototype.Length = function() { return this.$val.Length(); };
	Object.ptr.prototype.Index = function(i) {
		var i, o;
		o = this;
		return o.object[i];
	};
	Object.prototype.Index = function(i) { return this.$val.Index(i); };
	Object.ptr.prototype.SetIndex = function(i, value) {
		var i, o, value;
		o = this;
		o.object[i] = $externalize(value, $emptyInterface);
	};
	Object.prototype.SetIndex = function(i, value) { return this.$val.SetIndex(i, value); };
	Object.ptr.prototype.Call = function(name, args) {
		var args, name, o, obj;
		o = this;
		return (obj = o.object, obj[$externalize(name, $String)].apply(obj, $externalize(args, sliceType)));
	};
	Object.prototype.Call = function(name, args) { return this.$val.Call(name, args); };
	Object.ptr.prototype.Invoke = function(args) {
		var args, o;
		o = this;
		return o.object.apply(undefined, $externalize(args, sliceType));
	};
	Object.prototype.Invoke = function(args) { return this.$val.Invoke(args); };
	Object.ptr.prototype.New = function(args) {
		var args, o;
		o = this;
		return new ($global.Function.prototype.bind.apply(o.object, [undefined].concat($externalize(args, sliceType))));
	};
	Object.prototype.New = function(args) { return this.$val.New(args); };
	Object.ptr.prototype.Bool = function() {
		var o;
		o = this;
		return !!(o.object);
	};
	Object.prototype.Bool = function() { return this.$val.Bool(); };
	Object.ptr.prototype.String = function() {
		var o;
		o = this;
		return $internalize(o.object, $String);
	};
	Object.prototype.String = function() { return this.$val.String(); };
	Object.ptr.prototype.Int = function() {
		var o;
		o = this;
		return $parseInt(o.object) >> 0;
	};
	Object.prototype.Int = function() { return this.$val.Int(); };
	Object.ptr.prototype.Int64 = function() {
		var o;
		o = this;
		return $internalize(o.object, $Int64);
	};
	Object.prototype.Int64 = function() { return this.$val.Int64(); };
	Object.ptr.prototype.Uint64 = function() {
		var o;
		o = this;
		return $internalize(o.object, $Uint64);
	};
	Object.prototype.Uint64 = function() { return this.$val.Uint64(); };
	Object.ptr.prototype.Float = function() {
		var o;
		o = this;
		return $parseFloat(o.object);
	};
	Object.prototype.Float = function() { return this.$val.Float(); };
	Object.ptr.prototype.Interface = function() {
		var o;
		o = this;
		return $internalize(o.object, $emptyInterface);
	};
	Object.prototype.Interface = function() { return this.$val.Interface(); };
	Object.ptr.prototype.Unsafe = function() {
		var o;
		o = this;
		return o.object;
	};
	Object.prototype.Unsafe = function() { return this.$val.Unsafe(); };
	Error.ptr.prototype.Error = function() {
		var err;
		err = this;
		return "JavaScript error: " + $internalize(err.Object.message, $String);
	};
	Error.prototype.Error = function() { return this.$val.Error(); };
	Error.ptr.prototype.Stack = function() {
		var err;
		err = this;
		return $internalize(err.Object.stack, $String);
	};
	Error.prototype.Stack = function() { return this.$val.Stack(); };
	MakeFunc = function(fn) {
		var fn;
		return $makeFunc(fn);
	};
	$pkg.MakeFunc = MakeFunc;
	MakeWrapper = function(i) {
		var i, i$1, m, methods, o, v;
		v = i;
		o = new ($global.Object)();
		o.__internal_object__ = v;
		methods = v.constructor.methods;
		i$1 = 0;
		while (true) {
			if (!(i$1 < $parseInt(methods.length))) { break; }
			m = [m];
			m[0] = methods[i$1];
			if (!($internalize(m[0].pkg, $String) === "")) {
				i$1 = i$1 + (1) >> 0;
				continue;
			}
			o[$externalize($internalize(m[0].name, $String), $String)] = $externalize((function(m) { return function(args) {
				var args;
				return $externalizeFunction(v[$externalize($internalize(m[0].prop, $String), $String)], m[0].typ, $externalize(true, $Bool)).apply(v, $externalize(args, sliceType$2));
			}; })(m), funcType);
			i$1 = i$1 + (1) >> 0;
		}
		return o;
	};
	$pkg.MakeWrapper = MakeWrapper;
	init = function() {
		var e;
		e = new Error.ptr(null);
		$unused(e);
	};
	ptrType.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([$String], [ptrType], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$String, $emptyInterface], [], false)}, {prop: "Delete", name: "Delete", pkg: "", typ: $funcType([$String], [], false)}, {prop: "Length", name: "Length", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Index", name: "Index", pkg: "", typ: $funcType([$Int], [ptrType], false)}, {prop: "SetIndex", name: "SetIndex", pkg: "", typ: $funcType([$Int, $emptyInterface], [], false)}, {prop: "Call", name: "Call", pkg: "", typ: $funcType([$String, sliceType], [ptrType], true)}, {prop: "Invoke", name: "Invoke", pkg: "", typ: $funcType([sliceType], [ptrType], true)}, {prop: "New", name: "New", pkg: "", typ: $funcType([sliceType], [ptrType], true)}, {prop: "Bool", name: "Bool", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Int", name: "Int", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Int64", name: "Int64", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}, {prop: "Float", name: "Float", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Interface", name: "Interface", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Unsafe", name: "Unsafe", pkg: "", typ: $funcType([], [$Uintptr], false)}];
	ptrType$1.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Stack", name: "Stack", pkg: "", typ: $funcType([], [$String], false)}];
	Object.init("github.com/gopherjs/gopherjs/js", [{prop: "object", name: "object", anonymous: false, exported: false, typ: ptrType, tag: ""}]);
	Error.init("", [{prop: "Object", name: "Object", anonymous: true, exported: true, typ: ptrType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["runtime/internal/sys"] = (function() {
	var $pkg = {}, $init;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["runtime"] = (function() {
	var $pkg = {}, $init, js, sys, Error, TypeAssertionError, errorString, ptrType$4, init, GOROOT, Goexit, SetFinalizer, KeepAlive, throw$1;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	sys = $packages["runtime/internal/sys"];
	Error = $pkg.Error = $newType(8, $kindInterface, "runtime.Error", true, "runtime", true, null);
	TypeAssertionError = $pkg.TypeAssertionError = $newType(0, $kindStruct, "runtime.TypeAssertionError", true, "runtime", true, function(interfaceString_, concreteString_, assertedString_, missingMethod_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.interfaceString = "";
			this.concreteString = "";
			this.assertedString = "";
			this.missingMethod = "";
			return;
		}
		this.interfaceString = interfaceString_;
		this.concreteString = concreteString_;
		this.assertedString = assertedString_;
		this.missingMethod = missingMethod_;
	});
	errorString = $pkg.errorString = $newType(8, $kindString, "runtime.errorString", true, "runtime", false, null);
	ptrType$4 = $ptrType(TypeAssertionError);
	init = function() {
		var e, jsPkg;
		jsPkg = $packages[$externalize("github.com/gopherjs/gopherjs/js", $String)];
		$jsObjectPtr = jsPkg.Object.ptr;
		$jsErrorPtr = jsPkg.Error.ptr;
		$throwRuntimeError = throw$1;
		e = $ifaceNil;
		e = new TypeAssertionError.ptr("", "", "", "");
		$unused(e);
	};
	GOROOT = function() {
		var goroot, process;
		process = $global.process;
		if (process === undefined) {
			return "/";
		}
		goroot = process.env.GOROOT;
		if (!(goroot === undefined)) {
			return $internalize(goroot, $String);
		}
		return "/usr/lib/go";
	};
	$pkg.GOROOT = GOROOT;
	Goexit = function() {
		$curGoroutine.exit = $externalize(true, $Bool);
		$throw(null);
	};
	$pkg.Goexit = Goexit;
	SetFinalizer = function(x, f) {
		var f, x;
	};
	$pkg.SetFinalizer = SetFinalizer;
	KeepAlive = function(param) {
		var param;
	};
	$pkg.KeepAlive = KeepAlive;
	throw$1 = function(s) {
		var s;
		$panic(new errorString((s)));
	};
	TypeAssertionError.ptr.prototype.RuntimeError = function() {
	};
	TypeAssertionError.prototype.RuntimeError = function() { return this.$val.RuntimeError(); };
	TypeAssertionError.ptr.prototype.Error = function() {
		var e, inter;
		e = this;
		inter = e.interfaceString;
		if (inter === "") {
			inter = "interface";
		}
		if (e.concreteString === "") {
			return "interface conversion: " + inter + " is nil, not " + e.assertedString;
		}
		if (e.missingMethod === "") {
			return "interface conversion: " + inter + " is " + e.concreteString + ", not " + e.assertedString;
		}
		return "interface conversion: " + e.concreteString + " is not " + e.assertedString + ": missing method " + e.missingMethod;
	};
	TypeAssertionError.prototype.Error = function() { return this.$val.Error(); };
	errorString.prototype.RuntimeError = function() {
		var e;
		e = this.$val;
	};
	$ptrType(errorString).prototype.RuntimeError = function() { return new errorString(this.$get()).RuntimeError(); };
	errorString.prototype.Error = function() {
		var e;
		e = this.$val;
		return "runtime error: " + (e);
	};
	$ptrType(errorString).prototype.Error = function() { return new errorString(this.$get()).Error(); };
	ptrType$4.methods = [{prop: "RuntimeError", name: "RuntimeError", pkg: "", typ: $funcType([], [], false)}, {prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	errorString.methods = [{prop: "RuntimeError", name: "RuntimeError", pkg: "", typ: $funcType([], [], false)}, {prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	Error.init([{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}, {prop: "RuntimeError", name: "RuntimeError", pkg: "", typ: $funcType([], [], false)}]);
	TypeAssertionError.init("runtime", [{prop: "interfaceString", name: "interfaceString", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "concreteString", name: "concreteString", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "assertedString", name: "assertedString", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "missingMethod", name: "missingMethod", anonymous: false, exported: false, typ: $String, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sys.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["errors"] = (function() {
	var $pkg = {}, $init, errorString, ptrType, New;
	errorString = $pkg.errorString = $newType(0, $kindStruct, "errors.errorString", true, "errors", false, function(s_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.s = "";
			return;
		}
		this.s = s_;
	});
	ptrType = $ptrType(errorString);
	New = function(text) {
		var text;
		return new errorString.ptr(text);
	};
	$pkg.New = New;
	errorString.ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.s;
	};
	errorString.prototype.Error = function() { return this.$val.Error(); };
	ptrType.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	errorString.init("errors", [{prop: "s", name: "s", anonymous: false, exported: false, typ: $String, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/race"] = (function() {
	var $pkg = {}, $init, Acquire, Release, ReleaseMerge, ReadRange, WriteRange;
	Acquire = function(addr) {
		var addr;
	};
	$pkg.Acquire = Acquire;
	Release = function(addr) {
		var addr;
	};
	$pkg.Release = Release;
	ReleaseMerge = function(addr) {
		var addr;
	};
	$pkg.ReleaseMerge = ReleaseMerge;
	ReadRange = function(addr, len) {
		var addr, len;
	};
	$pkg.ReadRange = ReadRange;
	WriteRange = function(addr, len) {
		var addr, len;
	};
	$pkg.WriteRange = WriteRange;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["sync/atomic"] = (function() {
	var $pkg = {}, $init, js, Value, noCopy, ptrType, ptrType$1, CompareAndSwapInt32, CompareAndSwapUint64, CompareAndSwapPointer, AddInt32, LoadUint64, LoadPointer, StorePointer;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	Value = $pkg.Value = $newType(0, $kindStruct, "atomic.Value", true, "sync/atomic", true, function(noCopy_, v_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.noCopy = new noCopy.ptr();
			this.v = $ifaceNil;
			return;
		}
		this.noCopy = noCopy_;
		this.v = v_;
	});
	noCopy = $pkg.noCopy = $newType(0, $kindStruct, "atomic.noCopy", true, "sync/atomic", false, function() {
		this.$val = this;
		if (arguments.length === 0) {
			return;
		}
	});
	ptrType = $ptrType(Value);
	ptrType$1 = $ptrType(noCopy);
	CompareAndSwapInt32 = function(addr, old, new$1) {
		var addr, new$1, old;
		if (addr.$get() === old) {
			addr.$set(new$1);
			return true;
		}
		return false;
	};
	$pkg.CompareAndSwapInt32 = CompareAndSwapInt32;
	CompareAndSwapUint64 = function(addr, old, new$1) {
		var addr, new$1, old, x;
		if ((x = addr.$get(), (x.$high === old.$high && x.$low === old.$low))) {
			addr.$set(new$1);
			return true;
		}
		return false;
	};
	$pkg.CompareAndSwapUint64 = CompareAndSwapUint64;
	CompareAndSwapPointer = function(addr, old, new$1) {
		var addr, new$1, old;
		if (addr.$get() === old) {
			addr.$set(new$1);
			return true;
		}
		return false;
	};
	$pkg.CompareAndSwapPointer = CompareAndSwapPointer;
	AddInt32 = function(addr, delta) {
		var addr, delta, new$1;
		new$1 = addr.$get() + delta >> 0;
		addr.$set(new$1);
		return new$1;
	};
	$pkg.AddInt32 = AddInt32;
	LoadUint64 = function(addr) {
		var addr;
		return addr.$get();
	};
	$pkg.LoadUint64 = LoadUint64;
	LoadPointer = function(addr) {
		var addr;
		return addr.$get();
	};
	$pkg.LoadPointer = LoadPointer;
	StorePointer = function(addr, val) {
		var addr, val;
		addr.$set(val);
	};
	$pkg.StorePointer = StorePointer;
	Value.ptr.prototype.Load = function() {
		var v, x;
		x = $ifaceNil;
		v = this;
		x = v.v;
		return x;
	};
	Value.prototype.Load = function() { return this.$val.Load(); };
	Value.ptr.prototype.Store = function(x) {
		var v, x;
		v = this;
		if ($interfaceIsEqual(x, $ifaceNil)) {
			$panic(new $String("sync/atomic: store of nil value into Value"));
		}
		if (!($interfaceIsEqual(v.v, $ifaceNil)) && !(x.constructor === v.v.constructor)) {
			$panic(new $String("sync/atomic: store of inconsistently typed value into Value"));
		}
		v.v = x;
	};
	Value.prototype.Store = function(x) { return this.$val.Store(x); };
	noCopy.ptr.prototype.Lock = function() {
	};
	noCopy.prototype.Lock = function() { return this.$val.Lock(); };
	ptrType.methods = [{prop: "Load", name: "Load", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Store", name: "Store", pkg: "", typ: $funcType([$emptyInterface], [], false)}];
	ptrType$1.methods = [{prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false)}];
	Value.init("sync/atomic", [{prop: "noCopy", name: "noCopy", anonymous: false, exported: false, typ: noCopy, tag: ""}, {prop: "v", name: "v", anonymous: false, exported: false, typ: $emptyInterface, tag: ""}]);
	noCopy.init("", []);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["sync"] = (function() {
	var $pkg = {}, $init, js, race, runtime, atomic, Pool, Map, readOnly, entry, Mutex, poolLocalInternal, poolLocal, notifyList, ptrType, sliceType, ptrType$1, chanType, sliceType$1, ptrType$3, ptrType$4, ptrType$5, ptrType$6, ptrType$7, sliceType$4, funcType, funcType$1, ptrType$15, mapType, ptrType$16, arrayType$2, semWaiters, expunged, allPools, runtime_registerPoolCleanup, runtime_Semacquire, runtime_SemacquireMutex, runtime_Semrelease, runtime_notifyListCheck, runtime_canSpin, runtime_nanotime, newEntry, poolCleanup, init, indexLocal, init$1, runtime_doSpin;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	race = $packages["internal/race"];
	runtime = $packages["runtime"];
	atomic = $packages["sync/atomic"];
	Pool = $pkg.Pool = $newType(0, $kindStruct, "sync.Pool", true, "sync", true, function(local_, localSize_, store_, New_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.local = 0;
			this.localSize = 0;
			this.store = sliceType$4.nil;
			this.New = $throwNilPointerError;
			return;
		}
		this.local = local_;
		this.localSize = localSize_;
		this.store = store_;
		this.New = New_;
	});
	Map = $pkg.Map = $newType(0, $kindStruct, "sync.Map", true, "sync", true, function(mu_, read_, dirty_, misses_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.mu = new Mutex.ptr(0, 0);
			this.read = new atomic.Value.ptr(new atomic.noCopy.ptr(), $ifaceNil);
			this.dirty = false;
			this.misses = 0;
			return;
		}
		this.mu = mu_;
		this.read = read_;
		this.dirty = dirty_;
		this.misses = misses_;
	});
	readOnly = $pkg.readOnly = $newType(0, $kindStruct, "sync.readOnly", true, "sync", false, function(m_, amended_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.m = false;
			this.amended = false;
			return;
		}
		this.m = m_;
		this.amended = amended_;
	});
	entry = $pkg.entry = $newType(0, $kindStruct, "sync.entry", true, "sync", false, function(p_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.p = 0;
			return;
		}
		this.p = p_;
	});
	Mutex = $pkg.Mutex = $newType(0, $kindStruct, "sync.Mutex", true, "sync", true, function(state_, sema_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.state = 0;
			this.sema = 0;
			return;
		}
		this.state = state_;
		this.sema = sema_;
	});
	poolLocalInternal = $pkg.poolLocalInternal = $newType(0, $kindStruct, "sync.poolLocalInternal", true, "sync", false, function(private$0_, shared_, Mutex_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.private$0 = $ifaceNil;
			this.shared = sliceType$4.nil;
			this.Mutex = new Mutex.ptr(0, 0);
			return;
		}
		this.private$0 = private$0_;
		this.shared = shared_;
		this.Mutex = Mutex_;
	});
	poolLocal = $pkg.poolLocal = $newType(0, $kindStruct, "sync.poolLocal", true, "sync", false, function(poolLocalInternal_, pad_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.poolLocalInternal = new poolLocalInternal.ptr($ifaceNil, sliceType$4.nil, new Mutex.ptr(0, 0));
			this.pad = arrayType$2.zero();
			return;
		}
		this.poolLocalInternal = poolLocalInternal_;
		this.pad = pad_;
	});
	notifyList = $pkg.notifyList = $newType(0, $kindStruct, "sync.notifyList", true, "sync", false, function(wait_, notify_, lock_, head_, tail_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.wait = 0;
			this.notify = 0;
			this.lock = 0;
			this.head = 0;
			this.tail = 0;
			return;
		}
		this.wait = wait_;
		this.notify = notify_;
		this.lock = lock_;
		this.head = head_;
		this.tail = tail_;
	});
	ptrType = $ptrType(Pool);
	sliceType = $sliceType(ptrType);
	ptrType$1 = $ptrType($Uint32);
	chanType = $chanType($Bool, false, false);
	sliceType$1 = $sliceType(chanType);
	ptrType$3 = $ptrType($emptyInterface);
	ptrType$4 = $ptrType(entry);
	ptrType$5 = $ptrType($UnsafePointer);
	ptrType$6 = $ptrType($Int32);
	ptrType$7 = $ptrType(poolLocal);
	sliceType$4 = $sliceType($emptyInterface);
	funcType = $funcType([], [$emptyInterface], false);
	funcType$1 = $funcType([$emptyInterface, $emptyInterface], [$Bool], false);
	ptrType$15 = $ptrType(Map);
	mapType = $mapType($emptyInterface, ptrType$4);
	ptrType$16 = $ptrType(Mutex);
	arrayType$2 = $arrayType($Uint8, 100);
	Pool.ptr.prototype.Get = function() {
		var _r, p, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (p.store.$length === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (p.store.$length === 0) { */ case 1:
			/* */ if (!(p.New === $throwNilPointerError)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(p.New === $throwNilPointerError)) { */ case 3:
				_r = p.New(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } */ case 4:
			$s = -1; return $ifaceNil;
		/* } */ case 2:
		x$2 = (x = p.store, x$1 = p.store.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		p.store = $subslice(p.store, 0, (p.store.$length - 1 >> 0));
		$s = -1; return x$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Pool.ptr.prototype.Get }; } $f._r = _r; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Pool.prototype.Get = function() { return this.$val.Get(); };
	Pool.ptr.prototype.Put = function(x) {
		var p, x;
		p = this;
		if ($interfaceIsEqual(x, $ifaceNil)) {
			return;
		}
		p.store = $append(p.store, x);
	};
	Pool.prototype.Put = function(x) { return this.$val.Put(x); };
	runtime_registerPoolCleanup = function(cleanup) {
		var cleanup;
	};
	runtime_Semacquire = function(s) {
		var _entry, _key, _r, ch, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _key = $f._key; _r = $f._r; ch = $f.ch; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ if (s.$get() === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (s.$get() === 0) { */ case 1:
			ch = new $Chan($Bool, 0);
			_key = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key)] = { k: _key, v: $append((_entry = semWaiters[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : sliceType$1.nil), ch) };
			_r = $recv(ch); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r[0];
		/* } */ case 2:
		s.$set(s.$get() - (1) >>> 0);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_Semacquire }; } $f._entry = _entry; $f._key = _key; $f._r = _r; $f.ch = ch; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	runtime_SemacquireMutex = function(s, lifo) {
		var lifo, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; lifo = $f.lifo; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = runtime_Semacquire(s); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_SemacquireMutex }; } $f.lifo = lifo; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	runtime_Semrelease = function(s, handoff) {
		var _entry, _key, ch, handoff, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _key = $f._key; ch = $f.ch; handoff = $f.handoff; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s.$set(s.$get() + (1) >>> 0);
		w = (_entry = semWaiters[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : sliceType$1.nil);
		if (w.$length === 0) {
			$s = -1; return;
		}
		ch = (0 >= w.$length ? ($throwRuntimeError("index out of range"), undefined) : w.$array[w.$offset + 0]);
		w = $subslice(w, 1);
		_key = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key)] = { k: _key, v: w };
		if (w.$length === 0) {
			delete semWaiters[ptrType$1.keyFor(s)];
		}
		$r = $send(ch, true); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_Semrelease }; } $f._entry = _entry; $f._key = _key; $f.ch = ch; $f.handoff = handoff; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	runtime_notifyListCheck = function(size) {
		var size;
	};
	runtime_canSpin = function(i) {
		var i;
		return false;
	};
	runtime_nanotime = function() {
		return $mul64($internalize(new ($global.Date)().getTime(), $Int64), new $Int64(0, 1000000));
	};
	newEntry = function(i) {
		var i, i$24ptr;
		return new entry.ptr(((i$24ptr || (i$24ptr = new ptrType$3(function() { return i; }, function($v) { i = $v; })))));
	};
	Map.ptr.prototype.Load = function(key) {
		var _entry, _entry$1, _entry$2, _tmp, _tmp$1, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, e, key, m, ok, read, value, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; e = $f.e; key = $f.key; m = $f.m; ok = $f.ok; read = $f.read; value = $f.value; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		value = $ifaceNil;
		ok = false;
		m = this;
		_tuple = $assertType(m.read.Load(), readOnly, true);
		read = $clone(_tuple[0], readOnly);
		_tuple$1 = (_entry = read.m[$emptyInterface.keyFor(key)], _entry !== undefined ? [_entry.v, true] : [ptrType$4.nil, false]);
		e = _tuple$1[0];
		ok = _tuple$1[1];
		/* */ if (!ok && read.amended) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!ok && read.amended) { */ case 1:
			$r = m.mu.Lock(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_tuple$2 = $assertType(m.read.Load(), readOnly, true);
			readOnly.copy(read, _tuple$2[0]);
			_tuple$3 = (_entry$1 = read.m[$emptyInterface.keyFor(key)], _entry$1 !== undefined ? [_entry$1.v, true] : [ptrType$4.nil, false]);
			e = _tuple$3[0];
			ok = _tuple$3[1];
			if (!ok && read.amended) {
				_tuple$4 = (_entry$2 = m.dirty[$emptyInterface.keyFor(key)], _entry$2 !== undefined ? [_entry$2.v, true] : [ptrType$4.nil, false]);
				e = _tuple$4[0];
				ok = _tuple$4[1];
				m.missLocked();
			}
			$r = m.mu.Unlock(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		if (!ok) {
			_tmp = $ifaceNil;
			_tmp$1 = false;
			value = _tmp;
			ok = _tmp$1;
			$s = -1; return [value, ok];
		}
		_tuple$5 = e.load();
		value = _tuple$5[0];
		ok = _tuple$5[1];
		$s = -1; return [value, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Map.ptr.prototype.Load }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.e = e; $f.key = key; $f.m = m; $f.ok = ok; $f.read = read; $f.value = value; $f.$s = $s; $f.$r = $r; return $f;
	};
	Map.prototype.Load = function(key) { return this.$val.Load(key); };
	entry.ptr.prototype.load = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, e, ok, p, value;
		value = $ifaceNil;
		ok = false;
		e = this;
		p = atomic.LoadPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))));
		if (p === 0 || p === expunged) {
			_tmp = $ifaceNil;
			_tmp$1 = false;
			value = _tmp;
			ok = _tmp$1;
			return [value, ok];
		}
		_tmp$2 = (p).$get();
		_tmp$3 = true;
		value = _tmp$2;
		ok = _tmp$3;
		return [value, ok];
	};
	entry.prototype.load = function() { return this.$val.load(); };
	Map.ptr.prototype.Store = function(key, value) {
		var _entry, _entry$1, _entry$2, _key, _key$1, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, e, e$1, e$2, key, m, ok, ok$1, ok$2, read, value, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _key = $f._key; _key$1 = $f._key$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; e = $f.e; e$1 = $f.e$1; e$2 = $f.e$2; key = $f.key; m = $f.m; ok = $f.ok; ok$1 = $f.ok$1; ok$2 = $f.ok$2; read = $f.read; value = $f.value; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		value = [value];
		m = this;
		_tuple = $assertType(m.read.Load(), readOnly, true);
		read = $clone(_tuple[0], readOnly);
		_tuple$1 = (_entry = read.m[$emptyInterface.keyFor(key)], _entry !== undefined ? [_entry.v, true] : [ptrType$4.nil, false]);
		e = _tuple$1[0];
		ok = _tuple$1[1];
		if (ok && e.tryStore((value.$ptr || (value.$ptr = new ptrType$3(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, value))))) {
			$s = -1; return;
		}
		$r = m.mu.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_tuple$2 = $assertType(m.read.Load(), readOnly, true);
		readOnly.copy(read, _tuple$2[0]);
		_tuple$3 = (_entry$1 = read.m[$emptyInterface.keyFor(key)], _entry$1 !== undefined ? [_entry$1.v, true] : [ptrType$4.nil, false]);
		e$1 = _tuple$3[0];
		ok$1 = _tuple$3[1];
		if (ok$1) {
			if (e$1.unexpungeLocked()) {
				_key = key; (m.dirty || $throwRuntimeError("assignment to entry in nil map"))[$emptyInterface.keyFor(_key)] = { k: _key, v: e$1 };
			}
			e$1.storeLocked((value.$ptr || (value.$ptr = new ptrType$3(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, value))));
		} else {
			_tuple$4 = (_entry$2 = m.dirty[$emptyInterface.keyFor(key)], _entry$2 !== undefined ? [_entry$2.v, true] : [ptrType$4.nil, false]);
			e$2 = _tuple$4[0];
			ok$2 = _tuple$4[1];
			if (ok$2) {
				e$2.storeLocked((value.$ptr || (value.$ptr = new ptrType$3(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, value))));
			} else {
				if (!read.amended) {
					m.dirtyLocked();
					m.read.Store((x = new readOnly.ptr(read.m, true), new x.constructor.elem(x)));
				}
				_key$1 = key; (m.dirty || $throwRuntimeError("assignment to entry in nil map"))[$emptyInterface.keyFor(_key$1)] = { k: _key$1, v: newEntry(value[0]) };
			}
		}
		$r = m.mu.Unlock(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Map.ptr.prototype.Store }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._key = _key; $f._key$1 = _key$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f.e = e; $f.e$1 = e$1; $f.e$2 = e$2; $f.key = key; $f.m = m; $f.ok = ok; $f.ok$1 = ok$1; $f.ok$2 = ok$2; $f.read = read; $f.value = value; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Map.prototype.Store = function(key, value) { return this.$val.Store(key, value); };
	entry.ptr.prototype.tryStore = function(i) {
		var e, i, p;
		e = this;
		p = atomic.LoadPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))));
		if (p === expunged) {
			return false;
		}
		while (true) {
			if (atomic.CompareAndSwapPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))), p, (i))) {
				return true;
			}
			p = atomic.LoadPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))));
			if (p === expunged) {
				return false;
			}
		}
	};
	entry.prototype.tryStore = function(i) { return this.$val.tryStore(i); };
	entry.ptr.prototype.unexpungeLocked = function() {
		var e, wasExpunged;
		wasExpunged = false;
		e = this;
		wasExpunged = atomic.CompareAndSwapPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))), expunged, 0);
		return wasExpunged;
	};
	entry.prototype.unexpungeLocked = function() { return this.$val.unexpungeLocked(); };
	entry.ptr.prototype.storeLocked = function(i) {
		var e, i;
		e = this;
		atomic.StorePointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))), (i));
	};
	entry.prototype.storeLocked = function(i) { return this.$val.storeLocked(i); };
	Map.ptr.prototype.LoadOrStore = function(key, value) {
		var _entry, _entry$1, _entry$2, _key, _key$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, actual, actual$1, e, e$1, e$2, key, loaded, loaded$1, m, ok, ok$1, ok$2, ok$3, read, value, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _key = $f._key; _key$1 = $f._key$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; actual = $f.actual; actual$1 = $f.actual$1; e = $f.e; e$1 = $f.e$1; e$2 = $f.e$2; key = $f.key; loaded = $f.loaded; loaded$1 = $f.loaded$1; m = $f.m; ok = $f.ok; ok$1 = $f.ok$1; ok$2 = $f.ok$2; ok$3 = $f.ok$3; read = $f.read; value = $f.value; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		actual = $ifaceNil;
		loaded = false;
		m = this;
		_tuple = $assertType(m.read.Load(), readOnly, true);
		read = $clone(_tuple[0], readOnly);
		_tuple$1 = (_entry = read.m[$emptyInterface.keyFor(key)], _entry !== undefined ? [_entry.v, true] : [ptrType$4.nil, false]);
		e = _tuple$1[0];
		ok = _tuple$1[1];
		if (ok) {
			_tuple$2 = e.tryLoadOrStore(value);
			actual$1 = _tuple$2[0];
			loaded$1 = _tuple$2[1];
			ok$1 = _tuple$2[2];
			if (ok$1) {
				_tmp = actual$1;
				_tmp$1 = loaded$1;
				actual = _tmp;
				loaded = _tmp$1;
				$s = -1; return [actual, loaded];
			}
		}
		$r = m.mu.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_tuple$3 = $assertType(m.read.Load(), readOnly, true);
		readOnly.copy(read, _tuple$3[0]);
		_tuple$4 = (_entry$1 = read.m[$emptyInterface.keyFor(key)], _entry$1 !== undefined ? [_entry$1.v, true] : [ptrType$4.nil, false]);
		e$1 = _tuple$4[0];
		ok$2 = _tuple$4[1];
		if (ok$2) {
			if (e$1.unexpungeLocked()) {
				_key = key; (m.dirty || $throwRuntimeError("assignment to entry in nil map"))[$emptyInterface.keyFor(_key)] = { k: _key, v: e$1 };
			}
			_tuple$5 = e$1.tryLoadOrStore(value);
			actual = _tuple$5[0];
			loaded = _tuple$5[1];
		} else {
			_tuple$6 = (_entry$2 = m.dirty[$emptyInterface.keyFor(key)], _entry$2 !== undefined ? [_entry$2.v, true] : [ptrType$4.nil, false]);
			e$2 = _tuple$6[0];
			ok$3 = _tuple$6[1];
			if (ok$3) {
				_tuple$7 = e$2.tryLoadOrStore(value);
				actual = _tuple$7[0];
				loaded = _tuple$7[1];
				m.missLocked();
			} else {
				if (!read.amended) {
					m.dirtyLocked();
					m.read.Store((x = new readOnly.ptr(read.m, true), new x.constructor.elem(x)));
				}
				_key$1 = key; (m.dirty || $throwRuntimeError("assignment to entry in nil map"))[$emptyInterface.keyFor(_key$1)] = { k: _key$1, v: newEntry(value) };
				_tmp$2 = value;
				_tmp$3 = false;
				actual = _tmp$2;
				loaded = _tmp$3;
			}
		}
		$r = m.mu.Unlock(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_tmp$4 = actual;
		_tmp$5 = loaded;
		actual = _tmp$4;
		loaded = _tmp$5;
		$s = -1; return [actual, loaded];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Map.ptr.prototype.LoadOrStore }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._key = _key; $f._key$1 = _key$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f.actual = actual; $f.actual$1 = actual$1; $f.e = e; $f.e$1 = e$1; $f.e$2 = e$2; $f.key = key; $f.loaded = loaded; $f.loaded$1 = loaded$1; $f.m = m; $f.ok = ok; $f.ok$1 = ok$1; $f.ok$2 = ok$2; $f.ok$3 = ok$3; $f.read = read; $f.value = value; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Map.prototype.LoadOrStore = function(key, value) { return this.$val.LoadOrStore(key, value); };
	entry.ptr.prototype.tryLoadOrStore = function(i) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, actual, e, i, ic, ic$24ptr, loaded, ok, p;
		actual = $ifaceNil;
		loaded = false;
		ok = false;
		e = this;
		p = atomic.LoadPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))));
		if (p === expunged) {
			_tmp = $ifaceNil;
			_tmp$1 = false;
			_tmp$2 = false;
			actual = _tmp;
			loaded = _tmp$1;
			ok = _tmp$2;
			return [actual, loaded, ok];
		}
		if (!(p === 0)) {
			_tmp$3 = (p).$get();
			_tmp$4 = true;
			_tmp$5 = true;
			actual = _tmp$3;
			loaded = _tmp$4;
			ok = _tmp$5;
			return [actual, loaded, ok];
		}
		ic = i;
		while (true) {
			if (atomic.CompareAndSwapPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))), 0, ((ic$24ptr || (ic$24ptr = new ptrType$3(function() { return ic; }, function($v) { ic = $v; })))))) {
				_tmp$6 = i;
				_tmp$7 = false;
				_tmp$8 = true;
				actual = _tmp$6;
				loaded = _tmp$7;
				ok = _tmp$8;
				return [actual, loaded, ok];
			}
			p = atomic.LoadPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))));
			if (p === expunged) {
				_tmp$9 = $ifaceNil;
				_tmp$10 = false;
				_tmp$11 = false;
				actual = _tmp$9;
				loaded = _tmp$10;
				ok = _tmp$11;
				return [actual, loaded, ok];
			}
			if (!(p === 0)) {
				_tmp$12 = (p).$get();
				_tmp$13 = true;
				_tmp$14 = true;
				actual = _tmp$12;
				loaded = _tmp$13;
				ok = _tmp$14;
				return [actual, loaded, ok];
			}
		}
	};
	entry.prototype.tryLoadOrStore = function(i) { return this.$val.tryLoadOrStore(i); };
	Map.ptr.prototype.Delete = function(key) {
		var _entry, _entry$1, _tuple, _tuple$1, _tuple$2, _tuple$3, e, key, m, ok, read, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; e = $f.e; key = $f.key; m = $f.m; ok = $f.ok; read = $f.read; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		_tuple = $assertType(m.read.Load(), readOnly, true);
		read = $clone(_tuple[0], readOnly);
		_tuple$1 = (_entry = read.m[$emptyInterface.keyFor(key)], _entry !== undefined ? [_entry.v, true] : [ptrType$4.nil, false]);
		e = _tuple$1[0];
		ok = _tuple$1[1];
		/* */ if (!ok && read.amended) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!ok && read.amended) { */ case 1:
			$r = m.mu.Lock(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_tuple$2 = $assertType(m.read.Load(), readOnly, true);
			readOnly.copy(read, _tuple$2[0]);
			_tuple$3 = (_entry$1 = read.m[$emptyInterface.keyFor(key)], _entry$1 !== undefined ? [_entry$1.v, true] : [ptrType$4.nil, false]);
			e = _tuple$3[0];
			ok = _tuple$3[1];
			if (!ok && read.amended) {
				delete m.dirty[$emptyInterface.keyFor(key)];
			}
			$r = m.mu.Unlock(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		if (ok) {
			e.delete$();
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Map.ptr.prototype.Delete }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.e = e; $f.key = key; $f.m = m; $f.ok = ok; $f.read = read; $f.$s = $s; $f.$r = $r; return $f;
	};
	Map.prototype.Delete = function(key) { return this.$val.Delete(key); };
	entry.ptr.prototype.delete$ = function() {
		var e, hadValue, p;
		hadValue = false;
		e = this;
		while (true) {
			p = atomic.LoadPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))));
			if (p === 0 || p === expunged) {
				hadValue = false;
				return hadValue;
			}
			if (atomic.CompareAndSwapPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))), p, 0)) {
				hadValue = true;
				return hadValue;
			}
		}
	};
	entry.prototype.delete$ = function() { return this.$val.delete$(); };
	Map.ptr.prototype.Range = function(f) {
		var _entry, _i, _keys, _r, _ref, _tuple, _tuple$1, _tuple$2, e, f, k, m, ok, read, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _r = $f._r; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; e = $f.e; f = $f.f; k = $f.k; m = $f.m; ok = $f.ok; read = $f.read; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		_tuple = $assertType(m.read.Load(), readOnly, true);
		read = $clone(_tuple[0], readOnly);
		/* */ if (read.amended) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (read.amended) { */ case 1:
			$r = m.mu.Lock(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_tuple$1 = $assertType(m.read.Load(), readOnly, true);
			readOnly.copy(read, _tuple$1[0]);
			if (read.amended) {
				readOnly.copy(read, new readOnly.ptr(m.dirty, false));
				m.read.Store(new read.constructor.elem(read));
				m.dirty = false;
				m.misses = 0;
			}
			$r = m.mu.Unlock(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		_ref = read.m;
		_i = 0;
		_keys = $keys(_ref);
		/* while (true) { */ case 5:
			/* if (!(_i < _keys.length)) { break; } */ if(!(_i < _keys.length)) { $s = 6; continue; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				/* continue; */ $s = 5; continue;
			}
			k = _entry.k;
			e = _entry.v;
			_tuple$2 = e.load();
			v = _tuple$2[0];
			ok = _tuple$2[1];
			/* */ if (!ok) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!ok) { */ case 7:
				_i++;
				/* continue; */ $s = 5; continue;
			/* } */ case 8:
			_r = f(k, v); /* */ $s = 11; case 11: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (!_r) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (!_r) { */ case 9:
				/* break; */ $s = 6; continue;
			/* } */ case 10:
			_i++;
		/* } */ $s = 5; continue; case 6:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Map.ptr.prototype.Range }; } $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._r = _r; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.e = e; $f.f = f; $f.k = k; $f.m = m; $f.ok = ok; $f.read = read; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Map.prototype.Range = function(f) { return this.$val.Range(f); };
	Map.ptr.prototype.missLocked = function() {
		var m, x;
		m = this;
		m.misses = m.misses + (1) >> 0;
		if (m.misses < $keys(m.dirty).length) {
			return;
		}
		m.read.Store((x = new readOnly.ptr(m.dirty, false), new x.constructor.elem(x)));
		m.dirty = false;
		m.misses = 0;
	};
	Map.prototype.missLocked = function() { return this.$val.missLocked(); };
	Map.ptr.prototype.dirtyLocked = function() {
		var _entry, _i, _key, _keys, _ref, _tuple, e, k, m, read, x;
		m = this;
		if (!(m.dirty === false)) {
			return;
		}
		_tuple = $assertType(m.read.Load(), readOnly, true);
		read = $clone(_tuple[0], readOnly);
		m.dirty = (x = $keys(read.m).length, ((x < 0 || x > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		_ref = read.m;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			e = _entry.v;
			if (!e.tryExpungeLocked()) {
				_key = k; (m.dirty || $throwRuntimeError("assignment to entry in nil map"))[$emptyInterface.keyFor(_key)] = { k: _key, v: e };
			}
			_i++;
		}
	};
	Map.prototype.dirtyLocked = function() { return this.$val.dirtyLocked(); };
	entry.ptr.prototype.tryExpungeLocked = function() {
		var e, isExpunged, p;
		isExpunged = false;
		e = this;
		p = atomic.LoadPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))));
		while (true) {
			if (!(p === 0)) { break; }
			if (atomic.CompareAndSwapPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))), 0, expunged)) {
				isExpunged = true;
				return isExpunged;
			}
			p = atomic.LoadPointer((e.$ptr_p || (e.$ptr_p = new ptrType$5(function() { return this.$target.p; }, function($v) { this.$target.p = $v; }, e))));
		}
		isExpunged = p === expunged;
		return isExpunged;
	};
	entry.prototype.tryExpungeLocked = function() { return this.$val.tryExpungeLocked(); };
	Mutex.ptr.prototype.Lock = function() {
		var awoke, delta, iter, m, new$1, old, queueLifo, starving, waitStartTime, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; awoke = $f.awoke; delta = $f.delta; iter = $f.iter; m = $f.m; new$1 = $f.new$1; old = $f.old; queueLifo = $f.queueLifo; starving = $f.starving; waitStartTime = $f.waitStartTime; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), 0, 1)) {
			if (false) {
				race.Acquire((m));
			}
			$s = -1; return;
		}
		waitStartTime = new $Int64(0, 0);
		starving = false;
		awoke = false;
		iter = 0;
		old = m.state;
		/* while (true) { */ case 1:
			/* */ if (((old & 5) === 1) && runtime_canSpin(iter)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (((old & 5) === 1) && runtime_canSpin(iter)) { */ case 3:
				if (!awoke && ((old & 2) === 0) && !(((old >> 3 >> 0) === 0)) && atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, old | 2)) {
					awoke = true;
				}
				runtime_doSpin();
				iter = iter + (1) >> 0;
				old = m.state;
				/* continue; */ $s = 1; continue;
			/* } */ case 4:
			new$1 = old;
			if ((old & 4) === 0) {
				new$1 = new$1 | (1);
			}
			if (!(((old & 5) === 0))) {
				new$1 = new$1 + (8) >> 0;
			}
			if (starving && !(((old & 1) === 0))) {
				new$1 = new$1 | (4);
			}
			if (awoke) {
				if ((new$1 & 2) === 0) {
					$panic(new $String("sync: inconsistent mutex state"));
				}
				new$1 = (new$1 & ~(2)) >> 0;
			}
			/* */ if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 5:
				if ((old & 5) === 0) {
					/* break; */ $s = 2; continue;
				}
				queueLifo = !((waitStartTime.$high === 0 && waitStartTime.$low === 0));
				if ((waitStartTime.$high === 0 && waitStartTime.$low === 0)) {
					waitStartTime = runtime_nanotime();
				}
				$r = runtime_SemacquireMutex((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), queueLifo); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				starving = starving || (x = (x$1 = runtime_nanotime(), new $Int64(x$1.$high - waitStartTime.$high, x$1.$low - waitStartTime.$low)), (x.$high > 0 || (x.$high === 0 && x.$low > 1000000)));
				old = m.state;
				if (!(((old & 4) === 0))) {
					if (!(((old & 3) === 0)) || ((old >> 3 >> 0) === 0)) {
						$panic(new $String("sync: inconsistent mutex state"));
					}
					delta = -7;
					if (!starving || ((old >> 3 >> 0) === 1)) {
						delta = delta - (4) >> 0;
					}
					atomic.AddInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), delta);
					/* break; */ $s = 2; continue;
				}
				awoke = true;
				iter = 0;
				$s = 7; continue;
			/* } else { */ case 6:
				old = m.state;
			/* } */ case 7:
		/* } */ $s = 1; continue; case 2:
		if (false) {
			race.Acquire((m));
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Mutex.ptr.prototype.Lock }; } $f.awoke = awoke; $f.delta = delta; $f.iter = iter; $f.m = m; $f.new$1 = new$1; $f.old = old; $f.queueLifo = queueLifo; $f.starving = starving; $f.waitStartTime = waitStartTime; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Mutex.prototype.Lock = function() { return this.$val.Lock(); };
	Mutex.ptr.prototype.Unlock = function() {
		var m, new$1, old, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; m = $f.m; new$1 = $f.new$1; old = $f.old; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		if (false) {
			$unused(m.state);
			race.Release((m));
		}
		new$1 = atomic.AddInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), -1);
		if ((((new$1 + 1 >> 0)) & 1) === 0) {
			$panic(new $String("sync: unlock of unlocked mutex"));
		}
		/* */ if ((new$1 & 4) === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((new$1 & 4) === 0) { */ case 1:
			old = new$1;
			/* while (true) { */ case 4:
				if (((old >> 3 >> 0) === 0) || !(((old & 7) === 0))) {
					$s = -1; return;
				}
				new$1 = ((old - 8 >> 0)) | 2;
				/* */ if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { $s = 6; continue; }
				/* */ $s = 7; continue;
				/* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 6:
					$r = runtime_Semrelease((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), false); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					$s = -1; return;
				/* } */ case 7:
				old = m.state;
			/* } */ $s = 4; continue; case 5:
			$s = 3; continue;
		/* } else { */ case 2:
			$r = runtime_Semrelease((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), true); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Mutex.ptr.prototype.Unlock }; } $f.m = m; $f.new$1 = new$1; $f.old = old; $f.$s = $s; $f.$r = $r; return $f;
	};
	Mutex.prototype.Unlock = function() { return this.$val.Unlock(); };
	poolCleanup = function() {
		var _i, _i$1, _ref, _ref$1, i, i$1, j, l, p, x;
		_ref = allPools;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			p = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			((i < 0 || i >= allPools.$length) ? ($throwRuntimeError("index out of range"), undefined) : allPools.$array[allPools.$offset + i] = ptrType.nil);
			i$1 = 0;
			while (true) {
				if (!(i$1 < ((p.localSize >> 0)))) { break; }
				l = indexLocal(p.local, i$1);
				l.poolLocalInternal.private$0 = $ifaceNil;
				_ref$1 = l.poolLocalInternal.shared;
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					j = _i$1;
					(x = l.poolLocalInternal.shared, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j] = $ifaceNil));
					_i$1++;
				}
				l.poolLocalInternal.shared = sliceType$4.nil;
				i$1 = i$1 + (1) >> 0;
			}
			p.local = 0;
			p.localSize = 0;
			_i++;
		}
		allPools = new sliceType([]);
	};
	init = function() {
		runtime_registerPoolCleanup(poolCleanup);
	};
	indexLocal = function(l, i) {
		var i, l, lp;
		lp = (((l) + ($imul(((i >>> 0)), 128) >>> 0) >>> 0));
		return ($pointerOfStructConversion(lp, ptrType$7));
	};
	init$1 = function() {
		var n;
		n = new notifyList.ptr(0, 0, 0, 0, 0);
		runtime_notifyListCheck(20);
	};
	runtime_doSpin = function() {
		$throwRuntimeError("native function not implemented: sync.runtime_doSpin");
	};
	ptrType.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Put", name: "Put", pkg: "", typ: $funcType([$emptyInterface], [], false)}, {prop: "getSlow", name: "getSlow", pkg: "sync", typ: $funcType([], [$emptyInterface], false)}, {prop: "pin", name: "pin", pkg: "sync", typ: $funcType([], [ptrType$7], false)}, {prop: "pinSlow", name: "pinSlow", pkg: "sync", typ: $funcType([], [ptrType$7], false)}];
	ptrType$15.methods = [{prop: "Load", name: "Load", pkg: "", typ: $funcType([$emptyInterface], [$emptyInterface, $Bool], false)}, {prop: "Store", name: "Store", pkg: "", typ: $funcType([$emptyInterface, $emptyInterface], [], false)}, {prop: "LoadOrStore", name: "LoadOrStore", pkg: "", typ: $funcType([$emptyInterface, $emptyInterface], [$emptyInterface, $Bool], false)}, {prop: "Delete", name: "Delete", pkg: "", typ: $funcType([$emptyInterface], [], false)}, {prop: "Range", name: "Range", pkg: "", typ: $funcType([funcType$1], [], false)}, {prop: "missLocked", name: "missLocked", pkg: "sync", typ: $funcType([], [], false)}, {prop: "dirtyLocked", name: "dirtyLocked", pkg: "sync", typ: $funcType([], [], false)}];
	ptrType$4.methods = [{prop: "load", name: "load", pkg: "sync", typ: $funcType([], [$emptyInterface, $Bool], false)}, {prop: "tryStore", name: "tryStore", pkg: "sync", typ: $funcType([ptrType$3], [$Bool], false)}, {prop: "unexpungeLocked", name: "unexpungeLocked", pkg: "sync", typ: $funcType([], [$Bool], false)}, {prop: "storeLocked", name: "storeLocked", pkg: "sync", typ: $funcType([ptrType$3], [], false)}, {prop: "tryLoadOrStore", name: "tryLoadOrStore", pkg: "sync", typ: $funcType([$emptyInterface], [$emptyInterface, $Bool, $Bool], false)}, {prop: "delete$", name: "delete", pkg: "sync", typ: $funcType([], [$Bool], false)}, {prop: "tryExpungeLocked", name: "tryExpungeLocked", pkg: "sync", typ: $funcType([], [$Bool], false)}];
	ptrType$16.methods = [{prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false)}, {prop: "Unlock", name: "Unlock", pkg: "", typ: $funcType([], [], false)}];
	Pool.init("sync", [{prop: "local", name: "local", anonymous: false, exported: false, typ: $UnsafePointer, tag: ""}, {prop: "localSize", name: "localSize", anonymous: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "store", name: "store", anonymous: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "New", name: "New", anonymous: false, exported: true, typ: funcType, tag: ""}]);
	Map.init("sync", [{prop: "mu", name: "mu", anonymous: false, exported: false, typ: Mutex, tag: ""}, {prop: "read", name: "read", anonymous: false, exported: false, typ: atomic.Value, tag: ""}, {prop: "dirty", name: "dirty", anonymous: false, exported: false, typ: mapType, tag: ""}, {prop: "misses", name: "misses", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	readOnly.init("sync", [{prop: "m", name: "m", anonymous: false, exported: false, typ: mapType, tag: ""}, {prop: "amended", name: "amended", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	entry.init("sync", [{prop: "p", name: "p", anonymous: false, exported: false, typ: $UnsafePointer, tag: ""}]);
	Mutex.init("sync", [{prop: "state", name: "state", anonymous: false, exported: false, typ: $Int32, tag: ""}, {prop: "sema", name: "sema", anonymous: false, exported: false, typ: $Uint32, tag: ""}]);
	poolLocalInternal.init("sync", [{prop: "private$0", name: "private", anonymous: false, exported: false, typ: $emptyInterface, tag: ""}, {prop: "shared", name: "shared", anonymous: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "Mutex", name: "Mutex", anonymous: true, exported: true, typ: Mutex, tag: ""}]);
	poolLocal.init("sync", [{prop: "poolLocalInternal", name: "poolLocalInternal", anonymous: true, exported: false, typ: poolLocalInternal, tag: ""}, {prop: "pad", name: "pad", anonymous: false, exported: false, typ: arrayType$2, tag: ""}]);
	notifyList.init("sync", [{prop: "wait", name: "wait", anonymous: false, exported: false, typ: $Uint32, tag: ""}, {prop: "notify", name: "notify", anonymous: false, exported: false, typ: $Uint32, tag: ""}, {prop: "lock", name: "lock", anonymous: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "head", name: "head", anonymous: false, exported: false, typ: $UnsafePointer, tag: ""}, {prop: "tail", name: "tail", anonymous: false, exported: false, typ: $UnsafePointer, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = race.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		allPools = sliceType.nil;
		semWaiters = {};
		expunged = (new Uint8Array(8));
		init();
		init$1();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["io"] = (function() {
	var $pkg = {}, $init, errors, sync, Reader, Writer, ReaderFrom, WriterTo, ByteReader, ByteScanner, RuneReader, RuneScanner, stringWriter, sliceType, errWhence, errOffset, WriteString;
	errors = $packages["errors"];
	sync = $packages["sync"];
	Reader = $pkg.Reader = $newType(8, $kindInterface, "io.Reader", true, "io", true, null);
	Writer = $pkg.Writer = $newType(8, $kindInterface, "io.Writer", true, "io", true, null);
	ReaderFrom = $pkg.ReaderFrom = $newType(8, $kindInterface, "io.ReaderFrom", true, "io", true, null);
	WriterTo = $pkg.WriterTo = $newType(8, $kindInterface, "io.WriterTo", true, "io", true, null);
	ByteReader = $pkg.ByteReader = $newType(8, $kindInterface, "io.ByteReader", true, "io", true, null);
	ByteScanner = $pkg.ByteScanner = $newType(8, $kindInterface, "io.ByteScanner", true, "io", true, null);
	RuneReader = $pkg.RuneReader = $newType(8, $kindInterface, "io.RuneReader", true, "io", true, null);
	RuneScanner = $pkg.RuneScanner = $newType(8, $kindInterface, "io.RuneScanner", true, "io", true, null);
	stringWriter = $pkg.stringWriter = $newType(8, $kindInterface, "io.stringWriter", true, "io", false, null);
	sliceType = $sliceType($Uint8);
	WriteString = function(w, s) {
		var _r, _r$1, _tuple, _tuple$1, _tuple$2, err, n, ok, s, sw, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; err = $f.err; n = $f.n; ok = $f.ok; s = $f.s; sw = $f.sw; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		_tuple = $assertType(w, stringWriter, true);
		sw = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (ok) { */ case 1:
			_r = sw.WriteString(s); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple$1 = _r;
			n = _tuple$1[0];
			err = _tuple$1[1];
			$s = -1; return [n, err];
		/* } */ case 2:
		_r$1 = w.Write((new sliceType($stringToBytes(s)))); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$2 = _r$1;
		n = _tuple$2[0];
		err = _tuple$2[1];
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: WriteString }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.err = err; $f.n = n; $f.ok = ok; $f.s = s; $f.sw = sw; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.WriteString = WriteString;
	Reader.init([{prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}]);
	Writer.init([{prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}]);
	ReaderFrom.init([{prop: "ReadFrom", name: "ReadFrom", pkg: "", typ: $funcType([Reader], [$Int64, $error], false)}]);
	WriterTo.init([{prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([Writer], [$Int64, $error], false)}]);
	ByteReader.init([{prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}]);
	ByteScanner.init([{prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}]);
	RuneReader.init([{prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}]);
	RuneScanner.init([{prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}]);
	stringWriter.init([{prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrShortWrite = errors.New("short write");
		$pkg.ErrShortBuffer = errors.New("short buffer");
		$pkg.EOF = errors.New("EOF");
		$pkg.ErrUnexpectedEOF = errors.New("unexpected EOF");
		$pkg.ErrNoProgress = errors.New("multiple Read calls return no data or error");
		errWhence = errors.New("Seek: invalid whence");
		errOffset = errors.New("Seek: invalid offset");
		$pkg.ErrClosedPipe = errors.New("io: read/write on closed pipe");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["unicode"] = (function() {
	var $pkg = {}, $init, RangeTable, Range16, Range32, CaseRange, d, foldPair, arrayType, sliceType, sliceType$1, ptrType, sliceType$2, sliceType$3, sliceType$4, _C, _Cc, _Cf, _Co, _Cs, _L, _Ll, _Lm, _Lo, _Lt, _Lu, _M, _Mc, _Me, _Mn, _N, _Nd, _Nl, _No, _P, _Pc, _Pd, _Pe, _Pf, _Pi, _Po, _Ps, _S, _Sc, _Sk, _Sm, _So, _Z, _Zl, _Zp, _Zs, _Adlam, _Ahom, _Anatolian_Hieroglyphs, _Arabic, _Armenian, _Avestan, _Balinese, _Bamum, _Bassa_Vah, _Batak, _Bengali, _Bhaiksuki, _Bopomofo, _Brahmi, _Braille, _Buginese, _Buhid, _Canadian_Aboriginal, _Carian, _Caucasian_Albanian, _Chakma, _Cham, _Cherokee, _Common, _Coptic, _Cuneiform, _Cypriot, _Cyrillic, _Deseret, _Devanagari, _Duployan, _Egyptian_Hieroglyphs, _Elbasan, _Ethiopic, _Georgian, _Glagolitic, _Gothic, _Grantha, _Greek, _Gujarati, _Gurmukhi, _Han, _Hangul, _Hanunoo, _Hatran, _Hebrew, _Hiragana, _Imperial_Aramaic, _Inherited, _Inscriptional_Pahlavi, _Inscriptional_Parthian, _Javanese, _Kaithi, _Kannada, _Katakana, _Kayah_Li, _Kharoshthi, _Khmer, _Khojki, _Khudawadi, _Lao, _Latin, _Lepcha, _Limbu, _Linear_A, _Linear_B, _Lisu, _Lycian, _Lydian, _Mahajani, _Malayalam, _Mandaic, _Manichaean, _Marchen, _Meetei_Mayek, _Mende_Kikakui, _Meroitic_Cursive, _Meroitic_Hieroglyphs, _Miao, _Modi, _Mongolian, _Mro, _Multani, _Myanmar, _Nabataean, _New_Tai_Lue, _Newa, _Nko, _Ogham, _Ol_Chiki, _Old_Hungarian, _Old_Italic, _Old_North_Arabian, _Old_Permic, _Old_Persian, _Old_South_Arabian, _Old_Turkic, _Oriya, _Osage, _Osmanya, _Pahawh_Hmong, _Palmyrene, _Pau_Cin_Hau, _Phags_Pa, _Phoenician, _Psalter_Pahlavi, _Rejang, _Runic, _Samaritan, _Saurashtra, _Sharada, _Shavian, _Siddham, _SignWriting, _Sinhala, _Sora_Sompeng, _Sundanese, _Syloti_Nagri, _Syriac, _Tagalog, _Tagbanwa, _Tai_Le, _Tai_Tham, _Tai_Viet, _Takri, _Tamil, _Tangut, _Telugu, _Thaana, _Thai, _Tibetan, _Tifinagh, _Tirhuta, _Ugaritic, _Vai, _Warang_Citi, _Yi, _White_Space, _CaseRanges, properties, asciiFold, caseOrbit, foldL, foldLl, foldLt, foldLu, foldM, foldMn, foldCommon, foldGreek, foldInherited, to, IsDigit, IsPrint, In, IsLetter, IsSpace, is16, is32, Is, isExcludingLatin, IsUpper, To, ToUpper, ToLower, SimpleFold;
	RangeTable = $pkg.RangeTable = $newType(0, $kindStruct, "unicode.RangeTable", true, "unicode", true, function(R16_, R32_, LatinOffset_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.R16 = sliceType.nil;
			this.R32 = sliceType$1.nil;
			this.LatinOffset = 0;
			return;
		}
		this.R16 = R16_;
		this.R32 = R32_;
		this.LatinOffset = LatinOffset_;
	});
	Range16 = $pkg.Range16 = $newType(0, $kindStruct, "unicode.Range16", true, "unicode", true, function(Lo_, Hi_, Stride_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Stride = 0;
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Stride = Stride_;
	});
	Range32 = $pkg.Range32 = $newType(0, $kindStruct, "unicode.Range32", true, "unicode", true, function(Lo_, Hi_, Stride_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Stride = 0;
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Stride = Stride_;
	});
	CaseRange = $pkg.CaseRange = $newType(0, $kindStruct, "unicode.CaseRange", true, "unicode", true, function(Lo_, Hi_, Delta_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Delta = arrayType.zero();
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Delta = Delta_;
	});
	d = $pkg.d = $newType(12, $kindArray, "unicode.d", true, "unicode", false, null);
	foldPair = $pkg.foldPair = $newType(0, $kindStruct, "unicode.foldPair", true, "unicode", false, function(From_, To_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.From = 0;
			this.To = 0;
			return;
		}
		this.From = From_;
		this.To = To_;
	});
	arrayType = $arrayType($Int32, 3);
	sliceType = $sliceType(Range16);
	sliceType$1 = $sliceType(Range32);
	ptrType = $ptrType(RangeTable);
	sliceType$2 = $sliceType(ptrType);
	sliceType$3 = $sliceType(CaseRange);
	sliceType$4 = $sliceType(foldPair);
	to = function(_case, r, caseRange) {
		var _case, _q, caseRange, cr, delta, hi, lo, m, r, x;
		if (_case < 0 || 3 <= _case) {
			return 65533;
		}
		lo = 0;
		hi = caseRange.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			cr = ((m < 0 || m >= caseRange.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseRange.$array[caseRange.$offset + m]);
			if (((cr.Lo >> 0)) <= r && r <= ((cr.Hi >> 0))) {
				delta = ((x = cr.Delta, ((_case < 0 || _case >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[_case])));
				if (delta > 1114111) {
					return ((cr.Lo >> 0)) + ((((((r - ((cr.Lo >> 0)) >> 0)) & ~1) >> 0) | (((_case & 1) >> 0)))) >> 0;
				}
				return r + delta >> 0;
			}
			if (r < ((cr.Lo >> 0))) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return r;
	};
	IsDigit = function(r) {
		var r;
		if (r <= 255) {
			return 48 <= r && r <= 57;
		}
		return isExcludingLatin($pkg.Digit, r);
	};
	$pkg.IsDigit = IsDigit;
	IsPrint = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 128) >>> 0) === 0));
		}
		return In(r, $pkg.PrintRanges);
	};
	$pkg.IsPrint = IsPrint;
	In = function(r, ranges) {
		var _i, _ref, inside, r, ranges;
		_ref = ranges;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			inside = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (Is(inside, r)) {
				return true;
			}
			_i++;
		}
		return false;
	};
	$pkg.In = In;
	IsLetter = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 96) >>> 0) === 0));
		}
		return isExcludingLatin($pkg.Letter, r);
	};
	$pkg.IsLetter = IsLetter;
	IsSpace = function(r) {
		var _1, r;
		if (((r >>> 0)) <= 255) {
			_1 = r;
			if ((_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12)) || (_1 === (13)) || (_1 === (32)) || (_1 === (133)) || (_1 === (160))) {
				return true;
			}
			return false;
		}
		return isExcludingLatin($pkg.White_Space, r);
	};
	$pkg.IsSpace = IsSpace;
	is16 = function(ranges, r) {
		var _i, _q, _r, _r$1, _ref, hi, i, lo, m, r, range_, range_$1, ranges;
		if (ranges.$length <= 18 || r <= 255) {
			_ref = ranges;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				range_ = ((i < 0 || i >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + i]);
				if (r < range_.Lo) {
					return false;
				}
				if (r <= range_.Hi) {
					return (_r = ((r - range_.Lo << 16 >>> 16)) % range_.Stride, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0;
				}
				_i++;
			}
			return false;
		}
		lo = 0;
		hi = ranges.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			range_$1 = ((m < 0 || m >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + m]);
			if (range_$1.Lo <= r && r <= range_$1.Hi) {
				return (_r$1 = ((r - range_$1.Lo << 16 >>> 16)) % range_$1.Stride, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0;
			}
			if (r < range_$1.Lo) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return false;
	};
	is32 = function(ranges, r) {
		var _i, _q, _r, _r$1, _ref, hi, i, lo, m, r, range_, range_$1, ranges;
		if (ranges.$length <= 18) {
			_ref = ranges;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				range_ = ((i < 0 || i >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + i]);
				if (r < range_.Lo) {
					return false;
				}
				if (r <= range_.Hi) {
					return (_r = ((r - range_.Lo >>> 0)) % range_.Stride, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0;
				}
				_i++;
			}
			return false;
		}
		lo = 0;
		hi = ranges.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			range_$1 = $clone(((m < 0 || m >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + m]), Range32);
			if (range_$1.Lo <= r && r <= range_$1.Hi) {
				return (_r$1 = ((r - range_$1.Lo >>> 0)) % range_$1.Stride, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0;
			}
			if (r < range_$1.Lo) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return false;
	};
	Is = function(rangeTab, r) {
		var r, r16, r32, rangeTab, x;
		r16 = rangeTab.R16;
		if (r16.$length > 0 && r <= (((x = r16.$length - 1 >> 0, ((x < 0 || x >= r16.$length) ? ($throwRuntimeError("index out of range"), undefined) : r16.$array[r16.$offset + x])).Hi >> 0))) {
			return is16(r16, ((r << 16 >>> 16)));
		}
		r32 = rangeTab.R32;
		if (r32.$length > 0 && r >= (((0 >= r32.$length ? ($throwRuntimeError("index out of range"), undefined) : r32.$array[r32.$offset + 0]).Lo >> 0))) {
			return is32(r32, ((r >>> 0)));
		}
		return false;
	};
	$pkg.Is = Is;
	isExcludingLatin = function(rangeTab, r) {
		var off, r, r16, r32, rangeTab, x;
		r16 = rangeTab.R16;
		off = rangeTab.LatinOffset;
		if (r16.$length > off && r <= (((x = r16.$length - 1 >> 0, ((x < 0 || x >= r16.$length) ? ($throwRuntimeError("index out of range"), undefined) : r16.$array[r16.$offset + x])).Hi >> 0))) {
			return is16($subslice(r16, off), ((r << 16 >>> 16)));
		}
		r32 = rangeTab.R32;
		if (r32.$length > 0 && r >= (((0 >= r32.$length ? ($throwRuntimeError("index out of range"), undefined) : r32.$array[r32.$offset + 0]).Lo >> 0))) {
			return is32(r32, ((r >>> 0)));
		}
		return false;
	};
	IsUpper = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return (((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 96) >>> 0) === 32;
		}
		return isExcludingLatin($pkg.Upper, r);
	};
	$pkg.IsUpper = IsUpper;
	To = function(_case, r) {
		var _case, r;
		return to(_case, r, $pkg.CaseRanges);
	};
	$pkg.To = To;
	ToUpper = function(r) {
		var r;
		if (r <= 127) {
			if (97 <= r && r <= 122) {
				r = r - (32) >> 0;
			}
			return r;
		}
		return To(0, r);
	};
	$pkg.ToUpper = ToUpper;
	ToLower = function(r) {
		var r;
		if (r <= 127) {
			if (65 <= r && r <= 90) {
				r = r + (32) >> 0;
			}
			return r;
		}
		return To(1, r);
	};
	$pkg.ToLower = ToLower;
	SimpleFold = function(r) {
		var _q, hi, l, lo, m, r;
		if (r < 0 || r > 1114111) {
			return r;
		}
		if (((r >> 0)) < 128) {
			return ((((r < 0 || r >= asciiFold.length) ? ($throwRuntimeError("index out of range"), undefined) : asciiFold[r]) >> 0));
		}
		lo = 0;
		hi = caseOrbit.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((((m < 0 || m >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + m]).From >> 0)) < r) {
				lo = m + 1 >> 0;
			} else {
				hi = m;
			}
		}
		if (lo < caseOrbit.$length && (((((lo < 0 || lo >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + lo]).From >> 0)) === r)) {
			return ((((lo < 0 || lo >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + lo]).To >> 0));
		}
		l = ToLower(r);
		if (!((l === r))) {
			return l;
		}
		return ToUpper(r);
	};
	$pkg.SimpleFold = SimpleFold;
	RangeTable.init("", [{prop: "R16", name: "R16", anonymous: false, exported: true, typ: sliceType, tag: ""}, {prop: "R32", name: "R32", anonymous: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "LatinOffset", name: "LatinOffset", anonymous: false, exported: true, typ: $Int, tag: ""}]);
	Range16.init("", [{prop: "Lo", name: "Lo", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Hi", name: "Hi", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Stride", name: "Stride", anonymous: false, exported: true, typ: $Uint16, tag: ""}]);
	Range32.init("", [{prop: "Lo", name: "Lo", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Hi", name: "Hi", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Stride", name: "Stride", anonymous: false, exported: true, typ: $Uint32, tag: ""}]);
	CaseRange.init("", [{prop: "Lo", name: "Lo", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Hi", name: "Hi", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Delta", name: "Delta", anonymous: false, exported: true, typ: d, tag: ""}]);
	d.init($Int32, 3);
	foldPair.init("", [{prop: "From", name: "From", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "To", name: "To", anonymous: false, exported: true, typ: $Uint16, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_C = new RangeTable.ptr(new sliceType([new Range16.ptr(0, 31, 1), new Range16.ptr(127, 159, 1), new Range16.ptr(173, 1536, 1363), new Range16.ptr(1537, 1541, 1), new Range16.ptr(1564, 1757, 193), new Range16.ptr(1807, 2274, 467), new Range16.ptr(6158, 8203, 2045), new Range16.ptr(8204, 8207, 1), new Range16.ptr(8234, 8238, 1), new Range16.ptr(8288, 8292, 1), new Range16.ptr(8294, 8303, 1), new Range16.ptr(55296, 63743, 1), new Range16.ptr(65279, 65529, 250), new Range16.ptr(65530, 65531, 1)]), new sliceType$1([new Range32.ptr(69821, 113824, 44003), new Range32.ptr(113825, 113827, 1), new Range32.ptr(119155, 119162, 1), new Range32.ptr(917505, 917536, 31), new Range32.ptr(917537, 917631, 1), new Range32.ptr(983040, 1048573, 1), new Range32.ptr(1048576, 1114109, 1)]), 2);
		_Cc = new RangeTable.ptr(new sliceType([new Range16.ptr(0, 31, 1), new Range16.ptr(127, 159, 1)]), sliceType$1.nil, 2);
		_Cf = new RangeTable.ptr(new sliceType([new Range16.ptr(173, 1536, 1363), new Range16.ptr(1537, 1541, 1), new Range16.ptr(1564, 1757, 193), new Range16.ptr(1807, 2274, 467), new Range16.ptr(6158, 8203, 2045), new Range16.ptr(8204, 8207, 1), new Range16.ptr(8234, 8238, 1), new Range16.ptr(8288, 8292, 1), new Range16.ptr(8294, 8303, 1), new Range16.ptr(65279, 65529, 250), new Range16.ptr(65530, 65531, 1)]), new sliceType$1([new Range32.ptr(69821, 113824, 44003), new Range32.ptr(113825, 113827, 1), new Range32.ptr(119155, 119162, 1), new Range32.ptr(917505, 917536, 31), new Range32.ptr(917537, 917631, 1)]), 0);
		_Co = new RangeTable.ptr(new sliceType([new Range16.ptr(57344, 63743, 1)]), new sliceType$1([new Range32.ptr(983040, 1048573, 1), new Range32.ptr(1048576, 1114109, 1)]), 0);
		_Cs = new RangeTable.ptr(new sliceType([new Range16.ptr(55296, 57343, 1)]), sliceType$1.nil, 0);
		_L = new RangeTable.ptr(new sliceType([new Range16.ptr(65, 90, 1), new Range16.ptr(97, 122, 1), new Range16.ptr(170, 181, 11), new Range16.ptr(186, 192, 6), new Range16.ptr(193, 214, 1), new Range16.ptr(216, 246, 1), new Range16.ptr(248, 705, 1), new Range16.ptr(710, 721, 1), new Range16.ptr(736, 740, 1), new Range16.ptr(748, 750, 2), new Range16.ptr(880, 884, 1), new Range16.ptr(886, 887, 1), new Range16.ptr(890, 893, 1), new Range16.ptr(895, 902, 7), new Range16.ptr(904, 906, 1), new Range16.ptr(908, 910, 2), new Range16.ptr(911, 929, 1), new Range16.ptr(931, 1013, 1), new Range16.ptr(1015, 1153, 1), new Range16.ptr(1162, 1327, 1), new Range16.ptr(1329, 1366, 1), new Range16.ptr(1369, 1377, 8), new Range16.ptr(1378, 1415, 1), new Range16.ptr(1488, 1514, 1), new Range16.ptr(1520, 1522, 1), new Range16.ptr(1568, 1610, 1), new Range16.ptr(1646, 1647, 1), new Range16.ptr(1649, 1747, 1), new Range16.ptr(1749, 1765, 16), new Range16.ptr(1766, 1774, 8), new Range16.ptr(1775, 1786, 11), new Range16.ptr(1787, 1788, 1), new Range16.ptr(1791, 1808, 17), new Range16.ptr(1810, 1839, 1), new Range16.ptr(1869, 1957, 1), new Range16.ptr(1969, 1994, 25), new Range16.ptr(1995, 2026, 1), new Range16.ptr(2036, 2037, 1), new Range16.ptr(2042, 2048, 6), new Range16.ptr(2049, 2069, 1), new Range16.ptr(2074, 2084, 10), new Range16.ptr(2088, 2112, 24), new Range16.ptr(2113, 2136, 1), new Range16.ptr(2208, 2228, 1), new Range16.ptr(2230, 2237, 1), new Range16.ptr(2308, 2361, 1), new Range16.ptr(2365, 2384, 19), new Range16.ptr(2392, 2401, 1), new Range16.ptr(2417, 2432, 1), new Range16.ptr(2437, 2444, 1), new Range16.ptr(2447, 2448, 1), new Range16.ptr(2451, 2472, 1), new Range16.ptr(2474, 2480, 1), new Range16.ptr(2482, 2486, 4), new Range16.ptr(2487, 2489, 1), new Range16.ptr(2493, 2510, 17), new Range16.ptr(2524, 2525, 1), new Range16.ptr(2527, 2529, 1), new Range16.ptr(2544, 2545, 1), new Range16.ptr(2565, 2570, 1), new Range16.ptr(2575, 2576, 1), new Range16.ptr(2579, 2600, 1), new Range16.ptr(2602, 2608, 1), new Range16.ptr(2610, 2611, 1), new Range16.ptr(2613, 2614, 1), new Range16.ptr(2616, 2617, 1), new Range16.ptr(2649, 2652, 1), new Range16.ptr(2654, 2674, 20), new Range16.ptr(2675, 2676, 1), new Range16.ptr(2693, 2701, 1), new Range16.ptr(2703, 2705, 1), new Range16.ptr(2707, 2728, 1), new Range16.ptr(2730, 2736, 1), new Range16.ptr(2738, 2739, 1), new Range16.ptr(2741, 2745, 1), new Range16.ptr(2749, 2768, 19), new Range16.ptr(2784, 2785, 1), new Range16.ptr(2809, 2821, 12), new Range16.ptr(2822, 2828, 1), new Range16.ptr(2831, 2832, 1), new Range16.ptr(2835, 2856, 1), new Range16.ptr(2858, 2864, 1), new Range16.ptr(2866, 2867, 1), new Range16.ptr(2869, 2873, 1), new Range16.ptr(2877, 2908, 31), new Range16.ptr(2909, 2911, 2), new Range16.ptr(2912, 2913, 1), new Range16.ptr(2929, 2947, 18), new Range16.ptr(2949, 2954, 1), new Range16.ptr(2958, 2960, 1), new Range16.ptr(2962, 2965, 1), new Range16.ptr(2969, 2970, 1), new Range16.ptr(2972, 2974, 2), new Range16.ptr(2975, 2979, 4), new Range16.ptr(2980, 2984, 4), new Range16.ptr(2985, 2986, 1), new Range16.ptr(2990, 3001, 1), new Range16.ptr(3024, 3077, 53), new Range16.ptr(3078, 3084, 1), new Range16.ptr(3086, 3088, 1), new Range16.ptr(3090, 3112, 1), new Range16.ptr(3114, 3129, 1), new Range16.ptr(3133, 3160, 27), new Range16.ptr(3161, 3162, 1), new Range16.ptr(3168, 3169, 1), new Range16.ptr(3200, 3205, 5), new Range16.ptr(3206, 3212, 1), new Range16.ptr(3214, 3216, 1), new Range16.ptr(3218, 3240, 1), new Range16.ptr(3242, 3251, 1), new Range16.ptr(3253, 3257, 1), new Range16.ptr(3261, 3294, 33), new Range16.ptr(3296, 3297, 1), new Range16.ptr(3313, 3314, 1), new Range16.ptr(3333, 3340, 1), new Range16.ptr(3342, 3344, 1), new Range16.ptr(3346, 3386, 1), new Range16.ptr(3389, 3406, 17), new Range16.ptr(3412, 3414, 1), new Range16.ptr(3423, 3425, 1), new Range16.ptr(3450, 3455, 1), new Range16.ptr(3461, 3478, 1), new Range16.ptr(3482, 3505, 1), new Range16.ptr(3507, 3515, 1), new Range16.ptr(3517, 3520, 3), new Range16.ptr(3521, 3526, 1), new Range16.ptr(3585, 3632, 1), new Range16.ptr(3634, 3635, 1), new Range16.ptr(3648, 3654, 1), new Range16.ptr(3713, 3714, 1), new Range16.ptr(3716, 3719, 3), new Range16.ptr(3720, 3722, 2), new Range16.ptr(3725, 3732, 7), new Range16.ptr(3733, 3735, 1), new Range16.ptr(3737, 3743, 1), new Range16.ptr(3745, 3747, 1), new Range16.ptr(3749, 3751, 2), new Range16.ptr(3754, 3755, 1), new Range16.ptr(3757, 3760, 1), new Range16.ptr(3762, 3763, 1), new Range16.ptr(3773, 3776, 3), new Range16.ptr(3777, 3780, 1), new Range16.ptr(3782, 3804, 22), new Range16.ptr(3805, 3807, 1), new Range16.ptr(3840, 3904, 64), new Range16.ptr(3905, 3911, 1), new Range16.ptr(3913, 3948, 1), new Range16.ptr(3976, 3980, 1), new Range16.ptr(4096, 4138, 1), new Range16.ptr(4159, 4176, 17), new Range16.ptr(4177, 4181, 1), new Range16.ptr(4186, 4189, 1), new Range16.ptr(4193, 4197, 4), new Range16.ptr(4198, 4206, 8), new Range16.ptr(4207, 4208, 1), new Range16.ptr(4213, 4225, 1), new Range16.ptr(4238, 4256, 18), new Range16.ptr(4257, 4293, 1), new Range16.ptr(4295, 4301, 6), new Range16.ptr(4304, 4346, 1), new Range16.ptr(4348, 4680, 1), new Range16.ptr(4682, 4685, 1), new Range16.ptr(4688, 4694, 1), new Range16.ptr(4696, 4698, 2), new Range16.ptr(4699, 4701, 1), new Range16.ptr(4704, 4744, 1), new Range16.ptr(4746, 4749, 1), new Range16.ptr(4752, 4784, 1), new Range16.ptr(4786, 4789, 1), new Range16.ptr(4792, 4798, 1), new Range16.ptr(4800, 4802, 2), new Range16.ptr(4803, 4805, 1), new Range16.ptr(4808, 4822, 1), new Range16.ptr(4824, 4880, 1), new Range16.ptr(4882, 4885, 1), new Range16.ptr(4888, 4954, 1), new Range16.ptr(4992, 5007, 1), new Range16.ptr(5024, 5109, 1), new Range16.ptr(5112, 5117, 1), new Range16.ptr(5121, 5740, 1), new Range16.ptr(5743, 5759, 1), new Range16.ptr(5761, 5786, 1), new Range16.ptr(5792, 5866, 1), new Range16.ptr(5873, 5880, 1), new Range16.ptr(5888, 5900, 1), new Range16.ptr(5902, 5905, 1), new Range16.ptr(5920, 5937, 1), new Range16.ptr(5952, 5969, 1), new Range16.ptr(5984, 5996, 1), new Range16.ptr(5998, 6000, 1), new Range16.ptr(6016, 6067, 1), new Range16.ptr(6103, 6108, 5), new Range16.ptr(6176, 6263, 1), new Range16.ptr(6272, 6276, 1), new Range16.ptr(6279, 6312, 1), new Range16.ptr(6314, 6320, 6), new Range16.ptr(6321, 6389, 1), new Range16.ptr(6400, 6430, 1), new Range16.ptr(6480, 6509, 1), new Range16.ptr(6512, 6516, 1), new Range16.ptr(6528, 6571, 1), new Range16.ptr(6576, 6601, 1), new Range16.ptr(6656, 6678, 1), new Range16.ptr(6688, 6740, 1), new Range16.ptr(6823, 6917, 94), new Range16.ptr(6918, 6963, 1), new Range16.ptr(6981, 6987, 1), new Range16.ptr(7043, 7072, 1), new Range16.ptr(7086, 7087, 1), new Range16.ptr(7098, 7141, 1), new Range16.ptr(7168, 7203, 1), new Range16.ptr(7245, 7247, 1), new Range16.ptr(7258, 7293, 1), new Range16.ptr(7296, 7304, 1), new Range16.ptr(7401, 7404, 1), new Range16.ptr(7406, 7409, 1), new Range16.ptr(7413, 7414, 1), new Range16.ptr(7424, 7615, 1), new Range16.ptr(7680, 7957, 1), new Range16.ptr(7960, 7965, 1), new Range16.ptr(7968, 8005, 1), new Range16.ptr(8008, 8013, 1), new Range16.ptr(8016, 8023, 1), new Range16.ptr(8025, 8031, 2), new Range16.ptr(8032, 8061, 1), new Range16.ptr(8064, 8116, 1), new Range16.ptr(8118, 8124, 1), new Range16.ptr(8126, 8130, 4), new Range16.ptr(8131, 8132, 1), new Range16.ptr(8134, 8140, 1), new Range16.ptr(8144, 8147, 1), new Range16.ptr(8150, 8155, 1), new Range16.ptr(8160, 8172, 1), new Range16.ptr(8178, 8180, 1), new Range16.ptr(8182, 8188, 1), new Range16.ptr(8305, 8319, 14), new Range16.ptr(8336, 8348, 1), new Range16.ptr(8450, 8455, 5), new Range16.ptr(8458, 8467, 1), new Range16.ptr(8469, 8473, 4), new Range16.ptr(8474, 8477, 1), new Range16.ptr(8484, 8490, 2), new Range16.ptr(8491, 8493, 1), new Range16.ptr(8495, 8505, 1), new Range16.ptr(8508, 8511, 1), new Range16.ptr(8517, 8521, 1), new Range16.ptr(8526, 8579, 53), new Range16.ptr(8580, 11264, 2684), new Range16.ptr(11265, 11310, 1), new Range16.ptr(11312, 11358, 1), new Range16.ptr(11360, 11492, 1), new Range16.ptr(11499, 11502, 1), new Range16.ptr(11506, 11507, 1), new Range16.ptr(11520, 11557, 1), new Range16.ptr(11559, 11565, 6), new Range16.ptr(11568, 11623, 1), new Range16.ptr(11631, 11648, 17), new Range16.ptr(11649, 11670, 1), new Range16.ptr(11680, 11686, 1), new Range16.ptr(11688, 11694, 1), new Range16.ptr(11696, 11702, 1), new Range16.ptr(11704, 11710, 1), new Range16.ptr(11712, 11718, 1), new Range16.ptr(11720, 11726, 1), new Range16.ptr(11728, 11734, 1), new Range16.ptr(11736, 11742, 1), new Range16.ptr(11823, 12293, 470), new Range16.ptr(12294, 12337, 43), new Range16.ptr(12338, 12341, 1), new Range16.ptr(12347, 12348, 1), new Range16.ptr(12353, 12438, 1), new Range16.ptr(12445, 12447, 1), new Range16.ptr(12449, 12538, 1), new Range16.ptr(12540, 12543, 1), new Range16.ptr(12549, 12589, 1), new Range16.ptr(12593, 12686, 1), new Range16.ptr(12704, 12730, 1), new Range16.ptr(12784, 12799, 1), new Range16.ptr(13312, 19893, 1), new Range16.ptr(19968, 40917, 1), new Range16.ptr(40960, 42124, 1), new Range16.ptr(42192, 42237, 1), new Range16.ptr(42240, 42508, 1), new Range16.ptr(42512, 42527, 1), new Range16.ptr(42538, 42539, 1), new Range16.ptr(42560, 42606, 1), new Range16.ptr(42623, 42653, 1), new Range16.ptr(42656, 42725, 1), new Range16.ptr(42775, 42783, 1), new Range16.ptr(42786, 42888, 1), new Range16.ptr(42891, 42926, 1), new Range16.ptr(42928, 42935, 1), new Range16.ptr(42999, 43009, 1), new Range16.ptr(43011, 43013, 1), new Range16.ptr(43015, 43018, 1), new Range16.ptr(43020, 43042, 1), new Range16.ptr(43072, 43123, 1), new Range16.ptr(43138, 43187, 1), new Range16.ptr(43250, 43255, 1), new Range16.ptr(43259, 43261, 2), new Range16.ptr(43274, 43301, 1), new Range16.ptr(43312, 43334, 1), new Range16.ptr(43360, 43388, 1), new Range16.ptr(43396, 43442, 1), new Range16.ptr(43471, 43488, 17), new Range16.ptr(43489, 43492, 1), new Range16.ptr(43494, 43503, 1), new Range16.ptr(43514, 43518, 1), new Range16.ptr(43520, 43560, 1), new Range16.ptr(43584, 43586, 1), new Range16.ptr(43588, 43595, 1), new Range16.ptr(43616, 43638, 1), new Range16.ptr(43642, 43646, 4), new Range16.ptr(43647, 43695, 1), new Range16.ptr(43697, 43701, 4), new Range16.ptr(43702, 43705, 3), new Range16.ptr(43706, 43709, 1), new Range16.ptr(43712, 43714, 2), new Range16.ptr(43739, 43741, 1), new Range16.ptr(43744, 43754, 1), new Range16.ptr(43762, 43764, 1), new Range16.ptr(43777, 43782, 1), new Range16.ptr(43785, 43790, 1), new Range16.ptr(43793, 43798, 1), new Range16.ptr(43808, 43814, 1), new Range16.ptr(43816, 43822, 1), new Range16.ptr(43824, 43866, 1), new Range16.ptr(43868, 43877, 1), new Range16.ptr(43888, 44002, 1), new Range16.ptr(44032, 55203, 1), new Range16.ptr(55216, 55238, 1), new Range16.ptr(55243, 55291, 1), new Range16.ptr(63744, 64109, 1), new Range16.ptr(64112, 64217, 1), new Range16.ptr(64256, 64262, 1), new Range16.ptr(64275, 64279, 1), new Range16.ptr(64285, 64287, 2), new Range16.ptr(64288, 64296, 1), new Range16.ptr(64298, 64310, 1), new Range16.ptr(64312, 64316, 1), new Range16.ptr(64318, 64320, 2), new Range16.ptr(64321, 64323, 2), new Range16.ptr(64324, 64326, 2), new Range16.ptr(64327, 64433, 1), new Range16.ptr(64467, 64829, 1), new Range16.ptr(64848, 64911, 1), new Range16.ptr(64914, 64967, 1), new Range16.ptr(65008, 65019, 1), new Range16.ptr(65136, 65140, 1), new Range16.ptr(65142, 65276, 1), new Range16.ptr(65313, 65338, 1), new Range16.ptr(65345, 65370, 1), new Range16.ptr(65382, 65470, 1), new Range16.ptr(65474, 65479, 1), new Range16.ptr(65482, 65487, 1), new Range16.ptr(65490, 65495, 1), new Range16.ptr(65498, 65500, 1)]), new sliceType$1([new Range32.ptr(65536, 65547, 1), new Range32.ptr(65549, 65574, 1), new Range32.ptr(65576, 65594, 1), new Range32.ptr(65596, 65597, 1), new Range32.ptr(65599, 65613, 1), new Range32.ptr(65616, 65629, 1), new Range32.ptr(65664, 65786, 1), new Range32.ptr(66176, 66204, 1), new Range32.ptr(66208, 66256, 1), new Range32.ptr(66304, 66335, 1), new Range32.ptr(66352, 66368, 1), new Range32.ptr(66370, 66377, 1), new Range32.ptr(66384, 66421, 1), new Range32.ptr(66432, 66461, 1), new Range32.ptr(66464, 66499, 1), new Range32.ptr(66504, 66511, 1), new Range32.ptr(66560, 66717, 1), new Range32.ptr(66736, 66771, 1), new Range32.ptr(66776, 66811, 1), new Range32.ptr(66816, 66855, 1), new Range32.ptr(66864, 66915, 1), new Range32.ptr(67072, 67382, 1), new Range32.ptr(67392, 67413, 1), new Range32.ptr(67424, 67431, 1), new Range32.ptr(67584, 67589, 1), new Range32.ptr(67592, 67594, 2), new Range32.ptr(67595, 67637, 1), new Range32.ptr(67639, 67640, 1), new Range32.ptr(67644, 67647, 3), new Range32.ptr(67648, 67669, 1), new Range32.ptr(67680, 67702, 1), new Range32.ptr(67712, 67742, 1), new Range32.ptr(67808, 67826, 1), new Range32.ptr(67828, 67829, 1), new Range32.ptr(67840, 67861, 1), new Range32.ptr(67872, 67897, 1), new Range32.ptr(67968, 68023, 1), new Range32.ptr(68030, 68031, 1), new Range32.ptr(68096, 68112, 16), new Range32.ptr(68113, 68115, 1), new Range32.ptr(68117, 68119, 1), new Range32.ptr(68121, 68147, 1), new Range32.ptr(68192, 68220, 1), new Range32.ptr(68224, 68252, 1), new Range32.ptr(68288, 68295, 1), new Range32.ptr(68297, 68324, 1), new Range32.ptr(68352, 68405, 1), new Range32.ptr(68416, 68437, 1), new Range32.ptr(68448, 68466, 1), new Range32.ptr(68480, 68497, 1), new Range32.ptr(68608, 68680, 1), new Range32.ptr(68736, 68786, 1), new Range32.ptr(68800, 68850, 1), new Range32.ptr(69635, 69687, 1), new Range32.ptr(69763, 69807, 1), new Range32.ptr(69840, 69864, 1), new Range32.ptr(69891, 69926, 1), new Range32.ptr(69968, 70002, 1), new Range32.ptr(70006, 70019, 13), new Range32.ptr(70020, 70066, 1), new Range32.ptr(70081, 70084, 1), new Range32.ptr(70106, 70108, 2), new Range32.ptr(70144, 70161, 1), new Range32.ptr(70163, 70187, 1), new Range32.ptr(70272, 70278, 1), new Range32.ptr(70280, 70282, 2), new Range32.ptr(70283, 70285, 1), new Range32.ptr(70287, 70301, 1), new Range32.ptr(70303, 70312, 1), new Range32.ptr(70320, 70366, 1), new Range32.ptr(70405, 70412, 1), new Range32.ptr(70415, 70416, 1), new Range32.ptr(70419, 70440, 1), new Range32.ptr(70442, 70448, 1), new Range32.ptr(70450, 70451, 1), new Range32.ptr(70453, 70457, 1), new Range32.ptr(70461, 70480, 19), new Range32.ptr(70493, 70497, 1), new Range32.ptr(70656, 70708, 1), new Range32.ptr(70727, 70730, 1), new Range32.ptr(70784, 70831, 1), new Range32.ptr(70852, 70853, 1), new Range32.ptr(70855, 71040, 185), new Range32.ptr(71041, 71086, 1), new Range32.ptr(71128, 71131, 1), new Range32.ptr(71168, 71215, 1), new Range32.ptr(71236, 71296, 60), new Range32.ptr(71297, 71338, 1), new Range32.ptr(71424, 71449, 1), new Range32.ptr(71840, 71903, 1), new Range32.ptr(71935, 72384, 449), new Range32.ptr(72385, 72440, 1), new Range32.ptr(72704, 72712, 1), new Range32.ptr(72714, 72750, 1), new Range32.ptr(72768, 72818, 50), new Range32.ptr(72819, 72847, 1), new Range32.ptr(73728, 74649, 1), new Range32.ptr(74880, 75075, 1), new Range32.ptr(77824, 78894, 1), new Range32.ptr(82944, 83526, 1), new Range32.ptr(92160, 92728, 1), new Range32.ptr(92736, 92766, 1), new Range32.ptr(92880, 92909, 1), new Range32.ptr(92928, 92975, 1), new Range32.ptr(92992, 92995, 1), new Range32.ptr(93027, 93047, 1), new Range32.ptr(93053, 93071, 1), new Range32.ptr(93952, 94020, 1), new Range32.ptr(94032, 94099, 67), new Range32.ptr(94100, 94111, 1), new Range32.ptr(94176, 94208, 32), new Range32.ptr(94209, 100332, 1), new Range32.ptr(100352, 101106, 1), new Range32.ptr(110592, 110593, 1), new Range32.ptr(113664, 113770, 1), new Range32.ptr(113776, 113788, 1), new Range32.ptr(113792, 113800, 1), new Range32.ptr(113808, 113817, 1), new Range32.ptr(119808, 119892, 1), new Range32.ptr(119894, 119964, 1), new Range32.ptr(119966, 119967, 1), new Range32.ptr(119970, 119973, 3), new Range32.ptr(119974, 119977, 3), new Range32.ptr(119978, 119980, 1), new Range32.ptr(119982, 119993, 1), new Range32.ptr(119995, 119997, 2), new Range32.ptr(119998, 120003, 1), new Range32.ptr(120005, 120069, 1), new Range32.ptr(120071, 120074, 1), new Range32.ptr(120077, 120084, 1), new Range32.ptr(120086, 120092, 1), new Range32.ptr(120094, 120121, 1), new Range32.ptr(120123, 120126, 1), new Range32.ptr(120128, 120132, 1), new Range32.ptr(120134, 120138, 4), new Range32.ptr(120139, 120144, 1), new Range32.ptr(120146, 120485, 1), new Range32.ptr(120488, 120512, 1), new Range32.ptr(120514, 120538, 1), new Range32.ptr(120540, 120570, 1), new Range32.ptr(120572, 120596, 1), new Range32.ptr(120598, 120628, 1), new Range32.ptr(120630, 120654, 1), new Range32.ptr(120656, 120686, 1), new Range32.ptr(120688, 120712, 1), new Range32.ptr(120714, 120744, 1), new Range32.ptr(120746, 120770, 1), new Range32.ptr(120772, 120779, 1), new Range32.ptr(124928, 125124, 1), new Range32.ptr(125184, 125251, 1), new Range32.ptr(126464, 126467, 1), new Range32.ptr(126469, 126495, 1), new Range32.ptr(126497, 126498, 1), new Range32.ptr(126500, 126503, 3), new Range32.ptr(126505, 126514, 1), new Range32.ptr(126516, 126519, 1), new Range32.ptr(126521, 126523, 2), new Range32.ptr(126530, 126535, 5), new Range32.ptr(126537, 126541, 2), new Range32.ptr(126542, 126543, 1), new Range32.ptr(126545, 126546, 1), new Range32.ptr(126548, 126551, 3), new Range32.ptr(126553, 126561, 2), new Range32.ptr(126562, 126564, 2), new Range32.ptr(126567, 126570, 1), new Range32.ptr(126572, 126578, 1), new Range32.ptr(126580, 126583, 1), new Range32.ptr(126585, 126588, 1), new Range32.ptr(126590, 126592, 2), new Range32.ptr(126593, 126601, 1), new Range32.ptr(126603, 126619, 1), new Range32.ptr(126625, 126627, 1), new Range32.ptr(126629, 126633, 1), new Range32.ptr(126635, 126651, 1), new Range32.ptr(131072, 173782, 1), new Range32.ptr(173824, 177972, 1), new Range32.ptr(177984, 178205, 1), new Range32.ptr(178208, 183969, 1), new Range32.ptr(194560, 195101, 1)]), 6);
		_Ll = new RangeTable.ptr(new sliceType([new Range16.ptr(97, 122, 1), new Range16.ptr(181, 223, 42), new Range16.ptr(224, 246, 1), new Range16.ptr(248, 255, 1), new Range16.ptr(257, 311, 2), new Range16.ptr(312, 328, 2), new Range16.ptr(329, 375, 2), new Range16.ptr(378, 382, 2), new Range16.ptr(383, 384, 1), new Range16.ptr(387, 389, 2), new Range16.ptr(392, 396, 4), new Range16.ptr(397, 402, 5), new Range16.ptr(405, 409, 4), new Range16.ptr(410, 411, 1), new Range16.ptr(414, 417, 3), new Range16.ptr(419, 421, 2), new Range16.ptr(424, 426, 2), new Range16.ptr(427, 429, 2), new Range16.ptr(432, 436, 4), new Range16.ptr(438, 441, 3), new Range16.ptr(442, 445, 3), new Range16.ptr(446, 447, 1), new Range16.ptr(454, 460, 3), new Range16.ptr(462, 476, 2), new Range16.ptr(477, 495, 2), new Range16.ptr(496, 499, 3), new Range16.ptr(501, 505, 4), new Range16.ptr(507, 563, 2), new Range16.ptr(564, 569, 1), new Range16.ptr(572, 575, 3), new Range16.ptr(576, 578, 2), new Range16.ptr(583, 591, 2), new Range16.ptr(592, 659, 1), new Range16.ptr(661, 687, 1), new Range16.ptr(881, 883, 2), new Range16.ptr(887, 891, 4), new Range16.ptr(892, 893, 1), new Range16.ptr(912, 940, 28), new Range16.ptr(941, 974, 1), new Range16.ptr(976, 977, 1), new Range16.ptr(981, 983, 1), new Range16.ptr(985, 1007, 2), new Range16.ptr(1008, 1011, 1), new Range16.ptr(1013, 1019, 3), new Range16.ptr(1020, 1072, 52), new Range16.ptr(1073, 1119, 1), new Range16.ptr(1121, 1153, 2), new Range16.ptr(1163, 1215, 2), new Range16.ptr(1218, 1230, 2), new Range16.ptr(1231, 1327, 2), new Range16.ptr(1377, 1415, 1), new Range16.ptr(5112, 5117, 1), new Range16.ptr(7296, 7304, 1), new Range16.ptr(7424, 7467, 1), new Range16.ptr(7531, 7543, 1), new Range16.ptr(7545, 7578, 1), new Range16.ptr(7681, 7829, 2), new Range16.ptr(7830, 7837, 1), new Range16.ptr(7839, 7935, 2), new Range16.ptr(7936, 7943, 1), new Range16.ptr(7952, 7957, 1), new Range16.ptr(7968, 7975, 1), new Range16.ptr(7984, 7991, 1), new Range16.ptr(8000, 8005, 1), new Range16.ptr(8016, 8023, 1), new Range16.ptr(8032, 8039, 1), new Range16.ptr(8048, 8061, 1), new Range16.ptr(8064, 8071, 1), new Range16.ptr(8080, 8087, 1), new Range16.ptr(8096, 8103, 1), new Range16.ptr(8112, 8116, 1), new Range16.ptr(8118, 8119, 1), new Range16.ptr(8126, 8130, 4), new Range16.ptr(8131, 8132, 1), new Range16.ptr(8134, 8135, 1), new Range16.ptr(8144, 8147, 1), new Range16.ptr(8150, 8151, 1), new Range16.ptr(8160, 8167, 1), new Range16.ptr(8178, 8180, 1), new Range16.ptr(8182, 8183, 1), new Range16.ptr(8458, 8462, 4), new Range16.ptr(8463, 8467, 4), new Range16.ptr(8495, 8505, 5), new Range16.ptr(8508, 8509, 1), new Range16.ptr(8518, 8521, 1), new Range16.ptr(8526, 8580, 54), new Range16.ptr(11312, 11358, 1), new Range16.ptr(11361, 11365, 4), new Range16.ptr(11366, 11372, 2), new Range16.ptr(11377, 11379, 2), new Range16.ptr(11380, 11382, 2), new Range16.ptr(11383, 11387, 1), new Range16.ptr(11393, 11491, 2), new Range16.ptr(11492, 11500, 8), new Range16.ptr(11502, 11507, 5), new Range16.ptr(11520, 11557, 1), new Range16.ptr(11559, 11565, 6), new Range16.ptr(42561, 42605, 2), new Range16.ptr(42625, 42651, 2), new Range16.ptr(42787, 42799, 2), new Range16.ptr(42800, 42801, 1), new Range16.ptr(42803, 42865, 2), new Range16.ptr(42866, 42872, 1), new Range16.ptr(42874, 42876, 2), new Range16.ptr(42879, 42887, 2), new Range16.ptr(42892, 42894, 2), new Range16.ptr(42897, 42899, 2), new Range16.ptr(42900, 42901, 1), new Range16.ptr(42903, 42921, 2), new Range16.ptr(42933, 42935, 2), new Range16.ptr(43002, 43824, 822), new Range16.ptr(43825, 43866, 1), new Range16.ptr(43872, 43877, 1), new Range16.ptr(43888, 43967, 1), new Range16.ptr(64256, 64262, 1), new Range16.ptr(64275, 64279, 1), new Range16.ptr(65345, 65370, 1)]), new sliceType$1([new Range32.ptr(66600, 66639, 1), new Range32.ptr(66776, 66811, 1), new Range32.ptr(68800, 68850, 1), new Range32.ptr(71872, 71903, 1), new Range32.ptr(119834, 119859, 1), new Range32.ptr(119886, 119892, 1), new Range32.ptr(119894, 119911, 1), new Range32.ptr(119938, 119963, 1), new Range32.ptr(119990, 119993, 1), new Range32.ptr(119995, 119997, 2), new Range32.ptr(119998, 120003, 1), new Range32.ptr(120005, 120015, 1), new Range32.ptr(120042, 120067, 1), new Range32.ptr(120094, 120119, 1), new Range32.ptr(120146, 120171, 1), new Range32.ptr(120198, 120223, 1), new Range32.ptr(120250, 120275, 1), new Range32.ptr(120302, 120327, 1), new Range32.ptr(120354, 120379, 1), new Range32.ptr(120406, 120431, 1), new Range32.ptr(120458, 120485, 1), new Range32.ptr(120514, 120538, 1), new Range32.ptr(120540, 120545, 1), new Range32.ptr(120572, 120596, 1), new Range32.ptr(120598, 120603, 1), new Range32.ptr(120630, 120654, 1), new Range32.ptr(120656, 120661, 1), new Range32.ptr(120688, 120712, 1), new Range32.ptr(120714, 120719, 1), new Range32.ptr(120746, 120770, 1), new Range32.ptr(120772, 120777, 1), new Range32.ptr(120779, 125218, 4439), new Range32.ptr(125219, 125251, 1)]), 4);
		_Lm = new RangeTable.ptr(new sliceType([new Range16.ptr(688, 705, 1), new Range16.ptr(710, 721, 1), new Range16.ptr(736, 740, 1), new Range16.ptr(748, 750, 2), new Range16.ptr(884, 890, 6), new Range16.ptr(1369, 1600, 231), new Range16.ptr(1765, 1766, 1), new Range16.ptr(2036, 2037, 1), new Range16.ptr(2042, 2074, 32), new Range16.ptr(2084, 2088, 4), new Range16.ptr(2417, 3654, 1237), new Range16.ptr(3782, 4348, 566), new Range16.ptr(6103, 6211, 108), new Range16.ptr(6823, 7288, 465), new Range16.ptr(7289, 7293, 1), new Range16.ptr(7468, 7530, 1), new Range16.ptr(7544, 7579, 35), new Range16.ptr(7580, 7615, 1), new Range16.ptr(8305, 8319, 14), new Range16.ptr(8336, 8348, 1), new Range16.ptr(11388, 11389, 1), new Range16.ptr(11631, 11823, 192), new Range16.ptr(12293, 12337, 44), new Range16.ptr(12338, 12341, 1), new Range16.ptr(12347, 12445, 98), new Range16.ptr(12446, 12540, 94), new Range16.ptr(12541, 12542, 1), new Range16.ptr(40981, 42232, 1251), new Range16.ptr(42233, 42237, 1), new Range16.ptr(42508, 42623, 115), new Range16.ptr(42652, 42653, 1), new Range16.ptr(42775, 42783, 1), new Range16.ptr(42864, 42888, 24), new Range16.ptr(43000, 43001, 1), new Range16.ptr(43471, 43494, 23), new Range16.ptr(43632, 43741, 109), new Range16.ptr(43763, 43764, 1), new Range16.ptr(43868, 43871, 1), new Range16.ptr(65392, 65438, 46), new Range16.ptr(65439, 65439, 1)]), new sliceType$1([new Range32.ptr(92992, 92992, 1), new Range32.ptr(92993, 92995, 1), new Range32.ptr(94099, 94111, 1), new Range32.ptr(94176, 94176, 1)]), 0);
		_Lo = new RangeTable.ptr(new sliceType([new Range16.ptr(170, 186, 16), new Range16.ptr(443, 448, 5), new Range16.ptr(449, 451, 1), new Range16.ptr(660, 1488, 828), new Range16.ptr(1489, 1514, 1), new Range16.ptr(1520, 1522, 1), new Range16.ptr(1568, 1599, 1), new Range16.ptr(1601, 1610, 1), new Range16.ptr(1646, 1647, 1), new Range16.ptr(1649, 1747, 1), new Range16.ptr(1749, 1774, 25), new Range16.ptr(1775, 1786, 11), new Range16.ptr(1787, 1788, 1), new Range16.ptr(1791, 1808, 17), new Range16.ptr(1810, 1839, 1), new Range16.ptr(1869, 1957, 1), new Range16.ptr(1969, 1994, 25), new Range16.ptr(1995, 2026, 1), new Range16.ptr(2048, 2069, 1), new Range16.ptr(2112, 2136, 1), new Range16.ptr(2208, 2228, 1), new Range16.ptr(2230, 2237, 1), new Range16.ptr(2308, 2361, 1), new Range16.ptr(2365, 2384, 19), new Range16.ptr(2392, 2401, 1), new Range16.ptr(2418, 2432, 1), new Range16.ptr(2437, 2444, 1), new Range16.ptr(2447, 2448, 1), new Range16.ptr(2451, 2472, 1), new Range16.ptr(2474, 2480, 1), new Range16.ptr(2482, 2486, 4), new Range16.ptr(2487, 2489, 1), new Range16.ptr(2493, 2510, 17), new Range16.ptr(2524, 2525, 1), new Range16.ptr(2527, 2529, 1), new Range16.ptr(2544, 2545, 1), new Range16.ptr(2565, 2570, 1), new Range16.ptr(2575, 2576, 1), new Range16.ptr(2579, 2600, 1), new Range16.ptr(2602, 2608, 1), new Range16.ptr(2610, 2611, 1), new Range16.ptr(2613, 2614, 1), new Range16.ptr(2616, 2617, 1), new Range16.ptr(2649, 2652, 1), new Range16.ptr(2654, 2674, 20), new Range16.ptr(2675, 2676, 1), new Range16.ptr(2693, 2701, 1), new Range16.ptr(2703, 2705, 1), new Range16.ptr(2707, 2728, 1), new Range16.ptr(2730, 2736, 1), new Range16.ptr(2738, 2739, 1), new Range16.ptr(2741, 2745, 1), new Range16.ptr(2749, 2768, 19), new Range16.ptr(2784, 2785, 1), new Range16.ptr(2809, 2821, 12), new Range16.ptr(2822, 2828, 1), new Range16.ptr(2831, 2832, 1), new Range16.ptr(2835, 2856, 1), new Range16.ptr(2858, 2864, 1), new Range16.ptr(2866, 2867, 1), new Range16.ptr(2869, 2873, 1), new Range16.ptr(2877, 2908, 31), new Range16.ptr(2909, 2911, 2), new Range16.ptr(2912, 2913, 1), new Range16.ptr(2929, 2947, 18), new Range16.ptr(2949, 2954, 1), new Range16.ptr(2958, 2960, 1), new Range16.ptr(2962, 2965, 1), new Range16.ptr(2969, 2970, 1), new Range16.ptr(2972, 2974, 2), new Range16.ptr(2975, 2979, 4), new Range16.ptr(2980, 2984, 4), new Range16.ptr(2985, 2986, 1), new Range16.ptr(2990, 3001, 1), new Range16.ptr(3024, 3077, 53), new Range16.ptr(3078, 3084, 1), new Range16.ptr(3086, 3088, 1), new Range16.ptr(3090, 3112, 1), new Range16.ptr(3114, 3129, 1), new Range16.ptr(3133, 3160, 27), new Range16.ptr(3161, 3162, 1), new Range16.ptr(3168, 3169, 1), new Range16.ptr(3200, 3205, 5), new Range16.ptr(3206, 3212, 1), new Range16.ptr(3214, 3216, 1), new Range16.ptr(3218, 3240, 1), new Range16.ptr(3242, 3251, 1), new Range16.ptr(3253, 3257, 1), new Range16.ptr(3261, 3294, 33), new Range16.ptr(3296, 3297, 1), new Range16.ptr(3313, 3314, 1), new Range16.ptr(3333, 3340, 1), new Range16.ptr(3342, 3344, 1), new Range16.ptr(3346, 3386, 1), new Range16.ptr(3389, 3406, 17), new Range16.ptr(3412, 3414, 1), new Range16.ptr(3423, 3425, 1), new Range16.ptr(3450, 3455, 1), new Range16.ptr(3461, 3478, 1), new Range16.ptr(3482, 3505, 1), new Range16.ptr(3507, 3515, 1), new Range16.ptr(3517, 3520, 3), new Range16.ptr(3521, 3526, 1), new Range16.ptr(3585, 3632, 1), new Range16.ptr(3634, 3635, 1), new Range16.ptr(3648, 3653, 1), new Range16.ptr(3713, 3714, 1), new Range16.ptr(3716, 3719, 3), new Range16.ptr(3720, 3722, 2), new Range16.ptr(3725, 3732, 7), new Range16.ptr(3733, 3735, 1), new Range16.ptr(3737, 3743, 1), new Range16.ptr(3745, 3747, 1), new Range16.ptr(3749, 3751, 2), new Range16.ptr(3754, 3755, 1), new Range16.ptr(3757, 3760, 1), new Range16.ptr(3762, 3763, 1), new Range16.ptr(3773, 3776, 3), new Range16.ptr(3777, 3780, 1), new Range16.ptr(3804, 3807, 1), new Range16.ptr(3840, 3904, 64), new Range16.ptr(3905, 3911, 1), new Range16.ptr(3913, 3948, 1), new Range16.ptr(3976, 3980, 1), new Range16.ptr(4096, 4138, 1), new Range16.ptr(4159, 4176, 17), new Range16.ptr(4177, 4181, 1), new Range16.ptr(4186, 4189, 1), new Range16.ptr(4193, 4197, 4), new Range16.ptr(4198, 4206, 8), new Range16.ptr(4207, 4208, 1), new Range16.ptr(4213, 4225, 1), new Range16.ptr(4238, 4304, 66), new Range16.ptr(4305, 4346, 1), new Range16.ptr(4349, 4680, 1), new Range16.ptr(4682, 4685, 1), new Range16.ptr(4688, 4694, 1), new Range16.ptr(4696, 4698, 2), new Range16.ptr(4699, 4701, 1), new Range16.ptr(4704, 4744, 1), new Range16.ptr(4746, 4749, 1), new Range16.ptr(4752, 4784, 1), new Range16.ptr(4786, 4789, 1), new Range16.ptr(4792, 4798, 1), new Range16.ptr(4800, 4802, 2), new Range16.ptr(4803, 4805, 1), new Range16.ptr(4808, 4822, 1), new Range16.ptr(4824, 4880, 1), new Range16.ptr(4882, 4885, 1), new Range16.ptr(4888, 4954, 1), new Range16.ptr(4992, 5007, 1), new Range16.ptr(5121, 5740, 1), new Range16.ptr(5743, 5759, 1), new Range16.ptr(5761, 5786, 1), new Range16.ptr(5792, 5866, 1), new Range16.ptr(5873, 5880, 1), new Range16.ptr(5888, 5900, 1), new Range16.ptr(5902, 5905, 1), new Range16.ptr(5920, 5937, 1), new Range16.ptr(5952, 5969, 1), new Range16.ptr(5984, 5996, 1), new Range16.ptr(5998, 6000, 1), new Range16.ptr(6016, 6067, 1), new Range16.ptr(6108, 6176, 68), new Range16.ptr(6177, 6210, 1), new Range16.ptr(6212, 6263, 1), new Range16.ptr(6272, 6276, 1), new Range16.ptr(6279, 6312, 1), new Range16.ptr(6314, 6320, 6), new Range16.ptr(6321, 6389, 1), new Range16.ptr(6400, 6430, 1), new Range16.ptr(6480, 6509, 1), new Range16.ptr(6512, 6516, 1), new Range16.ptr(6528, 6571, 1), new Range16.ptr(6576, 6601, 1), new Range16.ptr(6656, 6678, 1), new Range16.ptr(6688, 6740, 1), new Range16.ptr(6917, 6963, 1), new Range16.ptr(6981, 6987, 1), new Range16.ptr(7043, 7072, 1), new Range16.ptr(7086, 7087, 1), new Range16.ptr(7098, 7141, 1), new Range16.ptr(7168, 7203, 1), new Range16.ptr(7245, 7247, 1), new Range16.ptr(7258, 7287, 1), new Range16.ptr(7401, 7404, 1), new Range16.ptr(7406, 7409, 1), new Range16.ptr(7413, 7414, 1), new Range16.ptr(8501, 8504, 1), new Range16.ptr(11568, 11623, 1), new Range16.ptr(11648, 11670, 1), new Range16.ptr(11680, 11686, 1), new Range16.ptr(11688, 11694, 1), new Range16.ptr(11696, 11702, 1), new Range16.ptr(11704, 11710, 1), new Range16.ptr(11712, 11718, 1), new Range16.ptr(11720, 11726, 1), new Range16.ptr(11728, 11734, 1), new Range16.ptr(11736, 11742, 1), new Range16.ptr(12294, 12348, 54), new Range16.ptr(12353, 12438, 1), new Range16.ptr(12447, 12449, 2), new Range16.ptr(12450, 12538, 1), new Range16.ptr(12543, 12549, 6), new Range16.ptr(12550, 12589, 1), new Range16.ptr(12593, 12686, 1), new Range16.ptr(12704, 12730, 1), new Range16.ptr(12784, 12799, 1), new Range16.ptr(13312, 19893, 1), new Range16.ptr(19968, 40917, 1), new Range16.ptr(40960, 40980, 1), new Range16.ptr(40982, 42124, 1), new Range16.ptr(42192, 42231, 1), new Range16.ptr(42240, 42507, 1), new Range16.ptr(42512, 42527, 1), new Range16.ptr(42538, 42539, 1), new Range16.ptr(42606, 42656, 50), new Range16.ptr(42657, 42725, 1), new Range16.ptr(42895, 42999, 104), new Range16.ptr(43003, 43009, 1), new Range16.ptr(43011, 43013, 1), new Range16.ptr(43015, 43018, 1), new Range16.ptr(43020, 43042, 1), new Range16.ptr(43072, 43123, 1), new Range16.ptr(43138, 43187, 1), new Range16.ptr(43250, 43255, 1), new Range16.ptr(43259, 43261, 2), new Range16.ptr(43274, 43301, 1), new Range16.ptr(43312, 43334, 1), new Range16.ptr(43360, 43388, 1), new Range16.ptr(43396, 43442, 1), new Range16.ptr(43488, 43492, 1), new Range16.ptr(43495, 43503, 1), new Range16.ptr(43514, 43518, 1), new Range16.ptr(43520, 43560, 1), new Range16.ptr(43584, 43586, 1), new Range16.ptr(43588, 43595, 1), new Range16.ptr(43616, 43631, 1), new Range16.ptr(43633, 43638, 1), new Range16.ptr(43642, 43646, 4), new Range16.ptr(43647, 43695, 1), new Range16.ptr(43697, 43701, 4), new Range16.ptr(43702, 43705, 3), new Range16.ptr(43706, 43709, 1), new Range16.ptr(43712, 43714, 2), new Range16.ptr(43739, 43740, 1), new Range16.ptr(43744, 43754, 1), new Range16.ptr(43762, 43777, 15), new Range16.ptr(43778, 43782, 1), new Range16.ptr(43785, 43790, 1), new Range16.ptr(43793, 43798, 1), new Range16.ptr(43808, 43814, 1), new Range16.ptr(43816, 43822, 1), new Range16.ptr(43968, 44002, 1), new Range16.ptr(44032, 55203, 1), new Range16.ptr(55216, 55238, 1), new Range16.ptr(55243, 55291, 1), new Range16.ptr(63744, 64109, 1), new Range16.ptr(64112, 64217, 1), new Range16.ptr(64285, 64287, 2), new Range16.ptr(64288, 64296, 1), new Range16.ptr(64298, 64310, 1), new Range16.ptr(64312, 64316, 1), new Range16.ptr(64318, 64320, 2), new Range16.ptr(64321, 64323, 2), new Range16.ptr(64324, 64326, 2), new Range16.ptr(64327, 64433, 1), new Range16.ptr(64467, 64829, 1), new Range16.ptr(64848, 64911, 1), new Range16.ptr(64914, 64967, 1), new Range16.ptr(65008, 65019, 1), new Range16.ptr(65136, 65140, 1), new Range16.ptr(65142, 65276, 1), new Range16.ptr(65382, 65391, 1), new Range16.ptr(65393, 65437, 1), new Range16.ptr(65440, 65470, 1), new Range16.ptr(65474, 65479, 1), new Range16.ptr(65482, 65487, 1), new Range16.ptr(65490, 65495, 1), new Range16.ptr(65498, 65500, 1)]), new sliceType$1([new Range32.ptr(65536, 65547, 1), new Range32.ptr(65549, 65574, 1), new Range32.ptr(65576, 65594, 1), new Range32.ptr(65596, 65597, 1), new Range32.ptr(65599, 65613, 1), new Range32.ptr(65616, 65629, 1), new Range32.ptr(65664, 65786, 1), new Range32.ptr(66176, 66204, 1), new Range32.ptr(66208, 66256, 1), new Range32.ptr(66304, 66335, 1), new Range32.ptr(66352, 66368, 1), new Range32.ptr(66370, 66377, 1), new Range32.ptr(66384, 66421, 1), new Range32.ptr(66432, 66461, 1), new Range32.ptr(66464, 66499, 1), new Range32.ptr(66504, 66511, 1), new Range32.ptr(66640, 66717, 1), new Range32.ptr(66816, 66855, 1), new Range32.ptr(66864, 66915, 1), new Range32.ptr(67072, 67382, 1), new Range32.ptr(67392, 67413, 1), new Range32.ptr(67424, 67431, 1), new Range32.ptr(67584, 67589, 1), new Range32.ptr(67592, 67594, 2), new Range32.ptr(67595, 67637, 1), new Range32.ptr(67639, 67640, 1), new Range32.ptr(67644, 67647, 3), new Range32.ptr(67648, 67669, 1), new Range32.ptr(67680, 67702, 1), new Range32.ptr(67712, 67742, 1), new Range32.ptr(67808, 67826, 1), new Range32.ptr(67828, 67829, 1), new Range32.ptr(67840, 67861, 1), new Range32.ptr(67872, 67897, 1), new Range32.ptr(67968, 68023, 1), new Range32.ptr(68030, 68031, 1), new Range32.ptr(68096, 68112, 16), new Range32.ptr(68113, 68115, 1), new Range32.ptr(68117, 68119, 1), new Range32.ptr(68121, 68147, 1), new Range32.ptr(68192, 68220, 1), new Range32.ptr(68224, 68252, 1), new Range32.ptr(68288, 68295, 1), new Range32.ptr(68297, 68324, 1), new Range32.ptr(68352, 68405, 1), new Range32.ptr(68416, 68437, 1), new Range32.ptr(68448, 68466, 1), new Range32.ptr(68480, 68497, 1), new Range32.ptr(68608, 68680, 1), new Range32.ptr(69635, 69687, 1), new Range32.ptr(69763, 69807, 1), new Range32.ptr(69840, 69864, 1), new Range32.ptr(69891, 69926, 1), new Range32.ptr(69968, 70002, 1), new Range32.ptr(70006, 70019, 13), new Range32.ptr(70020, 70066, 1), new Range32.ptr(70081, 70084, 1), new Range32.ptr(70106, 70108, 2), new Range32.ptr(70144, 70161, 1), new Range32.ptr(70163, 70187, 1), new Range32.ptr(70272, 70278, 1), new Range32.ptr(70280, 70282, 2), new Range32.ptr(70283, 70285, 1), new Range32.ptr(70287, 70301, 1), new Range32.ptr(70303, 70312, 1), new Range32.ptr(70320, 70366, 1), new Range32.ptr(70405, 70412, 1), new Range32.ptr(70415, 70416, 1), new Range32.ptr(70419, 70440, 1), new Range32.ptr(70442, 70448, 1), new Range32.ptr(70450, 70451, 1), new Range32.ptr(70453, 70457, 1), new Range32.ptr(70461, 70480, 19), new Range32.ptr(70493, 70497, 1), new Range32.ptr(70656, 70708, 1), new Range32.ptr(70727, 70730, 1), new Range32.ptr(70784, 70831, 1), new Range32.ptr(70852, 70853, 1), new Range32.ptr(70855, 71040, 185), new Range32.ptr(71041, 71086, 1), new Range32.ptr(71128, 71131, 1), new Range32.ptr(71168, 71215, 1), new Range32.ptr(71236, 71296, 60), new Range32.ptr(71297, 71338, 1), new Range32.ptr(71424, 71449, 1), new Range32.ptr(71935, 72384, 449), new Range32.ptr(72385, 72440, 1), new Range32.ptr(72704, 72712, 1), new Range32.ptr(72714, 72750, 1), new Range32.ptr(72768, 72818, 50), new Range32.ptr(72819, 72847, 1), new Range32.ptr(73728, 74649, 1), new Range32.ptr(74880, 75075, 1), new Range32.ptr(77824, 78894, 1), new Range32.ptr(82944, 83526, 1), new Range32.ptr(92160, 92728, 1), new Range32.ptr(92736, 92766, 1), new Range32.ptr(92880, 92909, 1), new Range32.ptr(92928, 92975, 1), new Range32.ptr(93027, 93047, 1), new Range32.ptr(93053, 93071, 1), new Range32.ptr(93952, 94020, 1), new Range32.ptr(94032, 94208, 176), new Range32.ptr(94209, 100332, 1), new Range32.ptr(100352, 101106, 1), new Range32.ptr(110592, 110593, 1), new Range32.ptr(113664, 113770, 1), new Range32.ptr(113776, 113788, 1), new Range32.ptr(113792, 113800, 1), new Range32.ptr(113808, 113817, 1), new Range32.ptr(124928, 125124, 1), new Range32.ptr(126464, 126467, 1), new Range32.ptr(126469, 126495, 1), new Range32.ptr(126497, 126498, 1), new Range32.ptr(126500, 126503, 3), new Range32.ptr(126505, 126514, 1), new Range32.ptr(126516, 126519, 1), new Range32.ptr(126521, 126523, 2), new Range32.ptr(126530, 126535, 5), new Range32.ptr(126537, 126541, 2), new Range32.ptr(126542, 126543, 1), new Range32.ptr(126545, 126546, 1), new Range32.ptr(126548, 126551, 3), new Range32.ptr(126553, 126561, 2), new Range32.ptr(126562, 126564, 2), new Range32.ptr(126567, 126570, 1), new Range32.ptr(126572, 126578, 1), new Range32.ptr(126580, 126583, 1), new Range32.ptr(126585, 126588, 1), new Range32.ptr(126590, 126592, 2), new Range32.ptr(126593, 126601, 1), new Range32.ptr(126603, 126619, 1), new Range32.ptr(126625, 126627, 1), new Range32.ptr(126629, 126633, 1), new Range32.ptr(126635, 126651, 1), new Range32.ptr(131072, 173782, 1), new Range32.ptr(173824, 177972, 1), new Range32.ptr(177984, 178205, 1), new Range32.ptr(178208, 183969, 1), new Range32.ptr(194560, 195101, 1)]), 1);
		_Lt = new RangeTable.ptr(new sliceType([new Range16.ptr(453, 459, 3), new Range16.ptr(498, 8072, 7574), new Range16.ptr(8073, 8079, 1), new Range16.ptr(8088, 8095, 1), new Range16.ptr(8104, 8111, 1), new Range16.ptr(8124, 8140, 16), new Range16.ptr(8188, 8188, 1)]), sliceType$1.nil, 0);
		_Lu = new RangeTable.ptr(new sliceType([new Range16.ptr(65, 90, 1), new Range16.ptr(192, 214, 1), new Range16.ptr(216, 222, 1), new Range16.ptr(256, 310, 2), new Range16.ptr(313, 327, 2), new Range16.ptr(330, 376, 2), new Range16.ptr(377, 381, 2), new Range16.ptr(385, 386, 1), new Range16.ptr(388, 390, 2), new Range16.ptr(391, 393, 2), new Range16.ptr(394, 395, 1), new Range16.ptr(398, 401, 1), new Range16.ptr(403, 404, 1), new Range16.ptr(406, 408, 1), new Range16.ptr(412, 413, 1), new Range16.ptr(415, 416, 1), new Range16.ptr(418, 422, 2), new Range16.ptr(423, 425, 2), new Range16.ptr(428, 430, 2), new Range16.ptr(431, 433, 2), new Range16.ptr(434, 435, 1), new Range16.ptr(437, 439, 2), new Range16.ptr(440, 444, 4), new Range16.ptr(452, 461, 3), new Range16.ptr(463, 475, 2), new Range16.ptr(478, 494, 2), new Range16.ptr(497, 500, 3), new Range16.ptr(502, 504, 1), new Range16.ptr(506, 562, 2), new Range16.ptr(570, 571, 1), new Range16.ptr(573, 574, 1), new Range16.ptr(577, 579, 2), new Range16.ptr(580, 582, 1), new Range16.ptr(584, 590, 2), new Range16.ptr(880, 882, 2), new Range16.ptr(886, 895, 9), new Range16.ptr(902, 904, 2), new Range16.ptr(905, 906, 1), new Range16.ptr(908, 910, 2), new Range16.ptr(911, 913, 2), new Range16.ptr(914, 929, 1), new Range16.ptr(931, 939, 1), new Range16.ptr(975, 978, 3), new Range16.ptr(979, 980, 1), new Range16.ptr(984, 1006, 2), new Range16.ptr(1012, 1015, 3), new Range16.ptr(1017, 1018, 1), new Range16.ptr(1021, 1071, 1), new Range16.ptr(1120, 1152, 2), new Range16.ptr(1162, 1216, 2), new Range16.ptr(1217, 1229, 2), new Range16.ptr(1232, 1326, 2), new Range16.ptr(1329, 1366, 1), new Range16.ptr(4256, 4293, 1), new Range16.ptr(4295, 4301, 6), new Range16.ptr(5024, 5109, 1), new Range16.ptr(7680, 7828, 2), new Range16.ptr(7838, 7934, 2), new Range16.ptr(7944, 7951, 1), new Range16.ptr(7960, 7965, 1), new Range16.ptr(7976, 7983, 1), new Range16.ptr(7992, 7999, 1), new Range16.ptr(8008, 8013, 1), new Range16.ptr(8025, 8031, 2), new Range16.ptr(8040, 8047, 1), new Range16.ptr(8120, 8123, 1), new Range16.ptr(8136, 8139, 1), new Range16.ptr(8152, 8155, 1), new Range16.ptr(8168, 8172, 1), new Range16.ptr(8184, 8187, 1), new Range16.ptr(8450, 8455, 5), new Range16.ptr(8459, 8461, 1), new Range16.ptr(8464, 8466, 1), new Range16.ptr(8469, 8473, 4), new Range16.ptr(8474, 8477, 1), new Range16.ptr(8484, 8490, 2), new Range16.ptr(8491, 8493, 1), new Range16.ptr(8496, 8499, 1), new Range16.ptr(8510, 8511, 1), new Range16.ptr(8517, 8579, 62), new Range16.ptr(11264, 11310, 1), new Range16.ptr(11360, 11362, 2), new Range16.ptr(11363, 11364, 1), new Range16.ptr(11367, 11373, 2), new Range16.ptr(11374, 11376, 1), new Range16.ptr(11378, 11381, 3), new Range16.ptr(11390, 11392, 1), new Range16.ptr(11394, 11490, 2), new Range16.ptr(11499, 11501, 2), new Range16.ptr(11506, 42560, 31054), new Range16.ptr(42562, 42604, 2), new Range16.ptr(42624, 42650, 2), new Range16.ptr(42786, 42798, 2), new Range16.ptr(42802, 42862, 2), new Range16.ptr(42873, 42877, 2), new Range16.ptr(42878, 42886, 2), new Range16.ptr(42891, 42893, 2), new Range16.ptr(42896, 42898, 2), new Range16.ptr(42902, 42922, 2), new Range16.ptr(42923, 42926, 1), new Range16.ptr(42928, 42932, 1), new Range16.ptr(42934, 65313, 22379), new Range16.ptr(65314, 65338, 1)]), new sliceType$1([new Range32.ptr(66560, 66599, 1), new Range32.ptr(66736, 66771, 1), new Range32.ptr(68736, 68786, 1), new Range32.ptr(71840, 71871, 1), new Range32.ptr(119808, 119833, 1), new Range32.ptr(119860, 119885, 1), new Range32.ptr(119912, 119937, 1), new Range32.ptr(119964, 119966, 2), new Range32.ptr(119967, 119973, 3), new Range32.ptr(119974, 119977, 3), new Range32.ptr(119978, 119980, 1), new Range32.ptr(119982, 119989, 1), new Range32.ptr(120016, 120041, 1), new Range32.ptr(120068, 120069, 1), new Range32.ptr(120071, 120074, 1), new Range32.ptr(120077, 120084, 1), new Range32.ptr(120086, 120092, 1), new Range32.ptr(120120, 120121, 1), new Range32.ptr(120123, 120126, 1), new Range32.ptr(120128, 120132, 1), new Range32.ptr(120134, 120138, 4), new Range32.ptr(120139, 120144, 1), new Range32.ptr(120172, 120197, 1), new Range32.ptr(120224, 120249, 1), new Range32.ptr(120276, 120301, 1), new Range32.ptr(120328, 120353, 1), new Range32.ptr(120380, 120405, 1), new Range32.ptr(120432, 120457, 1), new Range32.ptr(120488, 120512, 1), new Range32.ptr(120546, 120570, 1), new Range32.ptr(120604, 120628, 1), new Range32.ptr(120662, 120686, 1), new Range32.ptr(120720, 120744, 1), new Range32.ptr(120778, 125184, 4406), new Range32.ptr(125185, 125217, 1)]), 3);
		_M = new RangeTable.ptr(new sliceType([new Range16.ptr(768, 879, 1), new Range16.ptr(1155, 1161, 1), new Range16.ptr(1425, 1469, 1), new Range16.ptr(1471, 1473, 2), new Range16.ptr(1474, 1476, 2), new Range16.ptr(1477, 1479, 2), new Range16.ptr(1552, 1562, 1), new Range16.ptr(1611, 1631, 1), new Range16.ptr(1648, 1750, 102), new Range16.ptr(1751, 1756, 1), new Range16.ptr(1759, 1764, 1), new Range16.ptr(1767, 1768, 1), new Range16.ptr(1770, 1773, 1), new Range16.ptr(1809, 1840, 31), new Range16.ptr(1841, 1866, 1), new Range16.ptr(1958, 1968, 1), new Range16.ptr(2027, 2035, 1), new Range16.ptr(2070, 2073, 1), new Range16.ptr(2075, 2083, 1), new Range16.ptr(2085, 2087, 1), new Range16.ptr(2089, 2093, 1), new Range16.ptr(2137, 2139, 1), new Range16.ptr(2260, 2273, 1), new Range16.ptr(2275, 2307, 1), new Range16.ptr(2362, 2364, 1), new Range16.ptr(2366, 2383, 1), new Range16.ptr(2385, 2391, 1), new Range16.ptr(2402, 2403, 1), new Range16.ptr(2433, 2435, 1), new Range16.ptr(2492, 2494, 2), new Range16.ptr(2495, 2500, 1), new Range16.ptr(2503, 2504, 1), new Range16.ptr(2507, 2509, 1), new Range16.ptr(2519, 2530, 11), new Range16.ptr(2531, 2561, 30), new Range16.ptr(2562, 2563, 1), new Range16.ptr(2620, 2622, 2), new Range16.ptr(2623, 2626, 1), new Range16.ptr(2631, 2632, 1), new Range16.ptr(2635, 2637, 1), new Range16.ptr(2641, 2672, 31), new Range16.ptr(2673, 2677, 4), new Range16.ptr(2689, 2691, 1), new Range16.ptr(2748, 2750, 2), new Range16.ptr(2751, 2757, 1), new Range16.ptr(2759, 2761, 1), new Range16.ptr(2763, 2765, 1), new Range16.ptr(2786, 2787, 1), new Range16.ptr(2817, 2819, 1), new Range16.ptr(2876, 2878, 2), new Range16.ptr(2879, 2884, 1), new Range16.ptr(2887, 2888, 1), new Range16.ptr(2891, 2893, 1), new Range16.ptr(2902, 2903, 1), new Range16.ptr(2914, 2915, 1), new Range16.ptr(2946, 3006, 60), new Range16.ptr(3007, 3010, 1), new Range16.ptr(3014, 3016, 1), new Range16.ptr(3018, 3021, 1), new Range16.ptr(3031, 3072, 41), new Range16.ptr(3073, 3075, 1), new Range16.ptr(3134, 3140, 1), new Range16.ptr(3142, 3144, 1), new Range16.ptr(3146, 3149, 1), new Range16.ptr(3157, 3158, 1), new Range16.ptr(3170, 3171, 1), new Range16.ptr(3201, 3203, 1), new Range16.ptr(3260, 3262, 2), new Range16.ptr(3263, 3268, 1), new Range16.ptr(3270, 3272, 1), new Range16.ptr(3274, 3277, 1), new Range16.ptr(3285, 3286, 1), new Range16.ptr(3298, 3299, 1), new Range16.ptr(3329, 3331, 1), new Range16.ptr(3390, 3396, 1), new Range16.ptr(3398, 3400, 1), new Range16.ptr(3402, 3405, 1), new Range16.ptr(3415, 3426, 11), new Range16.ptr(3427, 3458, 31), new Range16.ptr(3459, 3530, 71), new Range16.ptr(3535, 3540, 1), new Range16.ptr(3542, 3544, 2), new Range16.ptr(3545, 3551, 1), new Range16.ptr(3570, 3571, 1), new Range16.ptr(3633, 3636, 3), new Range16.ptr(3637, 3642, 1), new Range16.ptr(3655, 3662, 1), new Range16.ptr(3761, 3764, 3), new Range16.ptr(3765, 3769, 1), new Range16.ptr(3771, 3772, 1), new Range16.ptr(3784, 3789, 1), new Range16.ptr(3864, 3865, 1), new Range16.ptr(3893, 3897, 2), new Range16.ptr(3902, 3903, 1), new Range16.ptr(3953, 3972, 1), new Range16.ptr(3974, 3975, 1), new Range16.ptr(3981, 3991, 1), new Range16.ptr(3993, 4028, 1), new Range16.ptr(4038, 4139, 101), new Range16.ptr(4140, 4158, 1), new Range16.ptr(4182, 4185, 1), new Range16.ptr(4190, 4192, 1), new Range16.ptr(4194, 4196, 1), new Range16.ptr(4199, 4205, 1), new Range16.ptr(4209, 4212, 1), new Range16.ptr(4226, 4237, 1), new Range16.ptr(4239, 4250, 11), new Range16.ptr(4251, 4253, 1), new Range16.ptr(4957, 4959, 1), new Range16.ptr(5906, 5908, 1), new Range16.ptr(5938, 5940, 1), new Range16.ptr(5970, 5971, 1), new Range16.ptr(6002, 6003, 1), new Range16.ptr(6068, 6099, 1), new Range16.ptr(6109, 6155, 46), new Range16.ptr(6156, 6157, 1), new Range16.ptr(6277, 6278, 1), new Range16.ptr(6313, 6432, 119), new Range16.ptr(6433, 6443, 1), new Range16.ptr(6448, 6459, 1), new Range16.ptr(6679, 6683, 1), new Range16.ptr(6741, 6750, 1), new Range16.ptr(6752, 6780, 1), new Range16.ptr(6783, 6832, 49), new Range16.ptr(6833, 6846, 1), new Range16.ptr(6912, 6916, 1), new Range16.ptr(6964, 6980, 1), new Range16.ptr(7019, 7027, 1), new Range16.ptr(7040, 7042, 1), new Range16.ptr(7073, 7085, 1), new Range16.ptr(7142, 7155, 1), new Range16.ptr(7204, 7223, 1), new Range16.ptr(7376, 7378, 1), new Range16.ptr(7380, 7400, 1), new Range16.ptr(7405, 7410, 5), new Range16.ptr(7411, 7412, 1), new Range16.ptr(7416, 7417, 1), new Range16.ptr(7616, 7669, 1), new Range16.ptr(7675, 7679, 1), new Range16.ptr(8400, 8432, 1), new Range16.ptr(11503, 11505, 1), new Range16.ptr(11647, 11744, 97), new Range16.ptr(11745, 11775, 1), new Range16.ptr(12330, 12335, 1), new Range16.ptr(12441, 12442, 1), new Range16.ptr(42607, 42610, 1), new Range16.ptr(42612, 42621, 1), new Range16.ptr(42654, 42655, 1), new Range16.ptr(42736, 42737, 1), new Range16.ptr(43010, 43014, 4), new Range16.ptr(43019, 43043, 24), new Range16.ptr(43044, 43047, 1), new Range16.ptr(43136, 43137, 1), new Range16.ptr(43188, 43205, 1), new Range16.ptr(43232, 43249, 1), new Range16.ptr(43302, 43309, 1), new Range16.ptr(43335, 43347, 1), new Range16.ptr(43392, 43395, 1), new Range16.ptr(43443, 43456, 1), new Range16.ptr(43493, 43561, 68), new Range16.ptr(43562, 43574, 1), new Range16.ptr(43587, 43596, 9), new Range16.ptr(43597, 43643, 46), new Range16.ptr(43644, 43645, 1), new Range16.ptr(43696, 43698, 2), new Range16.ptr(43699, 43700, 1), new Range16.ptr(43703, 43704, 1), new Range16.ptr(43710, 43711, 1), new Range16.ptr(43713, 43755, 42), new Range16.ptr(43756, 43759, 1), new Range16.ptr(43765, 43766, 1), new Range16.ptr(44003, 44010, 1), new Range16.ptr(44012, 44013, 1), new Range16.ptr(64286, 65024, 738), new Range16.ptr(65025, 65039, 1), new Range16.ptr(65056, 65071, 1)]), new sliceType$1([new Range32.ptr(66045, 66272, 227), new Range32.ptr(66422, 66426, 1), new Range32.ptr(68097, 68099, 1), new Range32.ptr(68101, 68102, 1), new Range32.ptr(68108, 68111, 1), new Range32.ptr(68152, 68154, 1), new Range32.ptr(68159, 68325, 166), new Range32.ptr(68326, 69632, 1306), new Range32.ptr(69633, 69634, 1), new Range32.ptr(69688, 69702, 1), new Range32.ptr(69759, 69762, 1), new Range32.ptr(69808, 69818, 1), new Range32.ptr(69888, 69890, 1), new Range32.ptr(69927, 69940, 1), new Range32.ptr(70003, 70016, 13), new Range32.ptr(70017, 70018, 1), new Range32.ptr(70067, 70080, 1), new Range32.ptr(70090, 70092, 1), new Range32.ptr(70188, 70199, 1), new Range32.ptr(70206, 70367, 161), new Range32.ptr(70368, 70378, 1), new Range32.ptr(70400, 70403, 1), new Range32.ptr(70460, 70462, 2), new Range32.ptr(70463, 70468, 1), new Range32.ptr(70471, 70472, 1), new Range32.ptr(70475, 70477, 1), new Range32.ptr(70487, 70498, 11), new Range32.ptr(70499, 70502, 3), new Range32.ptr(70503, 70508, 1), new Range32.ptr(70512, 70516, 1), new Range32.ptr(70709, 70726, 1), new Range32.ptr(70832, 70851, 1), new Range32.ptr(71087, 71093, 1), new Range32.ptr(71096, 71104, 1), new Range32.ptr(71132, 71133, 1), new Range32.ptr(71216, 71232, 1), new Range32.ptr(71339, 71351, 1), new Range32.ptr(71453, 71467, 1), new Range32.ptr(72751, 72758, 1), new Range32.ptr(72760, 72767, 1), new Range32.ptr(72850, 72871, 1), new Range32.ptr(72873, 72886, 1), new Range32.ptr(92912, 92916, 1), new Range32.ptr(92976, 92982, 1), new Range32.ptr(94033, 94078, 1), new Range32.ptr(94095, 94098, 1), new Range32.ptr(113821, 113822, 1), new Range32.ptr(119141, 119145, 1), new Range32.ptr(119149, 119154, 1), new Range32.ptr(119163, 119170, 1), new Range32.ptr(119173, 119179, 1), new Range32.ptr(119210, 119213, 1), new Range32.ptr(119362, 119364, 1), new Range32.ptr(121344, 121398, 1), new Range32.ptr(121403, 121452, 1), new Range32.ptr(121461, 121476, 15), new Range32.ptr(121499, 121503, 1), new Range32.ptr(121505, 121519, 1), new Range32.ptr(122880, 122886, 1), new Range32.ptr(122888, 122904, 1), new Range32.ptr(122907, 122913, 1), new Range32.ptr(122915, 122916, 1), new Range32.ptr(122918, 122922, 1), new Range32.ptr(125136, 125142, 1), new Range32.ptr(125252, 125258, 1), new Range32.ptr(917760, 917999, 1)]), 0);
		_Mc = new RangeTable.ptr(new sliceType([new Range16.ptr(2307, 2363, 56), new Range16.ptr(2366, 2368, 1), new Range16.ptr(2377, 2380, 1), new Range16.ptr(2382, 2383, 1), new Range16.ptr(2434, 2435, 1), new Range16.ptr(2494, 2496, 1), new Range16.ptr(2503, 2504, 1), new Range16.ptr(2507, 2508, 1), new Range16.ptr(2519, 2563, 44), new Range16.ptr(2622, 2624, 1), new Range16.ptr(2691, 2750, 59), new Range16.ptr(2751, 2752, 1), new Range16.ptr(2761, 2763, 2), new Range16.ptr(2764, 2818, 54), new Range16.ptr(2819, 2878, 59), new Range16.ptr(2880, 2887, 7), new Range16.ptr(2888, 2891, 3), new Range16.ptr(2892, 2903, 11), new Range16.ptr(3006, 3007, 1), new Range16.ptr(3009, 3010, 1), new Range16.ptr(3014, 3016, 1), new Range16.ptr(3018, 3020, 1), new Range16.ptr(3031, 3073, 42), new Range16.ptr(3074, 3075, 1), new Range16.ptr(3137, 3140, 1), new Range16.ptr(3202, 3203, 1), new Range16.ptr(3262, 3264, 2), new Range16.ptr(3265, 3268, 1), new Range16.ptr(3271, 3272, 1), new Range16.ptr(3274, 3275, 1), new Range16.ptr(3285, 3286, 1), new Range16.ptr(3330, 3331, 1), new Range16.ptr(3390, 3392, 1), new Range16.ptr(3398, 3400, 1), new Range16.ptr(3402, 3404, 1), new Range16.ptr(3415, 3458, 43), new Range16.ptr(3459, 3535, 76), new Range16.ptr(3536, 3537, 1), new Range16.ptr(3544, 3551, 1), new Range16.ptr(3570, 3571, 1), new Range16.ptr(3902, 3903, 1), new Range16.ptr(3967, 4139, 172), new Range16.ptr(4140, 4145, 5), new Range16.ptr(4152, 4155, 3), new Range16.ptr(4156, 4182, 26), new Range16.ptr(4183, 4194, 11), new Range16.ptr(4195, 4196, 1), new Range16.ptr(4199, 4205, 1), new Range16.ptr(4227, 4228, 1), new Range16.ptr(4231, 4236, 1), new Range16.ptr(4239, 4250, 11), new Range16.ptr(4251, 4252, 1), new Range16.ptr(6070, 6078, 8), new Range16.ptr(6079, 6085, 1), new Range16.ptr(6087, 6088, 1), new Range16.ptr(6435, 6438, 1), new Range16.ptr(6441, 6443, 1), new Range16.ptr(6448, 6449, 1), new Range16.ptr(6451, 6456, 1), new Range16.ptr(6681, 6682, 1), new Range16.ptr(6741, 6743, 2), new Range16.ptr(6753, 6755, 2), new Range16.ptr(6756, 6765, 9), new Range16.ptr(6766, 6770, 1), new Range16.ptr(6916, 6965, 49), new Range16.ptr(6971, 6973, 2), new Range16.ptr(6974, 6977, 1), new Range16.ptr(6979, 6980, 1), new Range16.ptr(7042, 7073, 31), new Range16.ptr(7078, 7079, 1), new Range16.ptr(7082, 7143, 61), new Range16.ptr(7146, 7148, 1), new Range16.ptr(7150, 7154, 4), new Range16.ptr(7155, 7204, 49), new Range16.ptr(7205, 7211, 1), new Range16.ptr(7220, 7221, 1), new Range16.ptr(7393, 7410, 17), new Range16.ptr(7411, 12334, 4923), new Range16.ptr(12335, 43043, 30708), new Range16.ptr(43044, 43047, 3), new Range16.ptr(43136, 43137, 1), new Range16.ptr(43188, 43203, 1), new Range16.ptr(43346, 43347, 1), new Range16.ptr(43395, 43444, 49), new Range16.ptr(43445, 43450, 5), new Range16.ptr(43451, 43453, 2), new Range16.ptr(43454, 43456, 1), new Range16.ptr(43567, 43568, 1), new Range16.ptr(43571, 43572, 1), new Range16.ptr(43597, 43643, 46), new Range16.ptr(43645, 43755, 110), new Range16.ptr(43758, 43759, 1), new Range16.ptr(43765, 44003, 238), new Range16.ptr(44004, 44006, 2), new Range16.ptr(44007, 44009, 2), new Range16.ptr(44010, 44012, 2)]), new sliceType$1([new Range32.ptr(69632, 69634, 2), new Range32.ptr(69762, 69808, 46), new Range32.ptr(69809, 69810, 1), new Range32.ptr(69815, 69816, 1), new Range32.ptr(69932, 70018, 86), new Range32.ptr(70067, 70069, 1), new Range32.ptr(70079, 70080, 1), new Range32.ptr(70188, 70190, 1), new Range32.ptr(70194, 70195, 1), new Range32.ptr(70197, 70368, 171), new Range32.ptr(70369, 70370, 1), new Range32.ptr(70402, 70403, 1), new Range32.ptr(70462, 70463, 1), new Range32.ptr(70465, 70468, 1), new Range32.ptr(70471, 70472, 1), new Range32.ptr(70475, 70477, 1), new Range32.ptr(70487, 70498, 11), new Range32.ptr(70499, 70709, 210), new Range32.ptr(70710, 70711, 1), new Range32.ptr(70720, 70721, 1), new Range32.ptr(70725, 70832, 107), new Range32.ptr(70833, 70834, 1), new Range32.ptr(70841, 70843, 2), new Range32.ptr(70844, 70846, 1), new Range32.ptr(70849, 71087, 238), new Range32.ptr(71088, 71089, 1), new Range32.ptr(71096, 71099, 1), new Range32.ptr(71102, 71216, 114), new Range32.ptr(71217, 71218, 1), new Range32.ptr(71227, 71228, 1), new Range32.ptr(71230, 71340, 110), new Range32.ptr(71342, 71343, 1), new Range32.ptr(71350, 71456, 106), new Range32.ptr(71457, 71462, 5), new Range32.ptr(72751, 72766, 15), new Range32.ptr(72873, 72881, 8), new Range32.ptr(72884, 94033, 21149), new Range32.ptr(94034, 94078, 1), new Range32.ptr(119141, 119142, 1), new Range32.ptr(119149, 119154, 1)]), 0);
		_Me = new RangeTable.ptr(new sliceType([new Range16.ptr(1160, 1161, 1), new Range16.ptr(6846, 8413, 1567), new Range16.ptr(8414, 8416, 1), new Range16.ptr(8418, 8420, 1), new Range16.ptr(42608, 42610, 1)]), sliceType$1.nil, 0);
		_Mn = new RangeTable.ptr(new sliceType([new Range16.ptr(768, 879, 1), new Range16.ptr(1155, 1159, 1), new Range16.ptr(1425, 1469, 1), new Range16.ptr(1471, 1473, 2), new Range16.ptr(1474, 1476, 2), new Range16.ptr(1477, 1479, 2), new Range16.ptr(1552, 1562, 1), new Range16.ptr(1611, 1631, 1), new Range16.ptr(1648, 1750, 102), new Range16.ptr(1751, 1756, 1), new Range16.ptr(1759, 1764, 1), new Range16.ptr(1767, 1768, 1), new Range16.ptr(1770, 1773, 1), new Range16.ptr(1809, 1840, 31), new Range16.ptr(1841, 1866, 1), new Range16.ptr(1958, 1968, 1), new Range16.ptr(2027, 2035, 1), new Range16.ptr(2070, 2073, 1), new Range16.ptr(2075, 2083, 1), new Range16.ptr(2085, 2087, 1), new Range16.ptr(2089, 2093, 1), new Range16.ptr(2137, 2139, 1), new Range16.ptr(2260, 2273, 1), new Range16.ptr(2275, 2306, 1), new Range16.ptr(2362, 2364, 2), new Range16.ptr(2369, 2376, 1), new Range16.ptr(2381, 2385, 4), new Range16.ptr(2386, 2391, 1), new Range16.ptr(2402, 2403, 1), new Range16.ptr(2433, 2492, 59), new Range16.ptr(2497, 2500, 1), new Range16.ptr(2509, 2530, 21), new Range16.ptr(2531, 2561, 30), new Range16.ptr(2562, 2620, 58), new Range16.ptr(2625, 2626, 1), new Range16.ptr(2631, 2632, 1), new Range16.ptr(2635, 2637, 1), new Range16.ptr(2641, 2672, 31), new Range16.ptr(2673, 2677, 4), new Range16.ptr(2689, 2690, 1), new Range16.ptr(2748, 2753, 5), new Range16.ptr(2754, 2757, 1), new Range16.ptr(2759, 2760, 1), new Range16.ptr(2765, 2786, 21), new Range16.ptr(2787, 2817, 30), new Range16.ptr(2876, 2879, 3), new Range16.ptr(2881, 2884, 1), new Range16.ptr(2893, 2902, 9), new Range16.ptr(2914, 2915, 1), new Range16.ptr(2946, 3008, 62), new Range16.ptr(3021, 3072, 51), new Range16.ptr(3134, 3136, 1), new Range16.ptr(3142, 3144, 1), new Range16.ptr(3146, 3149, 1), new Range16.ptr(3157, 3158, 1), new Range16.ptr(3170, 3171, 1), new Range16.ptr(3201, 3260, 59), new Range16.ptr(3263, 3270, 7), new Range16.ptr(3276, 3277, 1), new Range16.ptr(3298, 3299, 1), new Range16.ptr(3329, 3393, 64), new Range16.ptr(3394, 3396, 1), new Range16.ptr(3405, 3426, 21), new Range16.ptr(3427, 3530, 103), new Range16.ptr(3538, 3540, 1), new Range16.ptr(3542, 3633, 91), new Range16.ptr(3636, 3642, 1), new Range16.ptr(3655, 3662, 1), new Range16.ptr(3761, 3764, 3), new Range16.ptr(3765, 3769, 1), new Range16.ptr(3771, 3772, 1), new Range16.ptr(3784, 3789, 1), new Range16.ptr(3864, 3865, 1), new Range16.ptr(3893, 3897, 2), new Range16.ptr(3953, 3966, 1), new Range16.ptr(3968, 3972, 1), new Range16.ptr(3974, 3975, 1), new Range16.ptr(3981, 3991, 1), new Range16.ptr(3993, 4028, 1), new Range16.ptr(4038, 4141, 103), new Range16.ptr(4142, 4144, 1), new Range16.ptr(4146, 4151, 1), new Range16.ptr(4153, 4154, 1), new Range16.ptr(4157, 4158, 1), new Range16.ptr(4184, 4185, 1), new Range16.ptr(4190, 4192, 1), new Range16.ptr(4209, 4212, 1), new Range16.ptr(4226, 4229, 3), new Range16.ptr(4230, 4237, 7), new Range16.ptr(4253, 4957, 704), new Range16.ptr(4958, 4959, 1), new Range16.ptr(5906, 5908, 1), new Range16.ptr(5938, 5940, 1), new Range16.ptr(5970, 5971, 1), new Range16.ptr(6002, 6003, 1), new Range16.ptr(6068, 6069, 1), new Range16.ptr(6071, 6077, 1), new Range16.ptr(6086, 6089, 3), new Range16.ptr(6090, 6099, 1), new Range16.ptr(6109, 6155, 46), new Range16.ptr(6156, 6157, 1), new Range16.ptr(6277, 6278, 1), new Range16.ptr(6313, 6432, 119), new Range16.ptr(6433, 6434, 1), new Range16.ptr(6439, 6440, 1), new Range16.ptr(6450, 6457, 7), new Range16.ptr(6458, 6459, 1), new Range16.ptr(6679, 6680, 1), new Range16.ptr(6683, 6742, 59), new Range16.ptr(6744, 6750, 1), new Range16.ptr(6752, 6754, 2), new Range16.ptr(6757, 6764, 1), new Range16.ptr(6771, 6780, 1), new Range16.ptr(6783, 6832, 49), new Range16.ptr(6833, 6845, 1), new Range16.ptr(6912, 6915, 1), new Range16.ptr(6964, 6966, 2), new Range16.ptr(6967, 6970, 1), new Range16.ptr(6972, 6978, 6), new Range16.ptr(7019, 7027, 1), new Range16.ptr(7040, 7041, 1), new Range16.ptr(7074, 7077, 1), new Range16.ptr(7080, 7081, 1), new Range16.ptr(7083, 7085, 1), new Range16.ptr(7142, 7144, 2), new Range16.ptr(7145, 7149, 4), new Range16.ptr(7151, 7153, 1), new Range16.ptr(7212, 7219, 1), new Range16.ptr(7222, 7223, 1), new Range16.ptr(7376, 7378, 1), new Range16.ptr(7380, 7392, 1), new Range16.ptr(7394, 7400, 1), new Range16.ptr(7405, 7412, 7), new Range16.ptr(7416, 7417, 1), new Range16.ptr(7616, 7669, 1), new Range16.ptr(7675, 7679, 1), new Range16.ptr(8400, 8412, 1), new Range16.ptr(8417, 8421, 4), new Range16.ptr(8422, 8432, 1), new Range16.ptr(11503, 11505, 1), new Range16.ptr(11647, 11744, 97), new Range16.ptr(11745, 11775, 1), new Range16.ptr(12330, 12333, 1), new Range16.ptr(12441, 12442, 1), new Range16.ptr(42607, 42612, 5), new Range16.ptr(42613, 42621, 1), new Range16.ptr(42654, 42655, 1), new Range16.ptr(42736, 42737, 1), new Range16.ptr(43010, 43014, 4), new Range16.ptr(43019, 43045, 26), new Range16.ptr(43046, 43204, 158), new Range16.ptr(43205, 43232, 27), new Range16.ptr(43233, 43249, 1), new Range16.ptr(43302, 43309, 1), new Range16.ptr(43335, 43345, 1), new Range16.ptr(43392, 43394, 1), new Range16.ptr(43443, 43446, 3), new Range16.ptr(43447, 43449, 1), new Range16.ptr(43452, 43493, 41), new Range16.ptr(43561, 43566, 1), new Range16.ptr(43569, 43570, 1), new Range16.ptr(43573, 43574, 1), new Range16.ptr(43587, 43596, 9), new Range16.ptr(43644, 43696, 52), new Range16.ptr(43698, 43700, 1), new Range16.ptr(43703, 43704, 1), new Range16.ptr(43710, 43711, 1), new Range16.ptr(43713, 43756, 43), new Range16.ptr(43757, 43766, 9), new Range16.ptr(44005, 44008, 3), new Range16.ptr(44013, 64286, 20273), new Range16.ptr(65024, 65039, 1), new Range16.ptr(65056, 65071, 1)]), new sliceType$1([new Range32.ptr(66045, 66272, 227), new Range32.ptr(66422, 66426, 1), new Range32.ptr(68097, 68099, 1), new Range32.ptr(68101, 68102, 1), new Range32.ptr(68108, 68111, 1), new Range32.ptr(68152, 68154, 1), new Range32.ptr(68159, 68325, 166), new Range32.ptr(68326, 69633, 1307), new Range32.ptr(69688, 69702, 1), new Range32.ptr(69759, 69761, 1), new Range32.ptr(69811, 69814, 1), new Range32.ptr(69817, 69818, 1), new Range32.ptr(69888, 69890, 1), new Range32.ptr(69927, 69931, 1), new Range32.ptr(69933, 69940, 1), new Range32.ptr(70003, 70016, 13), new Range32.ptr(70017, 70070, 53), new Range32.ptr(70071, 70078, 1), new Range32.ptr(70090, 70092, 1), new Range32.ptr(70191, 70193, 1), new Range32.ptr(70196, 70198, 2), new Range32.ptr(70199, 70206, 7), new Range32.ptr(70367, 70371, 4), new Range32.ptr(70372, 70378, 1), new Range32.ptr(70400, 70401, 1), new Range32.ptr(70460, 70464, 4), new Range32.ptr(70502, 70508, 1), new Range32.ptr(70512, 70516, 1), new Range32.ptr(70712, 70719, 1), new Range32.ptr(70722, 70724, 1), new Range32.ptr(70726, 70835, 109), new Range32.ptr(70836, 70840, 1), new Range32.ptr(70842, 70847, 5), new Range32.ptr(70848, 70850, 2), new Range32.ptr(70851, 71090, 239), new Range32.ptr(71091, 71093, 1), new Range32.ptr(71100, 71101, 1), new Range32.ptr(71103, 71104, 1), new Range32.ptr(71132, 71133, 1), new Range32.ptr(71219, 71226, 1), new Range32.ptr(71229, 71231, 2), new Range32.ptr(71232, 71339, 107), new Range32.ptr(71341, 71344, 3), new Range32.ptr(71345, 71349, 1), new Range32.ptr(71351, 71453, 102), new Range32.ptr(71454, 71455, 1), new Range32.ptr(71458, 71461, 1), new Range32.ptr(71463, 71467, 1), new Range32.ptr(72752, 72758, 1), new Range32.ptr(72760, 72765, 1), new Range32.ptr(72767, 72850, 83), new Range32.ptr(72851, 72871, 1), new Range32.ptr(72874, 72880, 1), new Range32.ptr(72882, 72883, 1), new Range32.ptr(72885, 72886, 1), new Range32.ptr(92912, 92916, 1), new Range32.ptr(92976, 92982, 1), new Range32.ptr(94095, 94098, 1), new Range32.ptr(113821, 113822, 1), new Range32.ptr(119143, 119145, 1), new Range32.ptr(119163, 119170, 1), new Range32.ptr(119173, 119179, 1), new Range32.ptr(119210, 119213, 1), new Range32.ptr(119362, 119364, 1), new Range32.ptr(121344, 121398, 1), new Range32.ptr(121403, 121452, 1), new Range32.ptr(121461, 121476, 15), new Range32.ptr(121499, 121503, 1), new Range32.ptr(121505, 121519, 1), new Range32.ptr(122880, 122886, 1), new Range32.ptr(122888, 122904, 1), new Range32.ptr(122907, 122913, 1), new Range32.ptr(122915, 122916, 1), new Range32.ptr(122918, 122922, 1), new Range32.ptr(125136, 125142, 1), new Range32.ptr(125252, 125258, 1), new Range32.ptr(917760, 917999, 1)]), 0);
		_N = new RangeTable.ptr(new sliceType([new Range16.ptr(48, 57, 1), new Range16.ptr(178, 179, 1), new Range16.ptr(185, 188, 3), new Range16.ptr(189, 190, 1), new Range16.ptr(1632, 1641, 1), new Range16.ptr(1776, 1785, 1), new Range16.ptr(1984, 1993, 1), new Range16.ptr(2406, 2415, 1), new Range16.ptr(2534, 2543, 1), new Range16.ptr(2548, 2553, 1), new Range16.ptr(2662, 2671, 1), new Range16.ptr(2790, 2799, 1), new Range16.ptr(2918, 2927, 1), new Range16.ptr(2930, 2935, 1), new Range16.ptr(3046, 3058, 1), new Range16.ptr(3174, 3183, 1), new Range16.ptr(3192, 3198, 1), new Range16.ptr(3302, 3311, 1), new Range16.ptr(3416, 3422, 1), new Range16.ptr(3430, 3448, 1), new Range16.ptr(3558, 3567, 1), new Range16.ptr(3664, 3673, 1), new Range16.ptr(3792, 3801, 1), new Range16.ptr(3872, 3891, 1), new Range16.ptr(4160, 4169, 1), new Range16.ptr(4240, 4249, 1), new Range16.ptr(4969, 4988, 1), new Range16.ptr(5870, 5872, 1), new Range16.ptr(6112, 6121, 1), new Range16.ptr(6128, 6137, 1), new Range16.ptr(6160, 6169, 1), new Range16.ptr(6470, 6479, 1), new Range16.ptr(6608, 6618, 1), new Range16.ptr(6784, 6793, 1), new Range16.ptr(6800, 6809, 1), new Range16.ptr(6992, 7001, 1), new Range16.ptr(7088, 7097, 1), new Range16.ptr(7232, 7241, 1), new Range16.ptr(7248, 7257, 1), new Range16.ptr(8304, 8308, 4), new Range16.ptr(8309, 8313, 1), new Range16.ptr(8320, 8329, 1), new Range16.ptr(8528, 8578, 1), new Range16.ptr(8581, 8585, 1), new Range16.ptr(9312, 9371, 1), new Range16.ptr(9450, 9471, 1), new Range16.ptr(10102, 10131, 1), new Range16.ptr(11517, 12295, 778), new Range16.ptr(12321, 12329, 1), new Range16.ptr(12344, 12346, 1), new Range16.ptr(12690, 12693, 1), new Range16.ptr(12832, 12841, 1), new Range16.ptr(12872, 12879, 1), new Range16.ptr(12881, 12895, 1), new Range16.ptr(12928, 12937, 1), new Range16.ptr(12977, 12991, 1), new Range16.ptr(42528, 42537, 1), new Range16.ptr(42726, 42735, 1), new Range16.ptr(43056, 43061, 1), new Range16.ptr(43216, 43225, 1), new Range16.ptr(43264, 43273, 1), new Range16.ptr(43472, 43481, 1), new Range16.ptr(43504, 43513, 1), new Range16.ptr(43600, 43609, 1), new Range16.ptr(44016, 44025, 1), new Range16.ptr(65296, 65305, 1)]), new sliceType$1([new Range32.ptr(65799, 65843, 1), new Range32.ptr(65856, 65912, 1), new Range32.ptr(65930, 65931, 1), new Range32.ptr(66273, 66299, 1), new Range32.ptr(66336, 66339, 1), new Range32.ptr(66369, 66378, 9), new Range32.ptr(66513, 66517, 1), new Range32.ptr(66720, 66729, 1), new Range32.ptr(67672, 67679, 1), new Range32.ptr(67705, 67711, 1), new Range32.ptr(67751, 67759, 1), new Range32.ptr(67835, 67839, 1), new Range32.ptr(67862, 67867, 1), new Range32.ptr(68028, 68029, 1), new Range32.ptr(68032, 68047, 1), new Range32.ptr(68050, 68095, 1), new Range32.ptr(68160, 68167, 1), new Range32.ptr(68221, 68222, 1), new Range32.ptr(68253, 68255, 1), new Range32.ptr(68331, 68335, 1), new Range32.ptr(68440, 68447, 1), new Range32.ptr(68472, 68479, 1), new Range32.ptr(68521, 68527, 1), new Range32.ptr(68858, 68863, 1), new Range32.ptr(69216, 69246, 1), new Range32.ptr(69714, 69743, 1), new Range32.ptr(69872, 69881, 1), new Range32.ptr(69942, 69951, 1), new Range32.ptr(70096, 70105, 1), new Range32.ptr(70113, 70132, 1), new Range32.ptr(70384, 70393, 1), new Range32.ptr(70736, 70745, 1), new Range32.ptr(70864, 70873, 1), new Range32.ptr(71248, 71257, 1), new Range32.ptr(71360, 71369, 1), new Range32.ptr(71472, 71483, 1), new Range32.ptr(71904, 71922, 1), new Range32.ptr(72784, 72812, 1), new Range32.ptr(74752, 74862, 1), new Range32.ptr(92768, 92777, 1), new Range32.ptr(93008, 93017, 1), new Range32.ptr(93019, 93025, 1), new Range32.ptr(119648, 119665, 1), new Range32.ptr(120782, 120831, 1), new Range32.ptr(125127, 125135, 1), new Range32.ptr(125264, 125273, 1), new Range32.ptr(127232, 127244, 1)]), 4);
		_Nd = new RangeTable.ptr(new sliceType([new Range16.ptr(48, 57, 1), new Range16.ptr(1632, 1641, 1), new Range16.ptr(1776, 1785, 1), new Range16.ptr(1984, 1993, 1), new Range16.ptr(2406, 2415, 1), new Range16.ptr(2534, 2543, 1), new Range16.ptr(2662, 2671, 1), new Range16.ptr(2790, 2799, 1), new Range16.ptr(2918, 2927, 1), new Range16.ptr(3046, 3055, 1), new Range16.ptr(3174, 3183, 1), new Range16.ptr(3302, 3311, 1), new Range16.ptr(3430, 3439, 1), new Range16.ptr(3558, 3567, 1), new Range16.ptr(3664, 3673, 1), new Range16.ptr(3792, 3801, 1), new Range16.ptr(3872, 3881, 1), new Range16.ptr(4160, 4169, 1), new Range16.ptr(4240, 4249, 1), new Range16.ptr(6112, 6121, 1), new Range16.ptr(6160, 6169, 1), new Range16.ptr(6470, 6479, 1), new Range16.ptr(6608, 6617, 1), new Range16.ptr(6784, 6793, 1), new Range16.ptr(6800, 6809, 1), new Range16.ptr(6992, 7001, 1), new Range16.ptr(7088, 7097, 1), new Range16.ptr(7232, 7241, 1), new Range16.ptr(7248, 7257, 1), new Range16.ptr(42528, 42537, 1), new Range16.ptr(43216, 43225, 1), new Range16.ptr(43264, 43273, 1), new Range16.ptr(43472, 43481, 1), new Range16.ptr(43504, 43513, 1), new Range16.ptr(43600, 43609, 1), new Range16.ptr(44016, 44025, 1), new Range16.ptr(65296, 65305, 1)]), new sliceType$1([new Range32.ptr(66720, 66729, 1), new Range32.ptr(69734, 69743, 1), new Range32.ptr(69872, 69881, 1), new Range32.ptr(69942, 69951, 1), new Range32.ptr(70096, 70105, 1), new Range32.ptr(70384, 70393, 1), new Range32.ptr(70736, 70745, 1), new Range32.ptr(70864, 70873, 1), new Range32.ptr(71248, 71257, 1), new Range32.ptr(71360, 71369, 1), new Range32.ptr(71472, 71481, 1), new Range32.ptr(71904, 71913, 1), new Range32.ptr(72784, 72793, 1), new Range32.ptr(92768, 92777, 1), new Range32.ptr(93008, 93017, 1), new Range32.ptr(120782, 120831, 1), new Range32.ptr(125264, 125273, 1)]), 1);
		_Nl = new RangeTable.ptr(new sliceType([new Range16.ptr(5870, 5872, 1), new Range16.ptr(8544, 8578, 1), new Range16.ptr(8581, 8584, 1), new Range16.ptr(12295, 12321, 26), new Range16.ptr(12322, 12329, 1), new Range16.ptr(12344, 12346, 1), new Range16.ptr(42726, 42735, 1)]), new sliceType$1([new Range32.ptr(65856, 65908, 1), new Range32.ptr(66369, 66378, 9), new Range32.ptr(66513, 66517, 1), new Range32.ptr(74752, 74862, 1)]), 0);
		_No = new RangeTable.ptr(new sliceType([new Range16.ptr(178, 179, 1), new Range16.ptr(185, 188, 3), new Range16.ptr(189, 190, 1), new Range16.ptr(2548, 2553, 1), new Range16.ptr(2930, 2935, 1), new Range16.ptr(3056, 3058, 1), new Range16.ptr(3192, 3198, 1), new Range16.ptr(3416, 3422, 1), new Range16.ptr(3440, 3448, 1), new Range16.ptr(3882, 3891, 1), new Range16.ptr(4969, 4988, 1), new Range16.ptr(6128, 6137, 1), new Range16.ptr(6618, 8304, 1686), new Range16.ptr(8308, 8313, 1), new Range16.ptr(8320, 8329, 1), new Range16.ptr(8528, 8543, 1), new Range16.ptr(8585, 9312, 727), new Range16.ptr(9313, 9371, 1), new Range16.ptr(9450, 9471, 1), new Range16.ptr(10102, 10131, 1), new Range16.ptr(11517, 12690, 1173), new Range16.ptr(12691, 12693, 1), new Range16.ptr(12832, 12841, 1), new Range16.ptr(12872, 12879, 1), new Range16.ptr(12881, 12895, 1), new Range16.ptr(12928, 12937, 1), new Range16.ptr(12977, 12991, 1), new Range16.ptr(43056, 43061, 1)]), new sliceType$1([new Range32.ptr(65799, 65843, 1), new Range32.ptr(65909, 65912, 1), new Range32.ptr(65930, 65931, 1), new Range32.ptr(66273, 66299, 1), new Range32.ptr(66336, 66339, 1), new Range32.ptr(67672, 67679, 1), new Range32.ptr(67705, 67711, 1), new Range32.ptr(67751, 67759, 1), new Range32.ptr(67835, 67839, 1), new Range32.ptr(67862, 67867, 1), new Range32.ptr(68028, 68029, 1), new Range32.ptr(68032, 68047, 1), new Range32.ptr(68050, 68095, 1), new Range32.ptr(68160, 68167, 1), new Range32.ptr(68221, 68222, 1), new Range32.ptr(68253, 68255, 1), new Range32.ptr(68331, 68335, 1), new Range32.ptr(68440, 68447, 1), new Range32.ptr(68472, 68479, 1), new Range32.ptr(68521, 68527, 1), new Range32.ptr(68858, 68863, 1), new Range32.ptr(69216, 69246, 1), new Range32.ptr(69714, 69733, 1), new Range32.ptr(70113, 70132, 1), new Range32.ptr(71482, 71483, 1), new Range32.ptr(71914, 71922, 1), new Range32.ptr(72794, 72812, 1), new Range32.ptr(93019, 93025, 1), new Range32.ptr(119648, 119665, 1), new Range32.ptr(125127, 125135, 1), new Range32.ptr(127232, 127244, 1)]), 3);
		_P = new RangeTable.ptr(new sliceType([new Range16.ptr(33, 35, 1), new Range16.ptr(37, 42, 1), new Range16.ptr(44, 47, 1), new Range16.ptr(58, 59, 1), new Range16.ptr(63, 64, 1), new Range16.ptr(91, 93, 1), new Range16.ptr(95, 123, 28), new Range16.ptr(125, 161, 36), new Range16.ptr(167, 171, 4), new Range16.ptr(182, 183, 1), new Range16.ptr(187, 191, 4), new Range16.ptr(894, 903, 9), new Range16.ptr(1370, 1375, 1), new Range16.ptr(1417, 1418, 1), new Range16.ptr(1470, 1472, 2), new Range16.ptr(1475, 1478, 3), new Range16.ptr(1523, 1524, 1), new Range16.ptr(1545, 1546, 1), new Range16.ptr(1548, 1549, 1), new Range16.ptr(1563, 1566, 3), new Range16.ptr(1567, 1642, 75), new Range16.ptr(1643, 1645, 1), new Range16.ptr(1748, 1792, 44), new Range16.ptr(1793, 1805, 1), new Range16.ptr(2039, 2041, 1), new Range16.ptr(2096, 2110, 1), new Range16.ptr(2142, 2404, 262), new Range16.ptr(2405, 2416, 11), new Range16.ptr(2800, 3572, 772), new Range16.ptr(3663, 3674, 11), new Range16.ptr(3675, 3844, 169), new Range16.ptr(3845, 3858, 1), new Range16.ptr(3860, 3898, 38), new Range16.ptr(3899, 3901, 1), new Range16.ptr(3973, 4048, 75), new Range16.ptr(4049, 4052, 1), new Range16.ptr(4057, 4058, 1), new Range16.ptr(4170, 4175, 1), new Range16.ptr(4347, 4960, 613), new Range16.ptr(4961, 4968, 1), new Range16.ptr(5120, 5741, 621), new Range16.ptr(5742, 5787, 45), new Range16.ptr(5788, 5867, 79), new Range16.ptr(5868, 5869, 1), new Range16.ptr(5941, 5942, 1), new Range16.ptr(6100, 6102, 1), new Range16.ptr(6104, 6106, 1), new Range16.ptr(6144, 6154, 1), new Range16.ptr(6468, 6469, 1), new Range16.ptr(6686, 6687, 1), new Range16.ptr(6816, 6822, 1), new Range16.ptr(6824, 6829, 1), new Range16.ptr(7002, 7008, 1), new Range16.ptr(7164, 7167, 1), new Range16.ptr(7227, 7231, 1), new Range16.ptr(7294, 7295, 1), new Range16.ptr(7360, 7367, 1), new Range16.ptr(7379, 8208, 829), new Range16.ptr(8209, 8231, 1), new Range16.ptr(8240, 8259, 1), new Range16.ptr(8261, 8273, 1), new Range16.ptr(8275, 8286, 1), new Range16.ptr(8317, 8318, 1), new Range16.ptr(8333, 8334, 1), new Range16.ptr(8968, 8971, 1), new Range16.ptr(9001, 9002, 1), new Range16.ptr(10088, 10101, 1), new Range16.ptr(10181, 10182, 1), new Range16.ptr(10214, 10223, 1), new Range16.ptr(10627, 10648, 1), new Range16.ptr(10712, 10715, 1), new Range16.ptr(10748, 10749, 1), new Range16.ptr(11513, 11516, 1), new Range16.ptr(11518, 11519, 1), new Range16.ptr(11632, 11776, 144), new Range16.ptr(11777, 11822, 1), new Range16.ptr(11824, 11844, 1), new Range16.ptr(12289, 12291, 1), new Range16.ptr(12296, 12305, 1), new Range16.ptr(12308, 12319, 1), new Range16.ptr(12336, 12349, 13), new Range16.ptr(12448, 12539, 91), new Range16.ptr(42238, 42239, 1), new Range16.ptr(42509, 42511, 1), new Range16.ptr(42611, 42622, 11), new Range16.ptr(42738, 42743, 1), new Range16.ptr(43124, 43127, 1), new Range16.ptr(43214, 43215, 1), new Range16.ptr(43256, 43258, 1), new Range16.ptr(43260, 43310, 50), new Range16.ptr(43311, 43359, 48), new Range16.ptr(43457, 43469, 1), new Range16.ptr(43486, 43487, 1), new Range16.ptr(43612, 43615, 1), new Range16.ptr(43742, 43743, 1), new Range16.ptr(43760, 43761, 1), new Range16.ptr(44011, 64830, 20819), new Range16.ptr(64831, 65040, 209), new Range16.ptr(65041, 65049, 1), new Range16.ptr(65072, 65106, 1), new Range16.ptr(65108, 65121, 1), new Range16.ptr(65123, 65128, 5), new Range16.ptr(65130, 65131, 1), new Range16.ptr(65281, 65283, 1), new Range16.ptr(65285, 65290, 1), new Range16.ptr(65292, 65295, 1), new Range16.ptr(65306, 65307, 1), new Range16.ptr(65311, 65312, 1), new Range16.ptr(65339, 65341, 1), new Range16.ptr(65343, 65371, 28), new Range16.ptr(65373, 65375, 2), new Range16.ptr(65376, 65381, 1)]), new sliceType$1([new Range32.ptr(65792, 65794, 1), new Range32.ptr(66463, 66512, 49), new Range32.ptr(66927, 67671, 744), new Range32.ptr(67871, 67903, 32), new Range32.ptr(68176, 68184, 1), new Range32.ptr(68223, 68336, 113), new Range32.ptr(68337, 68342, 1), new Range32.ptr(68409, 68415, 1), new Range32.ptr(68505, 68508, 1), new Range32.ptr(69703, 69709, 1), new Range32.ptr(69819, 69820, 1), new Range32.ptr(69822, 69825, 1), new Range32.ptr(69952, 69955, 1), new Range32.ptr(70004, 70005, 1), new Range32.ptr(70085, 70089, 1), new Range32.ptr(70093, 70107, 14), new Range32.ptr(70109, 70111, 1), new Range32.ptr(70200, 70205, 1), new Range32.ptr(70313, 70731, 418), new Range32.ptr(70732, 70735, 1), new Range32.ptr(70747, 70749, 2), new Range32.ptr(70854, 71105, 251), new Range32.ptr(71106, 71127, 1), new Range32.ptr(71233, 71235, 1), new Range32.ptr(71264, 71276, 1), new Range32.ptr(71484, 71486, 1), new Range32.ptr(72769, 72773, 1), new Range32.ptr(72816, 72817, 1), new Range32.ptr(74864, 74868, 1), new Range32.ptr(92782, 92783, 1), new Range32.ptr(92917, 92983, 66), new Range32.ptr(92984, 92987, 1), new Range32.ptr(92996, 113823, 20827), new Range32.ptr(121479, 121483, 1), new Range32.ptr(125278, 125279, 1)]), 11);
		_Pc = new RangeTable.ptr(new sliceType([new Range16.ptr(95, 8255, 8160), new Range16.ptr(8256, 8276, 20), new Range16.ptr(65075, 65076, 1), new Range16.ptr(65101, 65103, 1), new Range16.ptr(65343, 65343, 1)]), sliceType$1.nil, 0);
		_Pd = new RangeTable.ptr(new sliceType([new Range16.ptr(45, 1418, 1373), new Range16.ptr(1470, 5120, 3650), new Range16.ptr(6150, 8208, 2058), new Range16.ptr(8209, 8213, 1), new Range16.ptr(11799, 11802, 3), new Range16.ptr(11834, 11835, 1), new Range16.ptr(11840, 12316, 476), new Range16.ptr(12336, 12448, 112), new Range16.ptr(65073, 65074, 1), new Range16.ptr(65112, 65123, 11), new Range16.ptr(65293, 65293, 1)]), sliceType$1.nil, 0);
		_Pe = new RangeTable.ptr(new sliceType([new Range16.ptr(41, 93, 52), new Range16.ptr(125, 3899, 3774), new Range16.ptr(3901, 5788, 1887), new Range16.ptr(8262, 8318, 56), new Range16.ptr(8334, 8969, 635), new Range16.ptr(8971, 9002, 31), new Range16.ptr(10089, 10101, 2), new Range16.ptr(10182, 10215, 33), new Range16.ptr(10217, 10223, 2), new Range16.ptr(10628, 10648, 2), new Range16.ptr(10713, 10715, 2), new Range16.ptr(10749, 11811, 1062), new Range16.ptr(11813, 11817, 2), new Range16.ptr(12297, 12305, 2), new Range16.ptr(12309, 12315, 2), new Range16.ptr(12318, 12319, 1), new Range16.ptr(64830, 65048, 218), new Range16.ptr(65078, 65092, 2), new Range16.ptr(65096, 65114, 18), new Range16.ptr(65116, 65118, 2), new Range16.ptr(65289, 65341, 52), new Range16.ptr(65373, 65379, 3)]), sliceType$1.nil, 1);
		_Pf = new RangeTable.ptr(new sliceType([new Range16.ptr(187, 8217, 8030), new Range16.ptr(8221, 8250, 29), new Range16.ptr(11779, 11781, 2), new Range16.ptr(11786, 11789, 3), new Range16.ptr(11805, 11809, 4)]), sliceType$1.nil, 0);
		_Pi = new RangeTable.ptr(new sliceType([new Range16.ptr(171, 8216, 8045), new Range16.ptr(8219, 8220, 1), new Range16.ptr(8223, 8249, 26), new Range16.ptr(11778, 11780, 2), new Range16.ptr(11785, 11788, 3), new Range16.ptr(11804, 11808, 4)]), sliceType$1.nil, 0);
		_Po = new RangeTable.ptr(new sliceType([new Range16.ptr(33, 35, 1), new Range16.ptr(37, 39, 1), new Range16.ptr(42, 46, 2), new Range16.ptr(47, 58, 11), new Range16.ptr(59, 63, 4), new Range16.ptr(64, 92, 28), new Range16.ptr(161, 167, 6), new Range16.ptr(182, 183, 1), new Range16.ptr(191, 894, 703), new Range16.ptr(903, 1370, 467), new Range16.ptr(1371, 1375, 1), new Range16.ptr(1417, 1472, 55), new Range16.ptr(1475, 1478, 3), new Range16.ptr(1523, 1524, 1), new Range16.ptr(1545, 1546, 1), new Range16.ptr(1548, 1549, 1), new Range16.ptr(1563, 1566, 3), new Range16.ptr(1567, 1642, 75), new Range16.ptr(1643, 1645, 1), new Range16.ptr(1748, 1792, 44), new Range16.ptr(1793, 1805, 1), new Range16.ptr(2039, 2041, 1), new Range16.ptr(2096, 2110, 1), new Range16.ptr(2142, 2404, 262), new Range16.ptr(2405, 2416, 11), new Range16.ptr(2800, 3572, 772), new Range16.ptr(3663, 3674, 11), new Range16.ptr(3675, 3844, 169), new Range16.ptr(3845, 3858, 1), new Range16.ptr(3860, 3973, 113), new Range16.ptr(4048, 4052, 1), new Range16.ptr(4057, 4058, 1), new Range16.ptr(4170, 4175, 1), new Range16.ptr(4347, 4960, 613), new Range16.ptr(4961, 4968, 1), new Range16.ptr(5741, 5742, 1), new Range16.ptr(5867, 5869, 1), new Range16.ptr(5941, 5942, 1), new Range16.ptr(6100, 6102, 1), new Range16.ptr(6104, 6106, 1), new Range16.ptr(6144, 6149, 1), new Range16.ptr(6151, 6154, 1), new Range16.ptr(6468, 6469, 1), new Range16.ptr(6686, 6687, 1), new Range16.ptr(6816, 6822, 1), new Range16.ptr(6824, 6829, 1), new Range16.ptr(7002, 7008, 1), new Range16.ptr(7164, 7167, 1), new Range16.ptr(7227, 7231, 1), new Range16.ptr(7294, 7295, 1), new Range16.ptr(7360, 7367, 1), new Range16.ptr(7379, 8214, 835), new Range16.ptr(8215, 8224, 9), new Range16.ptr(8225, 8231, 1), new Range16.ptr(8240, 8248, 1), new Range16.ptr(8251, 8254, 1), new Range16.ptr(8257, 8259, 1), new Range16.ptr(8263, 8273, 1), new Range16.ptr(8275, 8277, 2), new Range16.ptr(8278, 8286, 1), new Range16.ptr(11513, 11516, 1), new Range16.ptr(11518, 11519, 1), new Range16.ptr(11632, 11776, 144), new Range16.ptr(11777, 11782, 5), new Range16.ptr(11783, 11784, 1), new Range16.ptr(11787, 11790, 3), new Range16.ptr(11791, 11798, 1), new Range16.ptr(11800, 11801, 1), new Range16.ptr(11803, 11806, 3), new Range16.ptr(11807, 11818, 11), new Range16.ptr(11819, 11822, 1), new Range16.ptr(11824, 11833, 1), new Range16.ptr(11836, 11839, 1), new Range16.ptr(11841, 11843, 2), new Range16.ptr(11844, 12289, 445), new Range16.ptr(12290, 12291, 1), new Range16.ptr(12349, 12539, 190), new Range16.ptr(42238, 42239, 1), new Range16.ptr(42509, 42511, 1), new Range16.ptr(42611, 42622, 11), new Range16.ptr(42738, 42743, 1), new Range16.ptr(43124, 43127, 1), new Range16.ptr(43214, 43215, 1), new Range16.ptr(43256, 43258, 1), new Range16.ptr(43260, 43310, 50), new Range16.ptr(43311, 43359, 48), new Range16.ptr(43457, 43469, 1), new Range16.ptr(43486, 43487, 1), new Range16.ptr(43612, 43615, 1), new Range16.ptr(43742, 43743, 1), new Range16.ptr(43760, 43761, 1), new Range16.ptr(44011, 65040, 21029), new Range16.ptr(65041, 65046, 1), new Range16.ptr(65049, 65072, 23), new Range16.ptr(65093, 65094, 1), new Range16.ptr(65097, 65100, 1), new Range16.ptr(65104, 65106, 1), new Range16.ptr(65108, 65111, 1), new Range16.ptr(65119, 65121, 1), new Range16.ptr(65128, 65130, 2), new Range16.ptr(65131, 65281, 150), new Range16.ptr(65282, 65283, 1), new Range16.ptr(65285, 65287, 1), new Range16.ptr(65290, 65294, 2), new Range16.ptr(65295, 65306, 11), new Range16.ptr(65307, 65311, 4), new Range16.ptr(65312, 65340, 28), new Range16.ptr(65377, 65380, 3), new Range16.ptr(65381, 65381, 1)]), new sliceType$1([new Range32.ptr(65792, 65792, 1), new Range32.ptr(65793, 65794, 1), new Range32.ptr(66463, 66512, 49), new Range32.ptr(66927, 67671, 744), new Range32.ptr(67871, 67903, 32), new Range32.ptr(68176, 68184, 1), new Range32.ptr(68223, 68336, 113), new Range32.ptr(68337, 68342, 1), new Range32.ptr(68409, 68415, 1), new Range32.ptr(68505, 68508, 1), new Range32.ptr(69703, 69709, 1), new Range32.ptr(69819, 69820, 1), new Range32.ptr(69822, 69825, 1), new Range32.ptr(69952, 69955, 1), new Range32.ptr(70004, 70005, 1), new Range32.ptr(70085, 70089, 1), new Range32.ptr(70093, 70107, 14), new Range32.ptr(70109, 70111, 1), new Range32.ptr(70200, 70205, 1), new Range32.ptr(70313, 70731, 418), new Range32.ptr(70732, 70735, 1), new Range32.ptr(70747, 70749, 2), new Range32.ptr(70854, 71105, 251), new Range32.ptr(71106, 71127, 1), new Range32.ptr(71233, 71235, 1), new Range32.ptr(71264, 71276, 1), new Range32.ptr(71484, 71486, 1), new Range32.ptr(72769, 72773, 1), new Range32.ptr(72816, 72817, 1), new Range32.ptr(74864, 74868, 1), new Range32.ptr(92782, 92783, 1), new Range32.ptr(92917, 92983, 66), new Range32.ptr(92984, 92987, 1), new Range32.ptr(92996, 113823, 20827), new Range32.ptr(121479, 121483, 1), new Range32.ptr(125278, 125279, 1)]), 8);
		_Ps = new RangeTable.ptr(new sliceType([new Range16.ptr(40, 91, 51), new Range16.ptr(123, 3898, 3775), new Range16.ptr(3900, 5787, 1887), new Range16.ptr(8218, 8222, 4), new Range16.ptr(8261, 8317, 56), new Range16.ptr(8333, 8968, 635), new Range16.ptr(8970, 9001, 31), new Range16.ptr(10088, 10100, 2), new Range16.ptr(10181, 10214, 33), new Range16.ptr(10216, 10222, 2), new Range16.ptr(10627, 10647, 2), new Range16.ptr(10712, 10714, 2), new Range16.ptr(10748, 11810, 1062), new Range16.ptr(11812, 11816, 2), new Range16.ptr(11842, 12296, 454), new Range16.ptr(12298, 12304, 2), new Range16.ptr(12308, 12314, 2), new Range16.ptr(12317, 64831, 52514), new Range16.ptr(65047, 65077, 30), new Range16.ptr(65079, 65091, 2), new Range16.ptr(65095, 65113, 18), new Range16.ptr(65115, 65117, 2), new Range16.ptr(65288, 65339, 51), new Range16.ptr(65371, 65375, 4), new Range16.ptr(65378, 65378, 1)]), sliceType$1.nil, 1);
		_S = new RangeTable.ptr(new sliceType([new Range16.ptr(36, 43, 7), new Range16.ptr(60, 62, 1), new Range16.ptr(94, 96, 2), new Range16.ptr(124, 126, 2), new Range16.ptr(162, 166, 1), new Range16.ptr(168, 169, 1), new Range16.ptr(172, 174, 2), new Range16.ptr(175, 177, 1), new Range16.ptr(180, 184, 4), new Range16.ptr(215, 247, 32), new Range16.ptr(706, 709, 1), new Range16.ptr(722, 735, 1), new Range16.ptr(741, 747, 1), new Range16.ptr(749, 751, 2), new Range16.ptr(752, 767, 1), new Range16.ptr(885, 900, 15), new Range16.ptr(901, 1014, 113), new Range16.ptr(1154, 1421, 267), new Range16.ptr(1422, 1423, 1), new Range16.ptr(1542, 1544, 1), new Range16.ptr(1547, 1550, 3), new Range16.ptr(1551, 1758, 207), new Range16.ptr(1769, 1789, 20), new Range16.ptr(1790, 2038, 248), new Range16.ptr(2546, 2547, 1), new Range16.ptr(2554, 2555, 1), new Range16.ptr(2801, 2928, 127), new Range16.ptr(3059, 3066, 1), new Range16.ptr(3199, 3407, 208), new Range16.ptr(3449, 3647, 198), new Range16.ptr(3841, 3843, 1), new Range16.ptr(3859, 3861, 2), new Range16.ptr(3862, 3863, 1), new Range16.ptr(3866, 3871, 1), new Range16.ptr(3892, 3896, 2), new Range16.ptr(4030, 4037, 1), new Range16.ptr(4039, 4044, 1), new Range16.ptr(4046, 4047, 1), new Range16.ptr(4053, 4056, 1), new Range16.ptr(4254, 4255, 1), new Range16.ptr(5008, 5017, 1), new Range16.ptr(6107, 6464, 357), new Range16.ptr(6622, 6655, 1), new Range16.ptr(7009, 7018, 1), new Range16.ptr(7028, 7036, 1), new Range16.ptr(8125, 8127, 2), new Range16.ptr(8128, 8129, 1), new Range16.ptr(8141, 8143, 1), new Range16.ptr(8157, 8159, 1), new Range16.ptr(8173, 8175, 1), new Range16.ptr(8189, 8190, 1), new Range16.ptr(8260, 8274, 14), new Range16.ptr(8314, 8316, 1), new Range16.ptr(8330, 8332, 1), new Range16.ptr(8352, 8382, 1), new Range16.ptr(8448, 8449, 1), new Range16.ptr(8451, 8454, 1), new Range16.ptr(8456, 8457, 1), new Range16.ptr(8468, 8470, 2), new Range16.ptr(8471, 8472, 1), new Range16.ptr(8478, 8483, 1), new Range16.ptr(8485, 8489, 2), new Range16.ptr(8494, 8506, 12), new Range16.ptr(8507, 8512, 5), new Range16.ptr(8513, 8516, 1), new Range16.ptr(8522, 8525, 1), new Range16.ptr(8527, 8586, 59), new Range16.ptr(8587, 8592, 5), new Range16.ptr(8593, 8967, 1), new Range16.ptr(8972, 9000, 1), new Range16.ptr(9003, 9214, 1), new Range16.ptr(9216, 9254, 1), new Range16.ptr(9280, 9290, 1), new Range16.ptr(9372, 9449, 1), new Range16.ptr(9472, 10087, 1), new Range16.ptr(10132, 10180, 1), new Range16.ptr(10183, 10213, 1), new Range16.ptr(10224, 10626, 1), new Range16.ptr(10649, 10711, 1), new Range16.ptr(10716, 10747, 1), new Range16.ptr(10750, 11123, 1), new Range16.ptr(11126, 11157, 1), new Range16.ptr(11160, 11193, 1), new Range16.ptr(11197, 11208, 1), new Range16.ptr(11210, 11217, 1), new Range16.ptr(11244, 11247, 1), new Range16.ptr(11493, 11498, 1), new Range16.ptr(11904, 11929, 1), new Range16.ptr(11931, 12019, 1), new Range16.ptr(12032, 12245, 1), new Range16.ptr(12272, 12283, 1), new Range16.ptr(12292, 12306, 14), new Range16.ptr(12307, 12320, 13), new Range16.ptr(12342, 12343, 1), new Range16.ptr(12350, 12351, 1), new Range16.ptr(12443, 12444, 1), new Range16.ptr(12688, 12689, 1), new Range16.ptr(12694, 12703, 1), new Range16.ptr(12736, 12771, 1), new Range16.ptr(12800, 12830, 1), new Range16.ptr(12842, 12871, 1), new Range16.ptr(12880, 12896, 16), new Range16.ptr(12897, 12927, 1), new Range16.ptr(12938, 12976, 1), new Range16.ptr(12992, 13054, 1), new Range16.ptr(13056, 13311, 1), new Range16.ptr(19904, 19967, 1), new Range16.ptr(42128, 42182, 1), new Range16.ptr(42752, 42774, 1), new Range16.ptr(42784, 42785, 1), new Range16.ptr(42889, 42890, 1), new Range16.ptr(43048, 43051, 1), new Range16.ptr(43062, 43065, 1), new Range16.ptr(43639, 43641, 1), new Range16.ptr(43867, 64297, 20430), new Range16.ptr(64434, 64449, 1), new Range16.ptr(65020, 65021, 1), new Range16.ptr(65122, 65124, 2), new Range16.ptr(65125, 65126, 1), new Range16.ptr(65129, 65284, 155), new Range16.ptr(65291, 65308, 17), new Range16.ptr(65309, 65310, 1), new Range16.ptr(65342, 65344, 2), new Range16.ptr(65372, 65374, 2), new Range16.ptr(65504, 65510, 1), new Range16.ptr(65512, 65518, 1), new Range16.ptr(65532, 65533, 1)]), new sliceType$1([new Range32.ptr(65847, 65855, 1), new Range32.ptr(65913, 65929, 1), new Range32.ptr(65932, 65934, 1), new Range32.ptr(65936, 65947, 1), new Range32.ptr(65952, 66000, 48), new Range32.ptr(66001, 66044, 1), new Range32.ptr(67703, 67704, 1), new Range32.ptr(68296, 71487, 3191), new Range32.ptr(92988, 92991, 1), new Range32.ptr(92997, 113820, 20823), new Range32.ptr(118784, 119029, 1), new Range32.ptr(119040, 119078, 1), new Range32.ptr(119081, 119140, 1), new Range32.ptr(119146, 119148, 1), new Range32.ptr(119171, 119172, 1), new Range32.ptr(119180, 119209, 1), new Range32.ptr(119214, 119272, 1), new Range32.ptr(119296, 119361, 1), new Range32.ptr(119365, 119552, 187), new Range32.ptr(119553, 119638, 1), new Range32.ptr(120513, 120539, 26), new Range32.ptr(120571, 120597, 26), new Range32.ptr(120629, 120655, 26), new Range32.ptr(120687, 120713, 26), new Range32.ptr(120745, 120771, 26), new Range32.ptr(120832, 121343, 1), new Range32.ptr(121399, 121402, 1), new Range32.ptr(121453, 121460, 1), new Range32.ptr(121462, 121475, 1), new Range32.ptr(121477, 121478, 1), new Range32.ptr(126704, 126705, 1), new Range32.ptr(126976, 127019, 1), new Range32.ptr(127024, 127123, 1), new Range32.ptr(127136, 127150, 1), new Range32.ptr(127153, 127167, 1), new Range32.ptr(127169, 127183, 1), new Range32.ptr(127185, 127221, 1), new Range32.ptr(127248, 127278, 1), new Range32.ptr(127280, 127339, 1), new Range32.ptr(127344, 127404, 1), new Range32.ptr(127462, 127490, 1), new Range32.ptr(127504, 127547, 1), new Range32.ptr(127552, 127560, 1), new Range32.ptr(127568, 127569, 1), new Range32.ptr(127744, 128722, 1), new Range32.ptr(128736, 128748, 1), new Range32.ptr(128752, 128758, 1), new Range32.ptr(128768, 128883, 1), new Range32.ptr(128896, 128980, 1), new Range32.ptr(129024, 129035, 1), new Range32.ptr(129040, 129095, 1), new Range32.ptr(129104, 129113, 1), new Range32.ptr(129120, 129159, 1), new Range32.ptr(129168, 129197, 1), new Range32.ptr(129296, 129310, 1), new Range32.ptr(129312, 129319, 1), new Range32.ptr(129328, 129331, 3), new Range32.ptr(129332, 129342, 1), new Range32.ptr(129344, 129355, 1), new Range32.ptr(129360, 129374, 1), new Range32.ptr(129408, 129425, 1), new Range32.ptr(129472, 129472, 1)]), 10);
		_Sc = new RangeTable.ptr(new sliceType([new Range16.ptr(36, 162, 126), new Range16.ptr(163, 165, 1), new Range16.ptr(1423, 1547, 124), new Range16.ptr(2546, 2547, 1), new Range16.ptr(2555, 2801, 246), new Range16.ptr(3065, 3647, 582), new Range16.ptr(6107, 8352, 2245), new Range16.ptr(8353, 8382, 1), new Range16.ptr(43064, 65020, 21956), new Range16.ptr(65129, 65284, 155), new Range16.ptr(65504, 65505, 1), new Range16.ptr(65509, 65510, 1)]), sliceType$1.nil, 2);
		_Sk = new RangeTable.ptr(new sliceType([new Range16.ptr(94, 96, 2), new Range16.ptr(168, 175, 7), new Range16.ptr(180, 184, 4), new Range16.ptr(706, 709, 1), new Range16.ptr(722, 735, 1), new Range16.ptr(741, 747, 1), new Range16.ptr(749, 751, 2), new Range16.ptr(752, 767, 1), new Range16.ptr(885, 900, 15), new Range16.ptr(901, 8125, 7224), new Range16.ptr(8127, 8129, 1), new Range16.ptr(8141, 8143, 1), new Range16.ptr(8157, 8159, 1), new Range16.ptr(8173, 8175, 1), new Range16.ptr(8189, 8190, 1), new Range16.ptr(12443, 12444, 1), new Range16.ptr(42752, 42774, 1), new Range16.ptr(42784, 42785, 1), new Range16.ptr(42889, 42890, 1), new Range16.ptr(43867, 64434, 20567), new Range16.ptr(64435, 64449, 1), new Range16.ptr(65342, 65344, 2), new Range16.ptr(65507, 65507, 1)]), new sliceType$1([new Range32.ptr(127995, 127995, 1), new Range32.ptr(127996, 127999, 1)]), 3);
		_Sm = new RangeTable.ptr(new sliceType([new Range16.ptr(43, 60, 17), new Range16.ptr(61, 62, 1), new Range16.ptr(124, 126, 2), new Range16.ptr(172, 177, 5), new Range16.ptr(215, 247, 32), new Range16.ptr(1014, 1542, 528), new Range16.ptr(1543, 1544, 1), new Range16.ptr(8260, 8274, 14), new Range16.ptr(8314, 8316, 1), new Range16.ptr(8330, 8332, 1), new Range16.ptr(8472, 8512, 40), new Range16.ptr(8513, 8516, 1), new Range16.ptr(8523, 8592, 69), new Range16.ptr(8593, 8596, 1), new Range16.ptr(8602, 8603, 1), new Range16.ptr(8608, 8614, 3), new Range16.ptr(8622, 8654, 32), new Range16.ptr(8655, 8658, 3), new Range16.ptr(8660, 8692, 32), new Range16.ptr(8693, 8959, 1), new Range16.ptr(8992, 8993, 1), new Range16.ptr(9084, 9115, 31), new Range16.ptr(9116, 9139, 1), new Range16.ptr(9180, 9185, 1), new Range16.ptr(9655, 9665, 10), new Range16.ptr(9720, 9727, 1), new Range16.ptr(9839, 10176, 337), new Range16.ptr(10177, 10180, 1), new Range16.ptr(10183, 10213, 1), new Range16.ptr(10224, 10239, 1), new Range16.ptr(10496, 10626, 1), new Range16.ptr(10649, 10711, 1), new Range16.ptr(10716, 10747, 1), new Range16.ptr(10750, 11007, 1), new Range16.ptr(11056, 11076, 1), new Range16.ptr(11079, 11084, 1), new Range16.ptr(64297, 65122, 825), new Range16.ptr(65124, 65126, 1), new Range16.ptr(65291, 65308, 17), new Range16.ptr(65309, 65310, 1), new Range16.ptr(65372, 65374, 2), new Range16.ptr(65506, 65513, 7), new Range16.ptr(65514, 65516, 1)]), new sliceType$1([new Range32.ptr(120513, 120539, 26), new Range32.ptr(120571, 120597, 26), new Range32.ptr(120629, 120655, 26), new Range32.ptr(120687, 120713, 26), new Range32.ptr(120745, 120771, 26), new Range32.ptr(126704, 126705, 1)]), 5);
		_So = new RangeTable.ptr(new sliceType([new Range16.ptr(166, 169, 3), new Range16.ptr(174, 176, 2), new Range16.ptr(1154, 1421, 267), new Range16.ptr(1422, 1550, 128), new Range16.ptr(1551, 1758, 207), new Range16.ptr(1769, 1789, 20), new Range16.ptr(1790, 2038, 248), new Range16.ptr(2554, 2928, 374), new Range16.ptr(3059, 3064, 1), new Range16.ptr(3066, 3199, 133), new Range16.ptr(3407, 3449, 42), new Range16.ptr(3841, 3843, 1), new Range16.ptr(3859, 3861, 2), new Range16.ptr(3862, 3863, 1), new Range16.ptr(3866, 3871, 1), new Range16.ptr(3892, 3896, 2), new Range16.ptr(4030, 4037, 1), new Range16.ptr(4039, 4044, 1), new Range16.ptr(4046, 4047, 1), new Range16.ptr(4053, 4056, 1), new Range16.ptr(4254, 4255, 1), new Range16.ptr(5008, 5017, 1), new Range16.ptr(6464, 6622, 158), new Range16.ptr(6623, 6655, 1), new Range16.ptr(7009, 7018, 1), new Range16.ptr(7028, 7036, 1), new Range16.ptr(8448, 8449, 1), new Range16.ptr(8451, 8454, 1), new Range16.ptr(8456, 8457, 1), new Range16.ptr(8468, 8470, 2), new Range16.ptr(8471, 8478, 7), new Range16.ptr(8479, 8483, 1), new Range16.ptr(8485, 8489, 2), new Range16.ptr(8494, 8506, 12), new Range16.ptr(8507, 8522, 15), new Range16.ptr(8524, 8525, 1), new Range16.ptr(8527, 8586, 59), new Range16.ptr(8587, 8597, 10), new Range16.ptr(8598, 8601, 1), new Range16.ptr(8604, 8607, 1), new Range16.ptr(8609, 8610, 1), new Range16.ptr(8612, 8613, 1), new Range16.ptr(8615, 8621, 1), new Range16.ptr(8623, 8653, 1), new Range16.ptr(8656, 8657, 1), new Range16.ptr(8659, 8661, 2), new Range16.ptr(8662, 8691, 1), new Range16.ptr(8960, 8967, 1), new Range16.ptr(8972, 8991, 1), new Range16.ptr(8994, 9000, 1), new Range16.ptr(9003, 9083, 1), new Range16.ptr(9085, 9114, 1), new Range16.ptr(9140, 9179, 1), new Range16.ptr(9186, 9214, 1), new Range16.ptr(9216, 9254, 1), new Range16.ptr(9280, 9290, 1), new Range16.ptr(9372, 9449, 1), new Range16.ptr(9472, 9654, 1), new Range16.ptr(9656, 9664, 1), new Range16.ptr(9666, 9719, 1), new Range16.ptr(9728, 9838, 1), new Range16.ptr(9840, 10087, 1), new Range16.ptr(10132, 10175, 1), new Range16.ptr(10240, 10495, 1), new Range16.ptr(11008, 11055, 1), new Range16.ptr(11077, 11078, 1), new Range16.ptr(11085, 11123, 1), new Range16.ptr(11126, 11157, 1), new Range16.ptr(11160, 11193, 1), new Range16.ptr(11197, 11208, 1), new Range16.ptr(11210, 11217, 1), new Range16.ptr(11244, 11247, 1), new Range16.ptr(11493, 11498, 1), new Range16.ptr(11904, 11929, 1), new Range16.ptr(11931, 12019, 1), new Range16.ptr(12032, 12245, 1), new Range16.ptr(12272, 12283, 1), new Range16.ptr(12292, 12306, 14), new Range16.ptr(12307, 12320, 13), new Range16.ptr(12342, 12343, 1), new Range16.ptr(12350, 12351, 1), new Range16.ptr(12688, 12689, 1), new Range16.ptr(12694, 12703, 1), new Range16.ptr(12736, 12771, 1), new Range16.ptr(12800, 12830, 1), new Range16.ptr(12842, 12871, 1), new Range16.ptr(12880, 12896, 16), new Range16.ptr(12897, 12927, 1), new Range16.ptr(12938, 12976, 1), new Range16.ptr(12992, 13054, 1), new Range16.ptr(13056, 13311, 1), new Range16.ptr(19904, 19967, 1), new Range16.ptr(42128, 42182, 1), new Range16.ptr(43048, 43051, 1), new Range16.ptr(43062, 43063, 1), new Range16.ptr(43065, 43639, 574), new Range16.ptr(43640, 43641, 1), new Range16.ptr(65021, 65508, 487), new Range16.ptr(65512, 65517, 5), new Range16.ptr(65518, 65532, 14), new Range16.ptr(65533, 65533, 1)]), new sliceType$1([new Range32.ptr(65847, 65847, 1), new Range32.ptr(65848, 65855, 1), new Range32.ptr(65913, 65929, 1), new Range32.ptr(65932, 65934, 1), new Range32.ptr(65936, 65947, 1), new Range32.ptr(65952, 66000, 48), new Range32.ptr(66001, 66044, 1), new Range32.ptr(67703, 67704, 1), new Range32.ptr(68296, 71487, 3191), new Range32.ptr(92988, 92991, 1), new Range32.ptr(92997, 113820, 20823), new Range32.ptr(118784, 119029, 1), new Range32.ptr(119040, 119078, 1), new Range32.ptr(119081, 119140, 1), new Range32.ptr(119146, 119148, 1), new Range32.ptr(119171, 119172, 1), new Range32.ptr(119180, 119209, 1), new Range32.ptr(119214, 119272, 1), new Range32.ptr(119296, 119361, 1), new Range32.ptr(119365, 119552, 187), new Range32.ptr(119553, 119638, 1), new Range32.ptr(120832, 121343, 1), new Range32.ptr(121399, 121402, 1), new Range32.ptr(121453, 121460, 1), new Range32.ptr(121462, 121475, 1), new Range32.ptr(121477, 121478, 1), new Range32.ptr(126976, 127019, 1), new Range32.ptr(127024, 127123, 1), new Range32.ptr(127136, 127150, 1), new Range32.ptr(127153, 127167, 1), new Range32.ptr(127169, 127183, 1), new Range32.ptr(127185, 127221, 1), new Range32.ptr(127248, 127278, 1), new Range32.ptr(127280, 127339, 1), new Range32.ptr(127344, 127404, 1), new Range32.ptr(127462, 127490, 1), new Range32.ptr(127504, 127547, 1), new Range32.ptr(127552, 127560, 1), new Range32.ptr(127568, 127569, 1), new Range32.ptr(127744, 127994, 1), new Range32.ptr(128000, 128722, 1), new Range32.ptr(128736, 128748, 1), new Range32.ptr(128752, 128758, 1), new Range32.ptr(128768, 128883, 1), new Range32.ptr(128896, 128980, 1), new Range32.ptr(129024, 129035, 1), new Range32.ptr(129040, 129095, 1), new Range32.ptr(129104, 129113, 1), new Range32.ptr(129120, 129159, 1), new Range32.ptr(129168, 129197, 1), new Range32.ptr(129296, 129310, 1), new Range32.ptr(129312, 129319, 1), new Range32.ptr(129328, 129331, 3), new Range32.ptr(129332, 129342, 1), new Range32.ptr(129344, 129355, 1), new Range32.ptr(129360, 129374, 1), new Range32.ptr(129408, 129425, 1), new Range32.ptr(129472, 129472, 1)]), 2);
		_Z = new RangeTable.ptr(new sliceType([new Range16.ptr(32, 160, 128), new Range16.ptr(5760, 8192, 2432), new Range16.ptr(8193, 8202, 1), new Range16.ptr(8232, 8233, 1), new Range16.ptr(8239, 8287, 48), new Range16.ptr(12288, 12288, 1)]), sliceType$1.nil, 1);
		_Zl = new RangeTable.ptr(new sliceType([new Range16.ptr(8232, 8232, 1)]), sliceType$1.nil, 0);
		_Zp = new RangeTable.ptr(new sliceType([new Range16.ptr(8233, 8233, 1)]), sliceType$1.nil, 0);
		_Zs = new RangeTable.ptr(new sliceType([new Range16.ptr(32, 160, 128), new Range16.ptr(5760, 8192, 2432), new Range16.ptr(8193, 8202, 1), new Range16.ptr(8239, 8287, 48), new Range16.ptr(12288, 12288, 1)]), sliceType$1.nil, 1);
		$pkg.Cc = _Cc;
		$pkg.Cf = _Cf;
		$pkg.Co = _Co;
		$pkg.Cs = _Cs;
		$pkg.Digit = _Nd;
		$pkg.Nd = _Nd;
		$pkg.Letter = _L;
		$pkg.L = _L;
		$pkg.Lm = _Lm;
		$pkg.Lo = _Lo;
		$pkg.Ll = _Ll;
		$pkg.M = _M;
		$pkg.Mc = _Mc;
		$pkg.Me = _Me;
		$pkg.Mn = _Mn;
		$pkg.Nl = _Nl;
		$pkg.No = _No;
		$pkg.N = _N;
		$pkg.C = _C;
		$pkg.Pc = _Pc;
		$pkg.Pd = _Pd;
		$pkg.Pe = _Pe;
		$pkg.Pf = _Pf;
		$pkg.Pi = _Pi;
		$pkg.Po = _Po;
		$pkg.Ps = _Ps;
		$pkg.P = _P;
		$pkg.Sc = _Sc;
		$pkg.Sk = _Sk;
		$pkg.Sm = _Sm;
		$pkg.So = _So;
		$pkg.Z = _Z;
		$pkg.S = _S;
		$pkg.PrintRanges = new sliceType$2([$pkg.L, $pkg.M, $pkg.N, $pkg.P, $pkg.S]);
		$pkg.Lt = _Lt;
		$pkg.Upper = _Lu;
		$pkg.Lu = _Lu;
		$pkg.Zl = _Zl;
		$pkg.Zp = _Zp;
		$pkg.Zs = _Zs;
		$pkg.Categories = $makeMap($String.keyFor, [{ k: "C", v: $pkg.C }, { k: "Cc", v: $pkg.Cc }, { k: "Cf", v: $pkg.Cf }, { k: "Co", v: $pkg.Co }, { k: "Cs", v: $pkg.Cs }, { k: "L", v: $pkg.L }, { k: "Ll", v: $pkg.Ll }, { k: "Lm", v: $pkg.Lm }, { k: "Lo", v: $pkg.Lo }, { k: "Lt", v: $pkg.Lt }, { k: "Lu", v: $pkg.Lu }, { k: "M", v: $pkg.M }, { k: "Mc", v: $pkg.Mc }, { k: "Me", v: $pkg.Me }, { k: "Mn", v: $pkg.Mn }, { k: "N", v: $pkg.N }, { k: "Nd", v: $pkg.Nd }, { k: "Nl", v: $pkg.Nl }, { k: "No", v: $pkg.No }, { k: "P", v: $pkg.P }, { k: "Pc", v: $pkg.Pc }, { k: "Pd", v: $pkg.Pd }, { k: "Pe", v: $pkg.Pe }, { k: "Pf", v: $pkg.Pf }, { k: "Pi", v: $pkg.Pi }, { k: "Po", v: $pkg.Po }, { k: "Ps", v: $pkg.Ps }, { k: "S", v: $pkg.S }, { k: "Sc", v: $pkg.Sc }, { k: "Sk", v: $pkg.Sk }, { k: "Sm", v: $pkg.Sm }, { k: "So", v: $pkg.So }, { k: "Z", v: $pkg.Z }, { k: "Zl", v: $pkg.Zl }, { k: "Zp", v: $pkg.Zp }, { k: "Zs", v: $pkg.Zs }]);
		_Adlam = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(125184, 125258, 1), new Range32.ptr(125264, 125273, 1), new Range32.ptr(125278, 125279, 1)]), 0);
		_Ahom = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(71424, 71449, 1), new Range32.ptr(71453, 71467, 1), new Range32.ptr(71472, 71487, 1)]), 0);
		_Anatolian_Hieroglyphs = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(82944, 83526, 1)]), 0);
		_Arabic = new RangeTable.ptr(new sliceType([new Range16.ptr(1536, 1540, 1), new Range16.ptr(1542, 1547, 1), new Range16.ptr(1549, 1562, 1), new Range16.ptr(1566, 1566, 1), new Range16.ptr(1568, 1599, 1), new Range16.ptr(1601, 1610, 1), new Range16.ptr(1622, 1647, 1), new Range16.ptr(1649, 1756, 1), new Range16.ptr(1758, 1791, 1), new Range16.ptr(1872, 1919, 1), new Range16.ptr(2208, 2228, 1), new Range16.ptr(2230, 2237, 1), new Range16.ptr(2260, 2273, 1), new Range16.ptr(2275, 2303, 1), new Range16.ptr(64336, 64449, 1), new Range16.ptr(64467, 64829, 1), new Range16.ptr(64848, 64911, 1), new Range16.ptr(64914, 64967, 1), new Range16.ptr(65008, 65021, 1), new Range16.ptr(65136, 65140, 1), new Range16.ptr(65142, 65276, 1)]), new sliceType$1([new Range32.ptr(69216, 69246, 1), new Range32.ptr(126464, 126467, 1), new Range32.ptr(126469, 126495, 1), new Range32.ptr(126497, 126498, 1), new Range32.ptr(126500, 126500, 1), new Range32.ptr(126503, 126503, 1), new Range32.ptr(126505, 126514, 1), new Range32.ptr(126516, 126519, 1), new Range32.ptr(126521, 126521, 1), new Range32.ptr(126523, 126523, 1), new Range32.ptr(126530, 126530, 1), new Range32.ptr(126535, 126535, 1), new Range32.ptr(126537, 126537, 1), new Range32.ptr(126539, 126539, 1), new Range32.ptr(126541, 126543, 1), new Range32.ptr(126545, 126546, 1), new Range32.ptr(126548, 126548, 1), new Range32.ptr(126551, 126551, 1), new Range32.ptr(126553, 126553, 1), new Range32.ptr(126555, 126555, 1), new Range32.ptr(126557, 126557, 1), new Range32.ptr(126559, 126559, 1), new Range32.ptr(126561, 126562, 1), new Range32.ptr(126564, 126564, 1), new Range32.ptr(126567, 126570, 1), new Range32.ptr(126572, 126578, 1), new Range32.ptr(126580, 126583, 1), new Range32.ptr(126585, 126588, 1), new Range32.ptr(126590, 126590, 1), new Range32.ptr(126592, 126601, 1), new Range32.ptr(126603, 126619, 1), new Range32.ptr(126625, 126627, 1), new Range32.ptr(126629, 126633, 1), new Range32.ptr(126635, 126651, 1), new Range32.ptr(126704, 126705, 1)]), 0);
		_Armenian = new RangeTable.ptr(new sliceType([new Range16.ptr(1329, 1366, 1), new Range16.ptr(1369, 1375, 1), new Range16.ptr(1377, 1415, 1), new Range16.ptr(1418, 1418, 1), new Range16.ptr(1421, 1423, 1), new Range16.ptr(64275, 64279, 1)]), sliceType$1.nil, 0);
		_Avestan = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68352, 68405, 1), new Range32.ptr(68409, 68415, 1)]), 0);
		_Balinese = new RangeTable.ptr(new sliceType([new Range16.ptr(6912, 6987, 1), new Range16.ptr(6992, 7036, 1)]), sliceType$1.nil, 0);
		_Bamum = new RangeTable.ptr(new sliceType([new Range16.ptr(42656, 42743, 1)]), new sliceType$1([new Range32.ptr(92160, 92728, 1)]), 0);
		_Bassa_Vah = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(92880, 92909, 1), new Range32.ptr(92912, 92917, 1)]), 0);
		_Batak = new RangeTable.ptr(new sliceType([new Range16.ptr(7104, 7155, 1), new Range16.ptr(7164, 7167, 1)]), sliceType$1.nil, 0);
		_Bengali = new RangeTable.ptr(new sliceType([new Range16.ptr(2432, 2435, 1), new Range16.ptr(2437, 2444, 1), new Range16.ptr(2447, 2448, 1), new Range16.ptr(2451, 2472, 1), new Range16.ptr(2474, 2480, 1), new Range16.ptr(2482, 2482, 1), new Range16.ptr(2486, 2489, 1), new Range16.ptr(2492, 2500, 1), new Range16.ptr(2503, 2504, 1), new Range16.ptr(2507, 2510, 1), new Range16.ptr(2519, 2519, 1), new Range16.ptr(2524, 2525, 1), new Range16.ptr(2527, 2531, 1), new Range16.ptr(2534, 2555, 1)]), sliceType$1.nil, 0);
		_Bhaiksuki = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(72704, 72712, 1), new Range32.ptr(72714, 72758, 1), new Range32.ptr(72760, 72773, 1), new Range32.ptr(72784, 72812, 1)]), 0);
		_Bopomofo = new RangeTable.ptr(new sliceType([new Range16.ptr(746, 747, 1), new Range16.ptr(12549, 12589, 1), new Range16.ptr(12704, 12730, 1)]), sliceType$1.nil, 0);
		_Brahmi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(69632, 69709, 1), new Range32.ptr(69714, 69743, 1), new Range32.ptr(69759, 69759, 1)]), 0);
		_Braille = new RangeTable.ptr(new sliceType([new Range16.ptr(10240, 10495, 1)]), sliceType$1.nil, 0);
		_Buginese = new RangeTable.ptr(new sliceType([new Range16.ptr(6656, 6683, 1), new Range16.ptr(6686, 6687, 1)]), sliceType$1.nil, 0);
		_Buhid = new RangeTable.ptr(new sliceType([new Range16.ptr(5952, 5971, 1)]), sliceType$1.nil, 0);
		_Canadian_Aboriginal = new RangeTable.ptr(new sliceType([new Range16.ptr(5120, 5759, 1), new Range16.ptr(6320, 6389, 1)]), sliceType$1.nil, 0);
		_Carian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66208, 66256, 1)]), 0);
		_Caucasian_Albanian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66864, 66915, 1), new Range32.ptr(66927, 66927, 1)]), 0);
		_Chakma = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(69888, 69940, 1), new Range32.ptr(69942, 69955, 1)]), 0);
		_Cham = new RangeTable.ptr(new sliceType([new Range16.ptr(43520, 43574, 1), new Range16.ptr(43584, 43597, 1), new Range16.ptr(43600, 43609, 1), new Range16.ptr(43612, 43615, 1)]), sliceType$1.nil, 0);
		_Cherokee = new RangeTable.ptr(new sliceType([new Range16.ptr(5024, 5109, 1), new Range16.ptr(5112, 5117, 1), new Range16.ptr(43888, 43967, 1)]), sliceType$1.nil, 0);
		_Common = new RangeTable.ptr(new sliceType([new Range16.ptr(0, 64, 1), new Range16.ptr(91, 96, 1), new Range16.ptr(123, 169, 1), new Range16.ptr(171, 185, 1), new Range16.ptr(187, 191, 1), new Range16.ptr(215, 215, 1), new Range16.ptr(247, 247, 1), new Range16.ptr(697, 735, 1), new Range16.ptr(741, 745, 1), new Range16.ptr(748, 767, 1), new Range16.ptr(884, 884, 1), new Range16.ptr(894, 894, 1), new Range16.ptr(901, 901, 1), new Range16.ptr(903, 903, 1), new Range16.ptr(1417, 1417, 1), new Range16.ptr(1541, 1541, 1), new Range16.ptr(1548, 1548, 1), new Range16.ptr(1563, 1564, 1), new Range16.ptr(1567, 1567, 1), new Range16.ptr(1600, 1600, 1), new Range16.ptr(1757, 1757, 1), new Range16.ptr(2274, 2274, 1), new Range16.ptr(2404, 2405, 1), new Range16.ptr(3647, 3647, 1), new Range16.ptr(4053, 4056, 1), new Range16.ptr(4347, 4347, 1), new Range16.ptr(5867, 5869, 1), new Range16.ptr(5941, 5942, 1), new Range16.ptr(6146, 6147, 1), new Range16.ptr(6149, 6149, 1), new Range16.ptr(7379, 7379, 1), new Range16.ptr(7393, 7393, 1), new Range16.ptr(7401, 7404, 1), new Range16.ptr(7406, 7411, 1), new Range16.ptr(7413, 7414, 1), new Range16.ptr(8192, 8203, 1), new Range16.ptr(8206, 8292, 1), new Range16.ptr(8294, 8304, 1), new Range16.ptr(8308, 8318, 1), new Range16.ptr(8320, 8334, 1), new Range16.ptr(8352, 8382, 1), new Range16.ptr(8448, 8485, 1), new Range16.ptr(8487, 8489, 1), new Range16.ptr(8492, 8497, 1), new Range16.ptr(8499, 8525, 1), new Range16.ptr(8527, 8543, 1), new Range16.ptr(8585, 8587, 1), new Range16.ptr(8592, 9214, 1), new Range16.ptr(9216, 9254, 1), new Range16.ptr(9280, 9290, 1), new Range16.ptr(9312, 10239, 1), new Range16.ptr(10496, 11123, 1), new Range16.ptr(11126, 11157, 1), new Range16.ptr(11160, 11193, 1), new Range16.ptr(11197, 11208, 1), new Range16.ptr(11210, 11217, 1), new Range16.ptr(11244, 11247, 1), new Range16.ptr(11776, 11844, 1), new Range16.ptr(12272, 12283, 1), new Range16.ptr(12288, 12292, 1), new Range16.ptr(12294, 12294, 1), new Range16.ptr(12296, 12320, 1), new Range16.ptr(12336, 12343, 1), new Range16.ptr(12348, 12351, 1), new Range16.ptr(12443, 12444, 1), new Range16.ptr(12448, 12448, 1), new Range16.ptr(12539, 12540, 1), new Range16.ptr(12688, 12703, 1), new Range16.ptr(12736, 12771, 1), new Range16.ptr(12832, 12895, 1), new Range16.ptr(12927, 13007, 1), new Range16.ptr(13144, 13311, 1), new Range16.ptr(19904, 19967, 1), new Range16.ptr(42752, 42785, 1), new Range16.ptr(42888, 42890, 1), new Range16.ptr(43056, 43065, 1), new Range16.ptr(43310, 43310, 1), new Range16.ptr(43471, 43471, 1), new Range16.ptr(43867, 43867, 1), new Range16.ptr(64830, 64831, 1), new Range16.ptr(65040, 65049, 1), new Range16.ptr(65072, 65106, 1), new Range16.ptr(65108, 65126, 1), new Range16.ptr(65128, 65131, 1), new Range16.ptr(65279, 65279, 1), new Range16.ptr(65281, 65312, 1), new Range16.ptr(65339, 65344, 1), new Range16.ptr(65371, 65381, 1), new Range16.ptr(65392, 65392, 1), new Range16.ptr(65438, 65439, 1), new Range16.ptr(65504, 65510, 1), new Range16.ptr(65512, 65518, 1), new Range16.ptr(65529, 65533, 1)]), new sliceType$1([new Range32.ptr(65792, 65794, 1), new Range32.ptr(65799, 65843, 1), new Range32.ptr(65847, 65855, 1), new Range32.ptr(65936, 65947, 1), new Range32.ptr(66000, 66044, 1), new Range32.ptr(66273, 66299, 1), new Range32.ptr(113824, 113827, 1), new Range32.ptr(118784, 119029, 1), new Range32.ptr(119040, 119078, 1), new Range32.ptr(119081, 119142, 1), new Range32.ptr(119146, 119162, 1), new Range32.ptr(119171, 119172, 1), new Range32.ptr(119180, 119209, 1), new Range32.ptr(119214, 119272, 1), new Range32.ptr(119552, 119638, 1), new Range32.ptr(119648, 119665, 1), new Range32.ptr(119808, 119892, 1), new Range32.ptr(119894, 119964, 1), new Range32.ptr(119966, 119967, 1), new Range32.ptr(119970, 119970, 1), new Range32.ptr(119973, 119974, 1), new Range32.ptr(119977, 119980, 1), new Range32.ptr(119982, 119993, 1), new Range32.ptr(119995, 119995, 1), new Range32.ptr(119997, 120003, 1), new Range32.ptr(120005, 120069, 1), new Range32.ptr(120071, 120074, 1), new Range32.ptr(120077, 120084, 1), new Range32.ptr(120086, 120092, 1), new Range32.ptr(120094, 120121, 1), new Range32.ptr(120123, 120126, 1), new Range32.ptr(120128, 120132, 1), new Range32.ptr(120134, 120134, 1), new Range32.ptr(120138, 120144, 1), new Range32.ptr(120146, 120485, 1), new Range32.ptr(120488, 120779, 1), new Range32.ptr(120782, 120831, 1), new Range32.ptr(126976, 127019, 1), new Range32.ptr(127024, 127123, 1), new Range32.ptr(127136, 127150, 1), new Range32.ptr(127153, 127167, 1), new Range32.ptr(127169, 127183, 1), new Range32.ptr(127185, 127221, 1), new Range32.ptr(127232, 127244, 1), new Range32.ptr(127248, 127278, 1), new Range32.ptr(127280, 127339, 1), new Range32.ptr(127344, 127404, 1), new Range32.ptr(127462, 127487, 1), new Range32.ptr(127489, 127490, 1), new Range32.ptr(127504, 127547, 1), new Range32.ptr(127552, 127560, 1), new Range32.ptr(127568, 127569, 1), new Range32.ptr(127744, 128722, 1), new Range32.ptr(128736, 128748, 1), new Range32.ptr(128752, 128758, 1), new Range32.ptr(128768, 128883, 1), new Range32.ptr(128896, 128980, 1), new Range32.ptr(129024, 129035, 1), new Range32.ptr(129040, 129095, 1), new Range32.ptr(129104, 129113, 1), new Range32.ptr(129120, 129159, 1), new Range32.ptr(129168, 129197, 1), new Range32.ptr(129296, 129310, 1), new Range32.ptr(129312, 129319, 1), new Range32.ptr(129328, 129328, 1), new Range32.ptr(129331, 129342, 1), new Range32.ptr(129344, 129355, 1), new Range32.ptr(129360, 129374, 1), new Range32.ptr(129408, 129425, 1), new Range32.ptr(129472, 129472, 1), new Range32.ptr(917505, 917505, 1), new Range32.ptr(917536, 917631, 1)]), 7);
		_Coptic = new RangeTable.ptr(new sliceType([new Range16.ptr(994, 1007, 1), new Range16.ptr(11392, 11507, 1), new Range16.ptr(11513, 11519, 1)]), sliceType$1.nil, 0);
		_Cuneiform = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(73728, 74649, 1), new Range32.ptr(74752, 74862, 1), new Range32.ptr(74864, 74868, 1), new Range32.ptr(74880, 75075, 1)]), 0);
		_Cypriot = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67584, 67589, 1), new Range32.ptr(67592, 67592, 1), new Range32.ptr(67594, 67637, 1), new Range32.ptr(67639, 67640, 1), new Range32.ptr(67644, 67644, 1), new Range32.ptr(67647, 67647, 1)]), 0);
		_Cyrillic = new RangeTable.ptr(new sliceType([new Range16.ptr(1024, 1156, 1), new Range16.ptr(1159, 1327, 1), new Range16.ptr(7296, 7304, 1), new Range16.ptr(7467, 7467, 1), new Range16.ptr(7544, 7544, 1), new Range16.ptr(11744, 11775, 1), new Range16.ptr(42560, 42655, 1), new Range16.ptr(65070, 65071, 1)]), sliceType$1.nil, 0);
		_Deseret = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66560, 66639, 1)]), 0);
		_Devanagari = new RangeTable.ptr(new sliceType([new Range16.ptr(2304, 2384, 1), new Range16.ptr(2387, 2403, 1), new Range16.ptr(2406, 2431, 1), new Range16.ptr(43232, 43261, 1)]), sliceType$1.nil, 0);
		_Duployan = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(113664, 113770, 1), new Range32.ptr(113776, 113788, 1), new Range32.ptr(113792, 113800, 1), new Range32.ptr(113808, 113817, 1), new Range32.ptr(113820, 113823, 1)]), 0);
		_Egyptian_Hieroglyphs = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(77824, 78894, 1)]), 0);
		_Elbasan = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66816, 66855, 1)]), 0);
		_Ethiopic = new RangeTable.ptr(new sliceType([new Range16.ptr(4608, 4680, 1), new Range16.ptr(4682, 4685, 1), new Range16.ptr(4688, 4694, 1), new Range16.ptr(4696, 4696, 1), new Range16.ptr(4698, 4701, 1), new Range16.ptr(4704, 4744, 1), new Range16.ptr(4746, 4749, 1), new Range16.ptr(4752, 4784, 1), new Range16.ptr(4786, 4789, 1), new Range16.ptr(4792, 4798, 1), new Range16.ptr(4800, 4800, 1), new Range16.ptr(4802, 4805, 1), new Range16.ptr(4808, 4822, 1), new Range16.ptr(4824, 4880, 1), new Range16.ptr(4882, 4885, 1), new Range16.ptr(4888, 4954, 1), new Range16.ptr(4957, 4988, 1), new Range16.ptr(4992, 5017, 1), new Range16.ptr(11648, 11670, 1), new Range16.ptr(11680, 11686, 1), new Range16.ptr(11688, 11694, 1), new Range16.ptr(11696, 11702, 1), new Range16.ptr(11704, 11710, 1), new Range16.ptr(11712, 11718, 1), new Range16.ptr(11720, 11726, 1), new Range16.ptr(11728, 11734, 1), new Range16.ptr(11736, 11742, 1), new Range16.ptr(43777, 43782, 1), new Range16.ptr(43785, 43790, 1), new Range16.ptr(43793, 43798, 1), new Range16.ptr(43808, 43814, 1), new Range16.ptr(43816, 43822, 1)]), sliceType$1.nil, 0);
		_Georgian = new RangeTable.ptr(new sliceType([new Range16.ptr(4256, 4293, 1), new Range16.ptr(4295, 4295, 1), new Range16.ptr(4301, 4301, 1), new Range16.ptr(4304, 4346, 1), new Range16.ptr(4348, 4351, 1), new Range16.ptr(11520, 11557, 1), new Range16.ptr(11559, 11559, 1), new Range16.ptr(11565, 11565, 1)]), sliceType$1.nil, 0);
		_Glagolitic = new RangeTable.ptr(new sliceType([new Range16.ptr(11264, 11310, 1), new Range16.ptr(11312, 11358, 1)]), new sliceType$1([new Range32.ptr(122880, 122886, 1), new Range32.ptr(122888, 122904, 1), new Range32.ptr(122907, 122913, 1), new Range32.ptr(122915, 122916, 1), new Range32.ptr(122918, 122922, 1)]), 0);
		_Gothic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66352, 66378, 1)]), 0);
		_Grantha = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70400, 70403, 1), new Range32.ptr(70405, 70412, 1), new Range32.ptr(70415, 70416, 1), new Range32.ptr(70419, 70440, 1), new Range32.ptr(70442, 70448, 1), new Range32.ptr(70450, 70451, 1), new Range32.ptr(70453, 70457, 1), new Range32.ptr(70460, 70468, 1), new Range32.ptr(70471, 70472, 1), new Range32.ptr(70475, 70477, 1), new Range32.ptr(70480, 70480, 1), new Range32.ptr(70487, 70487, 1), new Range32.ptr(70493, 70499, 1), new Range32.ptr(70502, 70508, 1), new Range32.ptr(70512, 70516, 1)]), 0);
		_Greek = new RangeTable.ptr(new sliceType([new Range16.ptr(880, 883, 1), new Range16.ptr(885, 887, 1), new Range16.ptr(890, 893, 1), new Range16.ptr(895, 895, 1), new Range16.ptr(900, 900, 1), new Range16.ptr(902, 902, 1), new Range16.ptr(904, 906, 1), new Range16.ptr(908, 908, 1), new Range16.ptr(910, 929, 1), new Range16.ptr(931, 993, 1), new Range16.ptr(1008, 1023, 1), new Range16.ptr(7462, 7466, 1), new Range16.ptr(7517, 7521, 1), new Range16.ptr(7526, 7530, 1), new Range16.ptr(7615, 7615, 1), new Range16.ptr(7936, 7957, 1), new Range16.ptr(7960, 7965, 1), new Range16.ptr(7968, 8005, 1), new Range16.ptr(8008, 8013, 1), new Range16.ptr(8016, 8023, 1), new Range16.ptr(8025, 8025, 1), new Range16.ptr(8027, 8027, 1), new Range16.ptr(8029, 8029, 1), new Range16.ptr(8031, 8061, 1), new Range16.ptr(8064, 8116, 1), new Range16.ptr(8118, 8132, 1), new Range16.ptr(8134, 8147, 1), new Range16.ptr(8150, 8155, 1), new Range16.ptr(8157, 8175, 1), new Range16.ptr(8178, 8180, 1), new Range16.ptr(8182, 8190, 1), new Range16.ptr(8486, 8486, 1), new Range16.ptr(43877, 43877, 1)]), new sliceType$1([new Range32.ptr(65856, 65934, 1), new Range32.ptr(65952, 65952, 1), new Range32.ptr(119296, 119365, 1)]), 0);
		_Gujarati = new RangeTable.ptr(new sliceType([new Range16.ptr(2689, 2691, 1), new Range16.ptr(2693, 2701, 1), new Range16.ptr(2703, 2705, 1), new Range16.ptr(2707, 2728, 1), new Range16.ptr(2730, 2736, 1), new Range16.ptr(2738, 2739, 1), new Range16.ptr(2741, 2745, 1), new Range16.ptr(2748, 2757, 1), new Range16.ptr(2759, 2761, 1), new Range16.ptr(2763, 2765, 1), new Range16.ptr(2768, 2768, 1), new Range16.ptr(2784, 2787, 1), new Range16.ptr(2790, 2801, 1), new Range16.ptr(2809, 2809, 1)]), sliceType$1.nil, 0);
		_Gurmukhi = new RangeTable.ptr(new sliceType([new Range16.ptr(2561, 2563, 1), new Range16.ptr(2565, 2570, 1), new Range16.ptr(2575, 2576, 1), new Range16.ptr(2579, 2600, 1), new Range16.ptr(2602, 2608, 1), new Range16.ptr(2610, 2611, 1), new Range16.ptr(2613, 2614, 1), new Range16.ptr(2616, 2617, 1), new Range16.ptr(2620, 2620, 1), new Range16.ptr(2622, 2626, 1), new Range16.ptr(2631, 2632, 1), new Range16.ptr(2635, 2637, 1), new Range16.ptr(2641, 2641, 1), new Range16.ptr(2649, 2652, 1), new Range16.ptr(2654, 2654, 1), new Range16.ptr(2662, 2677, 1)]), sliceType$1.nil, 0);
		_Han = new RangeTable.ptr(new sliceType([new Range16.ptr(11904, 11929, 1), new Range16.ptr(11931, 12019, 1), new Range16.ptr(12032, 12245, 1), new Range16.ptr(12293, 12293, 1), new Range16.ptr(12295, 12295, 1), new Range16.ptr(12321, 12329, 1), new Range16.ptr(12344, 12347, 1), new Range16.ptr(13312, 19893, 1), new Range16.ptr(19968, 40917, 1), new Range16.ptr(63744, 64109, 1), new Range16.ptr(64112, 64217, 1)]), new sliceType$1([new Range32.ptr(131072, 173782, 1), new Range32.ptr(173824, 177972, 1), new Range32.ptr(177984, 178205, 1), new Range32.ptr(178208, 183969, 1), new Range32.ptr(194560, 195101, 1)]), 0);
		_Hangul = new RangeTable.ptr(new sliceType([new Range16.ptr(4352, 4607, 1), new Range16.ptr(12334, 12335, 1), new Range16.ptr(12593, 12686, 1), new Range16.ptr(12800, 12830, 1), new Range16.ptr(12896, 12926, 1), new Range16.ptr(43360, 43388, 1), new Range16.ptr(44032, 55203, 1), new Range16.ptr(55216, 55238, 1), new Range16.ptr(55243, 55291, 1), new Range16.ptr(65440, 65470, 1), new Range16.ptr(65474, 65479, 1), new Range16.ptr(65482, 65487, 1), new Range16.ptr(65490, 65495, 1), new Range16.ptr(65498, 65500, 1)]), sliceType$1.nil, 0);
		_Hanunoo = new RangeTable.ptr(new sliceType([new Range16.ptr(5920, 5940, 1)]), sliceType$1.nil, 0);
		_Hatran = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67808, 67826, 1), new Range32.ptr(67828, 67829, 1), new Range32.ptr(67835, 67839, 1)]), 0);
		_Hebrew = new RangeTable.ptr(new sliceType([new Range16.ptr(1425, 1479, 1), new Range16.ptr(1488, 1514, 1), new Range16.ptr(1520, 1524, 1), new Range16.ptr(64285, 64310, 1), new Range16.ptr(64312, 64316, 1), new Range16.ptr(64318, 64318, 1), new Range16.ptr(64320, 64321, 1), new Range16.ptr(64323, 64324, 1), new Range16.ptr(64326, 64335, 1)]), sliceType$1.nil, 0);
		_Hiragana = new RangeTable.ptr(new sliceType([new Range16.ptr(12353, 12438, 1), new Range16.ptr(12445, 12447, 1)]), new sliceType$1([new Range32.ptr(110593, 110593, 1), new Range32.ptr(127488, 127488, 1)]), 0);
		_Imperial_Aramaic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67648, 67669, 1), new Range32.ptr(67671, 67679, 1)]), 0);
		_Inherited = new RangeTable.ptr(new sliceType([new Range16.ptr(768, 879, 1), new Range16.ptr(1157, 1158, 1), new Range16.ptr(1611, 1621, 1), new Range16.ptr(1648, 1648, 1), new Range16.ptr(2385, 2386, 1), new Range16.ptr(6832, 6846, 1), new Range16.ptr(7376, 7378, 1), new Range16.ptr(7380, 7392, 1), new Range16.ptr(7394, 7400, 1), new Range16.ptr(7405, 7405, 1), new Range16.ptr(7412, 7412, 1), new Range16.ptr(7416, 7417, 1), new Range16.ptr(7616, 7669, 1), new Range16.ptr(7675, 7679, 1), new Range16.ptr(8204, 8205, 1), new Range16.ptr(8400, 8432, 1), new Range16.ptr(12330, 12333, 1), new Range16.ptr(12441, 12442, 1), new Range16.ptr(65024, 65039, 1), new Range16.ptr(65056, 65069, 1)]), new sliceType$1([new Range32.ptr(66045, 66045, 1), new Range32.ptr(66272, 66272, 1), new Range32.ptr(119143, 119145, 1), new Range32.ptr(119163, 119170, 1), new Range32.ptr(119173, 119179, 1), new Range32.ptr(119210, 119213, 1), new Range32.ptr(917760, 917999, 1)]), 0);
		_Inscriptional_Pahlavi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68448, 68466, 1), new Range32.ptr(68472, 68479, 1)]), 0);
		_Inscriptional_Parthian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68416, 68437, 1), new Range32.ptr(68440, 68447, 1)]), 0);
		_Javanese = new RangeTable.ptr(new sliceType([new Range16.ptr(43392, 43469, 1), new Range16.ptr(43472, 43481, 1), new Range16.ptr(43486, 43487, 1)]), sliceType$1.nil, 0);
		_Kaithi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(69760, 69825, 1)]), 0);
		_Kannada = new RangeTable.ptr(new sliceType([new Range16.ptr(3200, 3203, 1), new Range16.ptr(3205, 3212, 1), new Range16.ptr(3214, 3216, 1), new Range16.ptr(3218, 3240, 1), new Range16.ptr(3242, 3251, 1), new Range16.ptr(3253, 3257, 1), new Range16.ptr(3260, 3268, 1), new Range16.ptr(3270, 3272, 1), new Range16.ptr(3274, 3277, 1), new Range16.ptr(3285, 3286, 1), new Range16.ptr(3294, 3294, 1), new Range16.ptr(3296, 3299, 1), new Range16.ptr(3302, 3311, 1), new Range16.ptr(3313, 3314, 1)]), sliceType$1.nil, 0);
		_Katakana = new RangeTable.ptr(new sliceType([new Range16.ptr(12449, 12538, 1), new Range16.ptr(12541, 12543, 1), new Range16.ptr(12784, 12799, 1), new Range16.ptr(13008, 13054, 1), new Range16.ptr(13056, 13143, 1), new Range16.ptr(65382, 65391, 1), new Range16.ptr(65393, 65437, 1)]), new sliceType$1([new Range32.ptr(110592, 110592, 1)]), 0);
		_Kayah_Li = new RangeTable.ptr(new sliceType([new Range16.ptr(43264, 43309, 1), new Range16.ptr(43311, 43311, 1)]), sliceType$1.nil, 0);
		_Kharoshthi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68096, 68099, 1), new Range32.ptr(68101, 68102, 1), new Range32.ptr(68108, 68115, 1), new Range32.ptr(68117, 68119, 1), new Range32.ptr(68121, 68147, 1), new Range32.ptr(68152, 68154, 1), new Range32.ptr(68159, 68167, 1), new Range32.ptr(68176, 68184, 1)]), 0);
		_Khmer = new RangeTable.ptr(new sliceType([new Range16.ptr(6016, 6109, 1), new Range16.ptr(6112, 6121, 1), new Range16.ptr(6128, 6137, 1), new Range16.ptr(6624, 6655, 1)]), sliceType$1.nil, 0);
		_Khojki = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70144, 70161, 1), new Range32.ptr(70163, 70206, 1)]), 0);
		_Khudawadi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70320, 70378, 1), new Range32.ptr(70384, 70393, 1)]), 0);
		_Lao = new RangeTable.ptr(new sliceType([new Range16.ptr(3713, 3714, 1), new Range16.ptr(3716, 3716, 1), new Range16.ptr(3719, 3720, 1), new Range16.ptr(3722, 3722, 1), new Range16.ptr(3725, 3725, 1), new Range16.ptr(3732, 3735, 1), new Range16.ptr(3737, 3743, 1), new Range16.ptr(3745, 3747, 1), new Range16.ptr(3749, 3749, 1), new Range16.ptr(3751, 3751, 1), new Range16.ptr(3754, 3755, 1), new Range16.ptr(3757, 3769, 1), new Range16.ptr(3771, 3773, 1), new Range16.ptr(3776, 3780, 1), new Range16.ptr(3782, 3782, 1), new Range16.ptr(3784, 3789, 1), new Range16.ptr(3792, 3801, 1), new Range16.ptr(3804, 3807, 1)]), sliceType$1.nil, 0);
		_Latin = new RangeTable.ptr(new sliceType([new Range16.ptr(65, 90, 1), new Range16.ptr(97, 122, 1), new Range16.ptr(170, 170, 1), new Range16.ptr(186, 186, 1), new Range16.ptr(192, 214, 1), new Range16.ptr(216, 246, 1), new Range16.ptr(248, 696, 1), new Range16.ptr(736, 740, 1), new Range16.ptr(7424, 7461, 1), new Range16.ptr(7468, 7516, 1), new Range16.ptr(7522, 7525, 1), new Range16.ptr(7531, 7543, 1), new Range16.ptr(7545, 7614, 1), new Range16.ptr(7680, 7935, 1), new Range16.ptr(8305, 8305, 1), new Range16.ptr(8319, 8319, 1), new Range16.ptr(8336, 8348, 1), new Range16.ptr(8490, 8491, 1), new Range16.ptr(8498, 8498, 1), new Range16.ptr(8526, 8526, 1), new Range16.ptr(8544, 8584, 1), new Range16.ptr(11360, 11391, 1), new Range16.ptr(42786, 42887, 1), new Range16.ptr(42891, 42926, 1), new Range16.ptr(42928, 42935, 1), new Range16.ptr(42999, 43007, 1), new Range16.ptr(43824, 43866, 1), new Range16.ptr(43868, 43876, 1), new Range16.ptr(64256, 64262, 1), new Range16.ptr(65313, 65338, 1), new Range16.ptr(65345, 65370, 1)]), sliceType$1.nil, 6);
		_Lepcha = new RangeTable.ptr(new sliceType([new Range16.ptr(7168, 7223, 1), new Range16.ptr(7227, 7241, 1), new Range16.ptr(7245, 7247, 1)]), sliceType$1.nil, 0);
		_Limbu = new RangeTable.ptr(new sliceType([new Range16.ptr(6400, 6430, 1), new Range16.ptr(6432, 6443, 1), new Range16.ptr(6448, 6459, 1), new Range16.ptr(6464, 6464, 1), new Range16.ptr(6468, 6479, 1)]), sliceType$1.nil, 0);
		_Linear_A = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67072, 67382, 1), new Range32.ptr(67392, 67413, 1), new Range32.ptr(67424, 67431, 1)]), 0);
		_Linear_B = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(65536, 65547, 1), new Range32.ptr(65549, 65574, 1), new Range32.ptr(65576, 65594, 1), new Range32.ptr(65596, 65597, 1), new Range32.ptr(65599, 65613, 1), new Range32.ptr(65616, 65629, 1), new Range32.ptr(65664, 65786, 1)]), 0);
		_Lisu = new RangeTable.ptr(new sliceType([new Range16.ptr(42192, 42239, 1)]), sliceType$1.nil, 0);
		_Lycian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66176, 66204, 1)]), 0);
		_Lydian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67872, 67897, 1), new Range32.ptr(67903, 67903, 1)]), 0);
		_Mahajani = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(69968, 70006, 1)]), 0);
		_Malayalam = new RangeTable.ptr(new sliceType([new Range16.ptr(3329, 3331, 1), new Range16.ptr(3333, 3340, 1), new Range16.ptr(3342, 3344, 1), new Range16.ptr(3346, 3386, 1), new Range16.ptr(3389, 3396, 1), new Range16.ptr(3398, 3400, 1), new Range16.ptr(3402, 3407, 1), new Range16.ptr(3412, 3427, 1), new Range16.ptr(3430, 3455, 1)]), sliceType$1.nil, 0);
		_Mandaic = new RangeTable.ptr(new sliceType([new Range16.ptr(2112, 2139, 1), new Range16.ptr(2142, 2142, 1)]), sliceType$1.nil, 0);
		_Manichaean = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68288, 68326, 1), new Range32.ptr(68331, 68342, 1)]), 0);
		_Marchen = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(72816, 72847, 1), new Range32.ptr(72850, 72871, 1), new Range32.ptr(72873, 72886, 1)]), 0);
		_Meetei_Mayek = new RangeTable.ptr(new sliceType([new Range16.ptr(43744, 43766, 1), new Range16.ptr(43968, 44013, 1), new Range16.ptr(44016, 44025, 1)]), sliceType$1.nil, 0);
		_Mende_Kikakui = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(124928, 125124, 1), new Range32.ptr(125127, 125142, 1)]), 0);
		_Meroitic_Cursive = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68000, 68023, 1), new Range32.ptr(68028, 68047, 1), new Range32.ptr(68050, 68095, 1)]), 0);
		_Meroitic_Hieroglyphs = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67968, 67999, 1)]), 0);
		_Miao = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(93952, 94020, 1), new Range32.ptr(94032, 94078, 1), new Range32.ptr(94095, 94111, 1)]), 0);
		_Modi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(71168, 71236, 1), new Range32.ptr(71248, 71257, 1)]), 0);
		_Mongolian = new RangeTable.ptr(new sliceType([new Range16.ptr(6144, 6145, 1), new Range16.ptr(6148, 6148, 1), new Range16.ptr(6150, 6158, 1), new Range16.ptr(6160, 6169, 1), new Range16.ptr(6176, 6263, 1), new Range16.ptr(6272, 6314, 1)]), new sliceType$1([new Range32.ptr(71264, 71276, 1)]), 0);
		_Mro = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(92736, 92766, 1), new Range32.ptr(92768, 92777, 1), new Range32.ptr(92782, 92783, 1)]), 0);
		_Multani = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70272, 70278, 1), new Range32.ptr(70280, 70280, 1), new Range32.ptr(70282, 70285, 1), new Range32.ptr(70287, 70301, 1), new Range32.ptr(70303, 70313, 1)]), 0);
		_Myanmar = new RangeTable.ptr(new sliceType([new Range16.ptr(4096, 4255, 1), new Range16.ptr(43488, 43518, 1), new Range16.ptr(43616, 43647, 1)]), sliceType$1.nil, 0);
		_Nabataean = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67712, 67742, 1), new Range32.ptr(67751, 67759, 1)]), 0);
		_New_Tai_Lue = new RangeTable.ptr(new sliceType([new Range16.ptr(6528, 6571, 1), new Range16.ptr(6576, 6601, 1), new Range16.ptr(6608, 6618, 1), new Range16.ptr(6622, 6623, 1)]), sliceType$1.nil, 0);
		_Newa = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70656, 70745, 1), new Range32.ptr(70747, 70747, 1), new Range32.ptr(70749, 70749, 1)]), 0);
		_Nko = new RangeTable.ptr(new sliceType([new Range16.ptr(1984, 2042, 1)]), sliceType$1.nil, 0);
		_Ogham = new RangeTable.ptr(new sliceType([new Range16.ptr(5760, 5788, 1)]), sliceType$1.nil, 0);
		_Ol_Chiki = new RangeTable.ptr(new sliceType([new Range16.ptr(7248, 7295, 1)]), sliceType$1.nil, 0);
		_Old_Hungarian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68736, 68786, 1), new Range32.ptr(68800, 68850, 1), new Range32.ptr(68858, 68863, 1)]), 0);
		_Old_Italic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66304, 66339, 1)]), 0);
		_Old_North_Arabian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68224, 68255, 1)]), 0);
		_Old_Permic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66384, 66426, 1)]), 0);
		_Old_Persian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66464, 66499, 1), new Range32.ptr(66504, 66517, 1)]), 0);
		_Old_South_Arabian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68192, 68223, 1)]), 0);
		_Old_Turkic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68608, 68680, 1)]), 0);
		_Oriya = new RangeTable.ptr(new sliceType([new Range16.ptr(2817, 2819, 1), new Range16.ptr(2821, 2828, 1), new Range16.ptr(2831, 2832, 1), new Range16.ptr(2835, 2856, 1), new Range16.ptr(2858, 2864, 1), new Range16.ptr(2866, 2867, 1), new Range16.ptr(2869, 2873, 1), new Range16.ptr(2876, 2884, 1), new Range16.ptr(2887, 2888, 1), new Range16.ptr(2891, 2893, 1), new Range16.ptr(2902, 2903, 1), new Range16.ptr(2908, 2909, 1), new Range16.ptr(2911, 2915, 1), new Range16.ptr(2918, 2935, 1)]), sliceType$1.nil, 0);
		_Osage = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66736, 66771, 1), new Range32.ptr(66776, 66811, 1)]), 0);
		_Osmanya = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66688, 66717, 1), new Range32.ptr(66720, 66729, 1)]), 0);
		_Pahawh_Hmong = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(92928, 92997, 1), new Range32.ptr(93008, 93017, 1), new Range32.ptr(93019, 93025, 1), new Range32.ptr(93027, 93047, 1), new Range32.ptr(93053, 93071, 1)]), 0);
		_Palmyrene = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67680, 67711, 1)]), 0);
		_Pau_Cin_Hau = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(72384, 72440, 1)]), 0);
		_Phags_Pa = new RangeTable.ptr(new sliceType([new Range16.ptr(43072, 43127, 1)]), sliceType$1.nil, 0);
		_Phoenician = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67840, 67867, 1), new Range32.ptr(67871, 67871, 1)]), 0);
		_Psalter_Pahlavi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68480, 68497, 1), new Range32.ptr(68505, 68508, 1), new Range32.ptr(68521, 68527, 1)]), 0);
		_Rejang = new RangeTable.ptr(new sliceType([new Range16.ptr(43312, 43347, 1), new Range16.ptr(43359, 43359, 1)]), sliceType$1.nil, 0);
		_Runic = new RangeTable.ptr(new sliceType([new Range16.ptr(5792, 5866, 1), new Range16.ptr(5870, 5880, 1)]), sliceType$1.nil, 0);
		_Samaritan = new RangeTable.ptr(new sliceType([new Range16.ptr(2048, 2093, 1), new Range16.ptr(2096, 2110, 1)]), sliceType$1.nil, 0);
		_Saurashtra = new RangeTable.ptr(new sliceType([new Range16.ptr(43136, 43205, 1), new Range16.ptr(43214, 43225, 1)]), sliceType$1.nil, 0);
		_Sharada = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70016, 70093, 1), new Range32.ptr(70096, 70111, 1)]), 0);
		_Shavian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66640, 66687, 1)]), 0);
		_Siddham = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(71040, 71093, 1), new Range32.ptr(71096, 71133, 1)]), 0);
		_SignWriting = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(120832, 121483, 1), new Range32.ptr(121499, 121503, 1), new Range32.ptr(121505, 121519, 1)]), 0);
		_Sinhala = new RangeTable.ptr(new sliceType([new Range16.ptr(3458, 3459, 1), new Range16.ptr(3461, 3478, 1), new Range16.ptr(3482, 3505, 1), new Range16.ptr(3507, 3515, 1), new Range16.ptr(3517, 3517, 1), new Range16.ptr(3520, 3526, 1), new Range16.ptr(3530, 3530, 1), new Range16.ptr(3535, 3540, 1), new Range16.ptr(3542, 3542, 1), new Range16.ptr(3544, 3551, 1), new Range16.ptr(3558, 3567, 1), new Range16.ptr(3570, 3572, 1)]), new sliceType$1([new Range32.ptr(70113, 70132, 1)]), 0);
		_Sora_Sompeng = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(69840, 69864, 1), new Range32.ptr(69872, 69881, 1)]), 0);
		_Sundanese = new RangeTable.ptr(new sliceType([new Range16.ptr(7040, 7103, 1), new Range16.ptr(7360, 7367, 1)]), sliceType$1.nil, 0);
		_Syloti_Nagri = new RangeTable.ptr(new sliceType([new Range16.ptr(43008, 43051, 1)]), sliceType$1.nil, 0);
		_Syriac = new RangeTable.ptr(new sliceType([new Range16.ptr(1792, 1805, 1), new Range16.ptr(1807, 1866, 1), new Range16.ptr(1869, 1871, 1)]), sliceType$1.nil, 0);
		_Tagalog = new RangeTable.ptr(new sliceType([new Range16.ptr(5888, 5900, 1), new Range16.ptr(5902, 5908, 1)]), sliceType$1.nil, 0);
		_Tagbanwa = new RangeTable.ptr(new sliceType([new Range16.ptr(5984, 5996, 1), new Range16.ptr(5998, 6000, 1), new Range16.ptr(6002, 6003, 1)]), sliceType$1.nil, 0);
		_Tai_Le = new RangeTable.ptr(new sliceType([new Range16.ptr(6480, 6509, 1), new Range16.ptr(6512, 6516, 1)]), sliceType$1.nil, 0);
		_Tai_Tham = new RangeTable.ptr(new sliceType([new Range16.ptr(6688, 6750, 1), new Range16.ptr(6752, 6780, 1), new Range16.ptr(6783, 6793, 1), new Range16.ptr(6800, 6809, 1), new Range16.ptr(6816, 6829, 1)]), sliceType$1.nil, 0);
		_Tai_Viet = new RangeTable.ptr(new sliceType([new Range16.ptr(43648, 43714, 1), new Range16.ptr(43739, 43743, 1)]), sliceType$1.nil, 0);
		_Takri = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(71296, 71351, 1), new Range32.ptr(71360, 71369, 1)]), 0);
		_Tamil = new RangeTable.ptr(new sliceType([new Range16.ptr(2946, 2947, 1), new Range16.ptr(2949, 2954, 1), new Range16.ptr(2958, 2960, 1), new Range16.ptr(2962, 2965, 1), new Range16.ptr(2969, 2970, 1), new Range16.ptr(2972, 2972, 1), new Range16.ptr(2974, 2975, 1), new Range16.ptr(2979, 2980, 1), new Range16.ptr(2984, 2986, 1), new Range16.ptr(2990, 3001, 1), new Range16.ptr(3006, 3010, 1), new Range16.ptr(3014, 3016, 1), new Range16.ptr(3018, 3021, 1), new Range16.ptr(3024, 3024, 1), new Range16.ptr(3031, 3031, 1), new Range16.ptr(3046, 3066, 1)]), sliceType$1.nil, 0);
		_Tangut = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(94176, 94176, 1), new Range32.ptr(94208, 100332, 1), new Range32.ptr(100352, 101106, 1)]), 0);
		_Telugu = new RangeTable.ptr(new sliceType([new Range16.ptr(3072, 3075, 1), new Range16.ptr(3077, 3084, 1), new Range16.ptr(3086, 3088, 1), new Range16.ptr(3090, 3112, 1), new Range16.ptr(3114, 3129, 1), new Range16.ptr(3133, 3140, 1), new Range16.ptr(3142, 3144, 1), new Range16.ptr(3146, 3149, 1), new Range16.ptr(3157, 3158, 1), new Range16.ptr(3160, 3162, 1), new Range16.ptr(3168, 3171, 1), new Range16.ptr(3174, 3183, 1), new Range16.ptr(3192, 3199, 1)]), sliceType$1.nil, 0);
		_Thaana = new RangeTable.ptr(new sliceType([new Range16.ptr(1920, 1969, 1)]), sliceType$1.nil, 0);
		_Thai = new RangeTable.ptr(new sliceType([new Range16.ptr(3585, 3642, 1), new Range16.ptr(3648, 3675, 1)]), sliceType$1.nil, 0);
		_Tibetan = new RangeTable.ptr(new sliceType([new Range16.ptr(3840, 3911, 1), new Range16.ptr(3913, 3948, 1), new Range16.ptr(3953, 3991, 1), new Range16.ptr(3993, 4028, 1), new Range16.ptr(4030, 4044, 1), new Range16.ptr(4046, 4052, 1), new Range16.ptr(4057, 4058, 1)]), sliceType$1.nil, 0);
		_Tifinagh = new RangeTable.ptr(new sliceType([new Range16.ptr(11568, 11623, 1), new Range16.ptr(11631, 11632, 1), new Range16.ptr(11647, 11647, 1)]), sliceType$1.nil, 0);
		_Tirhuta = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70784, 70855, 1), new Range32.ptr(70864, 70873, 1)]), 0);
		_Ugaritic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66432, 66461, 1), new Range32.ptr(66463, 66463, 1)]), 0);
		_Vai = new RangeTable.ptr(new sliceType([new Range16.ptr(42240, 42539, 1)]), sliceType$1.nil, 0);
		_Warang_Citi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(71840, 71922, 1), new Range32.ptr(71935, 71935, 1)]), 0);
		_Yi = new RangeTable.ptr(new sliceType([new Range16.ptr(40960, 42124, 1), new Range16.ptr(42128, 42182, 1)]), sliceType$1.nil, 0);
		$pkg.Adlam = _Adlam;
		$pkg.Ahom = _Ahom;
		$pkg.Anatolian_Hieroglyphs = _Anatolian_Hieroglyphs;
		$pkg.Arabic = _Arabic;
		$pkg.Armenian = _Armenian;
		$pkg.Avestan = _Avestan;
		$pkg.Balinese = _Balinese;
		$pkg.Bamum = _Bamum;
		$pkg.Bassa_Vah = _Bassa_Vah;
		$pkg.Batak = _Batak;
		$pkg.Bengali = _Bengali;
		$pkg.Bhaiksuki = _Bhaiksuki;
		$pkg.Bopomofo = _Bopomofo;
		$pkg.Brahmi = _Brahmi;
		$pkg.Braille = _Braille;
		$pkg.Buginese = _Buginese;
		$pkg.Buhid = _Buhid;
		$pkg.Canadian_Aboriginal = _Canadian_Aboriginal;
		$pkg.Carian = _Carian;
		$pkg.Caucasian_Albanian = _Caucasian_Albanian;
		$pkg.Chakma = _Chakma;
		$pkg.Cham = _Cham;
		$pkg.Cherokee = _Cherokee;
		$pkg.Common = _Common;
		$pkg.Coptic = _Coptic;
		$pkg.Cuneiform = _Cuneiform;
		$pkg.Cypriot = _Cypriot;
		$pkg.Cyrillic = _Cyrillic;
		$pkg.Deseret = _Deseret;
		$pkg.Devanagari = _Devanagari;
		$pkg.Duployan = _Duployan;
		$pkg.Egyptian_Hieroglyphs = _Egyptian_Hieroglyphs;
		$pkg.Elbasan = _Elbasan;
		$pkg.Ethiopic = _Ethiopic;
		$pkg.Georgian = _Georgian;
		$pkg.Glagolitic = _Glagolitic;
		$pkg.Gothic = _Gothic;
		$pkg.Grantha = _Grantha;
		$pkg.Greek = _Greek;
		$pkg.Gujarati = _Gujarati;
		$pkg.Gurmukhi = _Gurmukhi;
		$pkg.Han = _Han;
		$pkg.Hangul = _Hangul;
		$pkg.Hanunoo = _Hanunoo;
		$pkg.Hatran = _Hatran;
		$pkg.Hebrew = _Hebrew;
		$pkg.Hiragana = _Hiragana;
		$pkg.Imperial_Aramaic = _Imperial_Aramaic;
		$pkg.Inherited = _Inherited;
		$pkg.Inscriptional_Pahlavi = _Inscriptional_Pahlavi;
		$pkg.Inscriptional_Parthian = _Inscriptional_Parthian;
		$pkg.Javanese = _Javanese;
		$pkg.Kaithi = _Kaithi;
		$pkg.Kannada = _Kannada;
		$pkg.Katakana = _Katakana;
		$pkg.Kayah_Li = _Kayah_Li;
		$pkg.Kharoshthi = _Kharoshthi;
		$pkg.Khmer = _Khmer;
		$pkg.Khojki = _Khojki;
		$pkg.Khudawadi = _Khudawadi;
		$pkg.Lao = _Lao;
		$pkg.Latin = _Latin;
		$pkg.Lepcha = _Lepcha;
		$pkg.Limbu = _Limbu;
		$pkg.Linear_A = _Linear_A;
		$pkg.Linear_B = _Linear_B;
		$pkg.Lisu = _Lisu;
		$pkg.Lycian = _Lycian;
		$pkg.Lydian = _Lydian;
		$pkg.Mahajani = _Mahajani;
		$pkg.Malayalam = _Malayalam;
		$pkg.Mandaic = _Mandaic;
		$pkg.Manichaean = _Manichaean;
		$pkg.Marchen = _Marchen;
		$pkg.Meetei_Mayek = _Meetei_Mayek;
		$pkg.Mende_Kikakui = _Mende_Kikakui;
		$pkg.Meroitic_Cursive = _Meroitic_Cursive;
		$pkg.Meroitic_Hieroglyphs = _Meroitic_Hieroglyphs;
		$pkg.Miao = _Miao;
		$pkg.Modi = _Modi;
		$pkg.Mongolian = _Mongolian;
		$pkg.Mro = _Mro;
		$pkg.Multani = _Multani;
		$pkg.Myanmar = _Myanmar;
		$pkg.Nabataean = _Nabataean;
		$pkg.New_Tai_Lue = _New_Tai_Lue;
		$pkg.Newa = _Newa;
		$pkg.Nko = _Nko;
		$pkg.Ogham = _Ogham;
		$pkg.Ol_Chiki = _Ol_Chiki;
		$pkg.Old_Hungarian = _Old_Hungarian;
		$pkg.Old_Italic = _Old_Italic;
		$pkg.Old_North_Arabian = _Old_North_Arabian;
		$pkg.Old_Permic = _Old_Permic;
		$pkg.Old_Persian = _Old_Persian;
		$pkg.Old_South_Arabian = _Old_South_Arabian;
		$pkg.Old_Turkic = _Old_Turkic;
		$pkg.Oriya = _Oriya;
		$pkg.Osage = _Osage;
		$pkg.Osmanya = _Osmanya;
		$pkg.Pahawh_Hmong = _Pahawh_Hmong;
		$pkg.Palmyrene = _Palmyrene;
		$pkg.Pau_Cin_Hau = _Pau_Cin_Hau;
		$pkg.Phags_Pa = _Phags_Pa;
		$pkg.Phoenician = _Phoenician;
		$pkg.Psalter_Pahlavi = _Psalter_Pahlavi;
		$pkg.Rejang = _Rejang;
		$pkg.Runic = _Runic;
		$pkg.Samaritan = _Samaritan;
		$pkg.Saurashtra = _Saurashtra;
		$pkg.Sharada = _Sharada;
		$pkg.Shavian = _Shavian;
		$pkg.Siddham = _Siddham;
		$pkg.SignWriting = _SignWriting;
		$pkg.Sinhala = _Sinhala;
		$pkg.Sora_Sompeng = _Sora_Sompeng;
		$pkg.Sundanese = _Sundanese;
		$pkg.Syloti_Nagri = _Syloti_Nagri;
		$pkg.Syriac = _Syriac;
		$pkg.Tagalog = _Tagalog;
		$pkg.Tagbanwa = _Tagbanwa;
		$pkg.Tai_Le = _Tai_Le;
		$pkg.Tai_Tham = _Tai_Tham;
		$pkg.Tai_Viet = _Tai_Viet;
		$pkg.Takri = _Takri;
		$pkg.Tamil = _Tamil;
		$pkg.Tangut = _Tangut;
		$pkg.Telugu = _Telugu;
		$pkg.Thaana = _Thaana;
		$pkg.Thai = _Thai;
		$pkg.Tibetan = _Tibetan;
		$pkg.Tifinagh = _Tifinagh;
		$pkg.Tirhuta = _Tirhuta;
		$pkg.Ugaritic = _Ugaritic;
		$pkg.Vai = _Vai;
		$pkg.Warang_Citi = _Warang_Citi;
		$pkg.Yi = _Yi;
		$pkg.Scripts = $makeMap($String.keyFor, [{ k: "Adlam", v: $pkg.Adlam }, { k: "Ahom", v: $pkg.Ahom }, { k: "Anatolian_Hieroglyphs", v: $pkg.Anatolian_Hieroglyphs }, { k: "Arabic", v: $pkg.Arabic }, { k: "Armenian", v: $pkg.Armenian }, { k: "Avestan", v: $pkg.Avestan }, { k: "Balinese", v: $pkg.Balinese }, { k: "Bamum", v: $pkg.Bamum }, { k: "Bassa_Vah", v: $pkg.Bassa_Vah }, { k: "Batak", v: $pkg.Batak }, { k: "Bengali", v: $pkg.Bengali }, { k: "Bhaiksuki", v: $pkg.Bhaiksuki }, { k: "Bopomofo", v: $pkg.Bopomofo }, { k: "Brahmi", v: $pkg.Brahmi }, { k: "Braille", v: $pkg.Braille }, { k: "Buginese", v: $pkg.Buginese }, { k: "Buhid", v: $pkg.Buhid }, { k: "Canadian_Aboriginal", v: $pkg.Canadian_Aboriginal }, { k: "Carian", v: $pkg.Carian }, { k: "Caucasian_Albanian", v: $pkg.Caucasian_Albanian }, { k: "Chakma", v: $pkg.Chakma }, { k: "Cham", v: $pkg.Cham }, { k: "Cherokee", v: $pkg.Cherokee }, { k: "Common", v: $pkg.Common }, { k: "Coptic", v: $pkg.Coptic }, { k: "Cuneiform", v: $pkg.Cuneiform }, { k: "Cypriot", v: $pkg.Cypriot }, { k: "Cyrillic", v: $pkg.Cyrillic }, { k: "Deseret", v: $pkg.Deseret }, { k: "Devanagari", v: $pkg.Devanagari }, { k: "Duployan", v: $pkg.Duployan }, { k: "Egyptian_Hieroglyphs", v: $pkg.Egyptian_Hieroglyphs }, { k: "Elbasan", v: $pkg.Elbasan }, { k: "Ethiopic", v: $pkg.Ethiopic }, { k: "Georgian", v: $pkg.Georgian }, { k: "Glagolitic", v: $pkg.Glagolitic }, { k: "Gothic", v: $pkg.Gothic }, { k: "Grantha", v: $pkg.Grantha }, { k: "Greek", v: $pkg.Greek }, { k: "Gujarati", v: $pkg.Gujarati }, { k: "Gurmukhi", v: $pkg.Gurmukhi }, { k: "Han", v: $pkg.Han }, { k: "Hangul", v: $pkg.Hangul }, { k: "Hanunoo", v: $pkg.Hanunoo }, { k: "Hatran", v: $pkg.Hatran }, { k: "Hebrew", v: $pkg.Hebrew }, { k: "Hiragana", v: $pkg.Hiragana }, { k: "Imperial_Aramaic", v: $pkg.Imperial_Aramaic }, { k: "Inherited", v: $pkg.Inherited }, { k: "Inscriptional_Pahlavi", v: $pkg.Inscriptional_Pahlavi }, { k: "Inscriptional_Parthian", v: $pkg.Inscriptional_Parthian }, { k: "Javanese", v: $pkg.Javanese }, { k: "Kaithi", v: $pkg.Kaithi }, { k: "Kannada", v: $pkg.Kannada }, { k: "Katakana", v: $pkg.Katakana }, { k: "Kayah_Li", v: $pkg.Kayah_Li }, { k: "Kharoshthi", v: $pkg.Kharoshthi }, { k: "Khmer", v: $pkg.Khmer }, { k: "Khojki", v: $pkg.Khojki }, { k: "Khudawadi", v: $pkg.Khudawadi }, { k: "Lao", v: $pkg.Lao }, { k: "Latin", v: $pkg.Latin }, { k: "Lepcha", v: $pkg.Lepcha }, { k: "Limbu", v: $pkg.Limbu }, { k: "Linear_A", v: $pkg.Linear_A }, { k: "Linear_B", v: $pkg.Linear_B }, { k: "Lisu", v: $pkg.Lisu }, { k: "Lycian", v: $pkg.Lycian }, { k: "Lydian", v: $pkg.Lydian }, { k: "Mahajani", v: $pkg.Mahajani }, { k: "Malayalam", v: $pkg.Malayalam }, { k: "Mandaic", v: $pkg.Mandaic }, { k: "Manichaean", v: $pkg.Manichaean }, { k: "Marchen", v: $pkg.Marchen }, { k: "Meetei_Mayek", v: $pkg.Meetei_Mayek }, { k: "Mende_Kikakui", v: $pkg.Mende_Kikakui }, { k: "Meroitic_Cursive", v: $pkg.Meroitic_Cursive }, { k: "Meroitic_Hieroglyphs", v: $pkg.Meroitic_Hieroglyphs }, { k: "Miao", v: $pkg.Miao }, { k: "Modi", v: $pkg.Modi }, { k: "Mongolian", v: $pkg.Mongolian }, { k: "Mro", v: $pkg.Mro }, { k: "Multani", v: $pkg.Multani }, { k: "Myanmar", v: $pkg.Myanmar }, { k: "Nabataean", v: $pkg.Nabataean }, { k: "New_Tai_Lue", v: $pkg.New_Tai_Lue }, { k: "Newa", v: $pkg.Newa }, { k: "Nko", v: $pkg.Nko }, { k: "Ogham", v: $pkg.Ogham }, { k: "Ol_Chiki", v: $pkg.Ol_Chiki }, { k: "Old_Hungarian", v: $pkg.Old_Hungarian }, { k: "Old_Italic", v: $pkg.Old_Italic }, { k: "Old_North_Arabian", v: $pkg.Old_North_Arabian }, { k: "Old_Permic", v: $pkg.Old_Permic }, { k: "Old_Persian", v: $pkg.Old_Persian }, { k: "Old_South_Arabian", v: $pkg.Old_South_Arabian }, { k: "Old_Turkic", v: $pkg.Old_Turkic }, { k: "Oriya", v: $pkg.Oriya }, { k: "Osage", v: $pkg.Osage }, { k: "Osmanya", v: $pkg.Osmanya }, { k: "Pahawh_Hmong", v: $pkg.Pahawh_Hmong }, { k: "Palmyrene", v: $pkg.Palmyrene }, { k: "Pau_Cin_Hau", v: $pkg.Pau_Cin_Hau }, { k: "Phags_Pa", v: $pkg.Phags_Pa }, { k: "Phoenician", v: $pkg.Phoenician }, { k: "Psalter_Pahlavi", v: $pkg.Psalter_Pahlavi }, { k: "Rejang", v: $pkg.Rejang }, { k: "Runic", v: $pkg.Runic }, { k: "Samaritan", v: $pkg.Samaritan }, { k: "Saurashtra", v: $pkg.Saurashtra }, { k: "Sharada", v: $pkg.Sharada }, { k: "Shavian", v: $pkg.Shavian }, { k: "Siddham", v: $pkg.Siddham }, { k: "SignWriting", v: $pkg.SignWriting }, { k: "Sinhala", v: $pkg.Sinhala }, { k: "Sora_Sompeng", v: $pkg.Sora_Sompeng }, { k: "Sundanese", v: $pkg.Sundanese }, { k: "Syloti_Nagri", v: $pkg.Syloti_Nagri }, { k: "Syriac", v: $pkg.Syriac }, { k: "Tagalog", v: $pkg.Tagalog }, { k: "Tagbanwa", v: $pkg.Tagbanwa }, { k: "Tai_Le", v: $pkg.Tai_Le }, { k: "Tai_Tham", v: $pkg.Tai_Tham }, { k: "Tai_Viet", v: $pkg.Tai_Viet }, { k: "Takri", v: $pkg.Takri }, { k: "Tamil", v: $pkg.Tamil }, { k: "Tangut", v: $pkg.Tangut }, { k: "Telugu", v: $pkg.Telugu }, { k: "Thaana", v: $pkg.Thaana }, { k: "Thai", v: $pkg.Thai }, { k: "Tibetan", v: $pkg.Tibetan }, { k: "Tifinagh", v: $pkg.Tifinagh }, { k: "Tirhuta", v: $pkg.Tirhuta }, { k: "Ugaritic", v: $pkg.Ugaritic }, { k: "Vai", v: $pkg.Vai }, { k: "Warang_Citi", v: $pkg.Warang_Citi }, { k: "Yi", v: $pkg.Yi }]);
		_White_Space = new RangeTable.ptr(new sliceType([new Range16.ptr(9, 13, 1), new Range16.ptr(32, 32, 1), new Range16.ptr(133, 133, 1), new Range16.ptr(160, 160, 1), new Range16.ptr(5760, 5760, 1), new Range16.ptr(8192, 8202, 1), new Range16.ptr(8232, 8233, 1), new Range16.ptr(8239, 8239, 1), new Range16.ptr(8287, 8287, 1), new Range16.ptr(12288, 12288, 1)]), sliceType$1.nil, 4);
		$pkg.White_Space = _White_Space;
		_CaseRanges = new sliceType$3([new CaseRange.ptr(65, 90, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(97, 122, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(181, 181, $toNativeArray($kindInt32, [743, 0, 743])), new CaseRange.ptr(192, 214, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(216, 222, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(224, 246, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(248, 254, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(255, 255, $toNativeArray($kindInt32, [121, 0, 121])), new CaseRange.ptr(256, 303, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(304, 304, $toNativeArray($kindInt32, [0, -199, 0])), new CaseRange.ptr(305, 305, $toNativeArray($kindInt32, [-232, 0, -232])), new CaseRange.ptr(306, 311, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(313, 328, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(330, 375, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(376, 376, $toNativeArray($kindInt32, [0, -121, 0])), new CaseRange.ptr(377, 382, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(383, 383, $toNativeArray($kindInt32, [-300, 0, -300])), new CaseRange.ptr(384, 384, $toNativeArray($kindInt32, [195, 0, 195])), new CaseRange.ptr(385, 385, $toNativeArray($kindInt32, [0, 210, 0])), new CaseRange.ptr(386, 389, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(390, 390, $toNativeArray($kindInt32, [0, 206, 0])), new CaseRange.ptr(391, 392, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(393, 394, $toNativeArray($kindInt32, [0, 205, 0])), new CaseRange.ptr(395, 396, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(398, 398, $toNativeArray($kindInt32, [0, 79, 0])), new CaseRange.ptr(399, 399, $toNativeArray($kindInt32, [0, 202, 0])), new CaseRange.ptr(400, 400, $toNativeArray($kindInt32, [0, 203, 0])), new CaseRange.ptr(401, 402, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(403, 403, $toNativeArray($kindInt32, [0, 205, 0])), new CaseRange.ptr(404, 404, $toNativeArray($kindInt32, [0, 207, 0])), new CaseRange.ptr(405, 405, $toNativeArray($kindInt32, [97, 0, 97])), new CaseRange.ptr(406, 406, $toNativeArray($kindInt32, [0, 211, 0])), new CaseRange.ptr(407, 407, $toNativeArray($kindInt32, [0, 209, 0])), new CaseRange.ptr(408, 409, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(410, 410, $toNativeArray($kindInt32, [163, 0, 163])), new CaseRange.ptr(412, 412, $toNativeArray($kindInt32, [0, 211, 0])), new CaseRange.ptr(413, 413, $toNativeArray($kindInt32, [0, 213, 0])), new CaseRange.ptr(414, 414, $toNativeArray($kindInt32, [130, 0, 130])), new CaseRange.ptr(415, 415, $toNativeArray($kindInt32, [0, 214, 0])), new CaseRange.ptr(416, 421, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(422, 422, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(423, 424, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(425, 425, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(428, 429, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(430, 430, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(431, 432, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(433, 434, $toNativeArray($kindInt32, [0, 217, 0])), new CaseRange.ptr(435, 438, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(439, 439, $toNativeArray($kindInt32, [0, 219, 0])), new CaseRange.ptr(440, 441, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(444, 445, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(447, 447, $toNativeArray($kindInt32, [56, 0, 56])), new CaseRange.ptr(452, 452, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(453, 453, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(454, 454, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(455, 455, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(456, 456, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(457, 457, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(458, 458, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(459, 459, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(460, 460, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(461, 476, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(477, 477, $toNativeArray($kindInt32, [-79, 0, -79])), new CaseRange.ptr(478, 495, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(497, 497, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(498, 498, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(499, 499, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(500, 501, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(502, 502, $toNativeArray($kindInt32, [0, -97, 0])), new CaseRange.ptr(503, 503, $toNativeArray($kindInt32, [0, -56, 0])), new CaseRange.ptr(504, 543, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(544, 544, $toNativeArray($kindInt32, [0, -130, 0])), new CaseRange.ptr(546, 563, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(570, 570, $toNativeArray($kindInt32, [0, 10795, 0])), new CaseRange.ptr(571, 572, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(573, 573, $toNativeArray($kindInt32, [0, -163, 0])), new CaseRange.ptr(574, 574, $toNativeArray($kindInt32, [0, 10792, 0])), new CaseRange.ptr(575, 576, $toNativeArray($kindInt32, [10815, 0, 10815])), new CaseRange.ptr(577, 578, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(579, 579, $toNativeArray($kindInt32, [0, -195, 0])), new CaseRange.ptr(580, 580, $toNativeArray($kindInt32, [0, 69, 0])), new CaseRange.ptr(581, 581, $toNativeArray($kindInt32, [0, 71, 0])), new CaseRange.ptr(582, 591, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(592, 592, $toNativeArray($kindInt32, [10783, 0, 10783])), new CaseRange.ptr(593, 593, $toNativeArray($kindInt32, [10780, 0, 10780])), new CaseRange.ptr(594, 594, $toNativeArray($kindInt32, [10782, 0, 10782])), new CaseRange.ptr(595, 595, $toNativeArray($kindInt32, [-210, 0, -210])), new CaseRange.ptr(596, 596, $toNativeArray($kindInt32, [-206, 0, -206])), new CaseRange.ptr(598, 599, $toNativeArray($kindInt32, [-205, 0, -205])), new CaseRange.ptr(601, 601, $toNativeArray($kindInt32, [-202, 0, -202])), new CaseRange.ptr(603, 603, $toNativeArray($kindInt32, [-203, 0, -203])), new CaseRange.ptr(604, 604, $toNativeArray($kindInt32, [42319, 0, 42319])), new CaseRange.ptr(608, 608, $toNativeArray($kindInt32, [-205, 0, -205])), new CaseRange.ptr(609, 609, $toNativeArray($kindInt32, [42315, 0, 42315])), new CaseRange.ptr(611, 611, $toNativeArray($kindInt32, [-207, 0, -207])), new CaseRange.ptr(613, 613, $toNativeArray($kindInt32, [42280, 0, 42280])), new CaseRange.ptr(614, 614, $toNativeArray($kindInt32, [42308, 0, 42308])), new CaseRange.ptr(616, 616, $toNativeArray($kindInt32, [-209, 0, -209])), new CaseRange.ptr(617, 617, $toNativeArray($kindInt32, [-211, 0, -211])), new CaseRange.ptr(618, 618, $toNativeArray($kindInt32, [42308, 0, 42308])), new CaseRange.ptr(619, 619, $toNativeArray($kindInt32, [10743, 0, 10743])), new CaseRange.ptr(620, 620, $toNativeArray($kindInt32, [42305, 0, 42305])), new CaseRange.ptr(623, 623, $toNativeArray($kindInt32, [-211, 0, -211])), new CaseRange.ptr(625, 625, $toNativeArray($kindInt32, [10749, 0, 10749])), new CaseRange.ptr(626, 626, $toNativeArray($kindInt32, [-213, 0, -213])), new CaseRange.ptr(629, 629, $toNativeArray($kindInt32, [-214, 0, -214])), new CaseRange.ptr(637, 637, $toNativeArray($kindInt32, [10727, 0, 10727])), new CaseRange.ptr(640, 640, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(643, 643, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(647, 647, $toNativeArray($kindInt32, [42282, 0, 42282])), new CaseRange.ptr(648, 648, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(649, 649, $toNativeArray($kindInt32, [-69, 0, -69])), new CaseRange.ptr(650, 651, $toNativeArray($kindInt32, [-217, 0, -217])), new CaseRange.ptr(652, 652, $toNativeArray($kindInt32, [-71, 0, -71])), new CaseRange.ptr(658, 658, $toNativeArray($kindInt32, [-219, 0, -219])), new CaseRange.ptr(669, 669, $toNativeArray($kindInt32, [42261, 0, 42261])), new CaseRange.ptr(670, 670, $toNativeArray($kindInt32, [42258, 0, 42258])), new CaseRange.ptr(837, 837, $toNativeArray($kindInt32, [84, 0, 84])), new CaseRange.ptr(880, 883, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(886, 887, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(891, 893, $toNativeArray($kindInt32, [130, 0, 130])), new CaseRange.ptr(895, 895, $toNativeArray($kindInt32, [0, 116, 0])), new CaseRange.ptr(902, 902, $toNativeArray($kindInt32, [0, 38, 0])), new CaseRange.ptr(904, 906, $toNativeArray($kindInt32, [0, 37, 0])), new CaseRange.ptr(908, 908, $toNativeArray($kindInt32, [0, 64, 0])), new CaseRange.ptr(910, 911, $toNativeArray($kindInt32, [0, 63, 0])), new CaseRange.ptr(913, 929, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(931, 939, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(940, 940, $toNativeArray($kindInt32, [-38, 0, -38])), new CaseRange.ptr(941, 943, $toNativeArray($kindInt32, [-37, 0, -37])), new CaseRange.ptr(945, 961, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(962, 962, $toNativeArray($kindInt32, [-31, 0, -31])), new CaseRange.ptr(963, 971, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(972, 972, $toNativeArray($kindInt32, [-64, 0, -64])), new CaseRange.ptr(973, 974, $toNativeArray($kindInt32, [-63, 0, -63])), new CaseRange.ptr(975, 975, $toNativeArray($kindInt32, [0, 8, 0])), new CaseRange.ptr(976, 976, $toNativeArray($kindInt32, [-62, 0, -62])), new CaseRange.ptr(977, 977, $toNativeArray($kindInt32, [-57, 0, -57])), new CaseRange.ptr(981, 981, $toNativeArray($kindInt32, [-47, 0, -47])), new CaseRange.ptr(982, 982, $toNativeArray($kindInt32, [-54, 0, -54])), new CaseRange.ptr(983, 983, $toNativeArray($kindInt32, [-8, 0, -8])), new CaseRange.ptr(984, 1007, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1008, 1008, $toNativeArray($kindInt32, [-86, 0, -86])), new CaseRange.ptr(1009, 1009, $toNativeArray($kindInt32, [-80, 0, -80])), new CaseRange.ptr(1010, 1010, $toNativeArray($kindInt32, [7, 0, 7])), new CaseRange.ptr(1011, 1011, $toNativeArray($kindInt32, [-116, 0, -116])), new CaseRange.ptr(1012, 1012, $toNativeArray($kindInt32, [0, -60, 0])), new CaseRange.ptr(1013, 1013, $toNativeArray($kindInt32, [-96, 0, -96])), new CaseRange.ptr(1015, 1016, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1017, 1017, $toNativeArray($kindInt32, [0, -7, 0])), new CaseRange.ptr(1018, 1019, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1021, 1023, $toNativeArray($kindInt32, [0, -130, 0])), new CaseRange.ptr(1024, 1039, $toNativeArray($kindInt32, [0, 80, 0])), new CaseRange.ptr(1040, 1071, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(1072, 1103, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(1104, 1119, $toNativeArray($kindInt32, [-80, 0, -80])), new CaseRange.ptr(1120, 1153, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1162, 1215, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1216, 1216, $toNativeArray($kindInt32, [0, 15, 0])), new CaseRange.ptr(1217, 1230, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1231, 1231, $toNativeArray($kindInt32, [-15, 0, -15])), new CaseRange.ptr(1232, 1327, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1329, 1366, $toNativeArray($kindInt32, [0, 48, 0])), new CaseRange.ptr(1377, 1414, $toNativeArray($kindInt32, [-48, 0, -48])), new CaseRange.ptr(4256, 4293, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(4295, 4295, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(4301, 4301, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(5024, 5103, $toNativeArray($kindInt32, [0, 38864, 0])), new CaseRange.ptr(5104, 5109, $toNativeArray($kindInt32, [0, 8, 0])), new CaseRange.ptr(5112, 5117, $toNativeArray($kindInt32, [-8, 0, -8])), new CaseRange.ptr(7296, 7296, $toNativeArray($kindInt32, [-6254, 0, -6254])), new CaseRange.ptr(7297, 7297, $toNativeArray($kindInt32, [-6253, 0, -6253])), new CaseRange.ptr(7298, 7298, $toNativeArray($kindInt32, [-6244, 0, -6244])), new CaseRange.ptr(7299, 7300, $toNativeArray($kindInt32, [-6242, 0, -6242])), new CaseRange.ptr(7301, 7301, $toNativeArray($kindInt32, [-6243, 0, -6243])), new CaseRange.ptr(7302, 7302, $toNativeArray($kindInt32, [-6236, 0, -6236])), new CaseRange.ptr(7303, 7303, $toNativeArray($kindInt32, [-6181, 0, -6181])), new CaseRange.ptr(7304, 7304, $toNativeArray($kindInt32, [35266, 0, 35266])), new CaseRange.ptr(7545, 7545, $toNativeArray($kindInt32, [35332, 0, 35332])), new CaseRange.ptr(7549, 7549, $toNativeArray($kindInt32, [3814, 0, 3814])), new CaseRange.ptr(7680, 7829, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(7835, 7835, $toNativeArray($kindInt32, [-59, 0, -59])), new CaseRange.ptr(7838, 7838, $toNativeArray($kindInt32, [0, -7615, 0])), new CaseRange.ptr(7840, 7935, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(7936, 7943, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7944, 7951, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7952, 7957, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7960, 7965, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7968, 7975, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7976, 7983, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7984, 7991, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7992, 7999, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8000, 8005, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8008, 8013, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8017, 8017, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8019, 8019, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8021, 8021, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8023, 8023, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8025, 8025, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8027, 8027, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8029, 8029, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8031, 8031, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8032, 8039, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8040, 8047, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8048, 8049, $toNativeArray($kindInt32, [74, 0, 74])), new CaseRange.ptr(8050, 8053, $toNativeArray($kindInt32, [86, 0, 86])), new CaseRange.ptr(8054, 8055, $toNativeArray($kindInt32, [100, 0, 100])), new CaseRange.ptr(8056, 8057, $toNativeArray($kindInt32, [128, 0, 128])), new CaseRange.ptr(8058, 8059, $toNativeArray($kindInt32, [112, 0, 112])), new CaseRange.ptr(8060, 8061, $toNativeArray($kindInt32, [126, 0, 126])), new CaseRange.ptr(8064, 8071, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8072, 8079, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8080, 8087, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8088, 8095, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8096, 8103, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8104, 8111, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8112, 8113, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8115, 8115, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8120, 8121, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8122, 8123, $toNativeArray($kindInt32, [0, -74, 0])), new CaseRange.ptr(8124, 8124, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8126, 8126, $toNativeArray($kindInt32, [-7205, 0, -7205])), new CaseRange.ptr(8131, 8131, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8136, 8139, $toNativeArray($kindInt32, [0, -86, 0])), new CaseRange.ptr(8140, 8140, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8144, 8145, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8152, 8153, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8154, 8155, $toNativeArray($kindInt32, [0, -100, 0])), new CaseRange.ptr(8160, 8161, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8165, 8165, $toNativeArray($kindInt32, [7, 0, 7])), new CaseRange.ptr(8168, 8169, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8170, 8171, $toNativeArray($kindInt32, [0, -112, 0])), new CaseRange.ptr(8172, 8172, $toNativeArray($kindInt32, [0, -7, 0])), new CaseRange.ptr(8179, 8179, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8184, 8185, $toNativeArray($kindInt32, [0, -128, 0])), new CaseRange.ptr(8186, 8187, $toNativeArray($kindInt32, [0, -126, 0])), new CaseRange.ptr(8188, 8188, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8486, 8486, $toNativeArray($kindInt32, [0, -7517, 0])), new CaseRange.ptr(8490, 8490, $toNativeArray($kindInt32, [0, -8383, 0])), new CaseRange.ptr(8491, 8491, $toNativeArray($kindInt32, [0, -8262, 0])), new CaseRange.ptr(8498, 8498, $toNativeArray($kindInt32, [0, 28, 0])), new CaseRange.ptr(8526, 8526, $toNativeArray($kindInt32, [-28, 0, -28])), new CaseRange.ptr(8544, 8559, $toNativeArray($kindInt32, [0, 16, 0])), new CaseRange.ptr(8560, 8575, $toNativeArray($kindInt32, [-16, 0, -16])), new CaseRange.ptr(8579, 8580, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(9398, 9423, $toNativeArray($kindInt32, [0, 26, 0])), new CaseRange.ptr(9424, 9449, $toNativeArray($kindInt32, [-26, 0, -26])), new CaseRange.ptr(11264, 11310, $toNativeArray($kindInt32, [0, 48, 0])), new CaseRange.ptr(11312, 11358, $toNativeArray($kindInt32, [-48, 0, -48])), new CaseRange.ptr(11360, 11361, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11362, 11362, $toNativeArray($kindInt32, [0, -10743, 0])), new CaseRange.ptr(11363, 11363, $toNativeArray($kindInt32, [0, -3814, 0])), new CaseRange.ptr(11364, 11364, $toNativeArray($kindInt32, [0, -10727, 0])), new CaseRange.ptr(11365, 11365, $toNativeArray($kindInt32, [-10795, 0, -10795])), new CaseRange.ptr(11366, 11366, $toNativeArray($kindInt32, [-10792, 0, -10792])), new CaseRange.ptr(11367, 11372, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11373, 11373, $toNativeArray($kindInt32, [0, -10780, 0])), new CaseRange.ptr(11374, 11374, $toNativeArray($kindInt32, [0, -10749, 0])), new CaseRange.ptr(11375, 11375, $toNativeArray($kindInt32, [0, -10783, 0])), new CaseRange.ptr(11376, 11376, $toNativeArray($kindInt32, [0, -10782, 0])), new CaseRange.ptr(11378, 11379, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11381, 11382, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11390, 11391, $toNativeArray($kindInt32, [0, -10815, 0])), new CaseRange.ptr(11392, 11491, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11499, 11502, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11506, 11507, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11520, 11557, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(11559, 11559, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(11565, 11565, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(42560, 42605, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42624, 42651, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42786, 42799, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42802, 42863, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42873, 42876, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42877, 42877, $toNativeArray($kindInt32, [0, -35332, 0])), new CaseRange.ptr(42878, 42887, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42891, 42892, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42893, 42893, $toNativeArray($kindInt32, [0, -42280, 0])), new CaseRange.ptr(42896, 42899, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42902, 42921, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42922, 42922, $toNativeArray($kindInt32, [0, -42308, 0])), new CaseRange.ptr(42923, 42923, $toNativeArray($kindInt32, [0, -42319, 0])), new CaseRange.ptr(42924, 42924, $toNativeArray($kindInt32, [0, -42315, 0])), new CaseRange.ptr(42925, 42925, $toNativeArray($kindInt32, [0, -42305, 0])), new CaseRange.ptr(42926, 42926, $toNativeArray($kindInt32, [0, -42308, 0])), new CaseRange.ptr(42928, 42928, $toNativeArray($kindInt32, [0, -42258, 0])), new CaseRange.ptr(42929, 42929, $toNativeArray($kindInt32, [0, -42282, 0])), new CaseRange.ptr(42930, 42930, $toNativeArray($kindInt32, [0, -42261, 0])), new CaseRange.ptr(42931, 42931, $toNativeArray($kindInt32, [0, 928, 0])), new CaseRange.ptr(42932, 42935, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(43859, 43859, $toNativeArray($kindInt32, [-928, 0, -928])), new CaseRange.ptr(43888, 43967, $toNativeArray($kindInt32, [-38864, 0, -38864])), new CaseRange.ptr(65313, 65338, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(65345, 65370, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(66560, 66599, $toNativeArray($kindInt32, [0, 40, 0])), new CaseRange.ptr(66600, 66639, $toNativeArray($kindInt32, [-40, 0, -40])), new CaseRange.ptr(66736, 66771, $toNativeArray($kindInt32, [0, 40, 0])), new CaseRange.ptr(66776, 66811, $toNativeArray($kindInt32, [-40, 0, -40])), new CaseRange.ptr(68736, 68786, $toNativeArray($kindInt32, [0, 64, 0])), new CaseRange.ptr(68800, 68850, $toNativeArray($kindInt32, [-64, 0, -64])), new CaseRange.ptr(71840, 71871, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(71872, 71903, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(125184, 125217, $toNativeArray($kindInt32, [0, 34, 0])), new CaseRange.ptr(125218, 125251, $toNativeArray($kindInt32, [-34, 0, -34]))]);
		$pkg.CaseRanges = _CaseRanges;
		properties = $toNativeArray($kindUint8, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 144, 130, 130, 130, 136, 130, 130, 130, 130, 130, 130, 136, 130, 130, 130, 130, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 130, 130, 136, 136, 136, 130, 130, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 130, 130, 130, 136, 130, 136, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 130, 136, 130, 136, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 130, 136, 136, 136, 136, 136, 130, 136, 136, 224, 130, 136, 0, 136, 136, 136, 136, 132, 132, 136, 192, 130, 130, 136, 132, 224, 130, 132, 132, 132, 130, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 136, 160, 160, 160, 160, 160, 160, 160, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 136, 192, 192, 192, 192, 192, 192, 192, 192]);
		asciiFold = $toNativeArray($kindUint16, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 91, 92, 93, 94, 95, 96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 8490, 76, 77, 78, 79, 80, 81, 82, 383, 84, 85, 86, 87, 88, 89, 90, 123, 124, 125, 126, 127]);
		caseOrbit = new sliceType$4([new foldPair.ptr(75, 107), new foldPair.ptr(83, 115), new foldPair.ptr(107, 8490), new foldPair.ptr(115, 383), new foldPair.ptr(181, 924), new foldPair.ptr(197, 229), new foldPair.ptr(223, 7838), new foldPair.ptr(229, 8491), new foldPair.ptr(304, 304), new foldPair.ptr(305, 305), new foldPair.ptr(383, 83), new foldPair.ptr(452, 453), new foldPair.ptr(453, 454), new foldPair.ptr(454, 452), new foldPair.ptr(455, 456), new foldPair.ptr(456, 457), new foldPair.ptr(457, 455), new foldPair.ptr(458, 459), new foldPair.ptr(459, 460), new foldPair.ptr(460, 458), new foldPair.ptr(497, 498), new foldPair.ptr(498, 499), new foldPair.ptr(499, 497), new foldPair.ptr(837, 921), new foldPair.ptr(914, 946), new foldPair.ptr(917, 949), new foldPair.ptr(920, 952), new foldPair.ptr(921, 953), new foldPair.ptr(922, 954), new foldPair.ptr(924, 956), new foldPair.ptr(928, 960), new foldPair.ptr(929, 961), new foldPair.ptr(931, 962), new foldPair.ptr(934, 966), new foldPair.ptr(937, 969), new foldPair.ptr(946, 976), new foldPair.ptr(949, 1013), new foldPair.ptr(952, 977), new foldPair.ptr(953, 8126), new foldPair.ptr(954, 1008), new foldPair.ptr(956, 181), new foldPair.ptr(960, 982), new foldPair.ptr(961, 1009), new foldPair.ptr(962, 963), new foldPair.ptr(963, 931), new foldPair.ptr(966, 981), new foldPair.ptr(969, 8486), new foldPair.ptr(976, 914), new foldPair.ptr(977, 1012), new foldPair.ptr(981, 934), new foldPair.ptr(982, 928), new foldPair.ptr(1008, 922), new foldPair.ptr(1009, 929), new foldPair.ptr(1012, 920), new foldPair.ptr(1013, 917), new foldPair.ptr(1042, 1074), new foldPair.ptr(1044, 1076), new foldPair.ptr(1054, 1086), new foldPair.ptr(1057, 1089), new foldPair.ptr(1058, 1090), new foldPair.ptr(1066, 1098), new foldPair.ptr(1074, 7296), new foldPair.ptr(1076, 7297), new foldPair.ptr(1086, 7298), new foldPair.ptr(1089, 7299), new foldPair.ptr(1090, 7300), new foldPair.ptr(1098, 7302), new foldPair.ptr(1122, 1123), new foldPair.ptr(1123, 7303), new foldPair.ptr(7296, 1042), new foldPair.ptr(7297, 1044), new foldPair.ptr(7298, 1054), new foldPair.ptr(7299, 1057), new foldPair.ptr(7300, 7301), new foldPair.ptr(7301, 1058), new foldPair.ptr(7302, 1066), new foldPair.ptr(7303, 1122), new foldPair.ptr(7304, 42570), new foldPair.ptr(7776, 7777), new foldPair.ptr(7777, 7835), new foldPair.ptr(7835, 7776), new foldPair.ptr(7838, 223), new foldPair.ptr(8126, 837), new foldPair.ptr(8486, 937), new foldPair.ptr(8490, 75), new foldPair.ptr(8491, 197), new foldPair.ptr(42570, 42571), new foldPair.ptr(42571, 7304)]);
		foldL = new RangeTable.ptr(new sliceType([new Range16.ptr(837, 837, 1)]), sliceType$1.nil, 0);
		foldLl = new RangeTable.ptr(new sliceType([new Range16.ptr(65, 90, 1), new Range16.ptr(192, 214, 1), new Range16.ptr(216, 222, 1), new Range16.ptr(256, 302, 2), new Range16.ptr(306, 310, 2), new Range16.ptr(313, 327, 2), new Range16.ptr(330, 376, 2), new Range16.ptr(377, 381, 2), new Range16.ptr(385, 386, 1), new Range16.ptr(388, 390, 2), new Range16.ptr(391, 393, 2), new Range16.ptr(394, 395, 1), new Range16.ptr(398, 401, 1), new Range16.ptr(403, 404, 1), new Range16.ptr(406, 408, 1), new Range16.ptr(412, 413, 1), new Range16.ptr(415, 416, 1), new Range16.ptr(418, 422, 2), new Range16.ptr(423, 425, 2), new Range16.ptr(428, 430, 2), new Range16.ptr(431, 433, 2), new Range16.ptr(434, 435, 1), new Range16.ptr(437, 439, 2), new Range16.ptr(440, 444, 4), new Range16.ptr(452, 453, 1), new Range16.ptr(455, 456, 1), new Range16.ptr(458, 459, 1), new Range16.ptr(461, 475, 2), new Range16.ptr(478, 494, 2), new Range16.ptr(497, 498, 1), new Range16.ptr(500, 502, 2), new Range16.ptr(503, 504, 1), new Range16.ptr(506, 562, 2), new Range16.ptr(570, 571, 1), new Range16.ptr(573, 574, 1), new Range16.ptr(577, 579, 2), new Range16.ptr(580, 582, 1), new Range16.ptr(584, 590, 2), new Range16.ptr(837, 880, 43), new Range16.ptr(882, 886, 4), new Range16.ptr(895, 902, 7), new Range16.ptr(904, 906, 1), new Range16.ptr(908, 910, 2), new Range16.ptr(911, 913, 2), new Range16.ptr(914, 929, 1), new Range16.ptr(931, 939, 1), new Range16.ptr(975, 984, 9), new Range16.ptr(986, 1006, 2), new Range16.ptr(1012, 1015, 3), new Range16.ptr(1017, 1018, 1), new Range16.ptr(1021, 1071, 1), new Range16.ptr(1120, 1152, 2), new Range16.ptr(1162, 1216, 2), new Range16.ptr(1217, 1229, 2), new Range16.ptr(1232, 1326, 2), new Range16.ptr(1329, 1366, 1), new Range16.ptr(4256, 4293, 1), new Range16.ptr(4295, 4301, 6), new Range16.ptr(5024, 5109, 1), new Range16.ptr(7680, 7828, 2), new Range16.ptr(7838, 7934, 2), new Range16.ptr(7944, 7951, 1), new Range16.ptr(7960, 7965, 1), new Range16.ptr(7976, 7983, 1), new Range16.ptr(7992, 7999, 1), new Range16.ptr(8008, 8013, 1), new Range16.ptr(8025, 8031, 2), new Range16.ptr(8040, 8047, 1), new Range16.ptr(8072, 8079, 1), new Range16.ptr(8088, 8095, 1), new Range16.ptr(8104, 8111, 1), new Range16.ptr(8120, 8124, 1), new Range16.ptr(8136, 8140, 1), new Range16.ptr(8152, 8155, 1), new Range16.ptr(8168, 8172, 1), new Range16.ptr(8184, 8188, 1), new Range16.ptr(8486, 8490, 4), new Range16.ptr(8491, 8498, 7), new Range16.ptr(8579, 11264, 2685), new Range16.ptr(11265, 11310, 1), new Range16.ptr(11360, 11362, 2), new Range16.ptr(11363, 11364, 1), new Range16.ptr(11367, 11373, 2), new Range16.ptr(11374, 11376, 1), new Range16.ptr(11378, 11381, 3), new Range16.ptr(11390, 11392, 1), new Range16.ptr(11394, 11490, 2), new Range16.ptr(11499, 11501, 2), new Range16.ptr(11506, 42560, 31054), new Range16.ptr(42562, 42604, 2), new Range16.ptr(42624, 42650, 2), new Range16.ptr(42786, 42798, 2), new Range16.ptr(42802, 42862, 2), new Range16.ptr(42873, 42877, 2), new Range16.ptr(42878, 42886, 2), new Range16.ptr(42891, 42893, 2), new Range16.ptr(42896, 42898, 2), new Range16.ptr(42902, 42922, 2), new Range16.ptr(42923, 42926, 1), new Range16.ptr(42928, 42932, 1), new Range16.ptr(42934, 65313, 22379), new Range16.ptr(65314, 65338, 1)]), new sliceType$1([new Range32.ptr(66560, 66599, 1), new Range32.ptr(66736, 66771, 1), new Range32.ptr(68736, 68786, 1), new Range32.ptr(71840, 71871, 1), new Range32.ptr(125184, 125217, 1)]), 3);
		foldLt = new RangeTable.ptr(new sliceType([new Range16.ptr(452, 454, 2), new Range16.ptr(455, 457, 2), new Range16.ptr(458, 460, 2), new Range16.ptr(497, 499, 2), new Range16.ptr(8064, 8071, 1), new Range16.ptr(8080, 8087, 1), new Range16.ptr(8096, 8103, 1), new Range16.ptr(8115, 8131, 16), new Range16.ptr(8179, 8179, 1)]), sliceType$1.nil, 0);
		foldLu = new RangeTable.ptr(new sliceType([new Range16.ptr(97, 122, 1), new Range16.ptr(181, 223, 42), new Range16.ptr(224, 246, 1), new Range16.ptr(248, 255, 1), new Range16.ptr(257, 303, 2), new Range16.ptr(307, 311, 2), new Range16.ptr(314, 328, 2), new Range16.ptr(331, 375, 2), new Range16.ptr(378, 382, 2), new Range16.ptr(383, 384, 1), new Range16.ptr(387, 389, 2), new Range16.ptr(392, 396, 4), new Range16.ptr(402, 405, 3), new Range16.ptr(409, 410, 1), new Range16.ptr(414, 417, 3), new Range16.ptr(419, 421, 2), new Range16.ptr(424, 429, 5), new Range16.ptr(432, 436, 4), new Range16.ptr(438, 441, 3), new Range16.ptr(445, 447, 2), new Range16.ptr(453, 454, 1), new Range16.ptr(456, 457, 1), new Range16.ptr(459, 460, 1), new Range16.ptr(462, 476, 2), new Range16.ptr(477, 495, 2), new Range16.ptr(498, 499, 1), new Range16.ptr(501, 505, 4), new Range16.ptr(507, 543, 2), new Range16.ptr(547, 563, 2), new Range16.ptr(572, 575, 3), new Range16.ptr(576, 578, 2), new Range16.ptr(583, 591, 2), new Range16.ptr(592, 596, 1), new Range16.ptr(598, 599, 1), new Range16.ptr(601, 603, 2), new Range16.ptr(604, 608, 4), new Range16.ptr(609, 613, 2), new Range16.ptr(614, 616, 2), new Range16.ptr(617, 620, 1), new Range16.ptr(623, 625, 2), new Range16.ptr(626, 629, 3), new Range16.ptr(637, 643, 3), new Range16.ptr(647, 652, 1), new Range16.ptr(658, 669, 11), new Range16.ptr(670, 837, 167), new Range16.ptr(881, 883, 2), new Range16.ptr(887, 891, 4), new Range16.ptr(892, 893, 1), new Range16.ptr(940, 943, 1), new Range16.ptr(945, 974, 1), new Range16.ptr(976, 977, 1), new Range16.ptr(981, 983, 1), new Range16.ptr(985, 1007, 2), new Range16.ptr(1008, 1011, 1), new Range16.ptr(1013, 1019, 3), new Range16.ptr(1072, 1119, 1), new Range16.ptr(1121, 1153, 2), new Range16.ptr(1163, 1215, 2), new Range16.ptr(1218, 1230, 2), new Range16.ptr(1231, 1327, 2), new Range16.ptr(1377, 1414, 1), new Range16.ptr(5112, 5117, 1), new Range16.ptr(7296, 7304, 1), new Range16.ptr(7545, 7549, 4), new Range16.ptr(7681, 7829, 2), new Range16.ptr(7835, 7841, 6), new Range16.ptr(7843, 7935, 2), new Range16.ptr(7936, 7943, 1), new Range16.ptr(7952, 7957, 1), new Range16.ptr(7968, 7975, 1), new Range16.ptr(7984, 7991, 1), new Range16.ptr(8000, 8005, 1), new Range16.ptr(8017, 8023, 2), new Range16.ptr(8032, 8039, 1), new Range16.ptr(8048, 8061, 1), new Range16.ptr(8112, 8113, 1), new Range16.ptr(8126, 8144, 18), new Range16.ptr(8145, 8160, 15), new Range16.ptr(8161, 8165, 4), new Range16.ptr(8526, 8580, 54), new Range16.ptr(11312, 11358, 1), new Range16.ptr(11361, 11365, 4), new Range16.ptr(11366, 11372, 2), new Range16.ptr(11379, 11382, 3), new Range16.ptr(11393, 11491, 2), new Range16.ptr(11500, 11502, 2), new Range16.ptr(11507, 11520, 13), new Range16.ptr(11521, 11557, 1), new Range16.ptr(11559, 11565, 6), new Range16.ptr(42561, 42605, 2), new Range16.ptr(42625, 42651, 2), new Range16.ptr(42787, 42799, 2), new Range16.ptr(42803, 42863, 2), new Range16.ptr(42874, 42876, 2), new Range16.ptr(42879, 42887, 2), new Range16.ptr(42892, 42897, 5), new Range16.ptr(42899, 42903, 4), new Range16.ptr(42905, 42921, 2), new Range16.ptr(42933, 42935, 2), new Range16.ptr(43859, 43888, 29), new Range16.ptr(43889, 43967, 1), new Range16.ptr(65345, 65370, 1)]), new sliceType$1([new Range32.ptr(66600, 66639, 1), new Range32.ptr(66776, 66811, 1), new Range32.ptr(68800, 68850, 1), new Range32.ptr(71872, 71903, 1), new Range32.ptr(125218, 125251, 1)]), 4);
		foldM = new RangeTable.ptr(new sliceType([new Range16.ptr(921, 953, 32), new Range16.ptr(8126, 8126, 1)]), sliceType$1.nil, 0);
		foldMn = new RangeTable.ptr(new sliceType([new Range16.ptr(921, 953, 32), new Range16.ptr(8126, 8126, 1)]), sliceType$1.nil, 0);
		$pkg.FoldCategory = $makeMap($String.keyFor, [{ k: "L", v: foldL }, { k: "Ll", v: foldLl }, { k: "Lt", v: foldLt }, { k: "Lu", v: foldLu }, { k: "M", v: foldM }, { k: "Mn", v: foldMn }]);
		foldCommon = new RangeTable.ptr(new sliceType([new Range16.ptr(924, 956, 32)]), sliceType$1.nil, 0);
		foldGreek = new RangeTable.ptr(new sliceType([new Range16.ptr(181, 837, 656)]), sliceType$1.nil, 0);
		foldInherited = new RangeTable.ptr(new sliceType([new Range16.ptr(921, 953, 32), new Range16.ptr(8126, 8126, 1)]), sliceType$1.nil, 0);
		$pkg.FoldScript = $makeMap($String.keyFor, [{ k: "Common", v: foldCommon }, { k: "Greek", v: foldGreek }, { k: "Inherited", v: foldInherited }]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["unicode/utf8"] = (function() {
	var $pkg = {}, $init, acceptRange, first, acceptRanges, FullRune, DecodeRune, DecodeRuneInString, DecodeLastRune, DecodeLastRuneInString, RuneLen, EncodeRune, RuneCount, RuneCountInString, RuneStart, ValidRune;
	acceptRange = $pkg.acceptRange = $newType(0, $kindStruct, "utf8.acceptRange", true, "unicode/utf8", false, function(lo_, hi_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.lo = 0;
			this.hi = 0;
			return;
		}
		this.lo = lo_;
		this.hi = hi_;
	});
	FullRune = function(p) {
		var accept, c, n, p, x, x$1, x$2;
		n = p.$length;
		if (n === 0) {
			return false;
		}
		x$1 = (x = (0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0]), ((x < 0 || x >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[x]));
		if (n >= ((((x$1 & 7) >>> 0) >> 0))) {
			return true;
		}
		accept = $clone((x$2 = x$1 >>> 4 << 24 >>> 24, ((x$2 < 0 || x$2 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$2])), acceptRange);
		if (n > 1) {
			c = (1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]);
			if (c < accept.lo || accept.hi < c) {
				return true;
			} else if (n > 2 && ((2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]) < 128 || 191 < (2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]))) {
				return true;
			}
		}
		return false;
	};
	$pkg.FullRune = FullRune;
	DecodeRune = function(p) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, accept, b1, b2, b3, mask, n, p, p0, r, size, sz, x, x$1;
		r = 0;
		size = 0;
		n = p.$length;
		if (n < 1) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		p0 = (0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0]);
		x = ((p0 < 0 || p0 >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[p0]);
		if (x >= 240) {
			mask = (((x >> 0)) << 31 >> 0) >> 31 >> 0;
			_tmp$2 = (((((0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0]) >> 0)) & ~mask) >> 0) | (65533 & mask);
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		sz = (x & 7) >>> 0;
		accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
		if (n < ((sz >> 0))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		b1 = (1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]);
		if (b1 < accept.lo || accept.hi < b1) {
			_tmp$6 = 65533;
			_tmp$7 = 1;
			r = _tmp$6;
			size = _tmp$7;
			return [r, size];
		}
		if (sz === 2) {
			_tmp$8 = (((((p0 & 31) >>> 0) >> 0)) << 6 >> 0) | ((((b1 & 63) >>> 0) >> 0));
			_tmp$9 = 2;
			r = _tmp$8;
			size = _tmp$9;
			return [r, size];
		}
		b2 = (2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]);
		if (b2 < 128 || 191 < b2) {
			_tmp$10 = 65533;
			_tmp$11 = 1;
			r = _tmp$10;
			size = _tmp$11;
			return [r, size];
		}
		if (sz === 3) {
			_tmp$12 = ((((((p0 & 15) >>> 0) >> 0)) << 12 >> 0) | (((((b1 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((b2 & 63) >>> 0) >> 0));
			_tmp$13 = 3;
			r = _tmp$12;
			size = _tmp$13;
			return [r, size];
		}
		b3 = (3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3]);
		if (b3 < 128 || 191 < b3) {
			_tmp$14 = 65533;
			_tmp$15 = 1;
			r = _tmp$14;
			size = _tmp$15;
			return [r, size];
		}
		_tmp$16 = (((((((p0 & 7) >>> 0) >> 0)) << 18 >> 0) | (((((b1 & 63) >>> 0) >> 0)) << 12 >> 0)) | (((((b2 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((b3 & 63) >>> 0) >> 0));
		_tmp$17 = 4;
		r = _tmp$16;
		size = _tmp$17;
		return [r, size];
	};
	$pkg.DecodeRune = DecodeRune;
	DecodeRuneInString = function(s) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, accept, mask, n, r, s, s0, s1, s2, s3, size, sz, x, x$1;
		r = 0;
		size = 0;
		n = s.length;
		if (n < 1) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		s0 = s.charCodeAt(0);
		x = ((s0 < 0 || s0 >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[s0]);
		if (x >= 240) {
			mask = (((x >> 0)) << 31 >> 0) >> 31 >> 0;
			_tmp$2 = ((((s.charCodeAt(0) >> 0)) & ~mask) >> 0) | (65533 & mask);
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		sz = (x & 7) >>> 0;
		accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
		if (n < ((sz >> 0))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		s1 = s.charCodeAt(1);
		if (s1 < accept.lo || accept.hi < s1) {
			_tmp$6 = 65533;
			_tmp$7 = 1;
			r = _tmp$6;
			size = _tmp$7;
			return [r, size];
		}
		if (sz === 2) {
			_tmp$8 = (((((s0 & 31) >>> 0) >> 0)) << 6 >> 0) | ((((s1 & 63) >>> 0) >> 0));
			_tmp$9 = 2;
			r = _tmp$8;
			size = _tmp$9;
			return [r, size];
		}
		s2 = s.charCodeAt(2);
		if (s2 < 128 || 191 < s2) {
			_tmp$10 = 65533;
			_tmp$11 = 1;
			r = _tmp$10;
			size = _tmp$11;
			return [r, size];
		}
		if (sz === 3) {
			_tmp$12 = ((((((s0 & 15) >>> 0) >> 0)) << 12 >> 0) | (((((s1 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((s2 & 63) >>> 0) >> 0));
			_tmp$13 = 3;
			r = _tmp$12;
			size = _tmp$13;
			return [r, size];
		}
		s3 = s.charCodeAt(3);
		if (s3 < 128 || 191 < s3) {
			_tmp$14 = 65533;
			_tmp$15 = 1;
			r = _tmp$14;
			size = _tmp$15;
			return [r, size];
		}
		_tmp$16 = (((((((s0 & 7) >>> 0) >> 0)) << 18 >> 0) | (((((s1 & 63) >>> 0) >> 0)) << 12 >> 0)) | (((((s2 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((s3 & 63) >>> 0) >> 0));
		_tmp$17 = 4;
		r = _tmp$16;
		size = _tmp$17;
		return [r, size];
	};
	$pkg.DecodeRuneInString = DecodeRuneInString;
	DecodeLastRune = function(p) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, end, lim, p, r, size, start;
		r = 0;
		size = 0;
		end = p.$length;
		if (end === 0) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		start = end - 1 >> 0;
		r = ((((start < 0 || start >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + start]) >> 0));
		if (r < 128) {
			_tmp$2 = r;
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		lim = end - 4 >> 0;
		if (lim < 0) {
			lim = 0;
		}
		start = start - (1) >> 0;
		while (true) {
			if (!(start >= lim)) { break; }
			if (RuneStart(((start < 0 || start >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + start]))) {
				break;
			}
			start = start - (1) >> 0;
		}
		if (start < 0) {
			start = 0;
		}
		_tuple = DecodeRune($subslice(p, start, end));
		r = _tuple[0];
		size = _tuple[1];
		if (!(((start + size >> 0) === end))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		_tmp$6 = r;
		_tmp$7 = size;
		r = _tmp$6;
		size = _tmp$7;
		return [r, size];
	};
	$pkg.DecodeLastRune = DecodeLastRune;
	DecodeLastRuneInString = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, end, lim, r, s, size, start;
		r = 0;
		size = 0;
		end = s.length;
		if (end === 0) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		start = end - 1 >> 0;
		r = ((s.charCodeAt(start) >> 0));
		if (r < 128) {
			_tmp$2 = r;
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		lim = end - 4 >> 0;
		if (lim < 0) {
			lim = 0;
		}
		start = start - (1) >> 0;
		while (true) {
			if (!(start >= lim)) { break; }
			if (RuneStart(s.charCodeAt(start))) {
				break;
			}
			start = start - (1) >> 0;
		}
		if (start < 0) {
			start = 0;
		}
		_tuple = DecodeRuneInString($substring(s, start, end));
		r = _tuple[0];
		size = _tuple[1];
		if (!(((start + size >> 0) === end))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		_tmp$6 = r;
		_tmp$7 = size;
		r = _tmp$6;
		size = _tmp$7;
		return [r, size];
	};
	$pkg.DecodeLastRuneInString = DecodeLastRuneInString;
	RuneLen = function(r) {
		var r;
		if (r < 0) {
			return -1;
		} else if (r <= 127) {
			return 1;
		} else if (r <= 2047) {
			return 2;
		} else if (55296 <= r && r <= 57343) {
			return -1;
		} else if (r <= 65535) {
			return 3;
		} else if (r <= 1114111) {
			return 4;
		}
		return -1;
	};
	$pkg.RuneLen = RuneLen;
	EncodeRune = function(p, r) {
		var i, p, r;
		i = ((r >>> 0));
		if (i <= 127) {
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((r << 24 >>> 24)));
			return 1;
		} else if (i <= 2047) {
			$unused((1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((192 | (((r >> 6 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 2;
		} else if ((i > 1114111) || (55296 <= i && i <= 57343)) {
			r = 65533;
			$unused((2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((224 | (((r >> 12 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 3;
		} else if (i <= 65535) {
			$unused((2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((224 | (((r >> 12 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 3;
		} else {
			$unused((3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((240 | (((r >> 18 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 12 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 4;
		}
	};
	$pkg.EncodeRune = EncodeRune;
	RuneCount = function(p) {
		var accept, c, c$1, c$2, c$3, i, n, np, p, size, x, x$1, x$2, x$3, x$4;
		np = p.$length;
		n = 0;
		i = 0;
		while (true) {
			if (!(i < np)) { break; }
			n = n + (1) >> 0;
			c = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]);
			if (c < 128) {
				i = i + (1) >> 0;
				continue;
			}
			x = ((c < 0 || c >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[c]);
			if (x === 241) {
				i = i + (1) >> 0;
				continue;
			}
			size = ((((x & 7) >>> 0) >> 0));
			if ((i + size >> 0) > np) {
				i = i + (1) >> 0;
				continue;
			}
			accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
			c$1 = (x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$2]));
			if (c$1 < accept.lo || accept.hi < c$1) {
				size = 1;
			} else if (size === 2) {
			} else {
				c$2 = (x$3 = i + 2 >> 0, ((x$3 < 0 || x$3 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$3]));
				if (c$2 < 128 || 191 < c$2) {
					size = 1;
				} else if (size === 3) {
				} else {
					c$3 = (x$4 = i + 3 >> 0, ((x$4 < 0 || x$4 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$4]));
					if (c$3 < 128 || 191 < c$3) {
						size = 1;
					}
				}
			}
			i = i + (size) >> 0;
		}
		return n;
	};
	$pkg.RuneCount = RuneCount;
	RuneCountInString = function(s) {
		var accept, c, c$1, c$2, c$3, i, n, ns, s, size, x, x$1;
		n = 0;
		ns = s.length;
		i = 0;
		while (true) {
			if (!(i < ns)) { break; }
			c = s.charCodeAt(i);
			if (c < 128) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			x = ((c < 0 || c >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[c]);
			if (x === 241) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			size = ((((x & 7) >>> 0) >> 0));
			if ((i + size >> 0) > ns) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
			c$1 = s.charCodeAt((i + 1 >> 0));
			if (c$1 < accept.lo || accept.hi < c$1) {
				size = 1;
			} else if (size === 2) {
			} else {
				c$2 = s.charCodeAt((i + 2 >> 0));
				if (c$2 < 128 || 191 < c$2) {
					size = 1;
				} else if (size === 3) {
				} else {
					c$3 = s.charCodeAt((i + 3 >> 0));
					if (c$3 < 128 || 191 < c$3) {
						size = 1;
					}
				}
			}
			i = i + (size) >> 0;
			n = n + (1) >> 0;
		}
		n = n;
		return n;
	};
	$pkg.RuneCountInString = RuneCountInString;
	RuneStart = function(b) {
		var b;
		return !((((b & 192) >>> 0) === 128));
	};
	$pkg.RuneStart = RuneStart;
	ValidRune = function(r) {
		var r;
		if (0 <= r && r < 55296) {
			return true;
		} else if (57343 < r && r <= 1114111) {
			return true;
		}
		return false;
	};
	$pkg.ValidRune = ValidRune;
	acceptRange.init("unicode/utf8", [{prop: "lo", name: "lo", anonymous: false, exported: false, typ: $Uint8, tag: ""}, {prop: "hi", name: "hi", anonymous: false, exported: false, typ: $Uint8, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		first = $toNativeArray($kindUint8, [240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 19, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 35, 3, 3, 52, 4, 4, 4, 68, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241]);
		acceptRanges = $toNativeArray($kindStruct, [new acceptRange.ptr(128, 191), new acceptRange.ptr(160, 191), new acceptRange.ptr(128, 159), new acceptRange.ptr(144, 191), new acceptRange.ptr(128, 143)]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["bytes"] = (function() {
	var $pkg = {}, $init, errors, io, unicode, utf8, Buffer, readOp, ptrType, sliceType, arrayType, IndexByte, Equal, makeSlice, NewBuffer, Contains, HasPrefix, EqualFold, Index;
	errors = $packages["errors"];
	io = $packages["io"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	Buffer = $pkg.Buffer = $newType(0, $kindStruct, "bytes.Buffer", true, "bytes", true, function(buf_, off_, lastRead_, bootstrap_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = sliceType.nil;
			this.off = 0;
			this.lastRead = 0;
			this.bootstrap = arrayType.zero();
			return;
		}
		this.buf = buf_;
		this.off = off_;
		this.lastRead = lastRead_;
		this.bootstrap = bootstrap_;
	});
	readOp = $pkg.readOp = $newType(4, $kindInt, "bytes.readOp", true, "bytes", false, null);
	ptrType = $ptrType(Buffer);
	sliceType = $sliceType($Uint8);
	arrayType = $arrayType($Uint8, 64);
	IndexByte = function(s, c) {
		var _i, _ref, b, c, i, s;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (b === c) {
				return i;
			}
			_i++;
		}
		return -1;
	};
	$pkg.IndexByte = IndexByte;
	Equal = function(a, b) {
		var _i, _ref, a, b, c, i;
		if (!((a.$length === b.$length))) {
			return false;
		}
		_ref = a;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((c === ((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i])))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	$pkg.Equal = Equal;
	Buffer.ptr.prototype.Bytes = function() {
		var b;
		b = this;
		return $subslice(b.buf, b.off);
	};
	Buffer.prototype.Bytes = function() { return this.$val.Bytes(); };
	Buffer.ptr.prototype.String = function() {
		var b;
		b = this;
		if (b === ptrType.nil) {
			return "<nil>";
		}
		return ($bytesToString($subslice(b.buf, b.off)));
	};
	Buffer.prototype.String = function() { return this.$val.String(); };
	Buffer.ptr.prototype.Len = function() {
		var b;
		b = this;
		return b.buf.$length - b.off >> 0;
	};
	Buffer.prototype.Len = function() { return this.$val.Len(); };
	Buffer.ptr.prototype.Cap = function() {
		var b;
		b = this;
		return b.buf.$capacity;
	};
	Buffer.prototype.Cap = function() { return this.$val.Cap(); };
	Buffer.ptr.prototype.Truncate = function(n) {
		var b, n;
		b = this;
		if (n === 0) {
			b.Reset();
			return;
		}
		b.lastRead = 0;
		if (n < 0 || n > b.Len()) {
			$panic(new $String("bytes.Buffer: truncation out of range"));
		}
		b.buf = $subslice(b.buf, 0, (b.off + n >> 0));
	};
	Buffer.prototype.Truncate = function(n) { return this.$val.Truncate(n); };
	Buffer.ptr.prototype.Reset = function() {
		var b;
		b = this;
		b.buf = $subslice(b.buf, 0, 0);
		b.off = 0;
		b.lastRead = 0;
	};
	Buffer.prototype.Reset = function() { return this.$val.Reset(); };
	Buffer.ptr.prototype.tryGrowByReslice = function(n) {
		var b, l, n;
		b = this;
		l = b.buf.$length;
		if ((l + n >> 0) <= b.buf.$capacity) {
			b.buf = $subslice(b.buf, 0, (l + n >> 0));
			return [l, true];
		}
		return [0, false];
	};
	Buffer.prototype.tryGrowByReslice = function(n) { return this.$val.tryGrowByReslice(n); };
	Buffer.ptr.prototype.grow = function(n) {
		var _q, _tuple, b, buf, i, m, n, ok;
		b = this;
		m = b.Len();
		if ((m === 0) && !((b.off === 0))) {
			b.Reset();
		}
		_tuple = b.tryGrowByReslice(n);
		i = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			return i;
		}
		if (b.buf === sliceType.nil && n <= 64) {
			b.buf = $subslice(new sliceType(b.bootstrap), 0, n);
			return 0;
		}
		if ((m + n >> 0) <= (_q = b.buf.$capacity / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"))) {
			$copySlice(b.buf, $subslice(b.buf, b.off));
		} else {
			buf = makeSlice(($imul(2, b.buf.$capacity)) + n >> 0);
			$copySlice(buf, $subslice(b.buf, b.off));
			b.buf = buf;
		}
		b.off = 0;
		b.buf = $subslice(b.buf, 0, (m + n >> 0));
		return m;
	};
	Buffer.prototype.grow = function(n) { return this.$val.grow(n); };
	Buffer.ptr.prototype.Grow = function(n) {
		var b, m, n;
		b = this;
		if (n < 0) {
			$panic(new $String("bytes.Buffer.Grow: negative count"));
		}
		m = b.grow(n);
		b.buf = $subslice(b.buf, 0, m);
	};
	Buffer.prototype.Grow = function(n) { return this.$val.Grow(n); };
	Buffer.ptr.prototype.Write = function(p) {
		var _tmp, _tmp$1, _tuple, b, err, m, n, ok, p;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(p.$length);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(p.$length);
		}
		_tmp = $copySlice($subslice(b.buf, m), p);
		_tmp$1 = $ifaceNil;
		n = _tmp;
		err = _tmp$1;
		return [n, err];
	};
	Buffer.prototype.Write = function(p) { return this.$val.Write(p); };
	Buffer.ptr.prototype.WriteString = function(s) {
		var _tmp, _tmp$1, _tuple, b, err, m, n, ok, s;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(s.length);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(s.length);
		}
		_tmp = $copyString($subslice(b.buf, m), s);
		_tmp$1 = $ifaceNil;
		n = _tmp;
		err = _tmp$1;
		return [n, err];
	};
	Buffer.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	Buffer.ptr.prototype.ReadFrom = function(r) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, free, m, n, newBuf, r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; free = $f.free; m = $f.m; n = $f.n; newBuf = $f.newBuf; r = $f.r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		if (b.off >= b.buf.$length) {
			b.Reset();
		}
		/* while (true) { */ case 1:
			free = b.buf.$capacity - b.buf.$length >> 0;
			if (free < 512) {
				newBuf = b.buf;
				if ((b.off + free >> 0) < 512) {
					newBuf = makeSlice(($imul(2, b.buf.$capacity)) + 512 >> 0);
				}
				$copySlice(newBuf, $subslice(b.buf, b.off));
				b.buf = $subslice(newBuf, 0, (b.buf.$length - b.off >> 0));
				b.off = 0;
			}
			_r = r.Read($subslice(b.buf, b.buf.$length, b.buf.$capacity)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			b.buf = $subslice(b.buf, 0, (b.buf.$length + m >> 0));
			n = (x = (new $Int64(0, m)), new $Int64(n.$high + x.$high, n.$low + x.$low));
			if ($interfaceIsEqual(e, io.EOF)) {
				/* break; */ $s = 2; continue;
			}
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				_tmp = n;
				_tmp$1 = e;
				n = _tmp;
				err = _tmp$1;
				$s = -1; return [n, err];
			}
		/* } */ $s = 1; continue; case 2:
		_tmp$2 = n;
		_tmp$3 = $ifaceNil;
		n = _tmp$2;
		err = _tmp$3;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Buffer.ptr.prototype.ReadFrom }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.free = free; $f.m = m; $f.n = n; $f.newBuf = newBuf; $f.r = r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Buffer.prototype.ReadFrom = function(r) { return this.$val.ReadFrom(r); };
	makeSlice = function(n) {
		var n, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$deferred.push([(function() {
			if (!($interfaceIsEqual($recover(), $ifaceNil))) {
				$panic($pkg.ErrTooLarge);
			}
		}), []]);
		return $makeSlice(sliceType, n);
		/* */ } catch(err) { $err = err; return sliceType.nil; } finally { $callDeferred($deferred, $err); }
	};
	Buffer.ptr.prototype.WriteTo = function(w) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, m, n, nBytes, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; m = $f.m; n = $f.n; nBytes = $f.nBytes; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		/* */ if (b.off < b.buf.$length) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (b.off < b.buf.$length) { */ case 1:
			nBytes = b.Len();
			_r = w.Write($subslice(b.buf, b.off)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			if (m > nBytes) {
				$panic(new $String("bytes.Buffer.WriteTo: invalid Write count"));
			}
			b.off = b.off + (m) >> 0;
			n = (new $Int64(0, m));
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				_tmp = n;
				_tmp$1 = e;
				n = _tmp;
				err = _tmp$1;
				$s = -1; return [n, err];
			}
			if (!((m === nBytes))) {
				_tmp$2 = n;
				_tmp$3 = io.ErrShortWrite;
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
		/* } */ case 2:
		b.Reset();
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Buffer.ptr.prototype.WriteTo }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.m = m; $f.n = n; $f.nBytes = nBytes; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Buffer.prototype.WriteTo = function(w) { return this.$val.WriteTo(w); };
	Buffer.ptr.prototype.WriteByte = function(c) {
		var _tuple, b, c, m, ok, x;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(1);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(1);
		}
		(x = b.buf, ((m < 0 || m >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + m] = c));
		return $ifaceNil;
	};
	Buffer.prototype.WriteByte = function(c) { return this.$val.WriteByte(c); };
	Buffer.ptr.prototype.WriteRune = function(r) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, err, m, n, ok, r;
		n = 0;
		err = $ifaceNil;
		b = this;
		if (r < 128) {
			b.WriteByte(((r << 24 >>> 24)));
			_tmp = 1;
			_tmp$1 = $ifaceNil;
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(4);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(4);
		}
		n = utf8.EncodeRune($subslice(b.buf, m, (m + 4 >> 0)), r);
		b.buf = $subslice(b.buf, 0, (m + n >> 0));
		_tmp$2 = n;
		_tmp$3 = $ifaceNil;
		n = _tmp$2;
		err = _tmp$3;
		return [n, err];
	};
	Buffer.prototype.WriteRune = function(r) { return this.$val.WriteRune(r); };
	Buffer.ptr.prototype.Read = function(p) {
		var _tmp, _tmp$1, b, err, n, p;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		if (b.off >= b.buf.$length) {
			b.Reset();
			if (p.$length === 0) {
				return [n, err];
			}
			_tmp = 0;
			_tmp$1 = io.EOF;
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		n = $copySlice(p, $subslice(b.buf, b.off));
		b.off = b.off + (n) >> 0;
		if (n > 0) {
			b.lastRead = -1;
		}
		return [n, err];
	};
	Buffer.prototype.Read = function(p) { return this.$val.Read(p); };
	Buffer.ptr.prototype.Next = function(n) {
		var b, data, m, n;
		b = this;
		b.lastRead = 0;
		m = b.Len();
		if (n > m) {
			n = m;
		}
		data = $subslice(b.buf, b.off, (b.off + n >> 0));
		b.off = b.off + (n) >> 0;
		if (n > 0) {
			b.lastRead = -1;
		}
		return data;
	};
	Buffer.prototype.Next = function(n) { return this.$val.Next(n); };
	Buffer.ptr.prototype.ReadByte = function() {
		var b, c, x, x$1;
		b = this;
		b.lastRead = 0;
		if (b.off >= b.buf.$length) {
			b.Reset();
			return [0, io.EOF];
		}
		c = (x = b.buf, x$1 = b.off, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		b.off = b.off + (1) >> 0;
		b.lastRead = -1;
		return [c, $ifaceNil];
	};
	Buffer.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	Buffer.ptr.prototype.ReadRune = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tuple, b, c, err, n, r, size, x, x$1;
		r = 0;
		size = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		if (b.off >= b.buf.$length) {
			b.Reset();
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = io.EOF;
			r = _tmp;
			size = _tmp$1;
			err = _tmp$2;
			return [r, size, err];
		}
		c = (x = b.buf, x$1 = b.off, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (c < 128) {
			b.off = b.off + (1) >> 0;
			b.lastRead = 1;
			_tmp$3 = ((c >> 0));
			_tmp$4 = 1;
			_tmp$5 = $ifaceNil;
			r = _tmp$3;
			size = _tmp$4;
			err = _tmp$5;
			return [r, size, err];
		}
		_tuple = utf8.DecodeRune($subslice(b.buf, b.off));
		r = _tuple[0];
		n = _tuple[1];
		b.off = b.off + (n) >> 0;
		b.lastRead = ((n >> 0));
		_tmp$6 = r;
		_tmp$7 = n;
		_tmp$8 = $ifaceNil;
		r = _tmp$6;
		size = _tmp$7;
		err = _tmp$8;
		return [r, size, err];
	};
	Buffer.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	Buffer.ptr.prototype.UnreadRune = function() {
		var b;
		b = this;
		if (b.lastRead <= 0) {
			return errors.New("bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune");
		}
		if (b.off >= ((b.lastRead >> 0))) {
			b.off = b.off - (((b.lastRead >> 0))) >> 0;
		}
		b.lastRead = 0;
		return $ifaceNil;
	};
	Buffer.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	Buffer.ptr.prototype.UnreadByte = function() {
		var b;
		b = this;
		if (b.lastRead === 0) {
			return errors.New("bytes.Buffer: UnreadByte: previous operation was not a successful read");
		}
		b.lastRead = 0;
		if (b.off > 0) {
			b.off = b.off - (1) >> 0;
		}
		return $ifaceNil;
	};
	Buffer.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Buffer.ptr.prototype.ReadBytes = function(delim) {
		var _tuple, b, delim, err, line, slice;
		line = sliceType.nil;
		err = $ifaceNil;
		b = this;
		_tuple = b.readSlice(delim);
		slice = _tuple[0];
		err = _tuple[1];
		line = $appendSlice(line, slice);
		return [line, err];
	};
	Buffer.prototype.ReadBytes = function(delim) { return this.$val.ReadBytes(delim); };
	Buffer.ptr.prototype.readSlice = function(delim) {
		var _tmp, _tmp$1, b, delim, end, err, i, line;
		line = sliceType.nil;
		err = $ifaceNil;
		b = this;
		i = IndexByte($subslice(b.buf, b.off), delim);
		end = (b.off + i >> 0) + 1 >> 0;
		if (i < 0) {
			end = b.buf.$length;
			err = io.EOF;
		}
		line = $subslice(b.buf, b.off, end);
		b.off = end;
		b.lastRead = -1;
		_tmp = line;
		_tmp$1 = err;
		line = _tmp;
		err = _tmp$1;
		return [line, err];
	};
	Buffer.prototype.readSlice = function(delim) { return this.$val.readSlice(delim); };
	Buffer.ptr.prototype.ReadString = function(delim) {
		var _tmp, _tmp$1, _tuple, b, delim, err, line, slice;
		line = "";
		err = $ifaceNil;
		b = this;
		_tuple = b.readSlice(delim);
		slice = _tuple[0];
		err = _tuple[1];
		_tmp = ($bytesToString(slice));
		_tmp$1 = err;
		line = _tmp;
		err = _tmp$1;
		return [line, err];
	};
	Buffer.prototype.ReadString = function(delim) { return this.$val.ReadString(delim); };
	NewBuffer = function(buf) {
		var buf;
		return new Buffer.ptr(buf, 0, 0, arrayType.zero());
	};
	$pkg.NewBuffer = NewBuffer;
	Contains = function(b, subslice) {
		var b, subslice;
		return !((Index(b, subslice) === -1));
	};
	$pkg.Contains = Contains;
	HasPrefix = function(s, prefix) {
		var prefix, s;
		return s.$length >= prefix.$length && Equal($subslice(s, 0, prefix.$length), prefix);
	};
	$pkg.HasPrefix = HasPrefix;
	EqualFold = function(s, t) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, r, r$1, r$2, s, size, size$1, sr, t, tr;
		while (true) {
			if (!(!((s.$length === 0)) && !((t.$length === 0)))) { break; }
			_tmp = 0;
			_tmp$1 = 0;
			sr = _tmp;
			tr = _tmp$1;
			if ((0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0]) < 128) {
				_tmp$2 = (((0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0]) >> 0));
				_tmp$3 = $subslice(s, 1);
				sr = _tmp$2;
				s = _tmp$3;
			} else {
				_tuple = utf8.DecodeRune(s);
				r = _tuple[0];
				size = _tuple[1];
				_tmp$4 = r;
				_tmp$5 = $subslice(s, size);
				sr = _tmp$4;
				s = _tmp$5;
			}
			if ((0 >= t.$length ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + 0]) < 128) {
				_tmp$6 = (((0 >= t.$length ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + 0]) >> 0));
				_tmp$7 = $subslice(t, 1);
				tr = _tmp$6;
				t = _tmp$7;
			} else {
				_tuple$1 = utf8.DecodeRune(t);
				r$1 = _tuple$1[0];
				size$1 = _tuple$1[1];
				_tmp$8 = r$1;
				_tmp$9 = $subslice(t, size$1);
				tr = _tmp$8;
				t = _tmp$9;
			}
			if (tr === sr) {
				continue;
			}
			if (tr < sr) {
				_tmp$10 = sr;
				_tmp$11 = tr;
				tr = _tmp$10;
				sr = _tmp$11;
			}
			if (tr < 128 && 65 <= sr && sr <= 90) {
				if (tr === ((sr + 97 >> 0) - 65 >> 0)) {
					continue;
				}
				return false;
			}
			r$2 = unicode.SimpleFold(sr);
			while (true) {
				if (!(!((r$2 === sr)) && r$2 < tr)) { break; }
				r$2 = unicode.SimpleFold(r$2);
			}
			if (r$2 === tr) {
				continue;
			}
			return false;
		}
		return s.$length === t.$length;
	};
	$pkg.EqualFold = EqualFold;
	Index = function(s, sep) {
		var c, i, n, o, s, sep, t;
		n = sep.$length;
		if (n === 0) {
			return 0;
		}
		if (n > s.$length) {
			return -1;
		}
		c = (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]);
		if (n === 1) {
			return IndexByte(s, c);
		}
		i = 0;
		t = $subslice(s, 0, ((s.$length - n >> 0) + 1 >> 0));
		while (true) {
			if (!(i < t.$length)) { break; }
			if (!((((i < 0 || i >= t.$length) ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + i]) === c))) {
				o = IndexByte($subslice(t, i), c);
				if (o < 0) {
					break;
				}
				i = i + (o) >> 0;
			}
			if (Equal($subslice(s, i, (i + n >> 0)), sep)) {
				return i;
			}
			i = i + (1) >> 0;
		}
		return -1;
	};
	$pkg.Index = Index;
	ptrType.methods = [{prop: "Bytes", name: "Bytes", pkg: "", typ: $funcType([], [sliceType], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Truncate", name: "Truncate", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [], false)}, {prop: "tryGrowByReslice", name: "tryGrowByReslice", pkg: "bytes", typ: $funcType([$Int], [$Int, $Bool], false)}, {prop: "grow", name: "grow", pkg: "bytes", typ: $funcType([$Int], [$Int], false)}, {prop: "Grow", name: "Grow", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}, {prop: "ReadFrom", name: "ReadFrom", pkg: "", typ: $funcType([io.Reader], [$Int64, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([io.Writer], [$Int64, $error], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [$error], false)}, {prop: "WriteRune", name: "WriteRune", pkg: "", typ: $funcType([$Int32], [$Int, $error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "Next", name: "Next", pkg: "", typ: $funcType([$Int], [sliceType], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReadBytes", name: "ReadBytes", pkg: "", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "readSlice", name: "readSlice", pkg: "bytes", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "ReadString", name: "ReadString", pkg: "", typ: $funcType([$Uint8], [$String, $error], false)}];
	Buffer.init("bytes", [{prop: "buf", name: "buf", anonymous: false, exported: false, typ: sliceType, tag: ""}, {prop: "off", name: "off", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "lastRead", name: "lastRead", anonymous: false, exported: false, typ: readOp, tag: ""}, {prop: "bootstrap", name: "bootstrap", anonymous: false, exported: false, typ: arrayType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrTooLarge = errors.New("bytes.Buffer: too large");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["bufio"] = (function() {
	var $pkg = {}, $init, bytes, errors, io, utf8, Reader, Writer, sliceType, ptrType, sliceType$1, ptrType$1, errNegativeRead, errNegativeWrite, NewReaderSize, NewReader, NewWriterSize, NewWriter;
	bytes = $packages["bytes"];
	errors = $packages["errors"];
	io = $packages["io"];
	utf8 = $packages["unicode/utf8"];
	Reader = $pkg.Reader = $newType(0, $kindStruct, "bufio.Reader", true, "bufio", true, function(buf_, rd_, r_, w_, err_, lastByte_, lastRuneSize_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = sliceType.nil;
			this.rd = $ifaceNil;
			this.r = 0;
			this.w = 0;
			this.err = $ifaceNil;
			this.lastByte = 0;
			this.lastRuneSize = 0;
			return;
		}
		this.buf = buf_;
		this.rd = rd_;
		this.r = r_;
		this.w = w_;
		this.err = err_;
		this.lastByte = lastByte_;
		this.lastRuneSize = lastRuneSize_;
	});
	Writer = $pkg.Writer = $newType(0, $kindStruct, "bufio.Writer", true, "bufio", true, function(err_, buf_, n_, wr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.err = $ifaceNil;
			this.buf = sliceType.nil;
			this.n = 0;
			this.wr = $ifaceNil;
			return;
		}
		this.err = err_;
		this.buf = buf_;
		this.n = n_;
		this.wr = wr_;
	});
	sliceType = $sliceType($Uint8);
	ptrType = $ptrType(Reader);
	sliceType$1 = $sliceType(sliceType);
	ptrType$1 = $ptrType(Writer);
	NewReaderSize = function(rd, size) {
		var _tuple, b, ok, r, rd, size;
		_tuple = $assertType(rd, ptrType, true);
		b = _tuple[0];
		ok = _tuple[1];
		if (ok && b.buf.$length >= size) {
			return b;
		}
		if (size < 16) {
			size = 16;
		}
		r = new Reader.ptr(sliceType.nil, $ifaceNil, 0, 0, $ifaceNil, 0, 0);
		r.reset($makeSlice(sliceType, size), rd);
		return r;
	};
	$pkg.NewReaderSize = NewReaderSize;
	NewReader = function(rd) {
		var rd;
		return NewReaderSize(rd, 4096);
	};
	$pkg.NewReader = NewReader;
	Reader.ptr.prototype.Reset = function(r) {
		var b, r;
		b = this;
		b.reset(b.buf, r);
	};
	Reader.prototype.Reset = function(r) { return this.$val.Reset(r); };
	Reader.ptr.prototype.reset = function(buf, r) {
		var b, buf, r;
		b = this;
		Reader.copy(b, new Reader.ptr(buf, r, 0, 0, $ifaceNil, -1, -1));
	};
	Reader.prototype.reset = function(buf, r) { return this.$val.reset(buf, r); };
	Reader.ptr.prototype.fill = function() {
		var _r, _tuple, b, err, i, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; err = $f.err; i = $f.i; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		if (b.r > 0) {
			$copySlice(b.buf, $subslice(b.buf, b.r, b.w));
			b.w = b.w - (b.r) >> 0;
			b.r = 0;
		}
		if (b.w >= b.buf.$length) {
			$panic(new $String("bufio: tried to fill full buffer"));
		}
		i = 100;
		/* while (true) { */ case 1:
			/* if (!(i > 0)) { break; } */ if(!(i > 0)) { $s = 2; continue; }
			_r = b.rd.Read($subslice(b.buf, b.w)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			n = _tuple[0];
			err = _tuple[1];
			if (n < 0) {
				$panic(errNegativeRead);
			}
			b.w = b.w + (n) >> 0;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				b.err = err;
				$s = -1; return;
			}
			if (n > 0) {
				$s = -1; return;
			}
			i = i - (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		b.err = io.ErrNoProgress;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.fill }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.i = i; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.fill = function() { return this.$val.fill(); };
	Reader.ptr.prototype.readErr = function() {
		var b, err;
		b = this;
		err = b.err;
		b.err = $ifaceNil;
		return err;
	};
	Reader.prototype.readErr = function() { return this.$val.readErr(); };
	Reader.ptr.prototype.Peek = function(n) {
		var avail, b, err, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; avail = $f.avail; b = $f.b; err = $f.err; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		if (n < 0) {
			$s = -1; return [sliceType.nil, $pkg.ErrNegativeCount];
		}
		/* while (true) { */ case 1:
			/* if (!((b.w - b.r >> 0) < n && (b.w - b.r >> 0) < b.buf.$length && $interfaceIsEqual(b.err, $ifaceNil))) { break; } */ if(!((b.w - b.r >> 0) < n && (b.w - b.r >> 0) < b.buf.$length && $interfaceIsEqual(b.err, $ifaceNil))) { $s = 2; continue; }
			$r = b.fill(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		if (n > b.buf.$length) {
			$s = -1; return [$subslice(b.buf, b.r, b.w), $pkg.ErrBufferFull];
		}
		err = $ifaceNil;
		avail = b.w - b.r >> 0;
		if (avail < n) {
			n = avail;
			err = b.readErr();
			if ($interfaceIsEqual(err, $ifaceNil)) {
				err = $pkg.ErrBufferFull;
			}
		}
		$s = -1; return [$subslice(b.buf, b.r, (b.r + n >> 0)), err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.Peek }; } $f.avail = avail; $f.b = b; $f.err = err; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.Peek = function(n) { return this.$val.Peek(n); };
	Reader.ptr.prototype.Discard = function(n) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, discarded, err, n, remain, skip, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; b = $f.b; discarded = $f.discarded; err = $f.err; n = $f.n; remain = $f.remain; skip = $f.skip; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		discarded = 0;
		err = $ifaceNil;
		b = this;
		if (n < 0) {
			_tmp = 0;
			_tmp$1 = $pkg.ErrNegativeCount;
			discarded = _tmp;
			err = _tmp$1;
			$s = -1; return [discarded, err];
		}
		if (n === 0) {
			$s = -1; return [discarded, err];
		}
		remain = n;
		/* while (true) { */ case 1:
			skip = b.Buffered();
			/* */ if (skip === 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (skip === 0) { */ case 3:
				$r = b.fill(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				skip = b.Buffered();
			/* } */ case 4:
			if (skip > remain) {
				skip = remain;
			}
			b.r = b.r + (skip) >> 0;
			remain = remain - (skip) >> 0;
			if (remain === 0) {
				_tmp$2 = n;
				_tmp$3 = $ifaceNil;
				discarded = _tmp$2;
				err = _tmp$3;
				$s = -1; return [discarded, err];
			}
			if (!($interfaceIsEqual(b.err, $ifaceNil))) {
				_tmp$4 = n - remain >> 0;
				_tmp$5 = b.readErr();
				discarded = _tmp$4;
				err = _tmp$5;
				$s = -1; return [discarded, err];
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [discarded, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.Discard }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f.b = b; $f.discarded = discarded; $f.err = err; $f.n = n; $f.remain = remain; $f.skip = skip; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.Discard = function(n) { return this.$val.Discard(n); };
	Reader.ptr.prototype.Read = function(p) {
		var _r, _r$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, b, err, n, p, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; b = $f.b; err = $f.err; n = $f.n; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		b = this;
		n = p.$length;
		if (n === 0) {
			_tmp = 0;
			_tmp$1 = b.readErr();
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		/* */ if (b.r === b.w) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (b.r === b.w) { */ case 1:
			if (!($interfaceIsEqual(b.err, $ifaceNil))) {
				_tmp$2 = 0;
				_tmp$3 = b.readErr();
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
			/* */ if (p.$length >= b.buf.$length) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (p.$length >= b.buf.$length) { */ case 3:
				_r = b.rd.Read(p); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				n = _tuple[0];
				b.err = _tuple[1];
				if (n < 0) {
					$panic(errNegativeRead);
				}
				if (n > 0) {
					b.lastByte = (((x = n - 1 >> 0, ((x < 0 || x >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x])) >> 0));
					b.lastRuneSize = -1;
				}
				_tmp$4 = n;
				_tmp$5 = b.readErr();
				n = _tmp$4;
				err = _tmp$5;
				$s = -1; return [n, err];
			/* } */ case 4:
			b.r = 0;
			b.w = 0;
			_r$1 = b.rd.Read(b.buf); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			n = _tuple$1[0];
			b.err = _tuple$1[1];
			if (n < 0) {
				$panic(errNegativeRead);
			}
			if (n === 0) {
				_tmp$6 = 0;
				_tmp$7 = b.readErr();
				n = _tmp$6;
				err = _tmp$7;
				$s = -1; return [n, err];
			}
			b.w = b.w + (n) >> 0;
		/* } */ case 2:
		n = $copySlice(p, $subslice(b.buf, b.r, b.w));
		b.r = b.r + (n) >> 0;
		b.lastByte = (((x$1 = b.buf, x$2 = b.r - 1 >> 0, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2])) >> 0));
		b.lastRuneSize = -1;
		_tmp$8 = n;
		_tmp$9 = $ifaceNil;
		n = _tmp$8;
		err = _tmp$9;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.Read }; } $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.b = b; $f.err = err; $f.n = n; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.Read = function(p) { return this.$val.Read(p); };
	Reader.ptr.prototype.ReadByte = function() {
		var b, c, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; c = $f.c; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		b.lastRuneSize = -1;
		/* while (true) { */ case 1:
			/* if (!(b.r === b.w)) { break; } */ if(!(b.r === b.w)) { $s = 2; continue; }
			if (!($interfaceIsEqual(b.err, $ifaceNil))) {
				$s = -1; return [0, b.readErr()];
			}
			$r = b.fill(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		c = (x = b.buf, x$1 = b.r, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		b.r = b.r + (1) >> 0;
		b.lastByte = ((c >> 0));
		$s = -1; return [c, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadByte }; } $f.b = b; $f.c = c; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	Reader.ptr.prototype.UnreadByte = function() {
		var b, x, x$1;
		b = this;
		if (b.lastByte < 0 || (b.r === 0) && b.w > 0) {
			return $pkg.ErrInvalidUnreadByte;
		}
		if (b.r > 0) {
			b.r = b.r - (1) >> 0;
		} else {
			b.w = 1;
		}
		(x = b.buf, x$1 = b.r, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1] = ((b.lastByte << 24 >>> 24))));
		b.lastByte = -1;
		b.lastRuneSize = -1;
		return $ifaceNil;
	};
	Reader.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Reader.ptr.prototype.ReadRune = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, b, err, r, size, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tuple = $f._tuple; b = $f.b; err = $f.err; r = $f.r; size = $f.size; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = 0;
		size = 0;
		err = $ifaceNil;
		b = this;
		/* while (true) { */ case 1:
			/* if (!((b.r + 4 >> 0) > b.w && !utf8.FullRune($subslice(b.buf, b.r, b.w)) && $interfaceIsEqual(b.err, $ifaceNil) && (b.w - b.r >> 0) < b.buf.$length)) { break; } */ if(!((b.r + 4 >> 0) > b.w && !utf8.FullRune($subslice(b.buf, b.r, b.w)) && $interfaceIsEqual(b.err, $ifaceNil) && (b.w - b.r >> 0) < b.buf.$length)) { $s = 2; continue; }
			$r = b.fill(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		b.lastRuneSize = -1;
		if (b.r === b.w) {
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = b.readErr();
			r = _tmp;
			size = _tmp$1;
			err = _tmp$2;
			$s = -1; return [r, size, err];
		}
		_tmp$3 = (((x = b.buf, x$1 = b.r, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])) >> 0));
		_tmp$4 = 1;
		r = _tmp$3;
		size = _tmp$4;
		if (r >= 128) {
			_tuple = utf8.DecodeRune($subslice(b.buf, b.r, b.w));
			r = _tuple[0];
			size = _tuple[1];
		}
		b.r = b.r + (size) >> 0;
		b.lastByte = (((x$2 = b.buf, x$3 = b.r - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])) >> 0));
		b.lastRuneSize = size;
		_tmp$5 = r;
		_tmp$6 = size;
		_tmp$7 = $ifaceNil;
		r = _tmp$5;
		size = _tmp$6;
		err = _tmp$7;
		$s = -1; return [r, size, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadRune }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.r = r; $f.size = size; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	Reader.ptr.prototype.UnreadRune = function() {
		var b;
		b = this;
		if (b.lastRuneSize < 0 || b.r < b.lastRuneSize) {
			return $pkg.ErrInvalidUnreadRune;
		}
		b.r = b.r - (b.lastRuneSize) >> 0;
		b.lastByte = -1;
		b.lastRuneSize = -1;
		return $ifaceNil;
	};
	Reader.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	Reader.ptr.prototype.Buffered = function() {
		var b;
		b = this;
		return b.w - b.r >> 0;
	};
	Reader.prototype.Buffered = function() { return this.$val.Buffered(); };
	Reader.ptr.prototype.ReadSlice = function(delim) {
		var b, delim, err, i, i$1, line, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; delim = $f.delim; err = $f.err; i = $f.i; i$1 = $f.i$1; line = $f.line; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		line = sliceType.nil;
		err = $ifaceNil;
		b = this;
		/* while (true) { */ case 1:
			i = bytes.IndexByte($subslice(b.buf, b.r, b.w), delim);
			if (i >= 0) {
				line = $subslice(b.buf, b.r, ((b.r + i >> 0) + 1 >> 0));
				b.r = b.r + ((i + 1 >> 0)) >> 0;
				/* break; */ $s = 2; continue;
			}
			if (!($interfaceIsEqual(b.err, $ifaceNil))) {
				line = $subslice(b.buf, b.r, b.w);
				b.r = b.w;
				err = b.readErr();
				/* break; */ $s = 2; continue;
			}
			if (b.Buffered() >= b.buf.$length) {
				b.r = b.w;
				line = b.buf;
				err = $pkg.ErrBufferFull;
				/* break; */ $s = 2; continue;
			}
			$r = b.fill(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		i$1 = line.$length - 1 >> 0;
		if (i$1 >= 0) {
			b.lastByte = ((((i$1 < 0 || i$1 >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + i$1]) >> 0));
			b.lastRuneSize = -1;
		}
		$s = -1; return [line, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadSlice }; } $f.b = b; $f.delim = delim; $f.err = err; $f.i = i; $f.i$1 = i$1; $f.line = line; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadSlice = function(delim) { return this.$val.ReadSlice(delim); };
	Reader.ptr.prototype.ReadLine = function() {
		var _r, _tmp, _tmp$1, _tmp$2, _tuple, b, drop, err, isPrefix, line, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tuple = $f._tuple; b = $f.b; drop = $f.drop; err = $f.err; isPrefix = $f.isPrefix; line = $f.line; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		line = sliceType.nil;
		isPrefix = false;
		err = $ifaceNil;
		b = this;
		_r = b.ReadSlice(10); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		line = _tuple[0];
		err = _tuple[1];
		if ($interfaceIsEqual(err, $pkg.ErrBufferFull)) {
			if (line.$length > 0 && ((x = line.$length - 1 >> 0, ((x < 0 || x >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + x])) === 13)) {
				if (b.r === 0) {
					$panic(new $String("bufio: tried to rewind past start of buffer"));
				}
				b.r = b.r - (1) >> 0;
				line = $subslice(line, 0, (line.$length - 1 >> 0));
			}
			_tmp = line;
			_tmp$1 = true;
			_tmp$2 = $ifaceNil;
			line = _tmp;
			isPrefix = _tmp$1;
			err = _tmp$2;
			$s = -1; return [line, isPrefix, err];
		}
		if (line.$length === 0) {
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				line = sliceType.nil;
			}
			$s = -1; return [line, isPrefix, err];
		}
		err = $ifaceNil;
		if ((x$1 = line.$length - 1 >> 0, ((x$1 < 0 || x$1 >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + x$1])) === 10) {
			drop = 1;
			if (line.$length > 1 && ((x$2 = line.$length - 2 >> 0, ((x$2 < 0 || x$2 >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + x$2])) === 13)) {
				drop = 2;
			}
			line = $subslice(line, 0, (line.$length - drop >> 0));
		}
		$s = -1; return [line, isPrefix, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadLine }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tuple = _tuple; $f.b = b; $f.drop = drop; $f.err = err; $f.isPrefix = isPrefix; $f.line = line; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadLine = function() { return this.$val.ReadLine(); };
	Reader.ptr.prototype.ReadBytes = function(delim) {
		var _i, _i$1, _r, _ref, _ref$1, _tuple, b, buf, buf$1, delim, e, err, frag, full, i, i$1, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; _tuple = $f._tuple; b = $f.b; buf = $f.buf; buf$1 = $f.buf$1; delim = $f.delim; e = $f.e; err = $f.err; frag = $f.frag; full = $f.full; i = $f.i; i$1 = $f.i$1; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		frag = sliceType.nil;
		full = sliceType$1.nil;
		err = $ifaceNil;
		/* while (true) { */ case 1:
			e = $ifaceNil;
			_r = b.ReadSlice(delim); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			frag = _tuple[0];
			e = _tuple[1];
			if ($interfaceIsEqual(e, $ifaceNil)) {
				/* break; */ $s = 2; continue;
			}
			if (!($interfaceIsEqual(e, $pkg.ErrBufferFull))) {
				err = e;
				/* break; */ $s = 2; continue;
			}
			buf = $makeSlice(sliceType, frag.$length);
			$copySlice(buf, frag);
			full = $append(full, buf);
		/* } */ $s = 1; continue; case 2:
		n = 0;
		_ref = full;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			n = n + (((i < 0 || i >= full.$length) ? ($throwRuntimeError("index out of range"), undefined) : full.$array[full.$offset + i]).$length) >> 0;
			_i++;
		}
		n = n + (frag.$length) >> 0;
		buf$1 = $makeSlice(sliceType, n);
		n = 0;
		_ref$1 = full;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			n = n + ($copySlice($subslice(buf$1, n), ((i$1 < 0 || i$1 >= full.$length) ? ($throwRuntimeError("index out of range"), undefined) : full.$array[full.$offset + i$1]))) >> 0;
			_i$1++;
		}
		$copySlice($subslice(buf$1, n), frag);
		$s = -1; return [buf$1, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadBytes }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tuple = _tuple; $f.b = b; $f.buf = buf; $f.buf$1 = buf$1; $f.delim = delim; $f.e = e; $f.err = err; $f.frag = frag; $f.full = full; $f.i = i; $f.i$1 = i$1; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadBytes = function(delim) { return this.$val.ReadBytes(delim); };
	Reader.ptr.prototype.ReadString = function(delim) {
		var _r, _tuple, b, bytes$1, delim, err, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; bytes$1 = $f.bytes$1; delim = $f.delim; err = $f.err; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		_r = b.ReadBytes(delim); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		bytes$1 = _tuple[0];
		err = _tuple[1];
		$s = -1; return [($bytesToString(bytes$1)), err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadString }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.bytes$1 = bytes$1; $f.delim = delim; $f.err = err; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadString = function(delim) { return this.$val.ReadString(delim); };
	Reader.ptr.prototype.WriteTo = function(w) {
		var _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, b, err, err$1, err$2, err$3, m, m$1, m$2, n, ok, ok$1, r, w, w$1, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; b = $f.b; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; m = $f.m; m$1 = $f.m$1; m$2 = $f.m$2; n = $f.n; ok = $f.ok; ok$1 = $f.ok$1; r = $f.r; w = $f.w; w$1 = $f.w$1; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		_r = b.writeBuf(w); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [n, err];
		}
		_tuple$1 = $assertType(b.rd, io.WriterTo, true);
		r = _tuple$1[0];
		ok = _tuple$1[1];
		/* */ if (ok) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (ok) { */ case 2:
			_r$1 = r.WriteTo(w); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$2 = _r$1;
			m = _tuple$2[0];
			err$1 = _tuple$2[1];
			n = (x = m, new $Int64(n.$high + x.$high, n.$low + x.$low));
			_tmp = n;
			_tmp$1 = err$1;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		/* } */ case 3:
		_tuple$3 = $assertType(w, io.ReaderFrom, true);
		w$1 = _tuple$3[0];
		ok$1 = _tuple$3[1];
		/* */ if (ok$1) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (ok$1) { */ case 5:
			_r$2 = w$1.ReadFrom(b.rd); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_tuple$4 = _r$2;
			m$1 = _tuple$4[0];
			err$2 = _tuple$4[1];
			n = (x$1 = m$1, new $Int64(n.$high + x$1.$high, n.$low + x$1.$low));
			_tmp$2 = n;
			_tmp$3 = err$2;
			n = _tmp$2;
			err = _tmp$3;
			$s = -1; return [n, err];
		/* } */ case 6:
		/* */ if ((b.w - b.r >> 0) < b.buf.$length) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if ((b.w - b.r >> 0) < b.buf.$length) { */ case 8:
			$r = b.fill(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 9:
		/* while (true) { */ case 11:
			/* if (!(b.r < b.w)) { break; } */ if(!(b.r < b.w)) { $s = 12; continue; }
			_r$3 = b.writeBuf(w); /* */ $s = 13; case 13: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			_tuple$5 = _r$3;
			m$2 = _tuple$5[0];
			err$3 = _tuple$5[1];
			n = (x$2 = m$2, new $Int64(n.$high + x$2.$high, n.$low + x$2.$low));
			if (!($interfaceIsEqual(err$3, $ifaceNil))) {
				_tmp$4 = n;
				_tmp$5 = err$3;
				n = _tmp$4;
				err = _tmp$5;
				$s = -1; return [n, err];
			}
			$r = b.fill(); /* */ $s = 14; case 14: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 11; continue; case 12:
		if ($interfaceIsEqual(b.err, io.EOF)) {
			b.err = $ifaceNil;
		}
		_tmp$6 = n;
		_tmp$7 = b.readErr();
		n = _tmp$6;
		err = _tmp$7;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.WriteTo }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.b = b; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.m = m; $f.m$1 = m$1; $f.m$2 = m$2; $f.n = n; $f.ok = ok; $f.ok$1 = ok$1; $f.r = r; $f.w = w; $f.w$1 = w$1; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.WriteTo = function(w) { return this.$val.WriteTo(w); };
	Reader.ptr.prototype.writeBuf = function(w) {
		var _r, _tuple, b, err, n, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; err = $f.err; n = $f.n; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		_r = w.Write($subslice(b.buf, b.r, b.w)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		if (n < 0) {
			$panic(errNegativeWrite);
		}
		b.r = b.r + (n) >> 0;
		$s = -1; return [(new $Int64(0, n)), err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.writeBuf }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.n = n; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.writeBuf = function(w) { return this.$val.writeBuf(w); };
	NewWriterSize = function(w, size) {
		var _tuple, b, ok, size, w;
		_tuple = $assertType(w, ptrType$1, true);
		b = _tuple[0];
		ok = _tuple[1];
		if (ok && b.buf.$length >= size) {
			return b;
		}
		if (size <= 0) {
			size = 4096;
		}
		return new Writer.ptr($ifaceNil, $makeSlice(sliceType, size), 0, w);
	};
	$pkg.NewWriterSize = NewWriterSize;
	NewWriter = function(w) {
		var w;
		return NewWriterSize(w, 4096);
	};
	$pkg.NewWriter = NewWriter;
	Writer.ptr.prototype.Reset = function(w) {
		var b, w;
		b = this;
		b.err = $ifaceNil;
		b.n = 0;
		b.wr = w;
	};
	Writer.prototype.Reset = function(w) { return this.$val.Reset(w); };
	Writer.ptr.prototype.Flush = function() {
		var _r, _tuple, b, err, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; err = $f.err; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		if (!($interfaceIsEqual(b.err, $ifaceNil))) {
			$s = -1; return b.err;
		}
		if (b.n === 0) {
			$s = -1; return $ifaceNil;
		}
		_r = b.wr.Write($subslice(b.buf, 0, b.n)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		if (n < b.n && $interfaceIsEqual(err, $ifaceNil)) {
			err = io.ErrShortWrite;
		}
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			if (n > 0 && n < b.n) {
				$copySlice($subslice(b.buf, 0, (b.n - n >> 0)), $subslice(b.buf, n, b.n));
			}
			b.n = b.n - (n) >> 0;
			b.err = err;
			$s = -1; return err;
		}
		b.n = 0;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.Flush }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.Flush = function() { return this.$val.Flush(); };
	Writer.ptr.prototype.Available = function() {
		var b;
		b = this;
		return b.buf.$length - b.n >> 0;
	};
	Writer.prototype.Available = function() { return this.$val.Available(); };
	Writer.ptr.prototype.Buffered = function() {
		var b;
		b = this;
		return b.n;
	};
	Writer.prototype.Buffered = function() { return this.$val.Buffered(); };
	Writer.ptr.prototype.Write = function(p) {
		var _r, _r$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, err, n, n$1, nn, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; err = $f.err; n = $f.n; n$1 = $f.n$1; nn = $f.nn; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		nn = 0;
		err = $ifaceNil;
		b = this;
		/* while (true) { */ case 1:
			/* if (!(p.$length > b.Available() && $interfaceIsEqual(b.err, $ifaceNil))) { break; } */ if(!(p.$length > b.Available() && $interfaceIsEqual(b.err, $ifaceNil))) { $s = 2; continue; }
			n = 0;
			/* */ if (b.Buffered() === 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (b.Buffered() === 0) { */ case 3:
				_r = b.wr.Write(p); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				n = _tuple[0];
				b.err = _tuple[1];
				$s = 5; continue;
			/* } else { */ case 4:
				n = $copySlice($subslice(b.buf, b.n), p);
				b.n = b.n + (n) >> 0;
				_r$1 = b.Flush(); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_r$1;
			/* } */ case 5:
			nn = nn + (n) >> 0;
			p = $subslice(p, n);
		/* } */ $s = 1; continue; case 2:
		if (!($interfaceIsEqual(b.err, $ifaceNil))) {
			_tmp = nn;
			_tmp$1 = b.err;
			nn = _tmp;
			err = _tmp$1;
			$s = -1; return [nn, err];
		}
		n$1 = $copySlice($subslice(b.buf, b.n), p);
		b.n = b.n + (n$1) >> 0;
		nn = nn + (n$1) >> 0;
		_tmp$2 = nn;
		_tmp$3 = $ifaceNil;
		nn = _tmp$2;
		err = _tmp$3;
		$s = -1; return [nn, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.Write }; } $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.n = n; $f.n$1 = n$1; $f.nn = nn; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.Write = function(p) { return this.$val.Write(p); };
	Writer.ptr.prototype.WriteByte = function(c) {
		var _r, _v, b, c, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _v = $f._v; b = $f.b; c = $f.c; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		if (!($interfaceIsEqual(b.err, $ifaceNil))) {
			$s = -1; return b.err;
		}
		if (!(b.Available() <= 0)) { _v = false; $s = 3; continue s; }
		_r = b.Flush(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_v = !($interfaceIsEqual(_r, $ifaceNil)); case 3:
		/* */ if (_v) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_v) { */ case 1:
			$s = -1; return b.err;
		/* } */ case 2:
		(x = b.buf, x$1 = b.n, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1] = c));
		b.n = b.n + (1) >> 0;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.WriteByte }; } $f._r = _r; $f._v = _v; $f.b = b; $f.c = c; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.WriteByte = function(c) { return this.$val.WriteByte(c); };
	Writer.ptr.prototype.WriteRune = function(r) {
		var _r, _r$1, _r$2, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, b, err, n, r, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; b = $f.b; err = $f.err; n = $f.n; r = $f.r; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		size = 0;
		err = $ifaceNil;
		b = this;
		/* */ if (r < 128) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r < 128) { */ case 1:
			_r = b.WriteByte(((r << 24 >>> 24))); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			err = _r;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp = 0;
				_tmp$1 = err;
				size = _tmp;
				err = _tmp$1;
				$s = -1; return [size, err];
			}
			_tmp$2 = 1;
			_tmp$3 = $ifaceNil;
			size = _tmp$2;
			err = _tmp$3;
			$s = -1; return [size, err];
		/* } */ case 2:
		if (!($interfaceIsEqual(b.err, $ifaceNil))) {
			_tmp$4 = 0;
			_tmp$5 = b.err;
			size = _tmp$4;
			err = _tmp$5;
			$s = -1; return [size, err];
		}
		n = b.Available();
		/* */ if (n < 4) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (n < 4) { */ case 4:
			_r$1 = b.Flush(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$1;
			if (!($interfaceIsEqual(b.err, $ifaceNil))) {
				_tmp$6 = 0;
				_tmp$7 = b.err;
				size = _tmp$6;
				err = _tmp$7;
				$s = -1; return [size, err];
			}
			n = b.Available();
			/* */ if (n < 4) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (n < 4) { */ case 7:
				_r$2 = b.WriteString(($encodeRune(r))); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_tuple = _r$2;
				size = _tuple[0];
				err = _tuple[1];
				$s = -1; return [size, err];
			/* } */ case 8:
		/* } */ case 5:
		size = utf8.EncodeRune($subslice(b.buf, b.n), r);
		b.n = b.n + (size) >> 0;
		_tmp$8 = size;
		_tmp$9 = $ifaceNil;
		size = _tmp$8;
		err = _tmp$9;
		$s = -1; return [size, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.WriteRune }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.n = n; $f.r = r; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.WriteRune = function(r) { return this.$val.WriteRune(r); };
	Writer.ptr.prototype.WriteString = function(s) {
		var _r, b, n, n$1, nn, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; n = $f.n; n$1 = $f.n$1; nn = $f.nn; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		nn = 0;
		/* while (true) { */ case 1:
			/* if (!(s.length > b.Available() && $interfaceIsEqual(b.err, $ifaceNil))) { break; } */ if(!(s.length > b.Available() && $interfaceIsEqual(b.err, $ifaceNil))) { $s = 2; continue; }
			n = $copyString($subslice(b.buf, b.n), s);
			b.n = b.n + (n) >> 0;
			nn = nn + (n) >> 0;
			s = $substring(s, n);
			_r = b.Flush(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
		/* } */ $s = 1; continue; case 2:
		if (!($interfaceIsEqual(b.err, $ifaceNil))) {
			$s = -1; return [nn, b.err];
		}
		n$1 = $copyString($subslice(b.buf, b.n), s);
		b.n = b.n + (n$1) >> 0;
		nn = nn + (n$1) >> 0;
		$s = -1; return [nn, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.WriteString }; } $f._r = _r; $f.b = b; $f.n = n; $f.n$1 = n$1; $f.nn = nn; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	Writer.ptr.prototype.ReadFrom = function(r) {
		var _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, _tuple$2, b, err, err1, m, n, nr, ok, r, w, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; b = $f.b; err = $f.err; err1 = $f.err1; m = $f.m; n = $f.n; nr = $f.nr; ok = $f.ok; r = $f.r; w = $f.w; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		/* */ if (b.Buffered() === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (b.Buffered() === 0) { */ case 1:
			_tuple = $assertType(b.wr, io.ReaderFrom, true);
			w = _tuple[0];
			ok = _tuple[1];
			/* */ if (ok) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (ok) { */ case 3:
				_r = w.ReadFrom(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple$1 = _r;
				n = _tuple$1[0];
				err = _tuple$1[1];
				$s = -1; return [n, err];
			/* } */ case 4:
		/* } */ case 2:
		m = 0;
		/* while (true) { */ case 6:
			/* */ if (b.Available() === 0) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (b.Available() === 0) { */ case 8:
				_r$1 = b.Flush(); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				err1 = _r$1;
				if (!($interfaceIsEqual(err1, $ifaceNil))) {
					_tmp = n;
					_tmp$1 = err1;
					n = _tmp;
					err = _tmp$1;
					$s = -1; return [n, err];
				}
			/* } */ case 9:
			nr = 0;
			/* while (true) { */ case 11:
				/* if (!(nr < 100)) { break; } */ if(!(nr < 100)) { $s = 12; continue; }
				_r$2 = r.Read($subslice(b.buf, b.n)); /* */ $s = 13; case 13: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_tuple$2 = _r$2;
				m = _tuple$2[0];
				err = _tuple$2[1];
				if (!((m === 0)) || !($interfaceIsEqual(err, $ifaceNil))) {
					/* break; */ $s = 12; continue;
				}
				nr = nr + (1) >> 0;
			/* } */ $s = 11; continue; case 12:
			if (nr === 100) {
				_tmp$2 = n;
				_tmp$3 = io.ErrNoProgress;
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
			b.n = b.n + (m) >> 0;
			n = (x = (new $Int64(0, m)), new $Int64(n.$high + x.$high, n.$low + x.$low));
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				/* break; */ $s = 7; continue;
			}
		/* } */ $s = 6; continue; case 7:
		/* */ if ($interfaceIsEqual(err, io.EOF)) { $s = 14; continue; }
		/* */ $s = 15; continue;
		/* if ($interfaceIsEqual(err, io.EOF)) { */ case 14:
			/* */ if (b.Available() === 0) { $s = 16; continue; }
			/* */ $s = 17; continue;
			/* if (b.Available() === 0) { */ case 16:
				_r$3 = b.Flush(); /* */ $s = 19; case 19: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				err = _r$3;
				$s = 18; continue;
			/* } else { */ case 17:
				err = $ifaceNil;
			/* } */ case 18:
		/* } */ case 15:
		_tmp$4 = n;
		_tmp$5 = err;
		n = _tmp$4;
		err = _tmp$5;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.ReadFrom }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.b = b; $f.err = err; $f.err1 = err1; $f.m = m; $f.n = n; $f.nr = nr; $f.ok = ok; $f.r = r; $f.w = w; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.ReadFrom = function(r) { return this.$val.ReadFrom(r); };
	ptrType.methods = [{prop: "Reset", name: "Reset", pkg: "", typ: $funcType([io.Reader], [], false)}, {prop: "reset", name: "reset", pkg: "bufio", typ: $funcType([sliceType, io.Reader], [], false)}, {prop: "fill", name: "fill", pkg: "bufio", typ: $funcType([], [], false)}, {prop: "readErr", name: "readErr", pkg: "bufio", typ: $funcType([], [$error], false)}, {prop: "Peek", name: "Peek", pkg: "", typ: $funcType([$Int], [sliceType, $error], false)}, {prop: "Discard", name: "Discard", pkg: "", typ: $funcType([$Int], [$Int, $error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Buffered", name: "Buffered", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "ReadSlice", name: "ReadSlice", pkg: "", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "ReadLine", name: "ReadLine", pkg: "", typ: $funcType([], [sliceType, $Bool, $error], false)}, {prop: "ReadBytes", name: "ReadBytes", pkg: "", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "ReadString", name: "ReadString", pkg: "", typ: $funcType([$Uint8], [$String, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([io.Writer], [$Int64, $error], false)}, {prop: "writeBuf", name: "writeBuf", pkg: "bufio", typ: $funcType([io.Writer], [$Int64, $error], false)}];
	ptrType$1.methods = [{prop: "Reset", name: "Reset", pkg: "", typ: $funcType([io.Writer], [], false)}, {prop: "Flush", name: "Flush", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Available", name: "Available", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Buffered", name: "Buffered", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [$error], false)}, {prop: "WriteRune", name: "WriteRune", pkg: "", typ: $funcType([$Int32], [$Int, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}, {prop: "ReadFrom", name: "ReadFrom", pkg: "", typ: $funcType([io.Reader], [$Int64, $error], false)}];
	Reader.init("bufio", [{prop: "buf", name: "buf", anonymous: false, exported: false, typ: sliceType, tag: ""}, {prop: "rd", name: "rd", anonymous: false, exported: false, typ: io.Reader, tag: ""}, {prop: "r", name: "r", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "w", name: "w", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "err", name: "err", anonymous: false, exported: false, typ: $error, tag: ""}, {prop: "lastByte", name: "lastByte", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "lastRuneSize", name: "lastRuneSize", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	Writer.init("bufio", [{prop: "err", name: "err", anonymous: false, exported: false, typ: $error, tag: ""}, {prop: "buf", name: "buf", anonymous: false, exported: false, typ: sliceType, tag: ""}, {prop: "n", name: "n", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "wr", name: "wr", anonymous: false, exported: false, typ: io.Writer, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte");
		$pkg.ErrInvalidUnreadRune = errors.New("bufio: invalid use of UnreadRune");
		$pkg.ErrBufferFull = errors.New("bufio: buffer full");
		$pkg.ErrNegativeCount = errors.New("bufio: negative count");
		errNegativeRead = errors.New("bufio: reader returned negative count from Read");
		errNegativeWrite = errors.New("bufio: writer returned negative count from Write");
		$pkg.ErrTooLong = errors.New("bufio.Scanner: token too long");
		$pkg.ErrNegativeAdvance = errors.New("bufio.Scanner: SplitFunc returns negative advance count");
		$pkg.ErrAdvanceTooFar = errors.New("bufio.Scanner: SplitFunc returns advance count beyond input");
		$pkg.ErrFinalToken = errors.New("final token");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["math"] = (function() {
	var $pkg = {}, $init, js, arrayType, arrayType$1, arrayType$2, structType, math, zero, posInf, negInf, nan, buf, pow10tab, pow10postab32, pow10negtab32, Exp, Frexp, Inf, IsInf, IsNaN, Log, Log2, NaN, init, Float32bits, Float32frombits, Float64bits, Float64frombits, Abs, normalize, frexp, log2, Pow10;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	arrayType = $arrayType($Uint32, 2);
	arrayType$1 = $arrayType($Float32, 2);
	arrayType$2 = $arrayType($Float64, 1);
	structType = $structType("math", [{prop: "uint32array", name: "uint32array", anonymous: false, exported: false, typ: arrayType, tag: ""}, {prop: "float32array", name: "float32array", anonymous: false, exported: false, typ: arrayType$1, tag: ""}, {prop: "float64array", name: "float64array", anonymous: false, exported: false, typ: arrayType$2, tag: ""}]);
	Exp = function(x) {
		var x;
		return $parseFloat(math.exp(x));
	};
	$pkg.Exp = Exp;
	Frexp = function(f) {
		var _tuple, exp$1, f, frac;
		frac = 0;
		exp$1 = 0;
		_tuple = frexp(f);
		frac = _tuple[0];
		exp$1 = _tuple[1];
		return [frac, exp$1];
	};
	$pkg.Frexp = Frexp;
	Inf = function(sign) {
		var sign;
		if (sign >= 0) {
			return posInf;
		} else {
			return negInf;
		}
	};
	$pkg.Inf = Inf;
	IsInf = function(f, sign) {
		var f, sign;
		if (f === posInf) {
			return sign >= 0;
		}
		if (f === negInf) {
			return sign <= 0;
		}
		return false;
	};
	$pkg.IsInf = IsInf;
	IsNaN = function(f) {
		var f, is;
		is = false;
		is = !((f === f));
		return is;
	};
	$pkg.IsNaN = IsNaN;
	Log = function(x) {
		var x;
		if (!((x === x))) {
			return nan;
		}
		return $parseFloat(math.log(x));
	};
	$pkg.Log = Log;
	Log2 = function(x) {
		var x;
		return log2(x);
	};
	$pkg.Log2 = Log2;
	NaN = function() {
		return nan;
	};
	$pkg.NaN = NaN;
	init = function() {
		var ab;
		ab = new ($global.ArrayBuffer)(8);
		buf.uint32array = new ($global.Uint32Array)(ab);
		buf.float32array = new ($global.Float32Array)(ab);
		buf.float64array = new ($global.Float64Array)(ab);
	};
	Float32bits = function(f) {
		var f;
		buf.float32array[0] = f;
		return buf.uint32array[0];
	};
	$pkg.Float32bits = Float32bits;
	Float32frombits = function(b) {
		var b;
		buf.uint32array[0] = b;
		return buf.float32array[0];
	};
	$pkg.Float32frombits = Float32frombits;
	Float64bits = function(f) {
		var f, x, x$1;
		buf.float64array[0] = f;
		return (x = $shiftLeft64((new $Uint64(0, buf.uint32array[1])), 32), x$1 = (new $Uint64(0, buf.uint32array[0])), new $Uint64(x.$high + x$1.$high, x.$low + x$1.$low));
	};
	$pkg.Float64bits = Float64bits;
	Float64frombits = function(b) {
		var b;
		buf.uint32array[0] = ((b.$low >>> 0));
		buf.uint32array[1] = (($shiftRightUint64(b, 32).$low >>> 0));
		return buf.float64array[0];
	};
	$pkg.Float64frombits = Float64frombits;
	Abs = function(x) {
		var x;
		if (x < 0) {
			return -x;
		}
		if (x === 0) {
			return 0;
		}
		return x;
	};
	$pkg.Abs = Abs;
	normalize = function(x) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, exp$1, x, y;
		y = 0;
		exp$1 = 0;
		if (Abs(x) < 2.2250738585072014e-308) {
			_tmp = x * 4.503599627370496e+15;
			_tmp$1 = -52;
			y = _tmp;
			exp$1 = _tmp$1;
			return [y, exp$1];
		}
		_tmp$2 = x;
		_tmp$3 = 0;
		y = _tmp$2;
		exp$1 = _tmp$3;
		return [y, exp$1];
	};
	frexp = function(f) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, exp$1, f, frac, x, x$1, x$2, x$3;
		frac = 0;
		exp$1 = 0;
		if ((f === 0)) {
			_tmp = f;
			_tmp$1 = 0;
			frac = _tmp;
			exp$1 = _tmp$1;
			return [frac, exp$1];
		} else if (IsInf(f, 0) || IsNaN(f)) {
			_tmp$2 = f;
			_tmp$3 = 0;
			frac = _tmp$2;
			exp$1 = _tmp$3;
			return [frac, exp$1];
		}
		_tuple = normalize(f);
		f = _tuple[0];
		exp$1 = _tuple[1];
		x = Float64bits(f);
		exp$1 = exp$1 + ((((((x$1 = $shiftRightUint64(x, 52), new $Uint64(x$1.$high & 0, (x$1.$low & 2047) >>> 0)).$low >> 0)) - 1023 >> 0) + 1 >> 0)) >> 0;
		x = (x$2 = new $Uint64(2146435072, 0), new $Uint64(x.$high & ~x$2.$high, (x.$low & ~x$2.$low) >>> 0));
		x = (x$3 = new $Uint64(1071644672, 0), new $Uint64(x.$high | x$3.$high, (x.$low | x$3.$low) >>> 0));
		frac = Float64frombits(x);
		return [frac, exp$1];
	};
	log2 = function(x) {
		var _tuple, exp$1, frac, x;
		_tuple = Frexp(x);
		frac = _tuple[0];
		exp$1 = _tuple[1];
		if (frac === 0.5) {
			return ((exp$1 - 1 >> 0));
		}
		return Log(frac) * 1.4426950408889634 + (exp$1);
	};
	Pow10 = function(n) {
		var _q, _q$1, _r, _r$1, n, x, x$1, x$2, x$3;
		if (0 <= n && n <= 308) {
			return (x = (_q = ((n >>> 0)) / 32, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero")), ((x < 0 || x >= pow10postab32.length) ? ($throwRuntimeError("index out of range"), undefined) : pow10postab32[x])) * (x$1 = (_r = ((n >>> 0)) % 32, _r === _r ? _r : $throwRuntimeError("integer divide by zero")), ((x$1 < 0 || x$1 >= pow10tab.length) ? ($throwRuntimeError("index out of range"), undefined) : pow10tab[x$1]));
		}
		if (-323 <= n && n <= 0) {
			return (x$2 = (_q$1 = ((-n >>> 0)) / 32, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero")), ((x$2 < 0 || x$2 >= pow10negtab32.length) ? ($throwRuntimeError("index out of range"), undefined) : pow10negtab32[x$2])) / (x$3 = (_r$1 = ((-n >>> 0)) % 32, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")), ((x$3 < 0 || x$3 >= pow10tab.length) ? ($throwRuntimeError("index out of range"), undefined) : pow10tab[x$3]));
		}
		if (n > 0) {
			return Inf(1);
		}
		return 0;
	};
	$pkg.Pow10 = Pow10;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		buf = new structType.ptr(arrayType.zero(), arrayType$1.zero(), arrayType$2.zero());
		math = $global.Math;
		zero = 0;
		posInf = 1 / zero;
		negInf = -1 / zero;
		nan = 0 / zero;
		pow10tab = $toNativeArray($kindFloat64, [1, 10, 100, 1000, 10000, 100000, 1e+06, 1e+07, 1e+08, 1e+09, 1e+10, 1e+11, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16, 1e+17, 1e+18, 1e+19, 1e+20, 1e+21, 1e+22, 1e+23, 1e+24, 1e+25, 1e+26, 1e+27, 1e+28, 1e+29, 1e+30, 1e+31]);
		pow10postab32 = $toNativeArray($kindFloat64, [1, 1e+32, 1e+64, 1e+96, 1e+128, 1e+160, 1e+192, 1e+224, 1e+256, 1e+288]);
		pow10negtab32 = $toNativeArray($kindFloat64, [1, 1e-32, 1e-64, 1e-96, 1e-128, 1e-160, 1e-192, 1e-224, 1e-256, 1e-288, 1e-320]);
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["syscall"] = (function() {
	var $pkg = {}, $init, js, race, runtime, sync, SockaddrLinklayer, SockaddrNetlink, mmapper, Errno, Sockaddr, SockaddrInet4, SockaddrInet6, SockaddrUnix, Timespec, Stat_t, RawSockaddrInet4, RawSockaddrInet6, RawSockaddrUnix, RawSockaddrLinklayer, RawSockaddrNetlink, RawSockaddr, RawSockaddrAny, _Socklen, Linger, Iovec, IPMreq, IPMreqn, IPv6Mreq, Msghdr, sliceType, sliceType$1, ptrType$2, ptrType$4, arrayType$1, ptrType$8, arrayType$2, ptrType$11, arrayType$4, arrayType$7, arrayType$8, arrayType$9, arrayType$10, ptrType$18, ptrType$19, structType, ptrType$22, ptrType$24, ptrType$25, mapType, funcType$2, funcType$3, ptrType$26, ptrType$27, ptrType$28, ptrType$29, arrayType$15, ptrType$31, warningPrinted, lineBuffer, syscallModule, alreadyTriedToLoad, minusOne, envs, mapper, errEAGAIN, errEINVAL, errENOENT, ioSync, ioSync$24ptr, errors, init, printWarning, printToConsole, indexByte, runtime_envs, syscall, Syscall, Syscall6, BytePtrFromString, readInt, readIntBE, readIntLE, ParseDirent, CloseOnExec, SetNonblock, msanRead, msanWrite, itoa, uitoa, anyToSockaddr, Accept, Accept4, SetsockoptIPMreqn, Recvmsg, SendmsgN, ReadDirent, direntIno, direntReclen, direntNamlen, errnoErr, Read, Write, Recvfrom, Sendto, SetsockoptByte, SetsockoptInt, SetsockoptInet4Addr, SetsockoptIPMreq, SetsockoptIPv6Mreq, SetsockoptLinger, Close, Fchdir, Fchmod, fcntl, Fsync, Getdents, read, write, munmap, Fchown, Fstat, Ftruncate, Lstat, Pread, Pwrite, Seek, Shutdown, accept, accept4, setsockopt, recvfrom, sendto, recvmsg, sendmsg, mmap;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	race = $packages["internal/race"];
	runtime = $packages["runtime"];
	sync = $packages["sync"];
	SockaddrLinklayer = $pkg.SockaddrLinklayer = $newType(0, $kindStruct, "syscall.SockaddrLinklayer", true, "syscall", true, function(Protocol_, Ifindex_, Hatype_, Pkttype_, Halen_, Addr_, raw_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Protocol = 0;
			this.Ifindex = 0;
			this.Hatype = 0;
			this.Pkttype = 0;
			this.Halen = 0;
			this.Addr = arrayType$1.zero();
			this.raw = new RawSockaddrLinklayer.ptr(0, 0, 0, 0, 0, 0, arrayType$1.zero());
			return;
		}
		this.Protocol = Protocol_;
		this.Ifindex = Ifindex_;
		this.Hatype = Hatype_;
		this.Pkttype = Pkttype_;
		this.Halen = Halen_;
		this.Addr = Addr_;
		this.raw = raw_;
	});
	SockaddrNetlink = $pkg.SockaddrNetlink = $newType(0, $kindStruct, "syscall.SockaddrNetlink", true, "syscall", true, function(Family_, Pad_, Pid_, Groups_, raw_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Pad = 0;
			this.Pid = 0;
			this.Groups = 0;
			this.raw = new RawSockaddrNetlink.ptr(0, 0, 0, 0);
			return;
		}
		this.Family = Family_;
		this.Pad = Pad_;
		this.Pid = Pid_;
		this.Groups = Groups_;
		this.raw = raw_;
	});
	mmapper = $pkg.mmapper = $newType(0, $kindStruct, "syscall.mmapper", true, "syscall", false, function(Mutex_, active_, mmap_, munmap_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Mutex = new sync.Mutex.ptr(0, 0);
			this.active = false;
			this.mmap = $throwNilPointerError;
			this.munmap = $throwNilPointerError;
			return;
		}
		this.Mutex = Mutex_;
		this.active = active_;
		this.mmap = mmap_;
		this.munmap = munmap_;
	});
	Errno = $pkg.Errno = $newType(4, $kindUintptr, "syscall.Errno", true, "syscall", true, null);
	Sockaddr = $pkg.Sockaddr = $newType(8, $kindInterface, "syscall.Sockaddr", true, "syscall", true, null);
	SockaddrInet4 = $pkg.SockaddrInet4 = $newType(0, $kindStruct, "syscall.SockaddrInet4", true, "syscall", true, function(Port_, Addr_, raw_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Port = 0;
			this.Addr = arrayType$8.zero();
			this.raw = new RawSockaddrInet4.ptr(0, 0, arrayType$8.zero(), arrayType$1.zero());
			return;
		}
		this.Port = Port_;
		this.Addr = Addr_;
		this.raw = raw_;
	});
	SockaddrInet6 = $pkg.SockaddrInet6 = $newType(0, $kindStruct, "syscall.SockaddrInet6", true, "syscall", true, function(Port_, ZoneId_, Addr_, raw_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Port = 0;
			this.ZoneId = 0;
			this.Addr = arrayType$2.zero();
			this.raw = new RawSockaddrInet6.ptr(0, 0, 0, arrayType$2.zero(), 0);
			return;
		}
		this.Port = Port_;
		this.ZoneId = ZoneId_;
		this.Addr = Addr_;
		this.raw = raw_;
	});
	SockaddrUnix = $pkg.SockaddrUnix = $newType(0, $kindStruct, "syscall.SockaddrUnix", true, "syscall", true, function(Name_, raw_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = "";
			this.raw = new RawSockaddrUnix.ptr(0, arrayType$7.zero());
			return;
		}
		this.Name = Name_;
		this.raw = raw_;
	});
	Timespec = $pkg.Timespec = $newType(0, $kindStruct, "syscall.Timespec", true, "syscall", true, function(Sec_, Nsec_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Sec = new $Int64(0, 0);
			this.Nsec = new $Int64(0, 0);
			return;
		}
		this.Sec = Sec_;
		this.Nsec = Nsec_;
	});
	Stat_t = $pkg.Stat_t = $newType(0, $kindStruct, "syscall.Stat_t", true, "syscall", true, function(Dev_, Ino_, Nlink_, Mode_, Uid_, Gid_, X__pad0_, Rdev_, Size_, Blksize_, Blocks_, Atim_, Mtim_, Ctim_, X__unused_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Dev = new $Uint64(0, 0);
			this.Ino = new $Uint64(0, 0);
			this.Nlink = new $Uint64(0, 0);
			this.Mode = 0;
			this.Uid = 0;
			this.Gid = 0;
			this.X__pad0 = 0;
			this.Rdev = new $Uint64(0, 0);
			this.Size = new $Int64(0, 0);
			this.Blksize = new $Int64(0, 0);
			this.Blocks = new $Int64(0, 0);
			this.Atim = new Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0));
			this.Mtim = new Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0));
			this.Ctim = new Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0));
			this.X__unused = arrayType$15.zero();
			return;
		}
		this.Dev = Dev_;
		this.Ino = Ino_;
		this.Nlink = Nlink_;
		this.Mode = Mode_;
		this.Uid = Uid_;
		this.Gid = Gid_;
		this.X__pad0 = X__pad0_;
		this.Rdev = Rdev_;
		this.Size = Size_;
		this.Blksize = Blksize_;
		this.Blocks = Blocks_;
		this.Atim = Atim_;
		this.Mtim = Mtim_;
		this.Ctim = Ctim_;
		this.X__unused = X__unused_;
	});
	RawSockaddrInet4 = $pkg.RawSockaddrInet4 = $newType(0, $kindStruct, "syscall.RawSockaddrInet4", true, "syscall", true, function(Family_, Port_, Addr_, Zero_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Port = 0;
			this.Addr = arrayType$8.zero();
			this.Zero = arrayType$1.zero();
			return;
		}
		this.Family = Family_;
		this.Port = Port_;
		this.Addr = Addr_;
		this.Zero = Zero_;
	});
	RawSockaddrInet6 = $pkg.RawSockaddrInet6 = $newType(0, $kindStruct, "syscall.RawSockaddrInet6", true, "syscall", true, function(Family_, Port_, Flowinfo_, Addr_, Scope_id_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Port = 0;
			this.Flowinfo = 0;
			this.Addr = arrayType$2.zero();
			this.Scope_id = 0;
			return;
		}
		this.Family = Family_;
		this.Port = Port_;
		this.Flowinfo = Flowinfo_;
		this.Addr = Addr_;
		this.Scope_id = Scope_id_;
	});
	RawSockaddrUnix = $pkg.RawSockaddrUnix = $newType(0, $kindStruct, "syscall.RawSockaddrUnix", true, "syscall", true, function(Family_, Path_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Path = arrayType$7.zero();
			return;
		}
		this.Family = Family_;
		this.Path = Path_;
	});
	RawSockaddrLinklayer = $pkg.RawSockaddrLinklayer = $newType(0, $kindStruct, "syscall.RawSockaddrLinklayer", true, "syscall", true, function(Family_, Protocol_, Ifindex_, Hatype_, Pkttype_, Halen_, Addr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Protocol = 0;
			this.Ifindex = 0;
			this.Hatype = 0;
			this.Pkttype = 0;
			this.Halen = 0;
			this.Addr = arrayType$1.zero();
			return;
		}
		this.Family = Family_;
		this.Protocol = Protocol_;
		this.Ifindex = Ifindex_;
		this.Hatype = Hatype_;
		this.Pkttype = Pkttype_;
		this.Halen = Halen_;
		this.Addr = Addr_;
	});
	RawSockaddrNetlink = $pkg.RawSockaddrNetlink = $newType(0, $kindStruct, "syscall.RawSockaddrNetlink", true, "syscall", true, function(Family_, Pad_, Pid_, Groups_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Pad = 0;
			this.Pid = 0;
			this.Groups = 0;
			return;
		}
		this.Family = Family_;
		this.Pad = Pad_;
		this.Pid = Pid_;
		this.Groups = Groups_;
	});
	RawSockaddr = $pkg.RawSockaddr = $newType(0, $kindStruct, "syscall.RawSockaddr", true, "syscall", true, function(Family_, Data_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Data = arrayType$9.zero();
			return;
		}
		this.Family = Family_;
		this.Data = Data_;
	});
	RawSockaddrAny = $pkg.RawSockaddrAny = $newType(0, $kindStruct, "syscall.RawSockaddrAny", true, "syscall", true, function(Addr_, Pad_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Addr = new RawSockaddr.ptr(0, arrayType$9.zero());
			this.Pad = arrayType$10.zero();
			return;
		}
		this.Addr = Addr_;
		this.Pad = Pad_;
	});
	_Socklen = $pkg._Socklen = $newType(4, $kindUint32, "syscall._Socklen", true, "syscall", false, null);
	Linger = $pkg.Linger = $newType(0, $kindStruct, "syscall.Linger", true, "syscall", true, function(Onoff_, Linger_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Onoff = 0;
			this.Linger = 0;
			return;
		}
		this.Onoff = Onoff_;
		this.Linger = Linger_;
	});
	Iovec = $pkg.Iovec = $newType(0, $kindStruct, "syscall.Iovec", true, "syscall", true, function(Base_, Len_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Base = ptrType$2.nil;
			this.Len = new $Uint64(0, 0);
			return;
		}
		this.Base = Base_;
		this.Len = Len_;
	});
	IPMreq = $pkg.IPMreq = $newType(0, $kindStruct, "syscall.IPMreq", true, "syscall", true, function(Multiaddr_, Interface_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Multiaddr = arrayType$8.zero();
			this.Interface = arrayType$8.zero();
			return;
		}
		this.Multiaddr = Multiaddr_;
		this.Interface = Interface_;
	});
	IPMreqn = $pkg.IPMreqn = $newType(0, $kindStruct, "syscall.IPMreqn", true, "syscall", true, function(Multiaddr_, Address_, Ifindex_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Multiaddr = arrayType$8.zero();
			this.Address = arrayType$8.zero();
			this.Ifindex = 0;
			return;
		}
		this.Multiaddr = Multiaddr_;
		this.Address = Address_;
		this.Ifindex = Ifindex_;
	});
	IPv6Mreq = $pkg.IPv6Mreq = $newType(0, $kindStruct, "syscall.IPv6Mreq", true, "syscall", true, function(Multiaddr_, Interface_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Multiaddr = arrayType$2.zero();
			this.Interface = 0;
			return;
		}
		this.Multiaddr = Multiaddr_;
		this.Interface = Interface_;
	});
	Msghdr = $pkg.Msghdr = $newType(0, $kindStruct, "syscall.Msghdr", true, "syscall", true, function(Name_, Namelen_, Pad_cgo_0_, Iov_, Iovlen_, Control_, Controllen_, Flags_, Pad_cgo_1_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = ptrType$2.nil;
			this.Namelen = 0;
			this.Pad_cgo_0 = arrayType$8.zero();
			this.Iov = ptrType$19.nil;
			this.Iovlen = new $Uint64(0, 0);
			this.Control = ptrType$2.nil;
			this.Controllen = new $Uint64(0, 0);
			this.Flags = 0;
			this.Pad_cgo_1 = arrayType$8.zero();
			return;
		}
		this.Name = Name_;
		this.Namelen = Namelen_;
		this.Pad_cgo_0 = Pad_cgo_0_;
		this.Iov = Iov_;
		this.Iovlen = Iovlen_;
		this.Control = Control_;
		this.Controllen = Controllen_;
		this.Flags = Flags_;
		this.Pad_cgo_1 = Pad_cgo_1_;
	});
	sliceType = $sliceType($Uint8);
	sliceType$1 = $sliceType($String);
	ptrType$2 = $ptrType($Uint8);
	ptrType$4 = $ptrType($Int32);
	arrayType$1 = $arrayType($Uint8, 8);
	ptrType$8 = $ptrType($Uint16);
	arrayType$2 = $arrayType($Uint8, 16);
	ptrType$11 = $ptrType(SockaddrNetlink);
	arrayType$4 = $arrayType($Uint8, 32);
	arrayType$7 = $arrayType($Int8, 108);
	arrayType$8 = $arrayType($Uint8, 4);
	arrayType$9 = $arrayType($Int8, 14);
	arrayType$10 = $arrayType($Int8, 96);
	ptrType$18 = $ptrType(_Socklen);
	ptrType$19 = $ptrType(Iovec);
	structType = $structType("syscall", [{prop: "addr", name: "addr", anonymous: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "len", name: "len", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "cap", name: "cap", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	ptrType$22 = $ptrType($Int64);
	ptrType$24 = $ptrType(SockaddrLinklayer);
	ptrType$25 = $ptrType(mmapper);
	mapType = $mapType(ptrType$2, sliceType);
	funcType$2 = $funcType([$Uintptr, $Uintptr, $Int, $Int, $Int, $Int64], [$Uintptr, $error], false);
	funcType$3 = $funcType([$Uintptr, $Uintptr], [$error], false);
	ptrType$26 = $ptrType(SockaddrInet4);
	ptrType$27 = $ptrType(SockaddrInet6);
	ptrType$28 = $ptrType(SockaddrUnix);
	ptrType$29 = $ptrType(Timespec);
	arrayType$15 = $arrayType($Int64, 3);
	ptrType$31 = $ptrType(Msghdr);
	init = function() {
		$flushConsole = (function() {
			if (!((lineBuffer.$length === 0))) {
				$global.console.log($externalize(($bytesToString(lineBuffer)), $String));
				lineBuffer = sliceType.nil;
			}
		});
	};
	printWarning = function() {
		if (!warningPrinted) {
			$global.console.error($externalize("warning: system calls not available, see https://github.com/gopherjs/gopherjs/blob/master/doc/syscalls.md", $String));
		}
		warningPrinted = true;
	};
	printToConsole = function(b) {
		var b, goPrintToConsole, i;
		goPrintToConsole = $global.goPrintToConsole;
		if (!(goPrintToConsole === undefined)) {
			goPrintToConsole(b);
			return;
		}
		lineBuffer = $appendSlice(lineBuffer, b);
		while (true) {
			i = indexByte(lineBuffer, 10);
			if (i === -1) {
				break;
			}
			$global.console.log($externalize(($bytesToString($subslice(lineBuffer, 0, i))), $String));
			lineBuffer = $subslice(lineBuffer, (i + 1 >> 0));
		}
	};
	indexByte = function(s, c) {
		var _i, _ref, b, c, i, s;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (b === c) {
				return i;
			}
			_i++;
		}
		return -1;
	};
	runtime_envs = function() {
		var envkeys, envs$1, i, jsEnv, key, process;
		process = $global.process;
		if (process === undefined) {
			return sliceType$1.nil;
		}
		jsEnv = process.env;
		envkeys = $global.Object.keys(jsEnv);
		envs$1 = $makeSlice(sliceType$1, $parseInt(envkeys.length));
		i = 0;
		while (true) {
			if (!(i < $parseInt(envkeys.length))) { break; }
			key = $internalize(envkeys[i], $String);
			((i < 0 || i >= envs$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : envs$1.$array[envs$1.$offset + i] = key + "=" + $internalize(jsEnv[$externalize(key, $String)], $String));
			i = i + (1) >> 0;
		}
		return envs$1;
	};
	syscall = function(name) {
		var name, require, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$deferred.push([(function() {
			$recover();
		}), []]);
		if (syscallModule === null) {
			if (alreadyTriedToLoad) {
				return null;
			}
			alreadyTriedToLoad = true;
			require = $global.require;
			if (require === undefined) {
				$panic(new $String(""));
			}
			syscallModule = require($externalize("syscall", $String));
		}
		return syscallModule[$externalize(name, $String)];
		/* */ } catch(err) { $err = err; return null; } finally { $callDeferred($deferred, $err); }
	};
	Syscall = function(trap, a1, a2, a3) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, a1, a2, a3, array, err, f, r, r1, r2, slice, trap;
		r1 = 0;
		r2 = 0;
		err = 0;
		f = syscall("Syscall");
		if (!(f === null)) {
			r = f(trap, a1, a2, a3);
			_tmp = ((($parseInt(r[0]) >> 0) >>> 0));
			_tmp$1 = ((($parseInt(r[1]) >> 0) >>> 0));
			_tmp$2 = ((($parseInt(r[2]) >> 0) >>> 0));
			r1 = _tmp;
			r2 = _tmp$1;
			err = _tmp$2;
			return [r1, r2, err];
		}
		if ((trap === 1) && ((a1 === 1) || (a1 === 2))) {
			array = a2;
			slice = $makeSlice(sliceType, $parseInt(array.length));
			slice.$array = array;
			printToConsole(slice);
			_tmp$3 = (($parseInt(array.length) >>> 0));
			_tmp$4 = 0;
			_tmp$5 = 0;
			r1 = _tmp$3;
			r2 = _tmp$4;
			err = _tmp$5;
			return [r1, r2, err];
		}
		if (trap === 60) {
			runtime.Goexit();
		}
		printWarning();
		_tmp$6 = ((minusOne >>> 0));
		_tmp$7 = 0;
		_tmp$8 = 13;
		r1 = _tmp$6;
		r2 = _tmp$7;
		err = _tmp$8;
		return [r1, r2, err];
	};
	$pkg.Syscall = Syscall;
	Syscall6 = function(trap, a1, a2, a3, a4, a5, a6) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, a1, a2, a3, a4, a5, a6, err, f, r, r1, r2, trap;
		r1 = 0;
		r2 = 0;
		err = 0;
		f = syscall("Syscall6");
		if (!(f === null)) {
			r = f(trap, a1, a2, a3, a4, a5, a6);
			_tmp = ((($parseInt(r[0]) >> 0) >>> 0));
			_tmp$1 = ((($parseInt(r[1]) >> 0) >>> 0));
			_tmp$2 = ((($parseInt(r[2]) >> 0) >>> 0));
			r1 = _tmp;
			r2 = _tmp$1;
			err = _tmp$2;
			return [r1, r2, err];
		}
		if (!((trap === 202))) {
			printWarning();
		}
		_tmp$3 = ((minusOne >>> 0));
		_tmp$4 = 0;
		_tmp$5 = 13;
		r1 = _tmp$3;
		r2 = _tmp$4;
		err = _tmp$5;
		return [r1, r2, err];
	};
	$pkg.Syscall6 = Syscall6;
	BytePtrFromString = function(s) {
		var _i, _ref, array, b, i, s;
		array = new ($global.Uint8Array)(s.length + 1 >> 0);
		_ref = (new sliceType($stringToBytes(s)));
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (b === 0) {
				return [ptrType$2.nil, new Errno(22)];
			}
			array[i] = b;
			_i++;
		}
		array[s.length] = 0;
		return [((array)), $ifaceNil];
	};
	$pkg.BytePtrFromString = BytePtrFromString;
	readInt = function(b, off, size) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, off, ok, size, u;
		u = new $Uint64(0, 0);
		ok = false;
		if (b.$length < (((off + size >>> 0) >> 0))) {
			_tmp = new $Uint64(0, 0);
			_tmp$1 = false;
			u = _tmp;
			ok = _tmp$1;
			return [u, ok];
		}
		if (false) {
			_tmp$2 = readIntBE($subslice(b, off), size);
			_tmp$3 = true;
			u = _tmp$2;
			ok = _tmp$3;
			return [u, ok];
		}
		_tmp$4 = readIntLE($subslice(b, off), size);
		_tmp$5 = true;
		u = _tmp$4;
		ok = _tmp$5;
		return [u, ok];
	};
	readIntBE = function(b, size) {
		var _1, b, size, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		_1 = size;
		if (_1 === (1)) {
			return (new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0])));
		} else if (_1 === (2)) {
			$unused((1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]));
			return (x = (new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), x$1 = $shiftLeft64((new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), 8), new $Uint64(x.$high | x$1.$high, (x.$low | x$1.$low) >>> 0));
		} else if (_1 === (4)) {
			$unused((3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]));
			return (x$2 = (x$3 = (x$4 = (new $Uint64(0, (3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]))), x$5 = $shiftLeft64((new $Uint64(0, (2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2]))), 8), new $Uint64(x$4.$high | x$5.$high, (x$4.$low | x$5.$low) >>> 0)), x$6 = $shiftLeft64((new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), 16), new $Uint64(x$3.$high | x$6.$high, (x$3.$low | x$6.$low) >>> 0)), x$7 = $shiftLeft64((new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), 24), new $Uint64(x$2.$high | x$7.$high, (x$2.$low | x$7.$low) >>> 0));
		} else if (_1 === (8)) {
			$unused((7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7]));
			return (x$8 = (x$9 = (x$10 = (x$11 = (x$12 = (x$13 = (x$14 = (new $Uint64(0, (7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7]))), x$15 = $shiftLeft64((new $Uint64(0, (6 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 6]))), 8), new $Uint64(x$14.$high | x$15.$high, (x$14.$low | x$15.$low) >>> 0)), x$16 = $shiftLeft64((new $Uint64(0, (5 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 5]))), 16), new $Uint64(x$13.$high | x$16.$high, (x$13.$low | x$16.$low) >>> 0)), x$17 = $shiftLeft64((new $Uint64(0, (4 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 4]))), 24), new $Uint64(x$12.$high | x$17.$high, (x$12.$low | x$17.$low) >>> 0)), x$18 = $shiftLeft64((new $Uint64(0, (3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]))), 32), new $Uint64(x$11.$high | x$18.$high, (x$11.$low | x$18.$low) >>> 0)), x$19 = $shiftLeft64((new $Uint64(0, (2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2]))), 40), new $Uint64(x$10.$high | x$19.$high, (x$10.$low | x$19.$low) >>> 0)), x$20 = $shiftLeft64((new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), 48), new $Uint64(x$9.$high | x$20.$high, (x$9.$low | x$20.$low) >>> 0)), x$21 = $shiftLeft64((new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), 56), new $Uint64(x$8.$high | x$21.$high, (x$8.$low | x$21.$low) >>> 0));
		} else {
			$panic(new $String("syscall: readInt with unsupported size"));
		}
	};
	readIntLE = function(b, size) {
		var _1, b, size, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		_1 = size;
		if (_1 === (1)) {
			return (new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0])));
		} else if (_1 === (2)) {
			$unused((1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]));
			return (x = (new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), x$1 = $shiftLeft64((new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), 8), new $Uint64(x.$high | x$1.$high, (x.$low | x$1.$low) >>> 0));
		} else if (_1 === (4)) {
			$unused((3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]));
			return (x$2 = (x$3 = (x$4 = (new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), x$5 = $shiftLeft64((new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), 8), new $Uint64(x$4.$high | x$5.$high, (x$4.$low | x$5.$low) >>> 0)), x$6 = $shiftLeft64((new $Uint64(0, (2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2]))), 16), new $Uint64(x$3.$high | x$6.$high, (x$3.$low | x$6.$low) >>> 0)), x$7 = $shiftLeft64((new $Uint64(0, (3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]))), 24), new $Uint64(x$2.$high | x$7.$high, (x$2.$low | x$7.$low) >>> 0));
		} else if (_1 === (8)) {
			$unused((7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7]));
			return (x$8 = (x$9 = (x$10 = (x$11 = (x$12 = (x$13 = (x$14 = (new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), x$15 = $shiftLeft64((new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), 8), new $Uint64(x$14.$high | x$15.$high, (x$14.$low | x$15.$low) >>> 0)), x$16 = $shiftLeft64((new $Uint64(0, (2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2]))), 16), new $Uint64(x$13.$high | x$16.$high, (x$13.$low | x$16.$low) >>> 0)), x$17 = $shiftLeft64((new $Uint64(0, (3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]))), 24), new $Uint64(x$12.$high | x$17.$high, (x$12.$low | x$17.$low) >>> 0)), x$18 = $shiftLeft64((new $Uint64(0, (4 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 4]))), 32), new $Uint64(x$11.$high | x$18.$high, (x$11.$low | x$18.$low) >>> 0)), x$19 = $shiftLeft64((new $Uint64(0, (5 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 5]))), 40), new $Uint64(x$10.$high | x$19.$high, (x$10.$low | x$19.$low) >>> 0)), x$20 = $shiftLeft64((new $Uint64(0, (6 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 6]))), 48), new $Uint64(x$9.$high | x$20.$high, (x$9.$low | x$20.$low) >>> 0)), x$21 = $shiftLeft64((new $Uint64(0, (7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7]))), 56), new $Uint64(x$8.$high | x$21.$high, (x$8.$low | x$21.$low) >>> 0));
		} else {
			$panic(new $String("syscall: readInt with unsupported size"));
		}
	};
	ParseDirent = function(buf, max, names) {
		var _i, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, _tuple$2, buf, c, consumed, count, i, ino, max, name, names, namlen, newnames, ok, origlen, rec, reclen, x, x$1, x$2;
		consumed = 0;
		count = 0;
		newnames = sliceType$1.nil;
		origlen = buf.$length;
		count = 0;
		while (true) {
			if (!(!((max === 0)) && buf.$length > 0)) { break; }
			_tuple = direntReclen(buf);
			reclen = _tuple[0];
			ok = _tuple[1];
			if (!ok || (x = (new $Uint64(0, buf.$length)), (reclen.$high > x.$high || (reclen.$high === x.$high && reclen.$low > x.$low)))) {
				_tmp = origlen;
				_tmp$1 = count;
				_tmp$2 = names;
				consumed = _tmp;
				count = _tmp$1;
				newnames = _tmp$2;
				return [consumed, count, newnames];
			}
			rec = $subslice(buf, 0, $flatten64(reclen));
			buf = $subslice(buf, $flatten64(reclen));
			_tuple$1 = direntIno(rec);
			ino = _tuple$1[0];
			ok = _tuple$1[1];
			if (!ok) {
				break;
			}
			if ((ino.$high === 0 && ino.$low === 0)) {
				continue;
			}
			_tuple$2 = direntNamlen(rec);
			namlen = _tuple$2[0];
			ok = _tuple$2[1];
			if (!ok || (x$1 = new $Uint64(0 + namlen.$high, 19 + namlen.$low), x$2 = (new $Uint64(0, rec.$length)), (x$1.$high > x$2.$high || (x$1.$high === x$2.$high && x$1.$low > x$2.$low)))) {
				break;
			}
			name = $subslice(rec, 19, $flatten64(new $Uint64(0 + namlen.$high, 19 + namlen.$low)));
			_ref = name;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (c === 0) {
					name = $subslice(name, 0, i);
					break;
				}
				_i++;
			}
			if (($bytesToString(name)) === "." || ($bytesToString(name)) === "..") {
				continue;
			}
			max = max - (1) >> 0;
			count = count + (1) >> 0;
			names = $append(names, ($bytesToString(name)));
		}
		_tmp$3 = origlen - buf.$length >> 0;
		_tmp$4 = count;
		_tmp$5 = names;
		consumed = _tmp$3;
		count = _tmp$4;
		newnames = _tmp$5;
		return [consumed, count, newnames];
	};
	$pkg.ParseDirent = ParseDirent;
	CloseOnExec = function(fd) {
		var fd;
		fcntl(fd, 2, 1);
	};
	$pkg.CloseOnExec = CloseOnExec;
	SetNonblock = function(fd, nonblocking) {
		var _tuple, _tuple$1, err, fd, flag, nonblocking;
		err = $ifaceNil;
		_tuple = fcntl(fd, 3, 0);
		flag = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			err = err;
			return err;
		}
		if (nonblocking) {
			flag = flag | (2048);
		} else {
			flag = (flag & ~(2048)) >> 0;
		}
		_tuple$1 = fcntl(fd, 4, flag);
		err = _tuple$1[1];
		err = err;
		return err;
	};
	$pkg.SetNonblock = SetNonblock;
	msanRead = function(addr, len) {
		var addr, len;
	};
	msanWrite = function(addr, len) {
		var addr, len;
	};
	itoa = function(val) {
		var val;
		if (val < 0) {
			return "-" + uitoa(((-val >>> 0)));
		}
		return uitoa(((val >>> 0)));
	};
	uitoa = function(val) {
		var _q, _r, buf, i, val;
		buf = arrayType$4.zero();
		i = 31;
		while (true) {
			if (!(val >= 10)) { break; }
			((i < 0 || i >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[i] = ((((_r = val % 10, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) + 48 >>> 0) << 24 >>> 24)));
			i = i - (1) >> 0;
			val = (_q = val / (10), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		}
		((i < 0 || i >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[i] = (((val + 48 >>> 0) << 24 >>> 24)));
		return ($bytesToString($subslice(new sliceType(buf), i)));
	};
	Timespec.ptr.prototype.Unix = function() {
		var _tmp, _tmp$1, nsec, sec, ts;
		sec = new $Int64(0, 0);
		nsec = new $Int64(0, 0);
		ts = this;
		_tmp = (ts.Sec);
		_tmp$1 = (ts.Nsec);
		sec = _tmp;
		nsec = _tmp$1;
		return [sec, nsec];
	};
	Timespec.prototype.Unix = function() { return this.$val.Unix(); };
	Timespec.ptr.prototype.Nano = function() {
		var ts, x, x$1;
		ts = this;
		return (x = $mul64((ts.Sec), new $Int64(0, 1000000000)), x$1 = (ts.Nsec), new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));
	};
	Timespec.prototype.Nano = function() { return this.$val.Nano(); };
	SockaddrInet4.ptr.prototype.sockaddr = function() {
		var _array, _struct, _view, i, p, sa, x, x$1, x$2;
		sa = this;
		if (sa.Port < 0 || sa.Port > 65535) {
			return [0, 0, new Errno(22)];
		}
		sa.raw.Family = 2;
		p = (((x = sa.raw, (x.$ptr_Port || (x.$ptr_Port = new ptrType$8(function() { return this.$target.Port; }, function($v) { this.$target.Port = $v; }, x))))));
		p.nilCheck, p[0] = (((sa.Port >> 8 >> 0) << 24 >>> 24));
		p.nilCheck, p[1] = ((sa.Port << 24 >>> 24));
		i = 0;
		while (true) {
			if (!(i < 4)) { break; }
			(x$2 = sa.raw.Addr, ((i < 0 || i >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[i] = (x$1 = sa.Addr, ((i < 0 || i >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[i]))));
			i = i + (1) >> 0;
		}
		_array = new Uint8Array(16);
		return [(_array), 16, $ifaceNil];
	};
	SockaddrInet4.prototype.sockaddr = function() { return this.$val.sockaddr(); };
	SockaddrInet6.ptr.prototype.sockaddr = function() {
		var _array, _struct, _view, i, p, sa, x, x$1, x$2;
		sa = this;
		if (sa.Port < 0 || sa.Port > 65535) {
			return [0, 0, new Errno(22)];
		}
		sa.raw.Family = 10;
		p = (((x = sa.raw, (x.$ptr_Port || (x.$ptr_Port = new ptrType$8(function() { return this.$target.Port; }, function($v) { this.$target.Port = $v; }, x))))));
		p.nilCheck, p[0] = (((sa.Port >> 8 >> 0) << 24 >>> 24));
		p.nilCheck, p[1] = ((sa.Port << 24 >>> 24));
		sa.raw.Scope_id = sa.ZoneId;
		i = 0;
		while (true) {
			if (!(i < 16)) { break; }
			(x$2 = sa.raw.Addr, ((i < 0 || i >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[i] = (x$1 = sa.Addr, ((i < 0 || i >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[i]))));
			i = i + (1) >> 0;
		}
		_array = new Uint8Array(28);
		return [(_array), 28, $ifaceNil];
	};
	SockaddrInet6.prototype.sockaddr = function() { return this.$val.sockaddr(); };
	SockaddrUnix.ptr.prototype.sockaddr = function() {
		var _array, _struct, _view, i, n, name, sa, sl, x;
		sa = this;
		name = sa.Name;
		n = name.length;
		if (n >= 108) {
			return [0, 0, new Errno(22)];
		}
		sa.raw.Family = 1;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			(x = sa.raw.Path, ((i < 0 || i >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i] = ((name.charCodeAt(i) << 24 >> 24))));
			i = i + (1) >> 0;
		}
		sl = 2;
		if (n > 0) {
			sl = sl + ((((n >>> 0)) + 1 >>> 0)) >>> 0;
		}
		if (sa.raw.Path[0] === 64) {
			sa.raw.Path[0] = 0;
			sl = sl - (1) >>> 0;
		}
		_array = new Uint8Array(110);
		return [(_array), sl, $ifaceNil];
	};
	SockaddrUnix.prototype.sockaddr = function() { return this.$val.sockaddr(); };
	SockaddrLinklayer.ptr.prototype.sockaddr = function() {
		var _array, _struct, _view, i, sa, x, x$1;
		sa = this;
		if (sa.Ifindex < 0 || sa.Ifindex > 2147483647) {
			return [0, 0, new Errno(22)];
		}
		sa.raw.Family = 17;
		sa.raw.Protocol = sa.Protocol;
		sa.raw.Ifindex = ((sa.Ifindex >> 0));
		sa.raw.Hatype = sa.Hatype;
		sa.raw.Pkttype = sa.Pkttype;
		sa.raw.Halen = sa.Halen;
		i = 0;
		while (true) {
			if (!(i < 8)) { break; }
			(x$1 = sa.raw.Addr, ((i < 0 || i >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[i] = (x = sa.Addr, ((i < 0 || i >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i]))));
			i = i + (1) >> 0;
		}
		_array = new Uint8Array(20);
		return [(_array), 20, $ifaceNil];
	};
	SockaddrLinklayer.prototype.sockaddr = function() { return this.$val.sockaddr(); };
	SockaddrNetlink.ptr.prototype.sockaddr = function() {
		var _array, _struct, _view, sa;
		sa = this;
		sa.raw.Family = 16;
		sa.raw.Pad = sa.Pad;
		sa.raw.Pid = sa.Pid;
		sa.raw.Groups = sa.Groups;
		_array = new Uint8Array(12);
		return [(_array), 12, $ifaceNil];
	};
	SockaddrNetlink.prototype.sockaddr = function() { return this.$val.sockaddr(); };
	anyToSockaddr = function(rsa) {
		var _1, _array, _array$1, _array$2, _array$3, _array$4, _array$5, _array$6, _array$7, _array$8, _array$9, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, _struct$6, _struct$7, _struct$8, _struct$9, _view, _view$1, _view$2, _view$3, _view$4, _view$5, _view$6, _view$7, _view$8, _view$9, bytes, i, i$1, i$2, n, p, p$1, pp, pp$1, pp$2, pp$3, pp$4, rsa, sa, sa$1, sa$2, sa$3, sa$4, x, x$1, x$2, x$3, x$4, x$5, x$6;
		_1 = rsa.Addr.Family;
		if (_1 === (16)) {
			_array$1 = new Uint8Array(112);
			pp = ((_array = (_array$1), _struct = new RawSockaddrNetlink.ptr(0, 0, 0, 0), _view = new DataView(_array.buffer, _array.byteOffset), _struct.Family = _view.getUint16(0, true), _struct.Pad = _view.getUint16(2, true), _struct.Pid = _view.getUint32(4, true), _struct.Groups = _view.getUint32(8, true), _struct));
			_struct$1 = rsa, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.Addr.Family = _view$1.getUint16(0, true), _struct$1.Addr.Data = new ($nativeArray($kindInt8))(_array$1.buffer, $min(_array$1.byteOffset + 2, _array$1.buffer.byteLength)), _struct$1.Pad = new ($nativeArray($kindInt8))(_array$1.buffer, $min(_array$1.byteOffset + 16, _array$1.buffer.byteLength));
			sa = new SockaddrNetlink.ptr(0, 0, 0, 0, new RawSockaddrNetlink.ptr(0, 0, 0, 0));
			sa.Family = pp.Family;
			sa.Pad = pp.Pad;
			sa.Pid = pp.Pid;
			sa.Groups = pp.Groups;
			return [sa, $ifaceNil];
		} else if (_1 === (17)) {
			_array$3 = new Uint8Array(112);
			pp$1 = ((_array$2 = (_array$3), _struct$2 = new RawSockaddrLinklayer.ptr(0, 0, 0, 0, 0, 0, arrayType$1.zero()), _view$2 = new DataView(_array$2.buffer, _array$2.byteOffset), _struct$2.Family = _view$2.getUint16(0, true), _struct$2.Protocol = _view$2.getUint16(2, true), _struct$2.Ifindex = _view$2.getInt32(4, true), _struct$2.Hatype = _view$2.getUint16(8, true), _struct$2.Pkttype = _view$2.getUint8(10, true), _struct$2.Halen = _view$2.getUint8(11, true), _struct$2.Addr = new ($nativeArray($kindUint8))(_array$2.buffer, $min(_array$2.byteOffset + 12, _array$2.buffer.byteLength)), _struct$2));
			_struct$3 = rsa, _view$3 = new DataView(_array$3.buffer, _array$3.byteOffset), _struct$3.Addr.Family = _view$3.getUint16(0, true), _struct$3.Addr.Data = new ($nativeArray($kindInt8))(_array$3.buffer, $min(_array$3.byteOffset + 2, _array$3.buffer.byteLength)), _struct$3.Pad = new ($nativeArray($kindInt8))(_array$3.buffer, $min(_array$3.byteOffset + 16, _array$3.buffer.byteLength));
			sa$1 = new SockaddrLinklayer.ptr(0, 0, 0, 0, 0, arrayType$1.zero(), new RawSockaddrLinklayer.ptr(0, 0, 0, 0, 0, 0, arrayType$1.zero()));
			sa$1.Protocol = pp$1.Protocol;
			sa$1.Ifindex = ((pp$1.Ifindex >> 0));
			sa$1.Hatype = pp$1.Hatype;
			sa$1.Pkttype = pp$1.Pkttype;
			sa$1.Halen = pp$1.Halen;
			i = 0;
			while (true) {
				if (!(i < 8)) { break; }
				(x$1 = sa$1.Addr, ((i < 0 || i >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[i] = (x = pp$1.Addr, ((i < 0 || i >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i]))));
				i = i + (1) >> 0;
			}
			return [sa$1, $ifaceNil];
		} else if (_1 === (1)) {
			_array$5 = new Uint8Array(112);
			pp$2 = ((_array$4 = (_array$5), _struct$4 = new RawSockaddrUnix.ptr(0, arrayType$7.zero()), _view$4 = new DataView(_array$4.buffer, _array$4.byteOffset), _struct$4.Family = _view$4.getUint16(0, true), _struct$4.Path = new ($nativeArray($kindInt8))(_array$4.buffer, $min(_array$4.byteOffset + 2, _array$4.buffer.byteLength)), _struct$4));
			_struct$5 = rsa, _view$5 = new DataView(_array$5.buffer, _array$5.byteOffset), _struct$5.Addr.Family = _view$5.getUint16(0, true), _struct$5.Addr.Data = new ($nativeArray($kindInt8))(_array$5.buffer, $min(_array$5.byteOffset + 2, _array$5.buffer.byteLength)), _struct$5.Pad = new ($nativeArray($kindInt8))(_array$5.buffer, $min(_array$5.byteOffset + 16, _array$5.buffer.byteLength));
			sa$2 = new SockaddrUnix.ptr("", new RawSockaddrUnix.ptr(0, arrayType$7.zero()));
			if (pp$2.Path[0] === 0) {
				pp$2.Path[0] = 64;
			}
			n = 0;
			while (true) {
				if (!(n < 108 && !(((x$2 = pp$2.Path, ((n < 0 || n >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[n])) === 0)))) { break; }
				n = n + (1) >> 0;
			}
			bytes = $subslice(new sliceType((($sliceToArray(new sliceType(pp$2.Path))))), 0, n);
			sa$2.Name = ($bytesToString(bytes));
			return [sa$2, $ifaceNil];
		} else if (_1 === (2)) {
			_array$7 = new Uint8Array(112);
			pp$3 = ((_array$6 = (_array$7), _struct$6 = new RawSockaddrInet4.ptr(0, 0, arrayType$8.zero(), arrayType$1.zero()), _view$6 = new DataView(_array$6.buffer, _array$6.byteOffset), _struct$6.Family = _view$6.getUint16(0, true), _struct$6.Port = _view$6.getUint16(2, true), _struct$6.Addr = new ($nativeArray($kindUint8))(_array$6.buffer, $min(_array$6.byteOffset + 4, _array$6.buffer.byteLength)), _struct$6.Zero = new ($nativeArray($kindUint8))(_array$6.buffer, $min(_array$6.byteOffset + 8, _array$6.buffer.byteLength)), _struct$6));
			_struct$7 = rsa, _view$7 = new DataView(_array$7.buffer, _array$7.byteOffset), _struct$7.Addr.Family = _view$7.getUint16(0, true), _struct$7.Addr.Data = new ($nativeArray($kindInt8))(_array$7.buffer, $min(_array$7.byteOffset + 2, _array$7.buffer.byteLength)), _struct$7.Pad = new ($nativeArray($kindInt8))(_array$7.buffer, $min(_array$7.byteOffset + 16, _array$7.buffer.byteLength));
			sa$3 = new SockaddrInet4.ptr(0, arrayType$8.zero(), new RawSockaddrInet4.ptr(0, 0, arrayType$8.zero(), arrayType$1.zero()));
			p = (((pp$3.$ptr_Port || (pp$3.$ptr_Port = new ptrType$8(function() { return this.$target.Port; }, function($v) { this.$target.Port = $v; }, pp$3)))));
			sa$3.Port = ((((p.nilCheck, p[0]) >> 0)) << 8 >> 0) + (((p.nilCheck, p[1]) >> 0)) >> 0;
			i$1 = 0;
			while (true) {
				if (!(i$1 < 4)) { break; }
				(x$4 = sa$3.Addr, ((i$1 < 0 || i$1 >= x$4.length) ? ($throwRuntimeError("index out of range"), undefined) : x$4[i$1] = (x$3 = pp$3.Addr, ((i$1 < 0 || i$1 >= x$3.length) ? ($throwRuntimeError("index out of range"), undefined) : x$3[i$1]))));
				i$1 = i$1 + (1) >> 0;
			}
			return [sa$3, $ifaceNil];
		} else if (_1 === (10)) {
			_array$9 = new Uint8Array(112);
			pp$4 = ((_array$8 = (_array$9), _struct$8 = new RawSockaddrInet6.ptr(0, 0, 0, arrayType$2.zero(), 0), _view$8 = new DataView(_array$8.buffer, _array$8.byteOffset), _struct$8.Family = _view$8.getUint16(0, true), _struct$8.Port = _view$8.getUint16(2, true), _struct$8.Flowinfo = _view$8.getUint32(4, true), _struct$8.Addr = new ($nativeArray($kindUint8))(_array$8.buffer, $min(_array$8.byteOffset + 8, _array$8.buffer.byteLength)), _struct$8.Scope_id = _view$8.getUint32(24, true), _struct$8));
			_struct$9 = rsa, _view$9 = new DataView(_array$9.buffer, _array$9.byteOffset), _struct$9.Addr.Family = _view$9.getUint16(0, true), _struct$9.Addr.Data = new ($nativeArray($kindInt8))(_array$9.buffer, $min(_array$9.byteOffset + 2, _array$9.buffer.byteLength)), _struct$9.Pad = new ($nativeArray($kindInt8))(_array$9.buffer, $min(_array$9.byteOffset + 16, _array$9.buffer.byteLength));
			sa$4 = new SockaddrInet6.ptr(0, 0, arrayType$2.zero(), new RawSockaddrInet6.ptr(0, 0, 0, arrayType$2.zero(), 0));
			p$1 = (((pp$4.$ptr_Port || (pp$4.$ptr_Port = new ptrType$8(function() { return this.$target.Port; }, function($v) { this.$target.Port = $v; }, pp$4)))));
			sa$4.Port = ((((p$1.nilCheck, p$1[0]) >> 0)) << 8 >> 0) + (((p$1.nilCheck, p$1[1]) >> 0)) >> 0;
			sa$4.ZoneId = pp$4.Scope_id;
			i$2 = 0;
			while (true) {
				if (!(i$2 < 16)) { break; }
				(x$6 = sa$4.Addr, ((i$2 < 0 || i$2 >= x$6.length) ? ($throwRuntimeError("index out of range"), undefined) : x$6[i$2] = (x$5 = pp$4.Addr, ((i$2 < 0 || i$2 >= x$5.length) ? ($throwRuntimeError("index out of range"), undefined) : x$5[i$2]))));
				i$2 = i$2 + (1) >> 0;
			}
			return [sa$4, $ifaceNil];
		}
		return [$ifaceNil, new Errno(97)];
	};
	Accept = function(fd) {
		var _tuple, _tuple$1, err, fd, len, len$24ptr, nfd, rsa, sa;
		nfd = 0;
		sa = $ifaceNil;
		err = $ifaceNil;
		rsa = new RawSockaddrAny.ptr(new RawSockaddr.ptr(0, arrayType$9.zero()), arrayType$10.zero());
		len = 112;
		_tuple = accept(fd, rsa, (len$24ptr || (len$24ptr = new ptrType$18(function() { return len; }, function($v) { len = $v; }))));
		nfd = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [nfd, sa, err];
		}
		_tuple$1 = anyToSockaddr(rsa);
		sa = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			Close(nfd);
			nfd = 0;
		}
		return [nfd, sa, err];
	};
	$pkg.Accept = Accept;
	Accept4 = function(fd, flags) {
		var _tuple, _tuple$1, err, fd, flags, len, len$24ptr, nfd, rsa, sa;
		nfd = 0;
		sa = $ifaceNil;
		err = $ifaceNil;
		rsa = new RawSockaddrAny.ptr(new RawSockaddr.ptr(0, arrayType$9.zero()), arrayType$10.zero());
		len = 112;
		_tuple = accept4(fd, rsa, (len$24ptr || (len$24ptr = new ptrType$18(function() { return len; }, function($v) { len = $v; }))), flags);
		nfd = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [nfd, sa, err];
		}
		if (len > 112) {
			$panic(new $String("RawSockaddrAny too small"));
		}
		_tuple$1 = anyToSockaddr(rsa);
		sa = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			Close(nfd);
			nfd = 0;
		}
		return [nfd, sa, err];
	};
	$pkg.Accept4 = Accept4;
	SetsockoptIPMreqn = function(fd, level, opt, mreq) {
		var _array, _struct, _view, err, fd, level, mreq, opt;
		err = $ifaceNil;
		_array = new Uint8Array(12);
		err = setsockopt(fd, level, opt, (_array), 12);
		_struct = mreq, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Multiaddr = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 0, _array.buffer.byteLength)), _struct.Address = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 4, _array.buffer.byteLength)), _struct.Ifindex = _view.getInt32(8, true);
		return err;
	};
	$pkg.SetsockoptIPMreqn = SetsockoptIPMreqn;
	Recvmsg = function(fd, p, oob, flags) {
		var _array, _struct, _tuple, _tuple$1, _view, dummy, dummy$24ptr, err, fd, flags, from, iov, msg, n, oob, oobn, p, recvflags, rsa;
		n = 0;
		oobn = 0;
		recvflags = 0;
		from = $ifaceNil;
		err = $ifaceNil;
		msg = new Msghdr.ptr(ptrType$2.nil, 0, arrayType$8.zero(), ptrType$19.nil, new $Uint64(0, 0), ptrType$2.nil, new $Uint64(0, 0), 0, arrayType$8.zero());
		rsa = new RawSockaddrAny.ptr(new RawSockaddr.ptr(0, arrayType$9.zero()), arrayType$10.zero());
		_array = new Uint8Array(112);
		msg.Name = ((_array));
		_struct = rsa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Addr.Family = _view.getUint16(0, true), _struct.Addr.Data = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 2, _array.buffer.byteLength)), _struct.Pad = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 16, _array.buffer.byteLength));
		msg.Namelen = 112;
		iov = new Iovec.ptr(ptrType$2.nil, new $Uint64(0, 0));
		if (p.$length > 0) {
			iov.Base = (($sliceToArray(p)));
			iov.SetLen(p.$length);
		}
		dummy = 0;
		if (oob.$length > 0) {
			if (p.$length === 0) {
				iov.Base = (dummy$24ptr || (dummy$24ptr = new ptrType$2(function() { return dummy; }, function($v) { dummy = $v; })));
				iov.SetLen(1);
			}
			msg.Control = (($sliceToArray(oob)));
			msg.SetControllen(oob.$length);
		}
		msg.Iov = iov;
		msg.Iovlen = new $Uint64(0, 1);
		_tuple = recvmsg(fd, msg, flags);
		n = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [n, oobn, recvflags, from, err];
		}
		oobn = ((msg.Controllen.$low >> 0));
		recvflags = ((msg.Flags >> 0));
		if (!((rsa.Addr.Family === 0))) {
			_tuple$1 = anyToSockaddr(rsa);
			from = _tuple$1[0];
			err = _tuple$1[1];
		}
		return [n, oobn, recvflags, from, err];
	};
	$pkg.Recvmsg = Recvmsg;
	SendmsgN = function(fd, p, oob, to, flags) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, dummy, err, err$1, fd, flags, iov, msg, n, oob, p, ptr, salen, to, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; dummy = $f.dummy; err = $f.err; err$1 = $f.err$1; fd = $f.fd; flags = $f.flags; iov = $f.iov; msg = $f.msg; n = $f.n; oob = $f.oob; p = $f.p; ptr = $f.ptr; salen = $f.salen; to = $f.to; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		dummy = [dummy];
		iov = [iov];
		msg = [msg];
		n = 0;
		err = $ifaceNil;
		ptr = 0;
		salen = 0;
		/* */ if (!($interfaceIsEqual(to, $ifaceNil))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!($interfaceIsEqual(to, $ifaceNil))) { */ case 1:
			err$1 = $ifaceNil;
			_r = to.sockaddr(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			ptr = _tuple[0];
			salen = _tuple[1];
			err$1 = _tuple[2];
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				_tmp = 0;
				_tmp$1 = err$1;
				n = _tmp;
				err = _tmp$1;
				$s = -1; return [n, err];
			}
		/* } */ case 2:
		msg[0] = new Msghdr.ptr(ptrType$2.nil, 0, arrayType$8.zero(), ptrType$19.nil, new $Uint64(0, 0), ptrType$2.nil, new $Uint64(0, 0), 0, arrayType$8.zero());
		msg[0].Name = ((ptr));
		msg[0].Namelen = ((salen >>> 0));
		iov[0] = new Iovec.ptr(ptrType$2.nil, new $Uint64(0, 0));
		if (p.$length > 0) {
			iov[0].Base = (($sliceToArray(p)));
			iov[0].SetLen(p.$length);
		}
		dummy[0] = 0;
		if (oob.$length > 0) {
			if (p.$length === 0) {
				iov[0].Base = (dummy.$ptr || (dummy.$ptr = new ptrType$2(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, dummy)));
				iov[0].SetLen(1);
			}
			msg[0].Control = (($sliceToArray(oob)));
			msg[0].SetControllen(oob.$length);
		}
		msg[0].Iov = iov[0];
		msg[0].Iovlen = new $Uint64(0, 1);
		_tuple$1 = sendmsg(fd, msg[0], flags);
		n = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			_tmp$2 = 0;
			_tmp$3 = err;
			n = _tmp$2;
			err = _tmp$3;
			$s = -1; return [n, err];
		}
		if (oob.$length > 0 && (p.$length === 0)) {
			n = 0;
		}
		_tmp$4 = n;
		_tmp$5 = $ifaceNil;
		n = _tmp$4;
		err = _tmp$5;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: SendmsgN }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.dummy = dummy; $f.err = err; $f.err$1 = err$1; $f.fd = fd; $f.flags = flags; $f.iov = iov; $f.msg = msg; $f.n = n; $f.oob = oob; $f.p = p; $f.ptr = ptr; $f.salen = salen; $f.to = to; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.SendmsgN = SendmsgN;
	ReadDirent = function(fd, buf) {
		var _tuple, buf, err, fd, n;
		n = 0;
		err = $ifaceNil;
		_tuple = Getdents(fd, buf);
		n = _tuple[0];
		err = _tuple[1];
		return [n, err];
	};
	$pkg.ReadDirent = ReadDirent;
	direntIno = function(buf) {
		var buf;
		return readInt(buf, 0, 8);
	};
	direntReclen = function(buf) {
		var buf;
		return readInt(buf, 16, 2);
	};
	direntNamlen = function(buf) {
		var _tuple, buf, ok, reclen;
		_tuple = direntReclen(buf);
		reclen = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			return [new $Uint64(0, 0), false];
		}
		return [new $Uint64(reclen.$high - 0, reclen.$low - 19), true];
	};
	Iovec.ptr.prototype.SetLen = function(length) {
		var iov, length;
		iov = this;
		iov.Len = (new $Uint64(0, length));
	};
	Iovec.prototype.SetLen = function(length) { return this.$val.SetLen(length); };
	Msghdr.ptr.prototype.SetControllen = function(length) {
		var length, msghdr;
		msghdr = this;
		msghdr.Controllen = (new $Uint64(0, length));
	};
	Msghdr.prototype.SetControllen = function(length) { return this.$val.SetControllen(length); };
	mmapper.ptr.prototype.Mmap = function(fd, offset, length, prot, flags) {
		var _key, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, addr, b, data, err, errno, fd, flags, length, m, offset, p, prot, sl, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _key = $f._key; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; addr = $f.addr; b = $f.b; data = $f.data; err = $f.err; errno = $f.errno; fd = $f.fd; flags = $f.flags; length = $f.length; m = $f.m; offset = $f.offset; p = $f.p; prot = $f.prot; sl = $f.sl; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		sl = [sl];
		data = sliceType.nil;
		err = $ifaceNil;
		m = this;
		if (length <= 0) {
			_tmp = sliceType.nil;
			_tmp$1 = new Errno(22);
			data = _tmp;
			err = _tmp$1;
			$s = -1; return [data, err];
		}
		_r = m.mmap(0, ((length >>> 0)), prot, flags, fd, offset); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		addr = _tuple[0];
		errno = _tuple[1];
		if (!($interfaceIsEqual(errno, $ifaceNil))) {
			_tmp$2 = sliceType.nil;
			_tmp$3 = errno;
			data = _tmp$2;
			err = _tmp$3;
			$s = -1; return [data, err];
		}
		sl[0] = new structType.ptr(addr, length, length);
		b = sl[0];
		p = $indexPtr(b.$array, b.$offset + (b.$capacity - 1 >> 0), ptrType$2);
		$r = m.Mutex.Lock(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(m.Mutex, "Unlock"), []]);
		_key = p; (m.active || $throwRuntimeError("assignment to entry in nil map"))[ptrType$2.keyFor(_key)] = { k: _key, v: b };
		_tmp$4 = b;
		_tmp$5 = $ifaceNil;
		data = _tmp$4;
		err = _tmp$5;
		$s = -1; return [data, err];
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  [data, err]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: mmapper.ptr.prototype.Mmap }; } $f._key = _key; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.addr = addr; $f.b = b; $f.data = data; $f.err = err; $f.errno = errno; $f.fd = fd; $f.flags = flags; $f.length = length; $f.m = m; $f.offset = offset; $f.p = p; $f.prot = prot; $f.sl = sl; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	mmapper.prototype.Mmap = function(fd, offset, length, prot, flags) { return this.$val.Mmap(fd, offset, length, prot, flags); };
	mmapper.ptr.prototype.Munmap = function(data) {
		var _entry, _r, b, data, err, errno, m, p, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; b = $f.b; data = $f.data; err = $f.err; errno = $f.errno; m = $f.m; p = $f.p; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		err = $ifaceNil;
		m = this;
		if ((data.$length === 0) || !((data.$length === data.$capacity))) {
			err = new Errno(22);
			$s = -1; return err;
		}
		p = $indexPtr(data.$array, data.$offset + (data.$capacity - 1 >> 0), ptrType$2);
		$r = m.Mutex.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(m.Mutex, "Unlock"), []]);
		b = (_entry = m.active[ptrType$2.keyFor(p)], _entry !== undefined ? _entry.v : sliceType.nil);
		if (b === sliceType.nil || !($indexPtr(b.$array, b.$offset + 0, ptrType$2) === $indexPtr(data.$array, data.$offset + 0, ptrType$2))) {
			err = new Errno(22);
			$s = -1; return err;
		}
		_r = m.munmap((($sliceToArray(b))), ((b.$length >>> 0))); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		errno = _r;
		if (!($interfaceIsEqual(errno, $ifaceNil))) {
			err = errno;
			$s = -1; return err;
		}
		delete m.active[ptrType$2.keyFor(p)];
		err = $ifaceNil;
		$s = -1; return err;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  err; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: mmapper.ptr.prototype.Munmap }; } $f._entry = _entry; $f._r = _r; $f.b = b; $f.data = data; $f.err = err; $f.errno = errno; $f.m = m; $f.p = p; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	mmapper.prototype.Munmap = function(data) { return this.$val.Munmap(data); };
	Errno.prototype.Error = function() {
		var e, s;
		e = this.$val;
		if (0 <= ((e >> 0)) && ((e >> 0)) < 133) {
			s = ((e < 0 || e >= errors.length) ? ($throwRuntimeError("index out of range"), undefined) : errors[e]);
			if (!(s === "")) {
				return s;
			}
		}
		return "errno " + itoa(((e >> 0)));
	};
	$ptrType(Errno).prototype.Error = function() { return new Errno(this.$get()).Error(); };
	Errno.prototype.Temporary = function() {
		var e;
		e = this.$val;
		return (e === 4) || (e === 24) || (e === 104) || (e === 103) || new Errno(e).Timeout();
	};
	$ptrType(Errno).prototype.Temporary = function() { return new Errno(this.$get()).Temporary(); };
	Errno.prototype.Timeout = function() {
		var e;
		e = this.$val;
		return (e === 11) || (e === 11) || (e === 110);
	};
	$ptrType(Errno).prototype.Timeout = function() { return new Errno(this.$get()).Timeout(); };
	errnoErr = function(e) {
		var _1, e;
		_1 = e;
		if (_1 === (0)) {
			return $ifaceNil;
		} else if (_1 === (11)) {
			return errEAGAIN;
		} else if (_1 === (22)) {
			return errEINVAL;
		} else if (_1 === (2)) {
			return errENOENT;
		}
		return new Errno(e);
	};
	Read = function(fd, p) {
		var _tuple, err, fd, n, p;
		n = 0;
		err = $ifaceNil;
		_tuple = read(fd, p);
		n = _tuple[0];
		err = _tuple[1];
		if (false) {
			if (n > 0) {
				race.WriteRange(($sliceToArray(p)), n);
			}
			if ($interfaceIsEqual(err, $ifaceNil)) {
				race.Acquire(((ioSync$24ptr || (ioSync$24ptr = new ptrType$22(function() { return ioSync; }, function($v) { ioSync = $v; })))));
			}
		}
		if (false && n > 0) {
			msanWrite(($sliceToArray(p)), n);
		}
		return [n, err];
	};
	$pkg.Read = Read;
	Write = function(fd, p) {
		var _tuple, err, fd, n, p;
		n = 0;
		err = $ifaceNil;
		if (false) {
			race.ReleaseMerge(((ioSync$24ptr || (ioSync$24ptr = new ptrType$22(function() { return ioSync; }, function($v) { ioSync = $v; })))));
		}
		_tuple = write(fd, p);
		n = _tuple[0];
		err = _tuple[1];
		if (false && n > 0) {
			race.ReadRange(($sliceToArray(p)), n);
		}
		if (false && n > 0) {
			msanRead(($sliceToArray(p)), n);
		}
		return [n, err];
	};
	$pkg.Write = Write;
	Recvfrom = function(fd, p, flags) {
		var _tuple, _tuple$1, err, fd, flags, from, len, len$24ptr, n, p, rsa;
		n = 0;
		from = $ifaceNil;
		err = $ifaceNil;
		rsa = new RawSockaddrAny.ptr(new RawSockaddr.ptr(0, arrayType$9.zero()), arrayType$10.zero());
		len = 112;
		_tuple = recvfrom(fd, p, flags, rsa, (len$24ptr || (len$24ptr = new ptrType$18(function() { return len; }, function($v) { len = $v; }))));
		n = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [n, from, err];
		}
		if (!((rsa.Addr.Family === 0))) {
			_tuple$1 = anyToSockaddr(rsa);
			from = _tuple$1[0];
			err = _tuple$1[1];
		}
		return [n, from, err];
	};
	$pkg.Recvfrom = Recvfrom;
	Sendto = function(fd, p, flags, to) {
		var _r, _tuple, err, fd, flags, n, p, ptr, to, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; fd = $f.fd; flags = $f.flags; n = $f.n; p = $f.p; ptr = $f.ptr; to = $f.to; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		err = $ifaceNil;
		_r = to.sockaddr(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		ptr = _tuple[0];
		n = _tuple[1];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			err = err;
			$s = -1; return err;
		}
		err = sendto(fd, p, flags, ptr, n);
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Sendto }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.fd = fd; $f.flags = flags; $f.n = n; $f.p = p; $f.ptr = ptr; $f.to = to; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Sendto = Sendto;
	SetsockoptByte = function(fd, level, opt, value) {
		var err, fd, level, opt, value, value$24ptr;
		err = $ifaceNil;
		err = setsockopt(fd, level, opt, ((value$24ptr || (value$24ptr = new ptrType$2(function() { return value; }, function($v) { value = $v; })))), 1);
		return err;
	};
	$pkg.SetsockoptByte = SetsockoptByte;
	SetsockoptInt = function(fd, level, opt, value) {
		var err, fd, level, n, n$24ptr, opt, value;
		err = $ifaceNil;
		n = ((value >> 0));
		err = setsockopt(fd, level, opt, ((n$24ptr || (n$24ptr = new ptrType$4(function() { return n; }, function($v) { n = $v; })))), 4);
		return err;
	};
	$pkg.SetsockoptInt = SetsockoptInt;
	SetsockoptInet4Addr = function(fd, level, opt, value) {
		var err, fd, level, opt, value;
		err = $ifaceNil;
		err = setsockopt(fd, level, opt, ($sliceToArray(new sliceType(value))), 4);
		return err;
	};
	$pkg.SetsockoptInet4Addr = SetsockoptInet4Addr;
	SetsockoptIPMreq = function(fd, level, opt, mreq) {
		var _array, _struct, _view, err, fd, level, mreq, opt;
		err = $ifaceNil;
		_array = new Uint8Array(8);
		err = setsockopt(fd, level, opt, (_array), 8);
		_struct = mreq, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Multiaddr = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 0, _array.buffer.byteLength)), _struct.Interface = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 4, _array.buffer.byteLength));
		return err;
	};
	$pkg.SetsockoptIPMreq = SetsockoptIPMreq;
	SetsockoptIPv6Mreq = function(fd, level, opt, mreq) {
		var _array, _struct, _view, err, fd, level, mreq, opt;
		err = $ifaceNil;
		_array = new Uint8Array(20);
		err = setsockopt(fd, level, opt, (_array), 20);
		_struct = mreq, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Multiaddr = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 0, _array.buffer.byteLength)), _struct.Interface = _view.getUint32(16, true);
		return err;
	};
	$pkg.SetsockoptIPv6Mreq = SetsockoptIPv6Mreq;
	SetsockoptLinger = function(fd, level, opt, l) {
		var _array, _struct, _view, err, fd, l, level, opt;
		err = $ifaceNil;
		_array = new Uint8Array(8);
		err = setsockopt(fd, level, opt, (_array), 8);
		_struct = l, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Onoff = _view.getInt32(0, true), _struct.Linger = _view.getInt32(4, true);
		return err;
	};
	$pkg.SetsockoptLinger = SetsockoptLinger;
	Close = function(fd) {
		var _tuple, e1, err, fd;
		err = $ifaceNil;
		_tuple = Syscall(3, ((fd >>> 0)), 0, 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Close = Close;
	Fchdir = function(fd) {
		var _tuple, e1, err, fd;
		err = $ifaceNil;
		_tuple = Syscall(81, ((fd >>> 0)), 0, 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Fchdir = Fchdir;
	Fchmod = function(fd, mode) {
		var _tuple, e1, err, fd, mode;
		err = $ifaceNil;
		_tuple = Syscall(91, ((fd >>> 0)), ((mode >>> 0)), 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Fchmod = Fchmod;
	fcntl = function(fd, cmd, arg) {
		var _tuple, arg, cmd, e1, err, fd, r0, val;
		val = 0;
		err = $ifaceNil;
		_tuple = Syscall(72, ((fd >>> 0)), ((cmd >>> 0)), ((arg >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		val = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [val, err];
	};
	Fsync = function(fd) {
		var _tuple, e1, err, fd;
		err = $ifaceNil;
		_tuple = Syscall(74, ((fd >>> 0)), 0, 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Fsync = Fsync;
	Getdents = function(fd, buf) {
		var _p0, _tuple, buf, e1, err, fd, n, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (buf.$length > 0) {
			_p0 = ($sliceToArray(buf));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall(217, ((fd >>> 0)), (_p0), ((buf.$length >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	$pkg.Getdents = Getdents;
	read = function(fd, p) {
		var _p0, _tuple, e1, err, fd, n, p, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (p.$length > 0) {
			_p0 = ($sliceToArray(p));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall(0, ((fd >>> 0)), (_p0), ((p.$length >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	write = function(fd, p) {
		var _p0, _tuple, e1, err, fd, n, p, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (p.$length > 0) {
			_p0 = ($sliceToArray(p));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall(1, ((fd >>> 0)), (_p0), ((p.$length >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	munmap = function(addr, length) {
		var _tuple, addr, e1, err, length;
		err = $ifaceNil;
		_tuple = Syscall(11, (addr), (length), 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	Fchown = function(fd, uid, gid) {
		var _tuple, e1, err, fd, gid, uid;
		err = $ifaceNil;
		_tuple = Syscall(93, ((fd >>> 0)), ((uid >>> 0)), ((gid >>> 0)));
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Fchown = Fchown;
	Fstat = function(fd, stat) {
		var _array, _struct, _tuple, _view, e1, err, fd, stat;
		err = $ifaceNil;
		_array = new Uint8Array(144);
		_tuple = Syscall(5, ((fd >>> 0)), ((_array)), 0);
		_struct = stat, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Dev = new $Uint64(_view.getUint32(4, true), _view.getUint32(0, true)), _struct.Ino = new $Uint64(_view.getUint32(12, true), _view.getUint32(8, true)), _struct.Nlink = new $Uint64(_view.getUint32(20, true), _view.getUint32(16, true)), _struct.Mode = _view.getUint32(24, true), _struct.Uid = _view.getUint32(28, true), _struct.Gid = _view.getUint32(32, true), _struct.X__pad0 = _view.getInt32(36, true), _struct.Rdev = new $Uint64(_view.getUint32(44, true), _view.getUint32(40, true)), _struct.Size = new $Int64(_view.getUint32(52, true), _view.getUint32(48, true)), _struct.Blksize = new $Int64(_view.getUint32(60, true), _view.getUint32(56, true)), _struct.Blocks = new $Int64(_view.getUint32(68, true), _view.getUint32(64, true)), _struct.Atim.Sec = new $Int64(_view.getUint32(76, true), _view.getUint32(72, true)), _struct.Atim.Nsec = new $Int64(_view.getUint32(84, true), _view.getUint32(80, true)), _struct.Mtim.Sec = new $Int64(_view.getUint32(92, true), _view.getUint32(88, true)), _struct.Mtim.Nsec = new $Int64(_view.getUint32(100, true), _view.getUint32(96, true)), _struct.Ctim.Sec = new $Int64(_view.getUint32(108, true), _view.getUint32(104, true)), _struct.Ctim.Nsec = new $Int64(_view.getUint32(116, true), _view.getUint32(112, true)), _struct.X__unused = new ($nativeArray($kindInt64))(_array.buffer, $min(_array.byteOffset + 120, _array.buffer.byteLength));
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Fstat = Fstat;
	Ftruncate = function(fd, length) {
		var _tuple, e1, err, fd, length;
		err = $ifaceNil;
		_tuple = Syscall(77, ((fd >>> 0)), ((length.$low >>> 0)), 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Ftruncate = Ftruncate;
	Lstat = function(path, stat) {
		var _array, _p0, _struct, _tuple, _tuple$1, _view, e1, err, path, stat;
		err = $ifaceNil;
		_p0 = ptrType$2.nil;
		_tuple = BytePtrFromString(path);
		_p0 = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return err;
		}
		_array = new Uint8Array(144);
		_tuple$1 = Syscall(6, ((_p0)), ((_array)), 0);
		_struct = stat, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Dev = new $Uint64(_view.getUint32(4, true), _view.getUint32(0, true)), _struct.Ino = new $Uint64(_view.getUint32(12, true), _view.getUint32(8, true)), _struct.Nlink = new $Uint64(_view.getUint32(20, true), _view.getUint32(16, true)), _struct.Mode = _view.getUint32(24, true), _struct.Uid = _view.getUint32(28, true), _struct.Gid = _view.getUint32(32, true), _struct.X__pad0 = _view.getInt32(36, true), _struct.Rdev = new $Uint64(_view.getUint32(44, true), _view.getUint32(40, true)), _struct.Size = new $Int64(_view.getUint32(52, true), _view.getUint32(48, true)), _struct.Blksize = new $Int64(_view.getUint32(60, true), _view.getUint32(56, true)), _struct.Blocks = new $Int64(_view.getUint32(68, true), _view.getUint32(64, true)), _struct.Atim.Sec = new $Int64(_view.getUint32(76, true), _view.getUint32(72, true)), _struct.Atim.Nsec = new $Int64(_view.getUint32(84, true), _view.getUint32(80, true)), _struct.Mtim.Sec = new $Int64(_view.getUint32(92, true), _view.getUint32(88, true)), _struct.Mtim.Nsec = new $Int64(_view.getUint32(100, true), _view.getUint32(96, true)), _struct.Ctim.Sec = new $Int64(_view.getUint32(108, true), _view.getUint32(104, true)), _struct.Ctim.Nsec = new $Int64(_view.getUint32(116, true), _view.getUint32(112, true)), _struct.X__unused = new ($nativeArray($kindInt64))(_array.buffer, $min(_array.byteOffset + 120, _array.buffer.byteLength));
		e1 = _tuple$1[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Lstat = Lstat;
	Pread = function(fd, p, offset) {
		var _p0, _tuple, e1, err, fd, n, offset, p, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (p.$length > 0) {
			_p0 = ($sliceToArray(p));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall6(17, ((fd >>> 0)), (_p0), ((p.$length >>> 0)), ((offset.$low >>> 0)), 0, 0);
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	$pkg.Pread = Pread;
	Pwrite = function(fd, p, offset) {
		var _p0, _tuple, e1, err, fd, n, offset, p, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (p.$length > 0) {
			_p0 = ($sliceToArray(p));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall6(18, ((fd >>> 0)), (_p0), ((p.$length >>> 0)), ((offset.$low >>> 0)), 0, 0);
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	$pkg.Pwrite = Pwrite;
	Seek = function(fd, offset, whence) {
		var _tuple, e1, err, fd, off, offset, r0, whence;
		off = new $Int64(0, 0);
		err = $ifaceNil;
		_tuple = Syscall(8, ((fd >>> 0)), ((offset.$low >>> 0)), ((whence >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		off = (new $Int64(0, r0.constructor === Number ? r0 : 1));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [off, err];
	};
	$pkg.Seek = Seek;
	Shutdown = function(fd, how) {
		var _tuple, e1, err, fd, how;
		err = $ifaceNil;
		_tuple = Syscall(48, ((fd >>> 0)), ((how >>> 0)), 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Shutdown = Shutdown;
	accept = function(s, rsa, addrlen) {
		var _array, _struct, _tuple, _view, addrlen, e1, err, fd, r0, rsa, s;
		fd = 0;
		err = $ifaceNil;
		_array = new Uint8Array(112);
		_tuple = Syscall(43, ((s >>> 0)), ((_array)), ((addrlen)));
		_struct = rsa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Addr.Family = _view.getUint16(0, true), _struct.Addr.Data = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 2, _array.buffer.byteLength)), _struct.Pad = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 16, _array.buffer.byteLength));
		r0 = _tuple[0];
		e1 = _tuple[2];
		fd = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [fd, err];
	};
	accept4 = function(s, rsa, addrlen, flags) {
		var _array, _struct, _tuple, _view, addrlen, e1, err, fd, flags, r0, rsa, s;
		fd = 0;
		err = $ifaceNil;
		_array = new Uint8Array(112);
		_tuple = Syscall6(288, ((s >>> 0)), ((_array)), ((addrlen)), ((flags >>> 0)), 0, 0);
		_struct = rsa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Addr.Family = _view.getUint16(0, true), _struct.Addr.Data = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 2, _array.buffer.byteLength)), _struct.Pad = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 16, _array.buffer.byteLength));
		r0 = _tuple[0];
		e1 = _tuple[2];
		fd = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [fd, err];
	};
	setsockopt = function(s, level, name, val, vallen) {
		var _tuple, e1, err, level, name, s, val, vallen;
		err = $ifaceNil;
		_tuple = Syscall6(54, ((s >>> 0)), ((level >>> 0)), ((name >>> 0)), (val), (vallen), 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	recvfrom = function(fd, p, flags, from, fromlen) {
		var _array, _p0, _struct, _tuple, _view, e1, err, fd, flags, from, fromlen, n, p, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (p.$length > 0) {
			_p0 = ($sliceToArray(p));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_array = new Uint8Array(112);
		_tuple = Syscall6(45, ((fd >>> 0)), (_p0), ((p.$length >>> 0)), ((flags >>> 0)), ((_array)), ((fromlen)));
		_struct = from, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Addr.Family = _view.getUint16(0, true), _struct.Addr.Data = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 2, _array.buffer.byteLength)), _struct.Pad = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 16, _array.buffer.byteLength));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	sendto = function(s, buf, flags, to, addrlen) {
		var _p0, _tuple, addrlen, buf, e1, err, flags, s, to;
		err = $ifaceNil;
		_p0 = 0;
		if (buf.$length > 0) {
			_p0 = ($sliceToArray(buf));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall6(44, ((s >>> 0)), (_p0), ((buf.$length >>> 0)), ((flags >>> 0)), (to), ((addrlen >>> 0)));
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	recvmsg = function(s, msg, flags) {
		var _array, _struct, _tuple, _view, e1, err, flags, msg, n, r0, s;
		n = 0;
		err = $ifaceNil;
		_array = new Uint8Array(48);
		_tuple = Syscall(47, ((s >>> 0)), ((_array)), ((flags >>> 0)));
		_struct = msg, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Namelen = _view.getUint32(4, true), _struct.Pad_cgo_0 = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 8, _array.buffer.byteLength)), _struct.Iovlen = new $Uint64(_view.getUint32(20, true), _view.getUint32(16, true)), _struct.Controllen = new $Uint64(_view.getUint32(36, true), _view.getUint32(32, true)), _struct.Flags = _view.getInt32(40, true), _struct.Pad_cgo_1 = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 44, _array.buffer.byteLength));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	sendmsg = function(s, msg, flags) {
		var _array, _struct, _tuple, _view, e1, err, flags, msg, n, r0, s;
		n = 0;
		err = $ifaceNil;
		_array = new Uint8Array(48);
		_tuple = Syscall(46, ((s >>> 0)), ((_array)), ((flags >>> 0)));
		_struct = msg, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Namelen = _view.getUint32(4, true), _struct.Pad_cgo_0 = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 8, _array.buffer.byteLength)), _struct.Iovlen = new $Uint64(_view.getUint32(20, true), _view.getUint32(16, true)), _struct.Controllen = new $Uint64(_view.getUint32(36, true), _view.getUint32(32, true)), _struct.Flags = _view.getInt32(40, true), _struct.Pad_cgo_1 = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 44, _array.buffer.byteLength));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	mmap = function(addr, length, prot, flags, fd, offset) {
		var _tuple, addr, e1, err, fd, flags, length, offset, prot, r0, xaddr;
		xaddr = 0;
		err = $ifaceNil;
		_tuple = Syscall6(9, (addr), (length), ((prot >>> 0)), ((flags >>> 0)), ((fd >>> 0)), ((offset.$low >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		xaddr = (r0);
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [xaddr, err];
	};
	ptrType$24.methods = [{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}];
	ptrType$11.methods = [{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}];
	ptrType$25.methods = [{prop: "Mmap", name: "Mmap", pkg: "", typ: $funcType([$Int, $Int64, $Int, $Int, $Int], [sliceType, $error], false)}, {prop: "Munmap", name: "Munmap", pkg: "", typ: $funcType([sliceType], [$error], false)}];
	Errno.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Temporary", name: "Temporary", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Timeout", name: "Timeout", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$26.methods = [{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}];
	ptrType$27.methods = [{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}];
	ptrType$28.methods = [{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}];
	ptrType$29.methods = [{prop: "Unix", name: "Unix", pkg: "", typ: $funcType([], [$Int64, $Int64], false)}, {prop: "Nano", name: "Nano", pkg: "", typ: $funcType([], [$Int64], false)}];
	ptrType$19.methods = [{prop: "SetLen", name: "SetLen", pkg: "", typ: $funcType([$Int], [], false)}];
	ptrType$31.methods = [{prop: "SetControllen", name: "SetControllen", pkg: "", typ: $funcType([$Int], [], false)}];
	SockaddrLinklayer.init("syscall", [{prop: "Protocol", name: "Protocol", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Ifindex", name: "Ifindex", anonymous: false, exported: true, typ: $Int, tag: ""}, {prop: "Hatype", name: "Hatype", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pkttype", name: "Pkttype", anonymous: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Halen", name: "Halen", anonymous: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Addr", name: "Addr", anonymous: false, exported: true, typ: arrayType$1, tag: ""}, {prop: "raw", name: "raw", anonymous: false, exported: false, typ: RawSockaddrLinklayer, tag: ""}]);
	SockaddrNetlink.init("syscall", [{prop: "Family", name: "Family", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pad", name: "Pad", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pid", name: "Pid", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Groups", name: "Groups", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "raw", name: "raw", anonymous: false, exported: false, typ: RawSockaddrNetlink, tag: ""}]);
	mmapper.init("syscall", [{prop: "Mutex", name: "Mutex", anonymous: true, exported: true, typ: sync.Mutex, tag: ""}, {prop: "active", name: "active", anonymous: false, exported: false, typ: mapType, tag: ""}, {prop: "mmap", name: "mmap", anonymous: false, exported: false, typ: funcType$2, tag: ""}, {prop: "munmap", name: "munmap", anonymous: false, exported: false, typ: funcType$3, tag: ""}]);
	Sockaddr.init([{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}]);
	SockaddrInet4.init("syscall", [{prop: "Port", name: "Port", anonymous: false, exported: true, typ: $Int, tag: ""}, {prop: "Addr", name: "Addr", anonymous: false, exported: true, typ: arrayType$8, tag: ""}, {prop: "raw", name: "raw", anonymous: false, exported: false, typ: RawSockaddrInet4, tag: ""}]);
	SockaddrInet6.init("syscall", [{prop: "Port", name: "Port", anonymous: false, exported: true, typ: $Int, tag: ""}, {prop: "ZoneId", name: "ZoneId", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Addr", name: "Addr", anonymous: false, exported: true, typ: arrayType$2, tag: ""}, {prop: "raw", name: "raw", anonymous: false, exported: false, typ: RawSockaddrInet6, tag: ""}]);
	SockaddrUnix.init("syscall", [{prop: "Name", name: "Name", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "raw", name: "raw", anonymous: false, exported: false, typ: RawSockaddrUnix, tag: ""}]);
	Timespec.init("", [{prop: "Sec", name: "Sec", anonymous: false, exported: true, typ: $Int64, tag: ""}, {prop: "Nsec", name: "Nsec", anonymous: false, exported: true, typ: $Int64, tag: ""}]);
	Stat_t.init("", [{prop: "Dev", name: "Dev", anonymous: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Ino", name: "Ino", anonymous: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Nlink", name: "Nlink", anonymous: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Mode", name: "Mode", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Uid", name: "Uid", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Gid", name: "Gid", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "X__pad0", name: "X__pad0", anonymous: false, exported: true, typ: $Int32, tag: ""}, {prop: "Rdev", name: "Rdev", anonymous: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Size", name: "Size", anonymous: false, exported: true, typ: $Int64, tag: ""}, {prop: "Blksize", name: "Blksize", anonymous: false, exported: true, typ: $Int64, tag: ""}, {prop: "Blocks", name: "Blocks", anonymous: false, exported: true, typ: $Int64, tag: ""}, {prop: "Atim", name: "Atim", anonymous: false, exported: true, typ: Timespec, tag: ""}, {prop: "Mtim", name: "Mtim", anonymous: false, exported: true, typ: Timespec, tag: ""}, {prop: "Ctim", name: "Ctim", anonymous: false, exported: true, typ: Timespec, tag: ""}, {prop: "X__unused", name: "X__unused", anonymous: false, exported: true, typ: arrayType$15, tag: ""}]);
	RawSockaddrInet4.init("", [{prop: "Family", name: "Family", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Port", name: "Port", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Addr", name: "Addr", anonymous: false, exported: true, typ: arrayType$8, tag: ""}, {prop: "Zero", name: "Zero", anonymous: false, exported: true, typ: arrayType$1, tag: ""}]);
	RawSockaddrInet6.init("", [{prop: "Family", name: "Family", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Port", name: "Port", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Flowinfo", name: "Flowinfo", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Addr", name: "Addr", anonymous: false, exported: true, typ: arrayType$2, tag: ""}, {prop: "Scope_id", name: "Scope_id", anonymous: false, exported: true, typ: $Uint32, tag: ""}]);
	RawSockaddrUnix.init("", [{prop: "Family", name: "Family", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Path", name: "Path", anonymous: false, exported: true, typ: arrayType$7, tag: ""}]);
	RawSockaddrLinklayer.init("", [{prop: "Family", name: "Family", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Protocol", name: "Protocol", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Ifindex", name: "Ifindex", anonymous: false, exported: true, typ: $Int32, tag: ""}, {prop: "Hatype", name: "Hatype", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pkttype", name: "Pkttype", anonymous: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Halen", name: "Halen", anonymous: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Addr", name: "Addr", anonymous: false, exported: true, typ: arrayType$1, tag: ""}]);
	RawSockaddrNetlink.init("", [{prop: "Family", name: "Family", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pad", name: "Pad", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pid", name: "Pid", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Groups", name: "Groups", anonymous: false, exported: true, typ: $Uint32, tag: ""}]);
	RawSockaddr.init("", [{prop: "Family", name: "Family", anonymous: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Data", name: "Data", anonymous: false, exported: true, typ: arrayType$9, tag: ""}]);
	RawSockaddrAny.init("", [{prop: "Addr", name: "Addr", anonymous: false, exported: true, typ: RawSockaddr, tag: ""}, {prop: "Pad", name: "Pad", anonymous: false, exported: true, typ: arrayType$10, tag: ""}]);
	Linger.init("", [{prop: "Onoff", name: "Onoff", anonymous: false, exported: true, typ: $Int32, tag: ""}, {prop: "Linger", name: "Linger", anonymous: false, exported: true, typ: $Int32, tag: ""}]);
	Iovec.init("", [{prop: "Base", name: "Base", anonymous: false, exported: true, typ: ptrType$2, tag: ""}, {prop: "Len", name: "Len", anonymous: false, exported: true, typ: $Uint64, tag: ""}]);
	IPMreq.init("", [{prop: "Multiaddr", name: "Multiaddr", anonymous: false, exported: true, typ: arrayType$8, tag: ""}, {prop: "Interface", name: "Interface", anonymous: false, exported: true, typ: arrayType$8, tag: ""}]);
	IPMreqn.init("", [{prop: "Multiaddr", name: "Multiaddr", anonymous: false, exported: true, typ: arrayType$8, tag: ""}, {prop: "Address", name: "Address", anonymous: false, exported: true, typ: arrayType$8, tag: ""}, {prop: "Ifindex", name: "Ifindex", anonymous: false, exported: true, typ: $Int32, tag: ""}]);
	IPv6Mreq.init("", [{prop: "Multiaddr", name: "Multiaddr", anonymous: false, exported: true, typ: arrayType$2, tag: ""}, {prop: "Interface", name: "Interface", anonymous: false, exported: true, typ: $Uint32, tag: ""}]);
	Msghdr.init("", [{prop: "Name", name: "Name", anonymous: false, exported: true, typ: ptrType$2, tag: ""}, {prop: "Namelen", name: "Namelen", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Pad_cgo_0", name: "Pad_cgo_0", anonymous: false, exported: true, typ: arrayType$8, tag: ""}, {prop: "Iov", name: "Iov", anonymous: false, exported: true, typ: ptrType$19, tag: ""}, {prop: "Iovlen", name: "Iovlen", anonymous: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Control", name: "Control", anonymous: false, exported: true, typ: ptrType$2, tag: ""}, {prop: "Controllen", name: "Controllen", anonymous: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Flags", name: "Flags", anonymous: false, exported: true, typ: $Int32, tag: ""}, {prop: "Pad_cgo_1", name: "Pad_cgo_1", anonymous: false, exported: true, typ: arrayType$8, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = race.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		lineBuffer = sliceType.nil;
		syscallModule = null;
		ioSync = new $Int64(0, 0);
		warningPrinted = false;
		alreadyTriedToLoad = false;
		minusOne = -1;
		envs = runtime_envs();
		$pkg.Stdin = 0;
		$pkg.Stdout = 1;
		$pkg.Stderr = 2;
		errEAGAIN = new Errno(11);
		errEINVAL = new Errno(22);
		errENOENT = new Errno(2);
		errors = $toNativeArray($kindString, ["", "operation not permitted", "no such file or directory", "no such process", "interrupted system call", "input/output error", "no such device or address", "argument list too long", "exec format error", "bad file descriptor", "no child processes", "resource temporarily unavailable", "cannot allocate memory", "permission denied", "bad address", "block device required", "device or resource busy", "file exists", "invalid cross-device link", "no such device", "not a directory", "is a directory", "invalid argument", "too many open files in system", "too many open files", "inappropriate ioctl for device", "text file busy", "file too large", "no space left on device", "illegal seek", "read-only file system", "too many links", "broken pipe", "numerical argument out of domain", "numerical result out of range", "resource deadlock avoided", "file name too long", "no locks available", "function not implemented", "directory not empty", "too many levels of symbolic links", "", "no message of desired type", "identifier removed", "channel number out of range", "level 2 not synchronized", "level 3 halted", "level 3 reset", "link number out of range", "protocol driver not attached", "no CSI structure available", "level 2 halted", "invalid exchange", "invalid request descriptor", "exchange full", "no anode", "invalid request code", "invalid slot", "", "bad font file format", "device not a stream", "no data available", "timer expired", "out of streams resources", "machine is not on the network", "package not installed", "object is remote", "link has been severed", "advertise error", "srmount error", "communication error on send", "protocol error", "multihop attempted", "RFS specific error", "bad message", "value too large for defined data type", "name not unique on network", "file descriptor in bad state", "remote address changed", "can not access a needed shared library", "accessing a corrupted shared library", ".lib section in a.out corrupted", "attempting to link in too many shared libraries", "cannot exec a shared library directly", "invalid or incomplete multibyte or wide character", "interrupted system call should be restarted", "streams pipe error", "too many users", "socket operation on non-socket", "destination address required", "message too long", "protocol wrong type for socket", "protocol not available", "protocol not supported", "socket type not supported", "operation not supported", "protocol family not supported", "address family not supported by protocol", "address already in use", "cannot assign requested address", "network is down", "network is unreachable", "network dropped connection on reset", "software caused connection abort", "connection reset by peer", "no buffer space available", "transport endpoint is already connected", "transport endpoint is not connected", "cannot send after transport endpoint shutdown", "too many references: cannot splice", "connection timed out", "connection refused", "host is down", "no route to host", "operation already in progress", "operation now in progress", "stale NFS file handle", "structure needs cleaning", "not a XENIX named type file", "no XENIX semaphores available", "is a named type file", "remote I/O error", "disk quota exceeded", "no medium found", "wrong medium type", "operation canceled", "required key not available", "key has expired", "key has been revoked", "key was rejected by service", "owner died", "state not recoverable", "operation not possible due to RF-kill"]);
		mapper = new mmapper.ptr(new sync.Mutex.ptr(0, 0), {}, mmap, munmap);
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/gopherjs/gopherjs/nosync"] = (function() {
	var $pkg = {}, $init, Map, Mutex, WaitGroup, Once, Pool, funcType, ptrType, mapType, ptrType$1, ptrType$3, funcType$1, ptrType$4, sliceType, ptrType$5, funcType$2;
	Map = $pkg.Map = $newType(0, $kindStruct, "nosync.Map", true, "github.com/gopherjs/gopherjs/nosync", true, function(m_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.m = false;
			return;
		}
		this.m = m_;
	});
	Mutex = $pkg.Mutex = $newType(0, $kindStruct, "nosync.Mutex", true, "github.com/gopherjs/gopherjs/nosync", true, function(locked_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.locked = false;
			return;
		}
		this.locked = locked_;
	});
	WaitGroup = $pkg.WaitGroup = $newType(0, $kindStruct, "nosync.WaitGroup", true, "github.com/gopherjs/gopherjs/nosync", true, function(counter_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.counter = 0;
			return;
		}
		this.counter = counter_;
	});
	Once = $pkg.Once = $newType(0, $kindStruct, "nosync.Once", true, "github.com/gopherjs/gopherjs/nosync", true, function(doing_, done_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.doing = false;
			this.done = false;
			return;
		}
		this.doing = doing_;
		this.done = done_;
	});
	Pool = $pkg.Pool = $newType(0, $kindStruct, "nosync.Pool", true, "github.com/gopherjs/gopherjs/nosync", true, function(store_, New_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.store = sliceType.nil;
			this.New = $throwNilPointerError;
			return;
		}
		this.store = store_;
		this.New = New_;
	});
	funcType = $funcType([$emptyInterface, $emptyInterface], [$Bool], false);
	ptrType = $ptrType(Map);
	mapType = $mapType($emptyInterface, $emptyInterface);
	ptrType$1 = $ptrType(Mutex);
	ptrType$3 = $ptrType(WaitGroup);
	funcType$1 = $funcType([], [], false);
	ptrType$4 = $ptrType(Once);
	sliceType = $sliceType($emptyInterface);
	ptrType$5 = $ptrType(Pool);
	funcType$2 = $funcType([], [$emptyInterface], false);
	Map.ptr.prototype.Load = function(key) {
		var _entry, _tmp, _tmp$1, _tuple, key, m, ok, value;
		value = $ifaceNil;
		ok = false;
		m = this;
		_tuple = (_entry = m.m[$emptyInterface.keyFor(key)], _entry !== undefined ? [_entry.v, true] : [$ifaceNil, false]);
		value = _tuple[0];
		ok = _tuple[1];
		_tmp = value;
		_tmp$1 = ok;
		value = _tmp;
		ok = _tmp$1;
		return [value, ok];
	};
	Map.prototype.Load = function(key) { return this.$val.Load(key); };
	Map.ptr.prototype.Store = function(key, value) {
		var _key, key, m, value;
		m = this;
		if (m.m === false) {
			m.m = {};
		}
		_key = key; (m.m || $throwRuntimeError("assignment to entry in nil map"))[$emptyInterface.keyFor(_key)] = { k: _key, v: value };
	};
	Map.prototype.Store = function(key, value) { return this.$val.Store(key, value); };
	Map.ptr.prototype.LoadOrStore = function(key, value) {
		var _entry, _key, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, actual, key, loaded, m, ok, value, value$1;
		actual = $ifaceNil;
		loaded = false;
		m = this;
		_tuple = (_entry = m.m[$emptyInterface.keyFor(key)], _entry !== undefined ? [_entry.v, true] : [$ifaceNil, false]);
		value$1 = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			_tmp = value$1;
			_tmp$1 = true;
			actual = _tmp;
			loaded = _tmp$1;
			return [actual, loaded];
		}
		if (m.m === false) {
			m.m = {};
		}
		_key = key; (m.m || $throwRuntimeError("assignment to entry in nil map"))[$emptyInterface.keyFor(_key)] = { k: _key, v: value };
		_tmp$2 = value;
		_tmp$3 = false;
		actual = _tmp$2;
		loaded = _tmp$3;
		return [actual, loaded];
	};
	Map.prototype.LoadOrStore = function(key, value) { return this.$val.LoadOrStore(key, value); };
	Map.ptr.prototype.Delete = function(key) {
		var key, m;
		m = this;
		if (m.m === false) {
			return;
		}
		delete m.m[$emptyInterface.keyFor(key)];
	};
	Map.prototype.Delete = function(key) { return this.$val.Delete(key); };
	Map.ptr.prototype.Range = function(f) {
		var _entry, _i, _keys, _r, _ref, f, k, m, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _r = $f._r; _ref = $f._ref; f = $f.f; k = $f.k; m = $f.m; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		_ref = m.m;
		_i = 0;
		_keys = $keys(_ref);
		/* while (true) { */ case 1:
			/* if (!(_i < _keys.length)) { break; } */ if(!(_i < _keys.length)) { $s = 2; continue; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				/* continue; */ $s = 1; continue;
			}
			k = _entry.k;
			v = _entry.v;
			_r = f(k, v); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (!_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!_r) { */ case 3:
				/* break; */ $s = 2; continue;
			/* } */ case 4:
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Map.ptr.prototype.Range }; } $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._r = _r; $f._ref = _ref; $f.f = f; $f.k = k; $f.m = m; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Map.prototype.Range = function(f) { return this.$val.Range(f); };
	Mutex.ptr.prototype.Lock = function() {
		var m;
		m = this;
		if (m.locked) {
			$panic(new $String("nosync: mutex is already locked"));
		}
		m.locked = true;
	};
	Mutex.prototype.Lock = function() { return this.$val.Lock(); };
	Mutex.ptr.prototype.Unlock = function() {
		var m;
		m = this;
		if (!m.locked) {
			$panic(new $String("nosync: unlock of unlocked mutex"));
		}
		m.locked = false;
	};
	Mutex.prototype.Unlock = function() { return this.$val.Unlock(); };
	WaitGroup.ptr.prototype.Add = function(delta) {
		var delta, wg;
		wg = this;
		wg.counter = wg.counter + (delta) >> 0;
		if (wg.counter < 0) {
			$panic(new $String("sync: negative WaitGroup counter"));
		}
	};
	WaitGroup.prototype.Add = function(delta) { return this.$val.Add(delta); };
	WaitGroup.ptr.prototype.Done = function() {
		var wg;
		wg = this;
		wg.Add(-1);
	};
	WaitGroup.prototype.Done = function() { return this.$val.Done(); };
	WaitGroup.ptr.prototype.Wait = function() {
		var wg;
		wg = this;
		if (!((wg.counter === 0))) {
			$panic(new $String("sync: WaitGroup counter not zero"));
		}
	};
	WaitGroup.prototype.Wait = function() { return this.$val.Wait(); };
	Once.ptr.prototype.Do = function(f) {
		var f, o, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; f = $f.f; o = $f.o; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		o = [o];
		o[0] = this;
		if (o[0].done) {
			$s = -1; return;
		}
		if (o[0].doing) {
			$panic(new $String("nosync: Do called within f"));
		}
		o[0].doing = true;
		$deferred.push([(function(o) { return function() {
			o[0].doing = false;
			o[0].done = true;
		}; })(o), []]);
		$r = f(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Once.ptr.prototype.Do }; } $f.f = f; $f.o = o; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Once.prototype.Do = function(f) { return this.$val.Do(f); };
	Pool.ptr.prototype.Get = function() {
		var _r, p, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (p.store.$length === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (p.store.$length === 0) { */ case 1:
			/* */ if (!(p.New === $throwNilPointerError)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(p.New === $throwNilPointerError)) { */ case 3:
				_r = p.New(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } */ case 4:
			$s = -1; return $ifaceNil;
		/* } */ case 2:
		x$2 = (x = p.store, x$1 = p.store.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		p.store = $subslice(p.store, 0, (p.store.$length - 1 >> 0));
		$s = -1; return x$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Pool.ptr.prototype.Get }; } $f._r = _r; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Pool.prototype.Get = function() { return this.$val.Get(); };
	Pool.ptr.prototype.Put = function(x) {
		var p, x;
		p = this;
		if ($interfaceIsEqual(x, $ifaceNil)) {
			return;
		}
		p.store = $append(p.store, x);
	};
	Pool.prototype.Put = function(x) { return this.$val.Put(x); };
	ptrType.methods = [{prop: "Load", name: "Load", pkg: "", typ: $funcType([$emptyInterface], [$emptyInterface, $Bool], false)}, {prop: "Store", name: "Store", pkg: "", typ: $funcType([$emptyInterface, $emptyInterface], [], false)}, {prop: "LoadOrStore", name: "LoadOrStore", pkg: "", typ: $funcType([$emptyInterface, $emptyInterface], [$emptyInterface, $Bool], false)}, {prop: "Delete", name: "Delete", pkg: "", typ: $funcType([$emptyInterface], [], false)}, {prop: "Range", name: "Range", pkg: "", typ: $funcType([funcType], [], false)}];
	ptrType$1.methods = [{prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false)}, {prop: "Unlock", name: "Unlock", pkg: "", typ: $funcType([], [], false)}];
	ptrType$3.methods = [{prop: "Add", name: "Add", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Done", name: "Done", pkg: "", typ: $funcType([], [], false)}, {prop: "Wait", name: "Wait", pkg: "", typ: $funcType([], [], false)}];
	ptrType$4.methods = [{prop: "Do", name: "Do", pkg: "", typ: $funcType([funcType$1], [], false)}];
	ptrType$5.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Put", name: "Put", pkg: "", typ: $funcType([$emptyInterface], [], false)}];
	Map.init("github.com/gopherjs/gopherjs/nosync", [{prop: "m", name: "m", anonymous: false, exported: false, typ: mapType, tag: ""}]);
	Mutex.init("github.com/gopherjs/gopherjs/nosync", [{prop: "locked", name: "locked", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	WaitGroup.init("github.com/gopherjs/gopherjs/nosync", [{prop: "counter", name: "counter", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	Once.init("github.com/gopherjs/gopherjs/nosync", [{prop: "doing", name: "doing", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "done", name: "done", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	Pool.init("github.com/gopherjs/gopherjs/nosync", [{prop: "store", name: "store", anonymous: false, exported: false, typ: sliceType, tag: ""}, {prop: "New", name: "New", anonymous: false, exported: true, typ: funcType$2, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["time"] = (function() {
	var $pkg = {}, $init, errors, js, nosync, runtime, syscall, ParseError, Time, Month, Weekday, Duration, Location, zone, zoneTrans, sliceType, sliceType$1, ptrType, sliceType$2, arrayType, sliceType$3, arrayType$1, arrayType$2, ptrType$2, arrayType$4, ptrType$4, ptrType$7, std0x, longDayNames, shortDayNames, shortMonthNames, longMonthNames, atoiError, errBad, errLeadingInt, months, days, daysBefore, utcLoc, utcLoc$24ptr, localLoc, localLoc$24ptr, localOnce, errLocation, badData, zoneDirs, init, initLocal, runtimeNano, now, indexByte, startsWithLowerCase, nextStdChunk, match, lookup, appendInt, atoi, formatNano, quote, isDigit, getnum, cutspace, skip, Parse, parse, parseTimeZone, parseGMT, parseNanoseconds, leadingInt, absWeekday, absClock, fmtFrac, fmtInt, lessThanHalf, absDate, daysIn, Now, unixTime, Unix, isLeap, norm, Date, div, FixedZone;
	errors = $packages["errors"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	nosync = $packages["github.com/gopherjs/gopherjs/nosync"];
	runtime = $packages["runtime"];
	syscall = $packages["syscall"];
	ParseError = $pkg.ParseError = $newType(0, $kindStruct, "time.ParseError", true, "time", true, function(Layout_, Value_, LayoutElem_, ValueElem_, Message_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Layout = "";
			this.Value = "";
			this.LayoutElem = "";
			this.ValueElem = "";
			this.Message = "";
			return;
		}
		this.Layout = Layout_;
		this.Value = Value_;
		this.LayoutElem = LayoutElem_;
		this.ValueElem = ValueElem_;
		this.Message = Message_;
	});
	Time = $pkg.Time = $newType(0, $kindStruct, "time.Time", true, "time", true, function(wall_, ext_, loc_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.wall = new $Uint64(0, 0);
			this.ext = new $Int64(0, 0);
			this.loc = ptrType$2.nil;
			return;
		}
		this.wall = wall_;
		this.ext = ext_;
		this.loc = loc_;
	});
	Month = $pkg.Month = $newType(4, $kindInt, "time.Month", true, "time", true, null);
	Weekday = $pkg.Weekday = $newType(4, $kindInt, "time.Weekday", true, "time", true, null);
	Duration = $pkg.Duration = $newType(8, $kindInt64, "time.Duration", true, "time", true, null);
	Location = $pkg.Location = $newType(0, $kindStruct, "time.Location", true, "time", true, function(name_, zone_, tx_, cacheStart_, cacheEnd_, cacheZone_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = "";
			this.zone = sliceType.nil;
			this.tx = sliceType$1.nil;
			this.cacheStart = new $Int64(0, 0);
			this.cacheEnd = new $Int64(0, 0);
			this.cacheZone = ptrType.nil;
			return;
		}
		this.name = name_;
		this.zone = zone_;
		this.tx = tx_;
		this.cacheStart = cacheStart_;
		this.cacheEnd = cacheEnd_;
		this.cacheZone = cacheZone_;
	});
	zone = $pkg.zone = $newType(0, $kindStruct, "time.zone", true, "time", false, function(name_, offset_, isDST_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = "";
			this.offset = 0;
			this.isDST = false;
			return;
		}
		this.name = name_;
		this.offset = offset_;
		this.isDST = isDST_;
	});
	zoneTrans = $pkg.zoneTrans = $newType(0, $kindStruct, "time.zoneTrans", true, "time", false, function(when_, index_, isstd_, isutc_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.when = new $Int64(0, 0);
			this.index = 0;
			this.isstd = false;
			this.isutc = false;
			return;
		}
		this.when = when_;
		this.index = index_;
		this.isstd = isstd_;
		this.isutc = isutc_;
	});
	sliceType = $sliceType(zone);
	sliceType$1 = $sliceType(zoneTrans);
	ptrType = $ptrType(zone);
	sliceType$2 = $sliceType($String);
	arrayType = $arrayType($Uint8, 20);
	sliceType$3 = $sliceType($Uint8);
	arrayType$1 = $arrayType($Uint8, 9);
	arrayType$2 = $arrayType($Uint8, 64);
	ptrType$2 = $ptrType(Location);
	arrayType$4 = $arrayType($Uint8, 32);
	ptrType$4 = $ptrType(ParseError);
	ptrType$7 = $ptrType(Time);
	init = function() {
		$unused(Unix(new $Int64(0, 0), new $Int64(0, 0)));
	};
	initLocal = function() {
		var d, i, j, s;
		d = new ($global.Date)();
		s = $internalize(d, $String);
		i = indexByte(s, 40);
		j = indexByte(s, 41);
		if ((i === -1) || (j === -1)) {
			localLoc.name = "UTC";
			return;
		}
		localLoc.name = $substring(s, (i + 1 >> 0), j);
		localLoc.zone = new sliceType([new zone.ptr(localLoc.name, $imul(($parseInt(d.getTimezoneOffset()) >> 0), -60), false)]);
	};
	runtimeNano = function() {
		return $mul64($internalize(new ($global.Date)().getTime(), $Int64), new $Int64(0, 1000000));
	};
	now = function() {
		var _tmp, _tmp$1, _tmp$2, mono, n, nsec, sec, x;
		sec = new $Int64(0, 0);
		nsec = 0;
		mono = new $Int64(0, 0);
		n = runtimeNano();
		_tmp = $div64(n, new $Int64(0, 1000000000), false);
		_tmp$1 = (((x = $div64(n, new $Int64(0, 1000000000), true), x.$low + ((x.$high >> 31) * 4294967296)) >> 0));
		_tmp$2 = n;
		sec = _tmp;
		nsec = _tmp$1;
		mono = _tmp$2;
		return [sec, nsec, mono];
	};
	indexByte = function(s, c) {
		var c, s;
		return $parseInt(s.indexOf($global.String.fromCharCode(c))) >> 0;
	};
	startsWithLowerCase = function(str) {
		var c, str;
		if (str.length === 0) {
			return false;
		}
		c = str.charCodeAt(0);
		return 97 <= c && c <= 122;
	};
	nextStdChunk = function(layout) {
		var _1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, _tmp$27, _tmp$28, _tmp$29, _tmp$3, _tmp$30, _tmp$31, _tmp$32, _tmp$33, _tmp$34, _tmp$35, _tmp$36, _tmp$37, _tmp$38, _tmp$39, _tmp$4, _tmp$40, _tmp$41, _tmp$42, _tmp$43, _tmp$44, _tmp$45, _tmp$46, _tmp$47, _tmp$48, _tmp$49, _tmp$5, _tmp$50, _tmp$51, _tmp$52, _tmp$53, _tmp$54, _tmp$55, _tmp$56, _tmp$57, _tmp$58, _tmp$59, _tmp$6, _tmp$60, _tmp$61, _tmp$62, _tmp$63, _tmp$64, _tmp$65, _tmp$66, _tmp$67, _tmp$68, _tmp$69, _tmp$7, _tmp$70, _tmp$71, _tmp$72, _tmp$73, _tmp$74, _tmp$75, _tmp$76, _tmp$77, _tmp$78, _tmp$79, _tmp$8, _tmp$80, _tmp$81, _tmp$82, _tmp$83, _tmp$84, _tmp$85, _tmp$86, _tmp$9, c, ch, i, j, layout, prefix, std, std$1, suffix, x;
		prefix = "";
		std = 0;
		suffix = "";
		i = 0;
		while (true) {
			if (!(i < layout.length)) { break; }
			c = ((layout.charCodeAt(i) >> 0));
			_1 = c;
			if (_1 === (74)) {
				if (layout.length >= (i + 3 >> 0) && $substring(layout, i, (i + 3 >> 0)) === "Jan") {
					if (layout.length >= (i + 7 >> 0) && $substring(layout, i, (i + 7 >> 0)) === "January") {
						_tmp = $substring(layout, 0, i);
						_tmp$1 = 257;
						_tmp$2 = $substring(layout, (i + 7 >> 0));
						prefix = _tmp;
						std = _tmp$1;
						suffix = _tmp$2;
						return [prefix, std, suffix];
					}
					if (!startsWithLowerCase($substring(layout, (i + 3 >> 0)))) {
						_tmp$3 = $substring(layout, 0, i);
						_tmp$4 = 258;
						_tmp$5 = $substring(layout, (i + 3 >> 0));
						prefix = _tmp$3;
						std = _tmp$4;
						suffix = _tmp$5;
						return [prefix, std, suffix];
					}
				}
			} else if (_1 === (77)) {
				if (layout.length >= (i + 3 >> 0)) {
					if ($substring(layout, i, (i + 3 >> 0)) === "Mon") {
						if (layout.length >= (i + 6 >> 0) && $substring(layout, i, (i + 6 >> 0)) === "Monday") {
							_tmp$6 = $substring(layout, 0, i);
							_tmp$7 = 261;
							_tmp$8 = $substring(layout, (i + 6 >> 0));
							prefix = _tmp$6;
							std = _tmp$7;
							suffix = _tmp$8;
							return [prefix, std, suffix];
						}
						if (!startsWithLowerCase($substring(layout, (i + 3 >> 0)))) {
							_tmp$9 = $substring(layout, 0, i);
							_tmp$10 = 262;
							_tmp$11 = $substring(layout, (i + 3 >> 0));
							prefix = _tmp$9;
							std = _tmp$10;
							suffix = _tmp$11;
							return [prefix, std, suffix];
						}
					}
					if ($substring(layout, i, (i + 3 >> 0)) === "MST") {
						_tmp$12 = $substring(layout, 0, i);
						_tmp$13 = 21;
						_tmp$14 = $substring(layout, (i + 3 >> 0));
						prefix = _tmp$12;
						std = _tmp$13;
						suffix = _tmp$14;
						return [prefix, std, suffix];
					}
				}
			} else if (_1 === (48)) {
				if (layout.length >= (i + 2 >> 0) && 49 <= layout.charCodeAt((i + 1 >> 0)) && layout.charCodeAt((i + 1 >> 0)) <= 54) {
					_tmp$15 = $substring(layout, 0, i);
					_tmp$16 = (x = layout.charCodeAt((i + 1 >> 0)) - 49 << 24 >>> 24, ((x < 0 || x >= std0x.length) ? ($throwRuntimeError("index out of range"), undefined) : std0x[x]));
					_tmp$17 = $substring(layout, (i + 2 >> 0));
					prefix = _tmp$15;
					std = _tmp$16;
					suffix = _tmp$17;
					return [prefix, std, suffix];
				}
			} else if (_1 === (49)) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 53)) {
					_tmp$18 = $substring(layout, 0, i);
					_tmp$19 = 522;
					_tmp$20 = $substring(layout, (i + 2 >> 0));
					prefix = _tmp$18;
					std = _tmp$19;
					suffix = _tmp$20;
					return [prefix, std, suffix];
				}
				_tmp$21 = $substring(layout, 0, i);
				_tmp$22 = 259;
				_tmp$23 = $substring(layout, (i + 1 >> 0));
				prefix = _tmp$21;
				std = _tmp$22;
				suffix = _tmp$23;
				return [prefix, std, suffix];
			} else if (_1 === (50)) {
				if (layout.length >= (i + 4 >> 0) && $substring(layout, i, (i + 4 >> 0)) === "2006") {
					_tmp$24 = $substring(layout, 0, i);
					_tmp$25 = 273;
					_tmp$26 = $substring(layout, (i + 4 >> 0));
					prefix = _tmp$24;
					std = _tmp$25;
					suffix = _tmp$26;
					return [prefix, std, suffix];
				}
				_tmp$27 = $substring(layout, 0, i);
				_tmp$28 = 263;
				_tmp$29 = $substring(layout, (i + 1 >> 0));
				prefix = _tmp$27;
				std = _tmp$28;
				suffix = _tmp$29;
				return [prefix, std, suffix];
			} else if (_1 === (95)) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 50)) {
					if (layout.length >= (i + 5 >> 0) && $substring(layout, (i + 1 >> 0), (i + 5 >> 0)) === "2006") {
						_tmp$30 = $substring(layout, 0, (i + 1 >> 0));
						_tmp$31 = 273;
						_tmp$32 = $substring(layout, (i + 5 >> 0));
						prefix = _tmp$30;
						std = _tmp$31;
						suffix = _tmp$32;
						return [prefix, std, suffix];
					}
					_tmp$33 = $substring(layout, 0, i);
					_tmp$34 = 264;
					_tmp$35 = $substring(layout, (i + 2 >> 0));
					prefix = _tmp$33;
					std = _tmp$34;
					suffix = _tmp$35;
					return [prefix, std, suffix];
				}
			} else if (_1 === (51)) {
				_tmp$36 = $substring(layout, 0, i);
				_tmp$37 = 523;
				_tmp$38 = $substring(layout, (i + 1 >> 0));
				prefix = _tmp$36;
				std = _tmp$37;
				suffix = _tmp$38;
				return [prefix, std, suffix];
			} else if (_1 === (52)) {
				_tmp$39 = $substring(layout, 0, i);
				_tmp$40 = 525;
				_tmp$41 = $substring(layout, (i + 1 >> 0));
				prefix = _tmp$39;
				std = _tmp$40;
				suffix = _tmp$41;
				return [prefix, std, suffix];
			} else if (_1 === (53)) {
				_tmp$42 = $substring(layout, 0, i);
				_tmp$43 = 527;
				_tmp$44 = $substring(layout, (i + 1 >> 0));
				prefix = _tmp$42;
				std = _tmp$43;
				suffix = _tmp$44;
				return [prefix, std, suffix];
			} else if (_1 === (80)) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 77)) {
					_tmp$45 = $substring(layout, 0, i);
					_tmp$46 = 531;
					_tmp$47 = $substring(layout, (i + 2 >> 0));
					prefix = _tmp$45;
					std = _tmp$46;
					suffix = _tmp$47;
					return [prefix, std, suffix];
				}
			} else if (_1 === (112)) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 109)) {
					_tmp$48 = $substring(layout, 0, i);
					_tmp$49 = 532;
					_tmp$50 = $substring(layout, (i + 2 >> 0));
					prefix = _tmp$48;
					std = _tmp$49;
					suffix = _tmp$50;
					return [prefix, std, suffix];
				}
			} else if (_1 === (45)) {
				if (layout.length >= (i + 7 >> 0) && $substring(layout, i, (i + 7 >> 0)) === "-070000") {
					_tmp$51 = $substring(layout, 0, i);
					_tmp$52 = 28;
					_tmp$53 = $substring(layout, (i + 7 >> 0));
					prefix = _tmp$51;
					std = _tmp$52;
					suffix = _tmp$53;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 9 >> 0) && $substring(layout, i, (i + 9 >> 0)) === "-07:00:00") {
					_tmp$54 = $substring(layout, 0, i);
					_tmp$55 = 31;
					_tmp$56 = $substring(layout, (i + 9 >> 0));
					prefix = _tmp$54;
					std = _tmp$55;
					suffix = _tmp$56;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 5 >> 0) && $substring(layout, i, (i + 5 >> 0)) === "-0700") {
					_tmp$57 = $substring(layout, 0, i);
					_tmp$58 = 27;
					_tmp$59 = $substring(layout, (i + 5 >> 0));
					prefix = _tmp$57;
					std = _tmp$58;
					suffix = _tmp$59;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 6 >> 0) && $substring(layout, i, (i + 6 >> 0)) === "-07:00") {
					_tmp$60 = $substring(layout, 0, i);
					_tmp$61 = 30;
					_tmp$62 = $substring(layout, (i + 6 >> 0));
					prefix = _tmp$60;
					std = _tmp$61;
					suffix = _tmp$62;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 3 >> 0) && $substring(layout, i, (i + 3 >> 0)) === "-07") {
					_tmp$63 = $substring(layout, 0, i);
					_tmp$64 = 29;
					_tmp$65 = $substring(layout, (i + 3 >> 0));
					prefix = _tmp$63;
					std = _tmp$64;
					suffix = _tmp$65;
					return [prefix, std, suffix];
				}
			} else if (_1 === (90)) {
				if (layout.length >= (i + 7 >> 0) && $substring(layout, i, (i + 7 >> 0)) === "Z070000") {
					_tmp$66 = $substring(layout, 0, i);
					_tmp$67 = 23;
					_tmp$68 = $substring(layout, (i + 7 >> 0));
					prefix = _tmp$66;
					std = _tmp$67;
					suffix = _tmp$68;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 9 >> 0) && $substring(layout, i, (i + 9 >> 0)) === "Z07:00:00") {
					_tmp$69 = $substring(layout, 0, i);
					_tmp$70 = 26;
					_tmp$71 = $substring(layout, (i + 9 >> 0));
					prefix = _tmp$69;
					std = _tmp$70;
					suffix = _tmp$71;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 5 >> 0) && $substring(layout, i, (i + 5 >> 0)) === "Z0700") {
					_tmp$72 = $substring(layout, 0, i);
					_tmp$73 = 22;
					_tmp$74 = $substring(layout, (i + 5 >> 0));
					prefix = _tmp$72;
					std = _tmp$73;
					suffix = _tmp$74;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 6 >> 0) && $substring(layout, i, (i + 6 >> 0)) === "Z07:00") {
					_tmp$75 = $substring(layout, 0, i);
					_tmp$76 = 25;
					_tmp$77 = $substring(layout, (i + 6 >> 0));
					prefix = _tmp$75;
					std = _tmp$76;
					suffix = _tmp$77;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 3 >> 0) && $substring(layout, i, (i + 3 >> 0)) === "Z07") {
					_tmp$78 = $substring(layout, 0, i);
					_tmp$79 = 24;
					_tmp$80 = $substring(layout, (i + 3 >> 0));
					prefix = _tmp$78;
					std = _tmp$79;
					suffix = _tmp$80;
					return [prefix, std, suffix];
				}
			} else if (_1 === (46)) {
				if ((i + 1 >> 0) < layout.length && ((layout.charCodeAt((i + 1 >> 0)) === 48) || (layout.charCodeAt((i + 1 >> 0)) === 57))) {
					ch = layout.charCodeAt((i + 1 >> 0));
					j = i + 1 >> 0;
					while (true) {
						if (!(j < layout.length && (layout.charCodeAt(j) === ch))) { break; }
						j = j + (1) >> 0;
					}
					if (!isDigit(layout, j)) {
						std$1 = 32;
						if (layout.charCodeAt((i + 1 >> 0)) === 57) {
							std$1 = 33;
						}
						std$1 = std$1 | ((((j - ((i + 1 >> 0)) >> 0)) << 16 >> 0));
						_tmp$81 = $substring(layout, 0, i);
						_tmp$82 = std$1;
						_tmp$83 = $substring(layout, j);
						prefix = _tmp$81;
						std = _tmp$82;
						suffix = _tmp$83;
						return [prefix, std, suffix];
					}
				}
			}
			i = i + (1) >> 0;
		}
		_tmp$84 = layout;
		_tmp$85 = 0;
		_tmp$86 = "";
		prefix = _tmp$84;
		std = _tmp$85;
		suffix = _tmp$86;
		return [prefix, std, suffix];
	};
	match = function(s1, s2) {
		var c1, c2, i, s1, s2;
		i = 0;
		while (true) {
			if (!(i < s1.length)) { break; }
			c1 = s1.charCodeAt(i);
			c2 = s2.charCodeAt(i);
			if (!((c1 === c2))) {
				c1 = (c1 | (32)) >>> 0;
				c2 = (c2 | (32)) >>> 0;
				if (!((c1 === c2)) || c1 < 97 || c1 > 122) {
					return false;
				}
			}
			i = i + (1) >> 0;
		}
		return true;
	};
	lookup = function(tab, val) {
		var _i, _ref, i, tab, v, val;
		_ref = tab;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			v = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (val.length >= v.length && match($substring(val, 0, v.length), v)) {
				return [i, $substring(val, v.length), $ifaceNil];
			}
			_i++;
		}
		return [-1, val, errBad];
	};
	appendInt = function(b, x, width) {
		var _q, b, buf, i, q, u, w, width, x;
		u = ((x >>> 0));
		if (x < 0) {
			b = $append(b, 45);
			u = ((-x >>> 0));
		}
		buf = arrayType.zero();
		i = 20;
		while (true) {
			if (!(u >= 10)) { break; }
			i = i - (1) >> 0;
			q = (_q = u / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
			((i < 0 || i >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[i] = ((((48 + u >>> 0) - (q * 10 >>> 0) >>> 0) << 24 >>> 24)));
			u = q;
		}
		i = i - (1) >> 0;
		((i < 0 || i >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[i] = (((48 + u >>> 0) << 24 >>> 24)));
		w = 20 - i >> 0;
		while (true) {
			if (!(w < width)) { break; }
			b = $append(b, 48);
			w = w + (1) >> 0;
		}
		return $appendSlice(b, $subslice(new sliceType$3(buf), i));
	};
	atoi = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, err, neg, q, rem, s, x;
		x = 0;
		err = $ifaceNil;
		neg = false;
		if (!(s === "") && ((s.charCodeAt(0) === 45) || (s.charCodeAt(0) === 43))) {
			neg = s.charCodeAt(0) === 45;
			s = $substring(s, 1);
		}
		_tuple = leadingInt(s);
		q = _tuple[0];
		rem = _tuple[1];
		err = _tuple[2];
		x = (((q.$low + ((q.$high >> 31) * 4294967296)) >> 0));
		if (!($interfaceIsEqual(err, $ifaceNil)) || !(rem === "")) {
			_tmp = 0;
			_tmp$1 = atoiError;
			x = _tmp;
			err = _tmp$1;
			return [x, err];
		}
		if (neg) {
			x = -x;
		}
		_tmp$2 = x;
		_tmp$3 = $ifaceNil;
		x = _tmp$2;
		err = _tmp$3;
		return [x, err];
	};
	formatNano = function(b, nanosec, n, trim) {
		var _q, _r, b, buf, n, nanosec, start, trim, u, x;
		u = nanosec;
		buf = arrayType$1.zero();
		start = 9;
		while (true) {
			if (!(start > 0)) { break; }
			start = start - (1) >> 0;
			((start < 0 || start >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[start] = ((((_r = u % 10, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) + 48 >>> 0) << 24 >>> 24)));
			u = (_q = u / (10), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		}
		if (n > 9) {
			n = 9;
		}
		if (trim) {
			while (true) {
				if (!(n > 0 && ((x = n - 1 >> 0, ((x < 0 || x >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[x])) === 48))) { break; }
				n = n - (1) >> 0;
			}
			if (n === 0) {
				return b;
			}
		}
		b = $append(b, 46);
		return $appendSlice(b, $subslice(new sliceType$3(buf), 0, n));
	};
	Time.ptr.prototype.String = function() {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, buf, m0, m1, m2, s, sign, t, wid, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; buf = $f.buf; m0 = $f.m0; m1 = $f.m1; m2 = $f.m2; s = $f.s; sign = $f.sign; t = $f.t; wid = $f.wid; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).Format("2006-01-02 15:04:05.999999999 -0700 MST"); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		s = _r;
		if (!((x = (x$1 = t.wall, new $Uint64(x$1.$high & 2147483648, (x$1.$low & 0) >>> 0)), (x.$high === 0 && x.$low === 0)))) {
			m2 = ((x$2 = t.ext, new $Uint64(x$2.$high, x$2.$low)));
			sign = 43;
			if ((x$3 = t.ext, (x$3.$high < 0 || (x$3.$high === 0 && x$3.$low < 0)))) {
				sign = 45;
				m2 = new $Uint64(-m2.$high, -m2.$low);
			}
			_tmp = $div64(m2, new $Uint64(0, 1000000000), false);
			_tmp$1 = $div64(m2, new $Uint64(0, 1000000000), true);
			m1 = _tmp;
			m2 = _tmp$1;
			_tmp$2 = $div64(m1, new $Uint64(0, 1000000000), false);
			_tmp$3 = $div64(m1, new $Uint64(0, 1000000000), true);
			m0 = _tmp$2;
			m1 = _tmp$3;
			buf = sliceType$3.nil;
			buf = $appendSlice(buf, " m=");
			buf = $append(buf, sign);
			wid = 0;
			if (!((m0.$high === 0 && m0.$low === 0))) {
				buf = appendInt(buf, ((m0.$low >> 0)), 0);
				wid = 9;
			}
			buf = appendInt(buf, ((m1.$low >> 0)), wid);
			buf = $append(buf, 46);
			buf = appendInt(buf, ((m2.$low >> 0)), 9);
			s = s + (($bytesToString(buf)));
		}
		$s = -1; return s;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.String }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.buf = buf; $f.m0 = m0; $f.m1 = m1; $f.m2 = m2; $f.s = s; $f.sign = sign; $f.t = t; $f.wid = wid; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.String = function() { return this.$val.String(); };
	Time.ptr.prototype.Format = function(layout) {
		var _r, b, buf, layout, max, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; buf = $f.buf; layout = $f.layout; max = $f.max; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		b = sliceType$3.nil;
		max = layout.length + 10 >> 0;
		if (max < 64) {
			buf = arrayType$2.zero();
			b = $subslice(new sliceType$3(buf), 0, 0);
		} else {
			b = $makeSlice(sliceType$3, 0, max);
		}
		_r = $clone(t, Time).AppendFormat(b, layout); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		b = _r;
		$s = -1; return ($bytesToString(b));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Format }; } $f._r = _r; $f.b = b; $f.buf = buf; $f.layout = layout; $f.max = max; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Format = function(layout) { return this.$val.Format(layout); };
	Time.ptr.prototype.AppendFormat = function(b, layout) {
		var _1, _q, _q$1, _q$2, _q$3, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _tuple, _tuple$1, _tuple$2, _tuple$3, abs, absoffset, b, day, hour, hr, hr$1, layout, m, min, month, name, offset, prefix, s, sec, std, suffix, t, y, year, zone$1, zone$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _q$3 = $f._q$3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; abs = $f.abs; absoffset = $f.absoffset; b = $f.b; day = $f.day; hour = $f.hour; hr = $f.hr; hr$1 = $f.hr$1; layout = $f.layout; m = $f.m; min = $f.min; month = $f.month; name = $f.name; offset = $f.offset; prefix = $f.prefix; s = $f.s; sec = $f.sec; std = $f.std; suffix = $f.suffix; t = $f.t; y = $f.y; year = $f.year; zone$1 = $f.zone$1; zone$2 = $f.zone$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).locabs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		name = _tuple[0];
		offset = _tuple[1];
		abs = _tuple[2];
		year = -1;
		month = 0;
		day = 0;
		hour = -1;
		min = 0;
		sec = 0;
		while (true) {
			if (!(!(layout === ""))) { break; }
			_tuple$1 = nextStdChunk(layout);
			prefix = _tuple$1[0];
			std = _tuple$1[1];
			suffix = _tuple$1[2];
			if (!(prefix === "")) {
				b = $appendSlice(b, prefix);
			}
			if (std === 0) {
				break;
			}
			layout = suffix;
			if (year < 0 && !(((std & 256) === 0))) {
				_tuple$2 = absDate(abs, true);
				year = _tuple$2[0];
				month = _tuple$2[1];
				day = _tuple$2[2];
			}
			if (hour < 0 && !(((std & 512) === 0))) {
				_tuple$3 = absClock(abs);
				hour = _tuple$3[0];
				min = _tuple$3[1];
				sec = _tuple$3[2];
			}
			switch (0) { default:
				_1 = std & 65535;
				if (_1 === (274)) {
					y = year;
					if (y < 0) {
						y = -y;
					}
					b = appendInt(b, (_r$1 = y % 100, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")), 2);
				} else if (_1 === (273)) {
					b = appendInt(b, year, 4);
				} else if (_1 === (258)) {
					b = $appendSlice(b, $substring(new Month(month).String(), 0, 3));
				} else if (_1 === (257)) {
					m = new Month(month).String();
					b = $appendSlice(b, m);
				} else if (_1 === (259)) {
					b = appendInt(b, ((month >> 0)), 0);
				} else if (_1 === (260)) {
					b = appendInt(b, ((month >> 0)), 2);
				} else if (_1 === (262)) {
					b = $appendSlice(b, $substring(new Weekday(absWeekday(abs)).String(), 0, 3));
				} else if (_1 === (261)) {
					s = new Weekday(absWeekday(abs)).String();
					b = $appendSlice(b, s);
				} else if (_1 === (263)) {
					b = appendInt(b, day, 0);
				} else if (_1 === (264)) {
					if (day < 10) {
						b = $append(b, 32);
					}
					b = appendInt(b, day, 0);
				} else if (_1 === (265)) {
					b = appendInt(b, day, 2);
				} else if (_1 === (522)) {
					b = appendInt(b, hour, 2);
				} else if (_1 === (523)) {
					hr = (_r$2 = hour % 12, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero"));
					if (hr === 0) {
						hr = 12;
					}
					b = appendInt(b, hr, 0);
				} else if (_1 === (524)) {
					hr$1 = (_r$3 = hour % 12, _r$3 === _r$3 ? _r$3 : $throwRuntimeError("integer divide by zero"));
					if (hr$1 === 0) {
						hr$1 = 12;
					}
					b = appendInt(b, hr$1, 2);
				} else if (_1 === (525)) {
					b = appendInt(b, min, 0);
				} else if (_1 === (526)) {
					b = appendInt(b, min, 2);
				} else if (_1 === (527)) {
					b = appendInt(b, sec, 0);
				} else if (_1 === (528)) {
					b = appendInt(b, sec, 2);
				} else if (_1 === (531)) {
					if (hour >= 12) {
						b = $appendSlice(b, "PM");
					} else {
						b = $appendSlice(b, "AM");
					}
				} else if (_1 === (532)) {
					if (hour >= 12) {
						b = $appendSlice(b, "pm");
					} else {
						b = $appendSlice(b, "am");
					}
				} else if ((_1 === (22)) || (_1 === (25)) || (_1 === (23)) || (_1 === (24)) || (_1 === (26)) || (_1 === (27)) || (_1 === (30)) || (_1 === (28)) || (_1 === (29)) || (_1 === (31))) {
					if ((offset === 0) && ((std === 22) || (std === 25) || (std === 23) || (std === 24) || (std === 26))) {
						b = $append(b, 90);
						break;
					}
					zone$1 = (_q = offset / 60, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
					absoffset = offset;
					if (zone$1 < 0) {
						b = $append(b, 45);
						zone$1 = -zone$1;
						absoffset = -absoffset;
					} else {
						b = $append(b, 43);
					}
					b = appendInt(b, (_q$1 = zone$1 / 60, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")), 2);
					if ((std === 25) || (std === 30) || (std === 26) || (std === 31)) {
						b = $append(b, 58);
					}
					if (!((std === 29)) && !((std === 24))) {
						b = appendInt(b, (_r$4 = zone$1 % 60, _r$4 === _r$4 ? _r$4 : $throwRuntimeError("integer divide by zero")), 2);
					}
					if ((std === 23) || (std === 28) || (std === 31) || (std === 26)) {
						if ((std === 31) || (std === 26)) {
							b = $append(b, 58);
						}
						b = appendInt(b, (_r$5 = absoffset % 60, _r$5 === _r$5 ? _r$5 : $throwRuntimeError("integer divide by zero")), 2);
					}
				} else if (_1 === (21)) {
					if (!(name === "")) {
						b = $appendSlice(b, name);
						break;
					}
					zone$2 = (_q$2 = offset / 60, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero"));
					if (zone$2 < 0) {
						b = $append(b, 45);
						zone$2 = -zone$2;
					} else {
						b = $append(b, 43);
					}
					b = appendInt(b, (_q$3 = zone$2 / 60, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : $throwRuntimeError("integer divide by zero")), 2);
					b = appendInt(b, (_r$6 = zone$2 % 60, _r$6 === _r$6 ? _r$6 : $throwRuntimeError("integer divide by zero")), 2);
				} else if ((_1 === (32)) || (_1 === (33))) {
					b = formatNano(b, (($clone(t, Time).Nanosecond() >>> 0)), std >> 16 >> 0, (std & 65535) === 33);
				}
			}
		}
		$s = -1; return b;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.AppendFormat }; } $f._1 = _1; $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._q$3 = _q$3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.abs = abs; $f.absoffset = absoffset; $f.b = b; $f.day = day; $f.hour = hour; $f.hr = hr; $f.hr$1 = hr$1; $f.layout = layout; $f.m = m; $f.min = min; $f.month = month; $f.name = name; $f.offset = offset; $f.prefix = prefix; $f.s = s; $f.sec = sec; $f.std = std; $f.suffix = suffix; $f.t = t; $f.y = y; $f.year = year; $f.zone$1 = zone$1; $f.zone$2 = zone$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.AppendFormat = function(b, layout) { return this.$val.AppendFormat(b, layout); };
	quote = function(s) {
		var s;
		return "\"" + s + "\"";
	};
	ParseError.ptr.prototype.Error = function() {
		var e;
		e = this;
		if (e.Message === "") {
			return "parsing time " + quote(e.Value) + " as " + quote(e.Layout) + ": cannot parse " + quote(e.ValueElem) + " as " + quote(e.LayoutElem);
		}
		return "parsing time " + quote(e.Value) + e.Message;
	};
	ParseError.prototype.Error = function() { return this.$val.Error(); };
	isDigit = function(s, i) {
		var c, i, s;
		if (s.length <= i) {
			return false;
		}
		c = s.charCodeAt(i);
		return 48 <= c && c <= 57;
	};
	getnum = function(s, fixed) {
		var fixed, s;
		if (!isDigit(s, 0)) {
			return [0, s, errBad];
		}
		if (!isDigit(s, 1)) {
			if (fixed) {
				return [0, s, errBad];
			}
			return [(((s.charCodeAt(0) - 48 << 24 >>> 24) >> 0)), $substring(s, 1), $ifaceNil];
		}
		return [($imul((((s.charCodeAt(0) - 48 << 24 >>> 24) >> 0)), 10)) + (((s.charCodeAt(1) - 48 << 24 >>> 24) >> 0)) >> 0, $substring(s, 2), $ifaceNil];
	};
	cutspace = function(s) {
		var s;
		while (true) {
			if (!(s.length > 0 && (s.charCodeAt(0) === 32))) { break; }
			s = $substring(s, 1);
		}
		return s;
	};
	skip = function(value, prefix) {
		var prefix, value;
		while (true) {
			if (!(prefix.length > 0)) { break; }
			if (prefix.charCodeAt(0) === 32) {
				if (value.length > 0 && !((value.charCodeAt(0) === 32))) {
					return [value, errBad];
				}
				prefix = cutspace(prefix);
				value = cutspace(value);
				continue;
			}
			if ((value.length === 0) || !((value.charCodeAt(0) === prefix.charCodeAt(0)))) {
				return [value, errBad];
			}
			prefix = $substring(prefix, 1);
			value = $substring(value, 1);
		}
		return [value, $ifaceNil];
	};
	Parse = function(layout, value) {
		var _r, layout, value, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; layout = $f.layout; value = $f.value; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = parse(layout, value, $pkg.UTC, $pkg.Local); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Parse }; } $f._r = _r; $f.layout = layout; $f.value = value; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Parse = Parse;
	parse = function(layout, value, defaultLocation, local) {
		var _1, _2, _3, _4, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, _tmp$27, _tmp$28, _tmp$29, _tmp$3, _tmp$30, _tmp$31, _tmp$32, _tmp$33, _tmp$34, _tmp$35, _tmp$36, _tmp$37, _tmp$38, _tmp$39, _tmp$4, _tmp$40, _tmp$41, _tmp$42, _tmp$43, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$10, _tuple$11, _tuple$12, _tuple$13, _tuple$14, _tuple$15, _tuple$16, _tuple$17, _tuple$18, _tuple$19, _tuple$2, _tuple$20, _tuple$21, _tuple$22, _tuple$23, _tuple$24, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, alayout, amSet, avalue, day, defaultLocation, err, hour, hour$1, hr, i, layout, local, min, min$1, mm, month, n, n$1, name, ndigit, nsec, offset, offset$1, ok, ok$1, p, pmSet, prefix, rangeErrString, sec, seconds, sign, ss, std, stdstr, suffix, t, t$1, value, x, x$1, year, z, zoneName, zoneOffset, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$17 = $f._tmp$17; _tmp$18 = $f._tmp$18; _tmp$19 = $f._tmp$19; _tmp$2 = $f._tmp$2; _tmp$20 = $f._tmp$20; _tmp$21 = $f._tmp$21; _tmp$22 = $f._tmp$22; _tmp$23 = $f._tmp$23; _tmp$24 = $f._tmp$24; _tmp$25 = $f._tmp$25; _tmp$26 = $f._tmp$26; _tmp$27 = $f._tmp$27; _tmp$28 = $f._tmp$28; _tmp$29 = $f._tmp$29; _tmp$3 = $f._tmp$3; _tmp$30 = $f._tmp$30; _tmp$31 = $f._tmp$31; _tmp$32 = $f._tmp$32; _tmp$33 = $f._tmp$33; _tmp$34 = $f._tmp$34; _tmp$35 = $f._tmp$35; _tmp$36 = $f._tmp$36; _tmp$37 = $f._tmp$37; _tmp$38 = $f._tmp$38; _tmp$39 = $f._tmp$39; _tmp$4 = $f._tmp$4; _tmp$40 = $f._tmp$40; _tmp$41 = $f._tmp$41; _tmp$42 = $f._tmp$42; _tmp$43 = $f._tmp$43; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$10 = $f._tuple$10; _tuple$11 = $f._tuple$11; _tuple$12 = $f._tuple$12; _tuple$13 = $f._tuple$13; _tuple$14 = $f._tuple$14; _tuple$15 = $f._tuple$15; _tuple$16 = $f._tuple$16; _tuple$17 = $f._tuple$17; _tuple$18 = $f._tuple$18; _tuple$19 = $f._tuple$19; _tuple$2 = $f._tuple$2; _tuple$20 = $f._tuple$20; _tuple$21 = $f._tuple$21; _tuple$22 = $f._tuple$22; _tuple$23 = $f._tuple$23; _tuple$24 = $f._tuple$24; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; _tuple$8 = $f._tuple$8; _tuple$9 = $f._tuple$9; alayout = $f.alayout; amSet = $f.amSet; avalue = $f.avalue; day = $f.day; defaultLocation = $f.defaultLocation; err = $f.err; hour = $f.hour; hour$1 = $f.hour$1; hr = $f.hr; i = $f.i; layout = $f.layout; local = $f.local; min = $f.min; min$1 = $f.min$1; mm = $f.mm; month = $f.month; n = $f.n; n$1 = $f.n$1; name = $f.name; ndigit = $f.ndigit; nsec = $f.nsec; offset = $f.offset; offset$1 = $f.offset$1; ok = $f.ok; ok$1 = $f.ok$1; p = $f.p; pmSet = $f.pmSet; prefix = $f.prefix; rangeErrString = $f.rangeErrString; sec = $f.sec; seconds = $f.seconds; sign = $f.sign; ss = $f.ss; std = $f.std; stdstr = $f.stdstr; suffix = $f.suffix; t = $f.t; t$1 = $f.t$1; value = $f.value; x = $f.x; x$1 = $f.x$1; year = $f.year; z = $f.z; zoneName = $f.zoneName; zoneOffset = $f.zoneOffset; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tmp = layout;
		_tmp$1 = value;
		alayout = _tmp;
		avalue = _tmp$1;
		rangeErrString = "";
		amSet = false;
		pmSet = false;
		year = 0;
		month = 1;
		day = 1;
		hour = 0;
		min = 0;
		sec = 0;
		nsec = 0;
		z = ptrType$2.nil;
		zoneOffset = -1;
		zoneName = "";
		while (true) {
			err = $ifaceNil;
			_tuple = nextStdChunk(layout);
			prefix = _tuple[0];
			std = _tuple[1];
			suffix = _tuple[2];
			stdstr = $substring(layout, prefix.length, (layout.length - suffix.length >> 0));
			_tuple$1 = skip(value, prefix);
			value = _tuple$1[0];
			err = _tuple$1[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return [new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil), new ParseError.ptr(alayout, avalue, prefix, value, "")];
			}
			if (std === 0) {
				if (!((value.length === 0))) {
					$s = -1; return [new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil), new ParseError.ptr(alayout, avalue, "", value, ": extra text: " + value)];
				}
				break;
			}
			layout = suffix;
			p = "";
			switch (0) { default:
				_1 = std & 65535;
				if (_1 === (274)) {
					if (value.length < 2) {
						err = errBad;
						break;
					}
					_tmp$2 = $substring(value, 0, 2);
					_tmp$3 = $substring(value, 2);
					p = _tmp$2;
					value = _tmp$3;
					_tuple$2 = atoi(p);
					year = _tuple$2[0];
					err = _tuple$2[1];
					if (year >= 69) {
						year = year + (1900) >> 0;
					} else {
						year = year + (2000) >> 0;
					}
				} else if (_1 === (273)) {
					if (value.length < 4 || !isDigit(value, 0)) {
						err = errBad;
						break;
					}
					_tmp$4 = $substring(value, 0, 4);
					_tmp$5 = $substring(value, 4);
					p = _tmp$4;
					value = _tmp$5;
					_tuple$3 = atoi(p);
					year = _tuple$3[0];
					err = _tuple$3[1];
				} else if (_1 === (258)) {
					_tuple$4 = lookup(shortMonthNames, value);
					month = _tuple$4[0];
					value = _tuple$4[1];
					err = _tuple$4[2];
				} else if (_1 === (257)) {
					_tuple$5 = lookup(longMonthNames, value);
					month = _tuple$5[0];
					value = _tuple$5[1];
					err = _tuple$5[2];
				} else if ((_1 === (259)) || (_1 === (260))) {
					_tuple$6 = getnum(value, std === 260);
					month = _tuple$6[0];
					value = _tuple$6[1];
					err = _tuple$6[2];
					if (month <= 0 || 12 < month) {
						rangeErrString = "month";
					}
				} else if (_1 === (262)) {
					_tuple$7 = lookup(shortDayNames, value);
					value = _tuple$7[1];
					err = _tuple$7[2];
				} else if (_1 === (261)) {
					_tuple$8 = lookup(longDayNames, value);
					value = _tuple$8[1];
					err = _tuple$8[2];
				} else if ((_1 === (263)) || (_1 === (264)) || (_1 === (265))) {
					if ((std === 264) && value.length > 0 && (value.charCodeAt(0) === 32)) {
						value = $substring(value, 1);
					}
					_tuple$9 = getnum(value, std === 265);
					day = _tuple$9[0];
					value = _tuple$9[1];
					err = _tuple$9[2];
					if (day < 0) {
						rangeErrString = "day";
					}
				} else if (_1 === (522)) {
					_tuple$10 = getnum(value, false);
					hour = _tuple$10[0];
					value = _tuple$10[1];
					err = _tuple$10[2];
					if (hour < 0 || 24 <= hour) {
						rangeErrString = "hour";
					}
				} else if ((_1 === (523)) || (_1 === (524))) {
					_tuple$11 = getnum(value, std === 524);
					hour = _tuple$11[0];
					value = _tuple$11[1];
					err = _tuple$11[2];
					if (hour < 0 || 12 < hour) {
						rangeErrString = "hour";
					}
				} else if ((_1 === (525)) || (_1 === (526))) {
					_tuple$12 = getnum(value, std === 526);
					min = _tuple$12[0];
					value = _tuple$12[1];
					err = _tuple$12[2];
					if (min < 0 || 60 <= min) {
						rangeErrString = "minute";
					}
				} else if ((_1 === (527)) || (_1 === (528))) {
					_tuple$13 = getnum(value, std === 528);
					sec = _tuple$13[0];
					value = _tuple$13[1];
					err = _tuple$13[2];
					if (sec < 0 || 60 <= sec) {
						rangeErrString = "second";
						break;
					}
					if (value.length >= 2 && (value.charCodeAt(0) === 46) && isDigit(value, 1)) {
						_tuple$14 = nextStdChunk(layout);
						std = _tuple$14[1];
						std = std & (65535);
						if ((std === 32) || (std === 33)) {
							break;
						}
						n = 2;
						while (true) {
							if (!(n < value.length && isDigit(value, n))) { break; }
							n = n + (1) >> 0;
						}
						_tuple$15 = parseNanoseconds(value, n);
						nsec = _tuple$15[0];
						rangeErrString = _tuple$15[1];
						err = _tuple$15[2];
						value = $substring(value, n);
					}
				} else if (_1 === (531)) {
					if (value.length < 2) {
						err = errBad;
						break;
					}
					_tmp$6 = $substring(value, 0, 2);
					_tmp$7 = $substring(value, 2);
					p = _tmp$6;
					value = _tmp$7;
					_2 = p;
					if (_2 === ("PM")) {
						pmSet = true;
					} else if (_2 === ("AM")) {
						amSet = true;
					} else {
						err = errBad;
					}
				} else if (_1 === (532)) {
					if (value.length < 2) {
						err = errBad;
						break;
					}
					_tmp$8 = $substring(value, 0, 2);
					_tmp$9 = $substring(value, 2);
					p = _tmp$8;
					value = _tmp$9;
					_3 = p;
					if (_3 === ("pm")) {
						pmSet = true;
					} else if (_3 === ("am")) {
						amSet = true;
					} else {
						err = errBad;
					}
				} else if ((_1 === (22)) || (_1 === (25)) || (_1 === (23)) || (_1 === (24)) || (_1 === (26)) || (_1 === (27)) || (_1 === (29)) || (_1 === (30)) || (_1 === (28)) || (_1 === (31))) {
					if (((std === 22) || (std === 24) || (std === 25)) && value.length >= 1 && (value.charCodeAt(0) === 90)) {
						value = $substring(value, 1);
						z = $pkg.UTC;
						break;
					}
					_tmp$10 = "";
					_tmp$11 = "";
					_tmp$12 = "";
					_tmp$13 = "";
					sign = _tmp$10;
					hour$1 = _tmp$11;
					min$1 = _tmp$12;
					seconds = _tmp$13;
					if ((std === 25) || (std === 30)) {
						if (value.length < 6) {
							err = errBad;
							break;
						}
						if (!((value.charCodeAt(3) === 58))) {
							err = errBad;
							break;
						}
						_tmp$14 = $substring(value, 0, 1);
						_tmp$15 = $substring(value, 1, 3);
						_tmp$16 = $substring(value, 4, 6);
						_tmp$17 = "00";
						_tmp$18 = $substring(value, 6);
						sign = _tmp$14;
						hour$1 = _tmp$15;
						min$1 = _tmp$16;
						seconds = _tmp$17;
						value = _tmp$18;
					} else if ((std === 29) || (std === 24)) {
						if (value.length < 3) {
							err = errBad;
							break;
						}
						_tmp$19 = $substring(value, 0, 1);
						_tmp$20 = $substring(value, 1, 3);
						_tmp$21 = "00";
						_tmp$22 = "00";
						_tmp$23 = $substring(value, 3);
						sign = _tmp$19;
						hour$1 = _tmp$20;
						min$1 = _tmp$21;
						seconds = _tmp$22;
						value = _tmp$23;
					} else if ((std === 26) || (std === 31)) {
						if (value.length < 9) {
							err = errBad;
							break;
						}
						if (!((value.charCodeAt(3) === 58)) || !((value.charCodeAt(6) === 58))) {
							err = errBad;
							break;
						}
						_tmp$24 = $substring(value, 0, 1);
						_tmp$25 = $substring(value, 1, 3);
						_tmp$26 = $substring(value, 4, 6);
						_tmp$27 = $substring(value, 7, 9);
						_tmp$28 = $substring(value, 9);
						sign = _tmp$24;
						hour$1 = _tmp$25;
						min$1 = _tmp$26;
						seconds = _tmp$27;
						value = _tmp$28;
					} else if ((std === 23) || (std === 28)) {
						if (value.length < 7) {
							err = errBad;
							break;
						}
						_tmp$29 = $substring(value, 0, 1);
						_tmp$30 = $substring(value, 1, 3);
						_tmp$31 = $substring(value, 3, 5);
						_tmp$32 = $substring(value, 5, 7);
						_tmp$33 = $substring(value, 7);
						sign = _tmp$29;
						hour$1 = _tmp$30;
						min$1 = _tmp$31;
						seconds = _tmp$32;
						value = _tmp$33;
					} else {
						if (value.length < 5) {
							err = errBad;
							break;
						}
						_tmp$34 = $substring(value, 0, 1);
						_tmp$35 = $substring(value, 1, 3);
						_tmp$36 = $substring(value, 3, 5);
						_tmp$37 = "00";
						_tmp$38 = $substring(value, 5);
						sign = _tmp$34;
						hour$1 = _tmp$35;
						min$1 = _tmp$36;
						seconds = _tmp$37;
						value = _tmp$38;
					}
					_tmp$39 = 0;
					_tmp$40 = 0;
					_tmp$41 = 0;
					hr = _tmp$39;
					mm = _tmp$40;
					ss = _tmp$41;
					_tuple$16 = atoi(hour$1);
					hr = _tuple$16[0];
					err = _tuple$16[1];
					if ($interfaceIsEqual(err, $ifaceNil)) {
						_tuple$17 = atoi(min$1);
						mm = _tuple$17[0];
						err = _tuple$17[1];
					}
					if ($interfaceIsEqual(err, $ifaceNil)) {
						_tuple$18 = atoi(seconds);
						ss = _tuple$18[0];
						err = _tuple$18[1];
					}
					zoneOffset = ($imul(((($imul(hr, 60)) + mm >> 0)), 60)) + ss >> 0;
					_4 = sign.charCodeAt(0);
					if (_4 === (43)) {
					} else if (_4 === (45)) {
						zoneOffset = -zoneOffset;
					} else {
						err = errBad;
					}
				} else if (_1 === (21)) {
					if (value.length >= 3 && $substring(value, 0, 3) === "UTC") {
						z = $pkg.UTC;
						value = $substring(value, 3);
						break;
					}
					_tuple$19 = parseTimeZone(value);
					n$1 = _tuple$19[0];
					ok = _tuple$19[1];
					if (!ok) {
						err = errBad;
						break;
					}
					_tmp$42 = $substring(value, 0, n$1);
					_tmp$43 = $substring(value, n$1);
					zoneName = _tmp$42;
					value = _tmp$43;
				} else if (_1 === (32)) {
					ndigit = 1 + ((std >> 16 >> 0)) >> 0;
					if (value.length < ndigit) {
						err = errBad;
						break;
					}
					_tuple$20 = parseNanoseconds(value, ndigit);
					nsec = _tuple$20[0];
					rangeErrString = _tuple$20[1];
					err = _tuple$20[2];
					value = $substring(value, ndigit);
				} else if (_1 === (33)) {
					if (value.length < 2 || !((value.charCodeAt(0) === 46)) || value.charCodeAt(1) < 48 || 57 < value.charCodeAt(1)) {
						break;
					}
					i = 0;
					while (true) {
						if (!(i < 9 && (i + 1 >> 0) < value.length && 48 <= value.charCodeAt((i + 1 >> 0)) && value.charCodeAt((i + 1 >> 0)) <= 57)) { break; }
						i = i + (1) >> 0;
					}
					_tuple$21 = parseNanoseconds(value, 1 + i >> 0);
					nsec = _tuple$21[0];
					rangeErrString = _tuple$21[1];
					err = _tuple$21[2];
					value = $substring(value, (1 + i >> 0));
				}
			}
			if (!(rangeErrString === "")) {
				$s = -1; return [new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil), new ParseError.ptr(alayout, avalue, stdstr, value, ": " + rangeErrString + " out of range")];
			}
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return [new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil), new ParseError.ptr(alayout, avalue, stdstr, value, "")];
			}
		}
		if (pmSet && hour < 12) {
			hour = hour + (12) >> 0;
		} else if (amSet && (hour === 12)) {
			hour = 0;
		}
		if (day < 1 || day > daysIn(((month >> 0)), year)) {
			$s = -1; return [new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil), new ParseError.ptr(alayout, avalue, "", value, ": day out of range")];
		}
		/* */ if (!(z === ptrType$2.nil)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(z === ptrType$2.nil)) { */ case 1:
			_r = Date(year, ((month >> 0)), day, hour, min, sec, nsec, z); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return [_r, $ifaceNil];
		/* } */ case 2:
		/* */ if (!((zoneOffset === -1))) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!((zoneOffset === -1))) { */ case 4:
			_r$1 = Date(year, ((month >> 0)), day, hour, min, sec, nsec, $pkg.UTC); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			t = $clone(_r$1, Time);
			t.addSec((x = (new $Int64(0, zoneOffset)), new $Int64(-x.$high, -x.$low)));
			_r$2 = local.lookup(t.unixSec()); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_tuple$22 = _r$2;
			name = _tuple$22[0];
			offset = _tuple$22[1];
			if ((offset === zoneOffset) && (zoneName === "" || name === zoneName)) {
				t.setLoc(local);
				$s = -1; return [t, $ifaceNil];
			}
			t.setLoc(FixedZone(zoneName, zoneOffset));
			$s = -1; return [t, $ifaceNil];
		/* } */ case 5:
		/* */ if (!(zoneName === "")) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if (!(zoneName === "")) { */ case 8:
			_r$3 = Date(year, ((month >> 0)), day, hour, min, sec, nsec, $pkg.UTC); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			t$1 = $clone(_r$3, Time);
			_r$4 = local.lookupName(zoneName, t$1.unixSec()); /* */ $s = 11; case 11: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			_tuple$23 = _r$4;
			offset$1 = _tuple$23[0];
			ok$1 = _tuple$23[2];
			if (ok$1) {
				t$1.addSec((x$1 = (new $Int64(0, offset$1)), new $Int64(-x$1.$high, -x$1.$low)));
				t$1.setLoc(local);
				$s = -1; return [t$1, $ifaceNil];
			}
			if (zoneName.length > 3 && $substring(zoneName, 0, 3) === "GMT") {
				_tuple$24 = atoi($substring(zoneName, 3));
				offset$1 = _tuple$24[0];
				offset$1 = $imul(offset$1, (3600));
			}
			t$1.setLoc(FixedZone(zoneName, offset$1));
			$s = -1; return [t$1, $ifaceNil];
		/* } */ case 9:
		_r$5 = Date(year, ((month >> 0)), day, hour, min, sec, nsec, defaultLocation); /* */ $s = 12; case 12: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		$s = -1; return [_r$5, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: parse }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$17 = _tmp$17; $f._tmp$18 = _tmp$18; $f._tmp$19 = _tmp$19; $f._tmp$2 = _tmp$2; $f._tmp$20 = _tmp$20; $f._tmp$21 = _tmp$21; $f._tmp$22 = _tmp$22; $f._tmp$23 = _tmp$23; $f._tmp$24 = _tmp$24; $f._tmp$25 = _tmp$25; $f._tmp$26 = _tmp$26; $f._tmp$27 = _tmp$27; $f._tmp$28 = _tmp$28; $f._tmp$29 = _tmp$29; $f._tmp$3 = _tmp$3; $f._tmp$30 = _tmp$30; $f._tmp$31 = _tmp$31; $f._tmp$32 = _tmp$32; $f._tmp$33 = _tmp$33; $f._tmp$34 = _tmp$34; $f._tmp$35 = _tmp$35; $f._tmp$36 = _tmp$36; $f._tmp$37 = _tmp$37; $f._tmp$38 = _tmp$38; $f._tmp$39 = _tmp$39; $f._tmp$4 = _tmp$4; $f._tmp$40 = _tmp$40; $f._tmp$41 = _tmp$41; $f._tmp$42 = _tmp$42; $f._tmp$43 = _tmp$43; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$10 = _tuple$10; $f._tuple$11 = _tuple$11; $f._tuple$12 = _tuple$12; $f._tuple$13 = _tuple$13; $f._tuple$14 = _tuple$14; $f._tuple$15 = _tuple$15; $f._tuple$16 = _tuple$16; $f._tuple$17 = _tuple$17; $f._tuple$18 = _tuple$18; $f._tuple$19 = _tuple$19; $f._tuple$2 = _tuple$2; $f._tuple$20 = _tuple$20; $f._tuple$21 = _tuple$21; $f._tuple$22 = _tuple$22; $f._tuple$23 = _tuple$23; $f._tuple$24 = _tuple$24; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f._tuple$8 = _tuple$8; $f._tuple$9 = _tuple$9; $f.alayout = alayout; $f.amSet = amSet; $f.avalue = avalue; $f.day = day; $f.defaultLocation = defaultLocation; $f.err = err; $f.hour = hour; $f.hour$1 = hour$1; $f.hr = hr; $f.i = i; $f.layout = layout; $f.local = local; $f.min = min; $f.min$1 = min$1; $f.mm = mm; $f.month = month; $f.n = n; $f.n$1 = n$1; $f.name = name; $f.ndigit = ndigit; $f.nsec = nsec; $f.offset = offset; $f.offset$1 = offset$1; $f.ok = ok; $f.ok$1 = ok$1; $f.p = p; $f.pmSet = pmSet; $f.prefix = prefix; $f.rangeErrString = rangeErrString; $f.sec = sec; $f.seconds = seconds; $f.sign = sign; $f.ss = ss; $f.std = std; $f.stdstr = stdstr; $f.suffix = suffix; $f.t = t; $f.t$1 = t$1; $f.value = value; $f.x = x; $f.x$1 = x$1; $f.year = year; $f.z = z; $f.zoneName = zoneName; $f.zoneOffset = zoneOffset; $f.$s = $s; $f.$r = $r; return $f;
	};
	parseTimeZone = function(value) {
		var _1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, c, length, nUpper, ok, value;
		length = 0;
		ok = false;
		if (value.length < 3) {
			_tmp = 0;
			_tmp$1 = false;
			length = _tmp;
			ok = _tmp$1;
			return [length, ok];
		}
		if (value.length >= 4 && ($substring(value, 0, 4) === "ChST" || $substring(value, 0, 4) === "MeST")) {
			_tmp$2 = 4;
			_tmp$3 = true;
			length = _tmp$2;
			ok = _tmp$3;
			return [length, ok];
		}
		if ($substring(value, 0, 3) === "GMT") {
			length = parseGMT(value);
			_tmp$4 = length;
			_tmp$5 = true;
			length = _tmp$4;
			ok = _tmp$5;
			return [length, ok];
		}
		nUpper = 0;
		nUpper = 0;
		while (true) {
			if (!(nUpper < 6)) { break; }
			if (nUpper >= value.length) {
				break;
			}
			c = value.charCodeAt(nUpper);
			if (c < 65 || 90 < c) {
				break;
			}
			nUpper = nUpper + (1) >> 0;
		}
		_1 = nUpper;
		if ((_1 === (0)) || (_1 === (1)) || (_1 === (2)) || (_1 === (6))) {
			_tmp$6 = 0;
			_tmp$7 = false;
			length = _tmp$6;
			ok = _tmp$7;
			return [length, ok];
		} else if (_1 === (5)) {
			if (value.charCodeAt(4) === 84) {
				_tmp$8 = 5;
				_tmp$9 = true;
				length = _tmp$8;
				ok = _tmp$9;
				return [length, ok];
			}
		} else if (_1 === (4)) {
			if ((value.charCodeAt(3) === 84) || $substring(value, 0, 4) === "WITA") {
				_tmp$10 = 4;
				_tmp$11 = true;
				length = _tmp$10;
				ok = _tmp$11;
				return [length, ok];
			}
		} else if (_1 === (3)) {
			_tmp$12 = 3;
			_tmp$13 = true;
			length = _tmp$12;
			ok = _tmp$13;
			return [length, ok];
		}
		_tmp$14 = 0;
		_tmp$15 = false;
		length = _tmp$14;
		ok = _tmp$15;
		return [length, ok];
	};
	parseGMT = function(value) {
		var _tuple, err, rem, sign, value, x;
		value = $substring(value, 3);
		if (value.length === 0) {
			return 3;
		}
		sign = value.charCodeAt(0);
		if (!((sign === 45)) && !((sign === 43))) {
			return 3;
		}
		_tuple = leadingInt($substring(value, 1));
		x = _tuple[0];
		rem = _tuple[1];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return 3;
		}
		if (sign === 45) {
			x = new $Int64(-x.$high, -x.$low);
		}
		if ((x.$high === 0 && x.$low === 0) || (x.$high < -1 || (x.$high === -1 && x.$low < 4294967282)) || (0 < x.$high || (0 === x.$high && 12 < x.$low))) {
			return 3;
		}
		return (3 + value.length >> 0) - rem.length >> 0;
	};
	parseNanoseconds = function(value, nbytes) {
		var _tuple, err, i, nbytes, ns, rangeErrString, scaleDigits, value;
		ns = 0;
		rangeErrString = "";
		err = $ifaceNil;
		if (!((value.charCodeAt(0) === 46))) {
			err = errBad;
			return [ns, rangeErrString, err];
		}
		_tuple = atoi($substring(value, 1, nbytes));
		ns = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [ns, rangeErrString, err];
		}
		if (ns < 0 || 1000000000 <= ns) {
			rangeErrString = "fractional second";
			return [ns, rangeErrString, err];
		}
		scaleDigits = 10 - nbytes >> 0;
		i = 0;
		while (true) {
			if (!(i < scaleDigits)) { break; }
			ns = $imul(ns, (10));
			i = i + (1) >> 0;
		}
		return [ns, rangeErrString, err];
	};
	leadingInt = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, c, err, i, rem, s, x, x$1, x$2, x$3;
		x = new $Int64(0, 0);
		rem = "";
		err = $ifaceNil;
		i = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			c = s.charCodeAt(i);
			if (c < 48 || c > 57) {
				break;
			}
			if ((x.$high > 214748364 || (x.$high === 214748364 && x.$low > 3435973836))) {
				_tmp = new $Int64(0, 0);
				_tmp$1 = "";
				_tmp$2 = errLeadingInt;
				x = _tmp;
				rem = _tmp$1;
				err = _tmp$2;
				return [x, rem, err];
			}
			x = (x$1 = (x$2 = $mul64(x, new $Int64(0, 10)), x$3 = (new $Int64(0, c)), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low)), new $Int64(x$1.$high - 0, x$1.$low - 48));
			if ((x.$high < 0 || (x.$high === 0 && x.$low < 0))) {
				_tmp$3 = new $Int64(0, 0);
				_tmp$4 = "";
				_tmp$5 = errLeadingInt;
				x = _tmp$3;
				rem = _tmp$4;
				err = _tmp$5;
				return [x, rem, err];
			}
			i = i + (1) >> 0;
		}
		_tmp$6 = x;
		_tmp$7 = $substring(s, i);
		_tmp$8 = $ifaceNil;
		x = _tmp$6;
		rem = _tmp$7;
		err = _tmp$8;
		return [x, rem, err];
	};
	Time.ptr.prototype.nsec = function() {
		var t, x;
		t = this;
		return (((x = t.wall, new $Uint64(x.$high & 0, (x.$low & 1073741823) >>> 0)).$low >> 0));
	};
	Time.prototype.nsec = function() { return this.$val.nsec(); };
	Time.ptr.prototype.sec = function() {
		var t, x, x$1, x$2, x$3;
		t = this;
		if (!((x = (x$1 = t.wall, new $Uint64(x$1.$high & 2147483648, (x$1.$low & 0) >>> 0)), (x.$high === 0 && x.$low === 0)))) {
			return (x$2 = ((x$3 = $shiftRightUint64($shiftLeft64(t.wall, 1), 31), new $Int64(x$3.$high, x$3.$low))), new $Int64(13 + x$2.$high, 3618733952 + x$2.$low));
		}
		return (t.ext);
	};
	Time.prototype.sec = function() { return this.$val.sec(); };
	Time.ptr.prototype.unixSec = function() {
		var t, x;
		t = this;
		return (x = t.sec(), new $Int64(x.$high + -15, x.$low + 2288912640));
	};
	Time.prototype.unixSec = function() { return this.$val.unixSec(); };
	Time.ptr.prototype.addSec = function(d) {
		var d, dsec, sec, t, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8;
		t = this;
		if (!((x = (x$1 = t.wall, new $Uint64(x$1.$high & 2147483648, (x$1.$low & 0) >>> 0)), (x.$high === 0 && x.$low === 0)))) {
			sec = ((x$2 = $shiftRightUint64($shiftLeft64(t.wall, 1), 31), new $Int64(x$2.$high, x$2.$low)));
			dsec = new $Int64(sec.$high + d.$high, sec.$low + d.$low);
			if ((0 < dsec.$high || (0 === dsec.$high && 0 <= dsec.$low)) && (dsec.$high < 1 || (dsec.$high === 1 && dsec.$low <= 4294967295))) {
				t.wall = (x$3 = (x$4 = (x$5 = t.wall, new $Uint64(x$5.$high & 0, (x$5.$low & 1073741823) >>> 0)), x$6 = $shiftLeft64((new $Uint64(dsec.$high, dsec.$low)), 30), new $Uint64(x$4.$high | x$6.$high, (x$4.$low | x$6.$low) >>> 0)), new $Uint64(x$3.$high | 2147483648, (x$3.$low | 0) >>> 0));
				return;
			}
			t.stripMono();
		}
		t.ext = (x$7 = t.ext, x$8 = d, new $Int64(x$7.$high + x$8.$high, x$7.$low + x$8.$low));
	};
	Time.prototype.addSec = function(d) { return this.$val.addSec(d); };
	Time.ptr.prototype.setLoc = function(loc) {
		var loc, t;
		t = this;
		if (loc === utcLoc) {
			loc = ptrType$2.nil;
		}
		t.stripMono();
		t.loc = loc;
	};
	Time.prototype.setLoc = function(loc) { return this.$val.setLoc(loc); };
	Time.ptr.prototype.stripMono = function() {
		var t, x, x$1, x$2, x$3;
		t = this;
		if (!((x = (x$1 = t.wall, new $Uint64(x$1.$high & 2147483648, (x$1.$low & 0) >>> 0)), (x.$high === 0 && x.$low === 0)))) {
			t.ext = t.sec();
			t.wall = (x$2 = t.wall, x$3 = new $Uint64(0, 1073741823), new $Uint64(x$2.$high & x$3.$high, (x$2.$low & x$3.$low) >>> 0));
		}
	};
	Time.prototype.stripMono = function() { return this.$val.stripMono(); };
	Time.ptr.prototype.After = function(u) {
		var t, ts, u, us, x, x$1, x$2, x$3, x$4, x$5;
		t = this;
		if (!((x = (x$1 = (x$2 = t.wall, x$3 = u.wall, new $Uint64(x$2.$high & x$3.$high, (x$2.$low & x$3.$low) >>> 0)), new $Uint64(x$1.$high & 2147483648, (x$1.$low & 0) >>> 0)), (x.$high === 0 && x.$low === 0)))) {
			return (x$4 = t.ext, x$5 = u.ext, (x$4.$high > x$5.$high || (x$4.$high === x$5.$high && x$4.$low > x$5.$low)));
		}
		ts = t.sec();
		us = u.sec();
		return (ts.$high > us.$high || (ts.$high === us.$high && ts.$low > us.$low)) || (ts.$high === us.$high && ts.$low === us.$low) && t.nsec() > u.nsec();
	};
	Time.prototype.After = function(u) { return this.$val.After(u); };
	Time.ptr.prototype.Before = function(u) {
		var t, u, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		t = this;
		if (!((x = (x$1 = (x$2 = t.wall, x$3 = u.wall, new $Uint64(x$2.$high & x$3.$high, (x$2.$low & x$3.$low) >>> 0)), new $Uint64(x$1.$high & 2147483648, (x$1.$low & 0) >>> 0)), (x.$high === 0 && x.$low === 0)))) {
			return (x$4 = t.ext, x$5 = u.ext, (x$4.$high < x$5.$high || (x$4.$high === x$5.$high && x$4.$low < x$5.$low)));
		}
		return (x$6 = t.sec(), x$7 = u.sec(), (x$6.$high < x$7.$high || (x$6.$high === x$7.$high && x$6.$low < x$7.$low))) || (x$8 = t.sec(), x$9 = u.sec(), (x$8.$high === x$9.$high && x$8.$low === x$9.$low)) && t.nsec() < u.nsec();
	};
	Time.prototype.Before = function(u) { return this.$val.Before(u); };
	Time.ptr.prototype.Equal = function(u) {
		var t, u, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7;
		t = this;
		if (!((x = (x$1 = (x$2 = t.wall, x$3 = u.wall, new $Uint64(x$2.$high & x$3.$high, (x$2.$low & x$3.$low) >>> 0)), new $Uint64(x$1.$high & 2147483648, (x$1.$low & 0) >>> 0)), (x.$high === 0 && x.$low === 0)))) {
			return (x$4 = t.ext, x$5 = u.ext, (x$4.$high === x$5.$high && x$4.$low === x$5.$low));
		}
		return (x$6 = t.sec(), x$7 = u.sec(), (x$6.$high === x$7.$high && x$6.$low === x$7.$low)) && (t.nsec() === u.nsec());
	};
	Time.prototype.Equal = function(u) { return this.$val.Equal(u); };
	Month.prototype.String = function() {
		var buf, m, n, x;
		m = this.$val;
		if (1 <= m && m <= 12) {
			return (x = m - 1 >> 0, ((x < 0 || x >= months.length) ? ($throwRuntimeError("index out of range"), undefined) : months[x]));
		}
		buf = $makeSlice(sliceType$3, 20);
		n = fmtInt(buf, (new $Uint64(0, m)));
		return "%!Month(" + ($bytesToString($subslice(buf, n))) + ")";
	};
	$ptrType(Month).prototype.String = function() { return new Month(this.$get()).String(); };
	Weekday.prototype.String = function() {
		var d;
		d = this.$val;
		return ((d < 0 || d >= days.length) ? ($throwRuntimeError("index out of range"), undefined) : days[d]);
	};
	$ptrType(Weekday).prototype.String = function() { return new Weekday(this.$get()).String(); };
	Time.ptr.prototype.IsZero = function() {
		var t, x;
		t = this;
		return (x = t.sec(), (x.$high === 0 && x.$low === 0)) && (t.nsec() === 0);
	};
	Time.prototype.IsZero = function() { return this.$val.IsZero(); };
	Time.ptr.prototype.abs = function() {
		var _r, _r$1, _tuple, l, offset, sec, t, x, x$1, x$2, x$3, x$4, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; l = $f.l; offset = $f.offset; sec = $f.sec; t = $f.t; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		l = t.loc;
		/* */ if (l === ptrType$2.nil || l === localLoc) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (l === ptrType$2.nil || l === localLoc) { */ case 1:
			_r = l.get(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			l = _r;
		/* } */ case 2:
		sec = t.unixSec();
		/* */ if (!(l === utcLoc)) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!(l === utcLoc)) { */ case 4:
			/* */ if (!(l.cacheZone === ptrType.nil) && (x = l.cacheStart, (x.$high < sec.$high || (x.$high === sec.$high && x.$low <= sec.$low))) && (x$1 = l.cacheEnd, (sec.$high < x$1.$high || (sec.$high === x$1.$high && sec.$low < x$1.$low)))) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (!(l.cacheZone === ptrType.nil) && (x = l.cacheStart, (x.$high < sec.$high || (x.$high === sec.$high && x.$low <= sec.$low))) && (x$1 = l.cacheEnd, (sec.$high < x$1.$high || (sec.$high === x$1.$high && sec.$low < x$1.$low)))) { */ case 6:
				sec = (x$2 = (new $Int64(0, l.cacheZone.offset)), new $Int64(sec.$high + x$2.$high, sec.$low + x$2.$low));
				$s = 8; continue;
			/* } else { */ case 7:
				_r$1 = l.lookup(sec); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tuple = _r$1;
				offset = _tuple[1];
				sec = (x$3 = (new $Int64(0, offset)), new $Int64(sec.$high + x$3.$high, sec.$low + x$3.$low));
			/* } */ case 8:
		/* } */ case 5:
		$s = -1; return ((x$4 = new $Int64(sec.$high + 2147483646, sec.$low + 450480384), new $Uint64(x$4.$high, x$4.$low)));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.abs }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.l = l; $f.offset = offset; $f.sec = sec; $f.t = t; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.abs = function() { return this.$val.abs(); };
	Time.ptr.prototype.locabs = function() {
		var _r, _r$1, _tuple, abs, l, name, offset, sec, t, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; abs = $f.abs; l = $f.l; name = $f.name; offset = $f.offset; sec = $f.sec; t = $f.t; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		name = "";
		offset = 0;
		abs = new $Uint64(0, 0);
		t = this;
		l = t.loc;
		/* */ if (l === ptrType$2.nil || l === localLoc) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (l === ptrType$2.nil || l === localLoc) { */ case 1:
			_r = l.get(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			l = _r;
		/* } */ case 2:
		sec = t.unixSec();
		/* */ if (!(l === utcLoc)) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!(l === utcLoc)) { */ case 4:
			/* */ if (!(l.cacheZone === ptrType.nil) && (x = l.cacheStart, (x.$high < sec.$high || (x.$high === sec.$high && x.$low <= sec.$low))) && (x$1 = l.cacheEnd, (sec.$high < x$1.$high || (sec.$high === x$1.$high && sec.$low < x$1.$low)))) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!(l.cacheZone === ptrType.nil) && (x = l.cacheStart, (x.$high < sec.$high || (x.$high === sec.$high && x.$low <= sec.$low))) && (x$1 = l.cacheEnd, (sec.$high < x$1.$high || (sec.$high === x$1.$high && sec.$low < x$1.$low)))) { */ case 7:
				name = l.cacheZone.name;
				offset = l.cacheZone.offset;
				$s = 9; continue;
			/* } else { */ case 8:
				_r$1 = l.lookup(sec); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tuple = _r$1;
				name = _tuple[0];
				offset = _tuple[1];
			/* } */ case 9:
			sec = (x$2 = (new $Int64(0, offset)), new $Int64(sec.$high + x$2.$high, sec.$low + x$2.$low));
			$s = 6; continue;
		/* } else { */ case 5:
			name = "UTC";
		/* } */ case 6:
		abs = ((x$3 = new $Int64(sec.$high + 2147483646, sec.$low + 450480384), new $Uint64(x$3.$high, x$3.$low)));
		$s = -1; return [name, offset, abs];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.locabs }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.abs = abs; $f.l = l; $f.name = name; $f.offset = offset; $f.sec = sec; $f.t = t; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.locabs = function() { return this.$val.locabs(); };
	Time.ptr.prototype.Date = function() {
		var _r, _tuple, day, month, t, year, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; day = $f.day; month = $f.month; t = $f.t; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		year = 0;
		month = 0;
		day = 0;
		t = this;
		_r = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		year = _tuple[0];
		month = _tuple[1];
		day = _tuple[2];
		$s = -1; return [year, month, day];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Date }; } $f._r = _r; $f._tuple = _tuple; $f.day = day; $f.month = month; $f.t = t; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Date = function() { return this.$val.Date(); };
	Time.ptr.prototype.Year = function() {
		var _r, _tuple, t, year, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; t = $f.t; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).date(false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		year = _tuple[0];
		$s = -1; return year;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Year }; } $f._r = _r; $f._tuple = _tuple; $f.t = t; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Year = function() { return this.$val.Year(); };
	Time.ptr.prototype.Month = function() {
		var _r, _tuple, month, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; month = $f.month; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		month = _tuple[1];
		$s = -1; return month;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Month }; } $f._r = _r; $f._tuple = _tuple; $f.month = month; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Month = function() { return this.$val.Month(); };
	Time.ptr.prototype.Day = function() {
		var _r, _tuple, day, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; day = $f.day; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		day = _tuple[2];
		$s = -1; return day;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Day }; } $f._r = _r; $f._tuple = _tuple; $f.day = day; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Day = function() { return this.$val.Day(); };
	Time.ptr.prototype.Weekday = function() {
		var _r, _r$1, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = absWeekday(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Weekday }; } $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Weekday = function() { return this.$val.Weekday(); };
	absWeekday = function(abs) {
		var _q, abs, sec;
		sec = $div64((new $Uint64(abs.$high + 0, abs.$low + 86400)), new $Uint64(0, 604800), true);
		return (((_q = ((sec.$low >> 0)) / 86400, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0));
	};
	Time.ptr.prototype.ISOWeek = function() {
		var _q, _r, _r$1, _r$2, _r$3, _r$4, _tuple, day, dec31wday, jan1wday, month, t, wday, week, yday, year, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _tuple = $f._tuple; day = $f.day; dec31wday = $f.dec31wday; jan1wday = $f.jan1wday; month = $f.month; t = $f.t; wday = $f.wday; week = $f.week; yday = $f.yday; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		year = 0;
		week = 0;
		t = this;
		_r = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		year = _tuple[0];
		month = _tuple[1];
		day = _tuple[2];
		yday = _tuple[3];
		_r$2 = $clone(t, Time).Weekday(); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		wday = (_r$1 = (((_r$2 + 6 >> 0) >> 0)) % 7, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"));
		week = (_q = (((yday - wday >> 0) + 7 >> 0)) / 7, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		jan1wday = (_r$3 = (((wday - yday >> 0) + 371 >> 0)) % 7, _r$3 === _r$3 ? _r$3 : $throwRuntimeError("integer divide by zero"));
		if (1 <= jan1wday && jan1wday <= 3) {
			week = week + (1) >> 0;
		}
		if (week === 0) {
			year = year - (1) >> 0;
			week = 52;
			if ((jan1wday === 4) || ((jan1wday === 5) && isLeap(year))) {
				week = week + (1) >> 0;
			}
		}
		if ((month === 12) && day >= 29 && wday < 3) {
			dec31wday = (_r$4 = (((wday + 31 >> 0) - day >> 0)) % 7, _r$4 === _r$4 ? _r$4 : $throwRuntimeError("integer divide by zero"));
			if (0 <= dec31wday && dec31wday <= 2) {
				year = year + (1) >> 0;
				week = 1;
			}
		}
		$s = -1; return [year, week];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.ISOWeek }; } $f._q = _q; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tuple = _tuple; $f.day = day; $f.dec31wday = dec31wday; $f.jan1wday = jan1wday; $f.month = month; $f.t = t; $f.wday = wday; $f.week = week; $f.yday = yday; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.ISOWeek = function() { return this.$val.ISOWeek(); };
	Time.ptr.prototype.Clock = function() {
		var _r, _r$1, _tuple, hour, min, sec, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; hour = $f.hour; min = $f.min; sec = $f.sec; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		hour = 0;
		min = 0;
		sec = 0;
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = absClock(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		hour = _tuple[0];
		min = _tuple[1];
		sec = _tuple[2];
		$s = -1; return [hour, min, sec];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Clock }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.hour = hour; $f.min = min; $f.sec = sec; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Clock = function() { return this.$val.Clock(); };
	absClock = function(abs) {
		var _q, _q$1, abs, hour, min, sec;
		hour = 0;
		min = 0;
		sec = 0;
		sec = (($div64(abs, new $Uint64(0, 86400), true).$low >> 0));
		hour = (_q = sec / 3600, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		sec = sec - (($imul(hour, 3600))) >> 0;
		min = (_q$1 = sec / 60, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"));
		sec = sec - (($imul(min, 60))) >> 0;
		return [hour, min, sec];
	};
	Time.ptr.prototype.Hour = function() {
		var _q, _r, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return (_q = (($div64(_r, new $Uint64(0, 86400), true).$low >> 0)) / 3600, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Hour }; } $f._q = _q; $f._r = _r; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Hour = function() { return this.$val.Hour(); };
	Time.ptr.prototype.Minute = function() {
		var _q, _r, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return (_q = (($div64(_r, new $Uint64(0, 3600), true).$low >> 0)) / 60, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Minute }; } $f._q = _q; $f._r = _r; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Minute = function() { return this.$val.Minute(); };
	Time.ptr.prototype.Second = function() {
		var _r, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return (($div64(_r, new $Uint64(0, 60), true).$low >> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Second }; } $f._r = _r; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Second = function() { return this.$val.Second(); };
	Time.ptr.prototype.Nanosecond = function() {
		var t;
		t = this;
		return ((t.nsec() >> 0));
	};
	Time.prototype.Nanosecond = function() { return this.$val.Nanosecond(); };
	Time.ptr.prototype.YearDay = function() {
		var _r, _tuple, t, yday, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; t = $f.t; yday = $f.yday; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).date(false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		yday = _tuple[3];
		$s = -1; return yday + 1 >> 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.YearDay }; } $f._r = _r; $f._tuple = _tuple; $f.t = t; $f.yday = yday; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.YearDay = function() { return this.$val.YearDay(); };
	Duration.prototype.String = function() {
		var _tuple, _tuple$1, buf, d, neg, prec, u, w;
		d = this;
		buf = arrayType$4.zero();
		w = 32;
		u = (new $Uint64(d.$high, d.$low));
		neg = (d.$high < 0 || (d.$high === 0 && d.$low < 0));
		if (neg) {
			u = new $Uint64(-u.$high, -u.$low);
		}
		if ((u.$high < 0 || (u.$high === 0 && u.$low < 1000000000))) {
			prec = 0;
			w = w - (1) >> 0;
			((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 115);
			w = w - (1) >> 0;
			if ((u.$high === 0 && u.$low === 0)) {
				return "0s";
			} else if ((u.$high < 0 || (u.$high === 0 && u.$low < 1000))) {
				prec = 0;
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 110);
			} else if ((u.$high < 0 || (u.$high === 0 && u.$low < 1000000))) {
				prec = 3;
				w = w - (1) >> 0;
				$copyString($subslice(new sliceType$3(buf), w), "\xC2\xB5");
			} else {
				prec = 6;
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 109);
			}
			_tuple = fmtFrac($subslice(new sliceType$3(buf), 0, w), u, prec);
			w = _tuple[0];
			u = _tuple[1];
			w = fmtInt($subslice(new sliceType$3(buf), 0, w), u);
		} else {
			w = w - (1) >> 0;
			((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 115);
			_tuple$1 = fmtFrac($subslice(new sliceType$3(buf), 0, w), u, 9);
			w = _tuple$1[0];
			u = _tuple$1[1];
			w = fmtInt($subslice(new sliceType$3(buf), 0, w), $div64(u, new $Uint64(0, 60), true));
			u = $div64(u, (new $Uint64(0, 60)), false);
			if ((u.$high > 0 || (u.$high === 0 && u.$low > 0))) {
				w = w - (1) >> 0;
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 109);
				w = fmtInt($subslice(new sliceType$3(buf), 0, w), $div64(u, new $Uint64(0, 60), true));
				u = $div64(u, (new $Uint64(0, 60)), false);
				if ((u.$high > 0 || (u.$high === 0 && u.$low > 0))) {
					w = w - (1) >> 0;
					((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 104);
					w = fmtInt($subslice(new sliceType$3(buf), 0, w), u);
				}
			}
		}
		if (neg) {
			w = w - (1) >> 0;
			((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 45);
		}
		return ($bytesToString($subslice(new sliceType$3(buf), w)));
	};
	$ptrType(Duration).prototype.String = function() { return this.$get().String(); };
	fmtFrac = function(buf, v, prec) {
		var _tmp, _tmp$1, buf, digit, i, nv, nw, prec, print, v, w;
		nw = 0;
		nv = new $Uint64(0, 0);
		w = buf.$length;
		print = false;
		i = 0;
		while (true) {
			if (!(i < prec)) { break; }
			digit = $div64(v, new $Uint64(0, 10), true);
			print = print || !((digit.$high === 0 && digit.$low === 0));
			if (print) {
				w = w - (1) >> 0;
				((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = (((digit.$low << 24 >>> 24)) + 48 << 24 >>> 24));
			}
			v = $div64(v, (new $Uint64(0, 10)), false);
			i = i + (1) >> 0;
		}
		if (print) {
			w = w - (1) >> 0;
			((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = 46);
		}
		_tmp = w;
		_tmp$1 = v;
		nw = _tmp;
		nv = _tmp$1;
		return [nw, nv];
	};
	fmtInt = function(buf, v) {
		var buf, v, w;
		w = buf.$length;
		if ((v.$high === 0 && v.$low === 0)) {
			w = w - (1) >> 0;
			((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = 48);
		} else {
			while (true) {
				if (!((v.$high > 0 || (v.$high === 0 && v.$low > 0)))) { break; }
				w = w - (1) >> 0;
				((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = ((($div64(v, new $Uint64(0, 10), true).$low << 24 >>> 24)) + 48 << 24 >>> 24));
				v = $div64(v, (new $Uint64(0, 10)), false);
			}
		}
		return w;
	};
	Duration.prototype.Nanoseconds = function() {
		var d;
		d = this;
		return (new $Int64(d.$high, d.$low));
	};
	$ptrType(Duration).prototype.Nanoseconds = function() { return this.$get().Nanoseconds(); };
	Duration.prototype.Seconds = function() {
		var d, nsec, sec;
		d = this;
		sec = $div64(d, new Duration(0, 1000000000), false);
		nsec = $div64(d, new Duration(0, 1000000000), true);
		return ($flatten64(sec)) + ($flatten64(nsec)) / 1e+09;
	};
	$ptrType(Duration).prototype.Seconds = function() { return this.$get().Seconds(); };
	Duration.prototype.Minutes = function() {
		var d, min, nsec;
		d = this;
		min = $div64(d, new Duration(13, 4165425152), false);
		nsec = $div64(d, new Duration(13, 4165425152), true);
		return ($flatten64(min)) + ($flatten64(nsec)) / 6e+10;
	};
	$ptrType(Duration).prototype.Minutes = function() { return this.$get().Minutes(); };
	Duration.prototype.Hours = function() {
		var d, hour, nsec;
		d = this;
		hour = $div64(d, new Duration(838, 817405952), false);
		nsec = $div64(d, new Duration(838, 817405952), true);
		return ($flatten64(hour)) + ($flatten64(nsec)) / 3.6e+12;
	};
	$ptrType(Duration).prototype.Hours = function() { return this.$get().Hours(); };
	Duration.prototype.Truncate = function(m) {
		var d, m, x;
		d = this;
		if ((m.$high < 0 || (m.$high === 0 && m.$low <= 0))) {
			return d;
		}
		return (x = $div64(d, m, true), new Duration(d.$high - x.$high, d.$low - x.$low));
	};
	$ptrType(Duration).prototype.Truncate = function(m) { return this.$get().Truncate(m); };
	lessThanHalf = function(x, y) {
		var x, x$1, x$2, x$3, x$4, y;
		return (x$1 = (x$2 = (new $Uint64(x.$high, x.$low)), x$3 = (new $Uint64(x.$high, x.$low)), new $Uint64(x$2.$high + x$3.$high, x$2.$low + x$3.$low)), x$4 = (new $Uint64(y.$high, y.$low)), (x$1.$high < x$4.$high || (x$1.$high === x$4.$high && x$1.$low < x$4.$low)));
	};
	Duration.prototype.Round = function(m) {
		var d, d1, d1$1, m, r, x, x$1;
		d = this;
		if ((m.$high < 0 || (m.$high === 0 && m.$low <= 0))) {
			return d;
		}
		r = $div64(d, m, true);
		if ((d.$high < 0 || (d.$high === 0 && d.$low < 0))) {
			r = new Duration(-r.$high, -r.$low);
			if (lessThanHalf(r, m)) {
				return new Duration(d.$high + r.$high, d.$low + r.$low);
			}
			d1 = (x = new Duration(d.$high - m.$high, d.$low - m.$low), new Duration(x.$high + r.$high, x.$low + r.$low));
			if ((d1.$high < d.$high || (d1.$high === d.$high && d1.$low < d.$low))) {
				return d1;
			}
			return new Duration(-2147483648, 0);
		}
		if (lessThanHalf(r, m)) {
			return new Duration(d.$high - r.$high, d.$low - r.$low);
		}
		d1$1 = (x$1 = new Duration(d.$high + m.$high, d.$low + m.$low), new Duration(x$1.$high - r.$high, x$1.$low - r.$low));
		if ((d1$1.$high > d.$high || (d1$1.$high === d.$high && d1$1.$low > d.$low))) {
			return d1$1;
		}
		return new Duration(2147483647, 4294967295);
	};
	$ptrType(Duration).prototype.Round = function(m) { return this.$get().Round(m); };
	Time.ptr.prototype.Add = function(d) {
		var d, dsec, nsec, t, te, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		t = this;
		dsec = ((x = $div64(d, new Duration(0, 1000000000), false), new $Int64(x.$high, x.$low)));
		nsec = t.nsec() + (((x$1 = $div64(d, new Duration(0, 1000000000), true), x$1.$low + ((x$1.$high >> 31) * 4294967296)) >> 0)) >> 0;
		if (nsec >= 1000000000) {
			dsec = (x$2 = new $Int64(0, 1), new $Int64(dsec.$high + x$2.$high, dsec.$low + x$2.$low));
			nsec = nsec - (1000000000) >> 0;
		} else if (nsec < 0) {
			dsec = (x$3 = new $Int64(0, 1), new $Int64(dsec.$high - x$3.$high, dsec.$low - x$3.$low));
			nsec = nsec + (1000000000) >> 0;
		}
		t.wall = (x$4 = (x$5 = t.wall, new $Uint64(x$5.$high & ~0, (x$5.$low & ~1073741823) >>> 0)), x$6 = (new $Uint64(0, nsec)), new $Uint64(x$4.$high | x$6.$high, (x$4.$low | x$6.$low) >>> 0));
		t.addSec(dsec);
		if (!((x$7 = (x$8 = t.wall, new $Uint64(x$8.$high & 2147483648, (x$8.$low & 0) >>> 0)), (x$7.$high === 0 && x$7.$low === 0)))) {
			te = (x$9 = t.ext, x$10 = (new $Int64(d.$high, d.$low)), new $Int64(x$9.$high + x$10.$high, x$9.$low + x$10.$low));
			if ((d.$high < 0 || (d.$high === 0 && d.$low < 0)) && (x$11 = (t.ext), (te.$high > x$11.$high || (te.$high === x$11.$high && te.$low > x$11.$low))) || (d.$high > 0 || (d.$high === 0 && d.$low > 0)) && (x$12 = (t.ext), (te.$high < x$12.$high || (te.$high === x$12.$high && te.$low < x$12.$low)))) {
				t.stripMono();
			} else {
				t.ext = te;
			}
		}
		return t;
	};
	Time.prototype.Add = function(d) { return this.$val.Add(d); };
	Time.ptr.prototype.Sub = function(u) {
		var d, d$1, t, te, u, ue, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		t = this;
		if (!((x = (x$1 = (x$2 = t.wall, x$3 = u.wall, new $Uint64(x$2.$high & x$3.$high, (x$2.$low & x$3.$low) >>> 0)), new $Uint64(x$1.$high & 2147483648, (x$1.$low & 0) >>> 0)), (x.$high === 0 && x.$low === 0)))) {
			te = (t.ext);
			ue = (u.ext);
			d = ((x$4 = new $Int64(te.$high - ue.$high, te.$low - ue.$low), new Duration(x$4.$high, x$4.$low)));
			if ((d.$high < 0 || (d.$high === 0 && d.$low < 0)) && (te.$high > ue.$high || (te.$high === ue.$high && te.$low > ue.$low))) {
				return new Duration(2147483647, 4294967295);
			}
			if ((d.$high > 0 || (d.$high === 0 && d.$low > 0)) && (te.$high < ue.$high || (te.$high === ue.$high && te.$low < ue.$low))) {
				return new Duration(-2147483648, 0);
			}
			return d;
		}
		d$1 = (x$5 = $mul64(((x$6 = (x$7 = t.sec(), x$8 = u.sec(), new $Int64(x$7.$high - x$8.$high, x$7.$low - x$8.$low)), new Duration(x$6.$high, x$6.$low))), new Duration(0, 1000000000)), x$9 = (new Duration(0, (t.nsec() - u.nsec() >> 0))), new Duration(x$5.$high + x$9.$high, x$5.$low + x$9.$low));
		if ($clone($clone(u, Time).Add(d$1), Time).Equal($clone(t, Time))) {
			return d$1;
		} else if ($clone(t, Time).Before($clone(u, Time))) {
			return new Duration(-2147483648, 0);
		} else {
			return new Duration(2147483647, 4294967295);
		}
	};
	Time.prototype.Sub = function(u) { return this.$val.Sub(u); };
	Time.ptr.prototype.AddDate = function(years, months$1, days$1) {
		var _r, _r$1, _r$2, _tuple, _tuple$1, day, days$1, hour, min, month, months$1, sec, t, year, years, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; day = $f.day; days$1 = $f.days$1; hour = $f.hour; min = $f.min; month = $f.month; months$1 = $f.months$1; sec = $f.sec; t = $f.t; year = $f.year; years = $f.years; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).Date(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		year = _tuple[0];
		month = _tuple[1];
		day = _tuple[2];
		_r$1 = $clone(t, Time).Clock(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		hour = _tuple$1[0];
		min = _tuple$1[1];
		sec = _tuple$1[2];
		_r$2 = Date(year + years >> 0, month + ((months$1 >> 0)) >> 0, day + days$1 >> 0, hour, min, sec, ((t.nsec() >> 0)), $clone(t, Time).Location()); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.AddDate }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.day = day; $f.days$1 = days$1; $f.hour = hour; $f.min = min; $f.month = month; $f.months$1 = months$1; $f.sec = sec; $f.t = t; $f.year = year; $f.years = years; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.AddDate = function(years, months$1, days$1) { return this.$val.AddDate(years, months$1, days$1); };
	Time.ptr.prototype.date = function(full) {
		var _r, _r$1, _tuple, day, full, month, t, yday, year, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; day = $f.day; full = $f.full; month = $f.month; t = $f.t; yday = $f.yday; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		year = 0;
		month = 0;
		day = 0;
		yday = 0;
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = absDate(_r, full); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		year = _tuple[0];
		month = _tuple[1];
		day = _tuple[2];
		yday = _tuple[3];
		$s = -1; return [year, month, day, yday];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.date }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.day = day; $f.full = full; $f.month = month; $f.t = t; $f.yday = yday; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.date = function(full) { return this.$val.date(full); };
	absDate = function(abs, full) {
		var _q, abs, begin, d, day, end, full, month, n, x, x$1, x$10, x$11, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y, yday, year;
		year = 0;
		month = 0;
		day = 0;
		yday = 0;
		d = $div64(abs, new $Uint64(0, 86400), false);
		n = $div64(d, new $Uint64(0, 146097), false);
		y = $mul64(new $Uint64(0, 400), n);
		d = (x = $mul64(new $Uint64(0, 146097), n), new $Uint64(d.$high - x.$high, d.$low - x.$low));
		n = $div64(d, new $Uint64(0, 36524), false);
		n = (x$1 = $shiftRightUint64(n, 2), new $Uint64(n.$high - x$1.$high, n.$low - x$1.$low));
		y = (x$2 = $mul64(new $Uint64(0, 100), n), new $Uint64(y.$high + x$2.$high, y.$low + x$2.$low));
		d = (x$3 = $mul64(new $Uint64(0, 36524), n), new $Uint64(d.$high - x$3.$high, d.$low - x$3.$low));
		n = $div64(d, new $Uint64(0, 1461), false);
		y = (x$4 = $mul64(new $Uint64(0, 4), n), new $Uint64(y.$high + x$4.$high, y.$low + x$4.$low));
		d = (x$5 = $mul64(new $Uint64(0, 1461), n), new $Uint64(d.$high - x$5.$high, d.$low - x$5.$low));
		n = $div64(d, new $Uint64(0, 365), false);
		n = (x$6 = $shiftRightUint64(n, 2), new $Uint64(n.$high - x$6.$high, n.$low - x$6.$low));
		y = (x$7 = n, new $Uint64(y.$high + x$7.$high, y.$low + x$7.$low));
		d = (x$8 = $mul64(new $Uint64(0, 365), n), new $Uint64(d.$high - x$8.$high, d.$low - x$8.$low));
		year = (((x$9 = (x$10 = (new $Int64(y.$high, y.$low)), new $Int64(x$10.$high + -69, x$10.$low + 4075721025)), x$9.$low + ((x$9.$high >> 31) * 4294967296)) >> 0));
		yday = ((d.$low >> 0));
		if (!full) {
			return [year, month, day, yday];
		}
		day = yday;
		if (isLeap(year)) {
			if (day > 59) {
				day = day - (1) >> 0;
			} else if ((day === 59)) {
				month = 2;
				day = 29;
				return [year, month, day, yday];
			}
		}
		month = (((_q = day / 31, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0));
		end = (((x$11 = month + 1 >> 0, ((x$11 < 0 || x$11 >= daysBefore.length) ? ($throwRuntimeError("index out of range"), undefined) : daysBefore[x$11])) >> 0));
		begin = 0;
		if (day >= end) {
			month = month + (1) >> 0;
			begin = end;
		} else {
			begin = ((((month < 0 || month >= daysBefore.length) ? ($throwRuntimeError("index out of range"), undefined) : daysBefore[month]) >> 0));
		}
		month = month + (1) >> 0;
		day = (day - begin >> 0) + 1 >> 0;
		return [year, month, day, yday];
	};
	daysIn = function(m, year) {
		var m, x, year;
		if ((m === 2) && isLeap(year)) {
			return 29;
		}
		return (((((m < 0 || m >= daysBefore.length) ? ($throwRuntimeError("index out of range"), undefined) : daysBefore[m]) - (x = m - 1 >> 0, ((x < 0 || x >= daysBefore.length) ? ($throwRuntimeError("index out of range"), undefined) : daysBefore[x])) >> 0) >> 0));
	};
	Now = function() {
		var _tuple, mono, nsec, sec, x, x$1, x$2, x$3, x$4;
		_tuple = now();
		sec = _tuple[0];
		nsec = _tuple[1];
		mono = _tuple[2];
		sec = (x = new $Int64(0, 2682288000), new $Int64(sec.$high + x.$high, sec.$low + x.$low));
		if (!((x$1 = $shiftRightUint64((new $Uint64(sec.$high, sec.$low)), 33), (x$1.$high === 0 && x$1.$low === 0)))) {
			return new Time.ptr((new $Uint64(0, nsec)), new $Int64(sec.$high + 13, sec.$low + 3618733952), $pkg.Local);
		}
		return new Time.ptr((x$2 = (x$3 = $shiftLeft64((new $Uint64(sec.$high, sec.$low)), 30), new $Uint64(2147483648 | x$3.$high, (0 | x$3.$low) >>> 0)), x$4 = (new $Uint64(0, nsec)), new $Uint64(x$2.$high | x$4.$high, (x$2.$low | x$4.$low) >>> 0)), mono, $pkg.Local);
	};
	$pkg.Now = Now;
	unixTime = function(sec, nsec) {
		var nsec, sec;
		return new Time.ptr((new $Uint64(0, nsec)), new $Int64(sec.$high + 14, sec.$low + 2006054656), $pkg.Local);
	};
	Time.ptr.prototype.UTC = function() {
		var t;
		t = this;
		t.setLoc(utcLoc);
		return t;
	};
	Time.prototype.UTC = function() { return this.$val.UTC(); };
	Time.ptr.prototype.Local = function() {
		var t;
		t = this;
		t.setLoc($pkg.Local);
		return t;
	};
	Time.prototype.Local = function() { return this.$val.Local(); };
	Time.ptr.prototype.In = function(loc) {
		var loc, t;
		t = this;
		if (loc === ptrType$2.nil) {
			$panic(new $String("time: missing Location in call to Time.In"));
		}
		t.setLoc(loc);
		return t;
	};
	Time.prototype.In = function(loc) { return this.$val.In(loc); };
	Time.ptr.prototype.Location = function() {
		var l, t;
		t = this;
		l = t.loc;
		if (l === ptrType$2.nil) {
			l = $pkg.UTC;
		}
		return l;
	};
	Time.prototype.Location = function() { return this.$val.Location(); };
	Time.ptr.prototype.Zone = function() {
		var _r, _tuple, name, offset, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; name = $f.name; offset = $f.offset; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		name = "";
		offset = 0;
		t = this;
		_r = t.loc.lookup(t.unixSec()); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		name = _tuple[0];
		offset = _tuple[1];
		$s = -1; return [name, offset];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Zone }; } $f._r = _r; $f._tuple = _tuple; $f.name = name; $f.offset = offset; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Zone = function() { return this.$val.Zone(); };
	Time.ptr.prototype.Unix = function() {
		var t;
		t = this;
		return t.unixSec();
	};
	Time.prototype.Unix = function() { return this.$val.Unix(); };
	Time.ptr.prototype.UnixNano = function() {
		var t, x, x$1;
		t = this;
		return (x = $mul64((t.unixSec()), new $Int64(0, 1000000000)), x$1 = (new $Int64(0, t.nsec())), new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));
	};
	Time.prototype.UnixNano = function() { return this.$val.UnixNano(); };
	Time.ptr.prototype.MarshalBinary = function() {
		var _q, _r, _r$1, _tuple, enc, nsec, offset, offsetMin, sec, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; enc = $f.enc; nsec = $f.nsec; offset = $f.offset; offsetMin = $f.offsetMin; sec = $f.sec; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		offsetMin = 0;
		/* */ if ($clone(t, Time).Location() === $pkg.UTC) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($clone(t, Time).Location() === $pkg.UTC) { */ case 1:
			offsetMin = -1;
			$s = 3; continue;
		/* } else { */ case 2:
			_r = $clone(t, Time).Zone(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			offset = _tuple[1];
			if (!(((_r$1 = offset % 60, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0))) {
				$s = -1; return [sliceType$3.nil, errors.New("Time.MarshalBinary: zone offset has fractional minute")];
			}
			offset = (_q = offset / (60), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
			if (offset < -32768 || (offset === -1) || offset > 32767) {
				$s = -1; return [sliceType$3.nil, errors.New("Time.MarshalBinary: unexpected zone offset")];
			}
			offsetMin = ((offset << 16 >> 16));
		/* } */ case 3:
		sec = t.sec();
		nsec = t.nsec();
		enc = new sliceType$3([1, (($shiftRightInt64(sec, 56).$low << 24 >>> 24)), (($shiftRightInt64(sec, 48).$low << 24 >>> 24)), (($shiftRightInt64(sec, 40).$low << 24 >>> 24)), (($shiftRightInt64(sec, 32).$low << 24 >>> 24)), (($shiftRightInt64(sec, 24).$low << 24 >>> 24)), (($shiftRightInt64(sec, 16).$low << 24 >>> 24)), (($shiftRightInt64(sec, 8).$low << 24 >>> 24)), ((sec.$low << 24 >>> 24)), (((nsec >> 24 >> 0) << 24 >>> 24)), (((nsec >> 16 >> 0) << 24 >>> 24)), (((nsec >> 8 >> 0) << 24 >>> 24)), ((nsec << 24 >>> 24)), (((offsetMin >> 8 << 16 >> 16) << 24 >>> 24)), ((offsetMin << 24 >>> 24))]);
		$s = -1; return [enc, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.MarshalBinary }; } $f._q = _q; $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.enc = enc; $f.nsec = nsec; $f.offset = offset; $f.offsetMin = offsetMin; $f.sec = sec; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.MarshalBinary = function() { return this.$val.MarshalBinary(); };
	Time.ptr.prototype.UnmarshalBinary = function(data$1) {
		var _r, _tuple, buf, data$1, localoff, nsec, offset, sec, t, x, x$1, x$10, x$11, x$12, x$13, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; buf = $f.buf; data$1 = $f.data$1; localoff = $f.localoff; nsec = $f.nsec; offset = $f.offset; sec = $f.sec; t = $f.t; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		buf = data$1;
		if (buf.$length === 0) {
			$s = -1; return errors.New("Time.UnmarshalBinary: no data");
		}
		if (!(((0 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 0]) === 1))) {
			$s = -1; return errors.New("Time.UnmarshalBinary: unsupported version");
		}
		if (!((buf.$length === 15))) {
			$s = -1; return errors.New("Time.UnmarshalBinary: invalid length");
		}
		buf = $subslice(buf, 1);
		sec = (x = (x$1 = (x$2 = (x$3 = (x$4 = (x$5 = (x$6 = (new $Int64(0, (7 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 7]))), x$7 = $shiftLeft64((new $Int64(0, (6 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 6]))), 8), new $Int64(x$6.$high | x$7.$high, (x$6.$low | x$7.$low) >>> 0)), x$8 = $shiftLeft64((new $Int64(0, (5 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 5]))), 16), new $Int64(x$5.$high | x$8.$high, (x$5.$low | x$8.$low) >>> 0)), x$9 = $shiftLeft64((new $Int64(0, (4 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 4]))), 24), new $Int64(x$4.$high | x$9.$high, (x$4.$low | x$9.$low) >>> 0)), x$10 = $shiftLeft64((new $Int64(0, (3 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 3]))), 32), new $Int64(x$3.$high | x$10.$high, (x$3.$low | x$10.$low) >>> 0)), x$11 = $shiftLeft64((new $Int64(0, (2 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 2]))), 40), new $Int64(x$2.$high | x$11.$high, (x$2.$low | x$11.$low) >>> 0)), x$12 = $shiftLeft64((new $Int64(0, (1 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 1]))), 48), new $Int64(x$1.$high | x$12.$high, (x$1.$low | x$12.$low) >>> 0)), x$13 = $shiftLeft64((new $Int64(0, (0 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 0]))), 56), new $Int64(x.$high | x$13.$high, (x.$low | x$13.$low) >>> 0));
		buf = $subslice(buf, 8);
		nsec = (((((3 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 3]) >> 0)) | ((((2 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 2]) >> 0)) << 8 >> 0)) | ((((1 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 1]) >> 0)) << 16 >> 0)) | ((((0 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 0]) >> 0)) << 24 >> 0);
		buf = $subslice(buf, 4);
		offset = $imul(((((((1 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 1]) << 16 >> 16)) | ((((0 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 0]) << 16 >> 16)) << 8 << 16 >> 16)) >> 0)), 60);
		Time.copy(t, new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil));
		t.wall = (new $Uint64(0, nsec));
		t.ext = sec;
		/* */ if (offset === -60) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (offset === -60) { */ case 1:
			t.setLoc(utcLoc);
			$s = 3; continue;
		/* } else { */ case 2:
			_r = $pkg.Local.lookup(t.unixSec()); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			localoff = _tuple[1];
			if (offset === localoff) {
				t.setLoc($pkg.Local);
			} else {
				t.setLoc(FixedZone("", offset));
			}
		/* } */ case 3:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.UnmarshalBinary }; } $f._r = _r; $f._tuple = _tuple; $f.buf = buf; $f.data$1 = data$1; $f.localoff = localoff; $f.nsec = nsec; $f.offset = offset; $f.sec = sec; $f.t = t; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.UnmarshalBinary = function(data$1) { return this.$val.UnmarshalBinary(data$1); };
	Time.ptr.prototype.GobEncode = function() {
		var _r, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).MarshalBinary(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.GobEncode }; } $f._r = _r; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.GobEncode = function() { return this.$val.GobEncode(); };
	Time.ptr.prototype.GobDecode = function(data$1) {
		var _r, data$1, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; data$1 = $f.data$1; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = t.UnmarshalBinary(data$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.GobDecode }; } $f._r = _r; $f.data$1 = data$1; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.GobDecode = function(data$1) { return this.$val.GobDecode(data$1); };
	Time.ptr.prototype.MarshalJSON = function() {
		var _r, _r$1, b, t, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; b = $f.b; t = $f.t; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).Year(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		y = _r;
		if (y < 0 || y >= 10000) {
			$s = -1; return [sliceType$3.nil, errors.New("Time.MarshalJSON: year outside of range [0,9999]")];
		}
		b = $makeSlice(sliceType$3, 0, 37);
		b = $append(b, 34);
		_r$1 = $clone(t, Time).AppendFormat(b, "2006-01-02T15:04:05.999999999Z07:00"); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		b = _r$1;
		b = $append(b, 34);
		$s = -1; return [b, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.MarshalJSON }; } $f._r = _r; $f._r$1 = _r$1; $f.b = b; $f.t = t; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.MarshalJSON = function() { return this.$val.MarshalJSON(); };
	Time.ptr.prototype.UnmarshalJSON = function(data$1) {
		var _r, _tuple, data$1, err, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; data$1 = $f.data$1; err = $f.err; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (($bytesToString(data$1)) === "null") {
			$s = -1; return $ifaceNil;
		}
		err = $ifaceNil;
		_r = Parse("\"2006-01-02T15:04:05Z07:00\"", ($bytesToString(data$1))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		Time.copy(t, _tuple[0]);
		err = _tuple[1];
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.UnmarshalJSON }; } $f._r = _r; $f._tuple = _tuple; $f.data$1 = data$1; $f.err = err; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.UnmarshalJSON = function(data$1) { return this.$val.UnmarshalJSON(data$1); };
	Time.ptr.prototype.MarshalText = function() {
		var _r, _r$1, b, t, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; b = $f.b; t = $f.t; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).Year(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		y = _r;
		if (y < 0 || y >= 10000) {
			$s = -1; return [sliceType$3.nil, errors.New("Time.MarshalText: year outside of range [0,9999]")];
		}
		b = $makeSlice(sliceType$3, 0, 35);
		_r$1 = $clone(t, Time).AppendFormat(b, "2006-01-02T15:04:05.999999999Z07:00"); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return [_r$1, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.MarshalText }; } $f._r = _r; $f._r$1 = _r$1; $f.b = b; $f.t = t; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.MarshalText = function() { return this.$val.MarshalText(); };
	Time.ptr.prototype.UnmarshalText = function(data$1) {
		var _r, _tuple, data$1, err, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; data$1 = $f.data$1; err = $f.err; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		err = $ifaceNil;
		_r = Parse("2006-01-02T15:04:05Z07:00", ($bytesToString(data$1))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		Time.copy(t, _tuple[0]);
		err = _tuple[1];
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.UnmarshalText }; } $f._r = _r; $f._tuple = _tuple; $f.data$1 = data$1; $f.err = err; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.UnmarshalText = function(data$1) { return this.$val.UnmarshalText(data$1); };
	Unix = function(sec, nsec) {
		var n, nsec, sec, x, x$1, x$2, x$3;
		if ((nsec.$high < 0 || (nsec.$high === 0 && nsec.$low < 0)) || (nsec.$high > 0 || (nsec.$high === 0 && nsec.$low >= 1000000000))) {
			n = $div64(nsec, new $Int64(0, 1000000000), false);
			sec = (x = n, new $Int64(sec.$high + x.$high, sec.$low + x.$low));
			nsec = (x$1 = $mul64(n, new $Int64(0, 1000000000)), new $Int64(nsec.$high - x$1.$high, nsec.$low - x$1.$low));
			if ((nsec.$high < 0 || (nsec.$high === 0 && nsec.$low < 0))) {
				nsec = (x$2 = new $Int64(0, 1000000000), new $Int64(nsec.$high + x$2.$high, nsec.$low + x$2.$low));
				sec = (x$3 = new $Int64(0, 1), new $Int64(sec.$high - x$3.$high, sec.$low - x$3.$low));
			}
		}
		return unixTime(sec, (((nsec.$low + ((nsec.$high >> 31) * 4294967296)) >> 0)));
	};
	$pkg.Unix = Unix;
	isLeap = function(year) {
		var _r, _r$1, _r$2, year;
		return ((_r = year % 4, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0) && (!(((_r$1 = year % 100, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0)) || ((_r$2 = year % 400, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero")) === 0));
	};
	norm = function(hi, lo, base) {
		var _q, _q$1, _tmp, _tmp$1, base, hi, lo, n, n$1, nhi, nlo;
		nhi = 0;
		nlo = 0;
		if (lo < 0) {
			n = (_q = ((-lo - 1 >> 0)) / base, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0;
			hi = hi - (n) >> 0;
			lo = lo + (($imul(n, base))) >> 0;
		}
		if (lo >= base) {
			n$1 = (_q$1 = lo / base, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"));
			hi = hi + (n$1) >> 0;
			lo = lo - (($imul(n$1, base))) >> 0;
		}
		_tmp = hi;
		_tmp$1 = lo;
		nhi = _tmp;
		nlo = _tmp$1;
		return [nhi, nlo];
	};
	Date = function(year, month, day, hour, min, sec, nsec, loc) {
		var _r, _r$1, _r$2, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, abs, d, day, end, hour, loc, m, min, month, n, nsec, offset, sec, start, t, unix, utc, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y, year, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; abs = $f.abs; d = $f.d; day = $f.day; end = $f.end; hour = $f.hour; loc = $f.loc; m = $f.m; min = $f.min; month = $f.month; n = $f.n; nsec = $f.nsec; offset = $f.offset; sec = $f.sec; start = $f.start; t = $f.t; unix = $f.unix; utc = $f.utc; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$15 = $f.x$15; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; y = $f.y; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (loc === ptrType$2.nil) {
			$panic(new $String("time: missing Location in call to Date"));
		}
		m = ((month >> 0)) - 1 >> 0;
		_tuple = norm(year, m, 12);
		year = _tuple[0];
		m = _tuple[1];
		month = ((m >> 0)) + 1 >> 0;
		_tuple$1 = norm(sec, nsec, 1000000000);
		sec = _tuple$1[0];
		nsec = _tuple$1[1];
		_tuple$2 = norm(min, sec, 60);
		min = _tuple$2[0];
		sec = _tuple$2[1];
		_tuple$3 = norm(hour, min, 60);
		hour = _tuple$3[0];
		min = _tuple$3[1];
		_tuple$4 = norm(day, hour, 24);
		day = _tuple$4[0];
		hour = _tuple$4[1];
		y = ((x = (x$1 = (new $Int64(0, year)), new $Int64(x$1.$high - -69, x$1.$low - 4075721025)), new $Uint64(x.$high, x.$low)));
		n = $div64(y, new $Uint64(0, 400), false);
		y = (x$2 = $mul64(new $Uint64(0, 400), n), new $Uint64(y.$high - x$2.$high, y.$low - x$2.$low));
		d = $mul64(new $Uint64(0, 146097), n);
		n = $div64(y, new $Uint64(0, 100), false);
		y = (x$3 = $mul64(new $Uint64(0, 100), n), new $Uint64(y.$high - x$3.$high, y.$low - x$3.$low));
		d = (x$4 = $mul64(new $Uint64(0, 36524), n), new $Uint64(d.$high + x$4.$high, d.$low + x$4.$low));
		n = $div64(y, new $Uint64(0, 4), false);
		y = (x$5 = $mul64(new $Uint64(0, 4), n), new $Uint64(y.$high - x$5.$high, y.$low - x$5.$low));
		d = (x$6 = $mul64(new $Uint64(0, 1461), n), new $Uint64(d.$high + x$6.$high, d.$low + x$6.$low));
		n = y;
		d = (x$7 = $mul64(new $Uint64(0, 365), n), new $Uint64(d.$high + x$7.$high, d.$low + x$7.$low));
		d = (x$8 = (new $Uint64(0, (x$9 = month - 1 >> 0, ((x$9 < 0 || x$9 >= daysBefore.length) ? ($throwRuntimeError("index out of range"), undefined) : daysBefore[x$9])))), new $Uint64(d.$high + x$8.$high, d.$low + x$8.$low));
		if (isLeap(year) && month >= 3) {
			d = (x$10 = new $Uint64(0, 1), new $Uint64(d.$high + x$10.$high, d.$low + x$10.$low));
		}
		d = (x$11 = (new $Uint64(0, (day - 1 >> 0))), new $Uint64(d.$high + x$11.$high, d.$low + x$11.$low));
		abs = $mul64(d, new $Uint64(0, 86400));
		abs = (x$12 = (new $Uint64(0, ((($imul(hour, 3600)) + ($imul(min, 60)) >> 0) + sec >> 0))), new $Uint64(abs.$high + x$12.$high, abs.$low + x$12.$low));
		unix = (x$13 = (new $Int64(abs.$high, abs.$low)), new $Int64(x$13.$high + -2147483647, x$13.$low + 3844486912));
		_r = loc.lookup(unix); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$5 = _r;
		offset = _tuple$5[1];
		start = _tuple$5[3];
		end = _tuple$5[4];
		/* */ if (!((offset === 0))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((offset === 0))) { */ case 2:
				utc = (x$14 = (new $Int64(0, offset)), new $Int64(unix.$high - x$14.$high, unix.$low - x$14.$low));
				/* */ if ((utc.$high < start.$high || (utc.$high === start.$high && utc.$low < start.$low))) { $s = 5; continue; }
				/* */ if ((utc.$high > end.$high || (utc.$high === end.$high && utc.$low >= end.$low))) { $s = 6; continue; }
				/* */ $s = 7; continue;
				/* if ((utc.$high < start.$high || (utc.$high === start.$high && utc.$low < start.$low))) { */ case 5:
					_r$1 = loc.lookup(new $Int64(start.$high - 0, start.$low - 1)); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_tuple$6 = _r$1;
					offset = _tuple$6[1];
					$s = 7; continue;
				/* } else if ((utc.$high > end.$high || (utc.$high === end.$high && utc.$low >= end.$low))) { */ case 6:
					_r$2 = loc.lookup(end); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_tuple$7 = _r$2;
					offset = _tuple$7[1];
				/* } */ case 7:
			case 4:
			unix = (x$15 = (new $Int64(0, offset)), new $Int64(unix.$high - x$15.$high, unix.$low - x$15.$low));
		/* } */ case 3:
		t = $clone(unixTime(unix, ((nsec >> 0))), Time);
		t.setLoc(loc);
		$s = -1; return t;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Date }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f.abs = abs; $f.d = d; $f.day = day; $f.end = end; $f.hour = hour; $f.loc = loc; $f.m = m; $f.min = min; $f.month = month; $f.n = n; $f.nsec = nsec; $f.offset = offset; $f.sec = sec; $f.start = start; $f.t = t; $f.unix = unix; $f.utc = utc; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$15 = x$15; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.y = y; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Date = Date;
	Time.ptr.prototype.Truncate = function(d) {
		var _tuple, d, r, t;
		t = this;
		t.stripMono();
		if ((d.$high < 0 || (d.$high === 0 && d.$low <= 0))) {
			return t;
		}
		_tuple = div($clone(t, Time), d);
		r = _tuple[1];
		return $clone(t, Time).Add(new Duration(-r.$high, -r.$low));
	};
	Time.prototype.Truncate = function(d) { return this.$val.Truncate(d); };
	Time.ptr.prototype.Round = function(d) {
		var _tuple, d, r, t;
		t = this;
		t.stripMono();
		if ((d.$high < 0 || (d.$high === 0 && d.$low <= 0))) {
			return t;
		}
		_tuple = div($clone(t, Time), d);
		r = _tuple[1];
		if (lessThanHalf(r, d)) {
			return $clone(t, Time).Add(new Duration(-r.$high, -r.$low));
		}
		return $clone(t, Time).Add(new Duration(d.$high - r.$high, d.$low - r.$low));
	};
	Time.prototype.Round = function(d) { return this.$val.Round(d); };
	div = function(t, d) {
		var _q, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, d, d0, d1, d1$1, neg, nsec, qmod2, r, sec, sec$1, t, tmp, u0, u0x, u1, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		qmod2 = 0;
		r = new Duration(0, 0);
		neg = false;
		nsec = t.nsec();
		sec = t.sec();
		if ((sec.$high < 0 || (sec.$high === 0 && sec.$low < 0))) {
			neg = true;
			sec = new $Int64(-sec.$high, -sec.$low);
			nsec = -nsec;
			if (nsec < 0) {
				nsec = nsec + (1000000000) >> 0;
				sec = (x = new $Int64(0, 1), new $Int64(sec.$high - x.$high, sec.$low - x.$low));
			}
		}
		if ((d.$high < 0 || (d.$high === 0 && d.$low < 1000000000)) && (x$1 = $div64(new Duration(0, 1000000000), (new Duration(d.$high + d.$high, d.$low + d.$low)), true), (x$1.$high === 0 && x$1.$low === 0))) {
			qmod2 = (((_q = nsec / (((d.$low + ((d.$high >> 31) * 4294967296)) >> 0)), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0)) & 1;
			r = (new Duration(0, (_r = nsec % (((d.$low + ((d.$high >> 31) * 4294967296)) >> 0)), _r === _r ? _r : $throwRuntimeError("integer divide by zero"))));
		} else if ((x$2 = $div64(d, new Duration(0, 1000000000), true), (x$2.$high === 0 && x$2.$low === 0))) {
			d1 = ((x$3 = $div64(d, new Duration(0, 1000000000), false), new $Int64(x$3.$high, x$3.$low)));
			qmod2 = (((x$4 = $div64(sec, d1, false), x$4.$low + ((x$4.$high >> 31) * 4294967296)) >> 0)) & 1;
			r = (x$5 = $mul64(((x$6 = $div64(sec, d1, true), new Duration(x$6.$high, x$6.$low))), new Duration(0, 1000000000)), x$7 = (new Duration(0, nsec)), new Duration(x$5.$high + x$7.$high, x$5.$low + x$7.$low));
		} else {
			sec$1 = (new $Uint64(sec.$high, sec.$low));
			tmp = $mul64(($shiftRightUint64(sec$1, 32)), new $Uint64(0, 1000000000));
			u1 = $shiftRightUint64(tmp, 32);
			u0 = $shiftLeft64(tmp, 32);
			tmp = $mul64((new $Uint64(sec$1.$high & 0, (sec$1.$low & 4294967295) >>> 0)), new $Uint64(0, 1000000000));
			_tmp = u0;
			_tmp$1 = new $Uint64(u0.$high + tmp.$high, u0.$low + tmp.$low);
			u0x = _tmp;
			u0 = _tmp$1;
			if ((u0.$high < u0x.$high || (u0.$high === u0x.$high && u0.$low < u0x.$low))) {
				u1 = (x$8 = new $Uint64(0, 1), new $Uint64(u1.$high + x$8.$high, u1.$low + x$8.$low));
			}
			_tmp$2 = u0;
			_tmp$3 = (x$9 = (new $Uint64(0, nsec)), new $Uint64(u0.$high + x$9.$high, u0.$low + x$9.$low));
			u0x = _tmp$2;
			u0 = _tmp$3;
			if ((u0.$high < u0x.$high || (u0.$high === u0x.$high && u0.$low < u0x.$low))) {
				u1 = (x$10 = new $Uint64(0, 1), new $Uint64(u1.$high + x$10.$high, u1.$low + x$10.$low));
			}
			d1$1 = (new $Uint64(d.$high, d.$low));
			while (true) {
				if (!(!((x$11 = $shiftRightUint64(d1$1, 63), (x$11.$high === 0 && x$11.$low === 1))))) { break; }
				d1$1 = $shiftLeft64(d1$1, (1));
			}
			d0 = new $Uint64(0, 0);
			while (true) {
				qmod2 = 0;
				if ((u1.$high > d1$1.$high || (u1.$high === d1$1.$high && u1.$low > d1$1.$low)) || (u1.$high === d1$1.$high && u1.$low === d1$1.$low) && (u0.$high > d0.$high || (u0.$high === d0.$high && u0.$low >= d0.$low))) {
					qmod2 = 1;
					_tmp$4 = u0;
					_tmp$5 = new $Uint64(u0.$high - d0.$high, u0.$low - d0.$low);
					u0x = _tmp$4;
					u0 = _tmp$5;
					if ((u0.$high > u0x.$high || (u0.$high === u0x.$high && u0.$low > u0x.$low))) {
						u1 = (x$12 = new $Uint64(0, 1), new $Uint64(u1.$high - x$12.$high, u1.$low - x$12.$low));
					}
					u1 = (x$13 = d1$1, new $Uint64(u1.$high - x$13.$high, u1.$low - x$13.$low));
				}
				if ((d1$1.$high === 0 && d1$1.$low === 0) && (x$14 = (new $Uint64(d.$high, d.$low)), (d0.$high === x$14.$high && d0.$low === x$14.$low))) {
					break;
				}
				d0 = $shiftRightUint64(d0, (1));
				d0 = (x$15 = $shiftLeft64((new $Uint64(d1$1.$high & 0, (d1$1.$low & 1) >>> 0)), 63), new $Uint64(d0.$high | x$15.$high, (d0.$low | x$15.$low) >>> 0));
				d1$1 = $shiftRightUint64(d1$1, (1));
			}
			r = (new Duration(u0.$high, u0.$low));
		}
		if (neg && !((r.$high === 0 && r.$low === 0))) {
			qmod2 = (qmod2 ^ (1)) >> 0;
			r = new Duration(d.$high - r.$high, d.$low - r.$low);
		}
		return [qmod2, r];
	};
	Location.ptr.prototype.get = function() {
		var l, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; l = $f.l; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		if (l === ptrType$2.nil) {
			$s = -1; return utcLoc;
		}
		/* */ if (l === localLoc) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (l === localLoc) { */ case 1:
			$r = localOnce.Do(initLocal); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		$s = -1; return l;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.get }; } $f.l = l; $f.$s = $s; $f.$r = $r; return $f;
	};
	Location.prototype.get = function() { return this.$val.get(); };
	Location.ptr.prototype.String = function() {
		var _r, l, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; l = $f.l; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		_r = l.get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r.name;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.String }; } $f._r = _r; $f.l = l; $f.$s = $s; $f.$r = $r; return $f;
	};
	Location.prototype.String = function() { return this.$val.String(); };
	FixedZone = function(name, offset) {
		var l, name, offset, x;
		l = new Location.ptr(name, new sliceType([new zone.ptr(name, offset, false)]), new sliceType$1([new zoneTrans.ptr(new $Int64(-2147483648, 0), 0, false, false)]), new $Int64(-2147483648, 0), new $Int64(2147483647, 4294967295), ptrType.nil);
		l.cacheZone = (x = l.zone, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
		return l;
	};
	$pkg.FixedZone = FixedZone;
	Location.ptr.prototype.lookup = function(sec) {
		var _q, _r, end, hi, isDST, l, lim, lo, m, name, offset, sec, start, tx, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, zone$1, zone$2, zone$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; end = $f.end; hi = $f.hi; isDST = $f.isDST; l = $f.l; lim = $f.lim; lo = $f.lo; m = $f.m; name = $f.name; offset = $f.offset; sec = $f.sec; start = $f.start; tx = $f.tx; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; zone$1 = $f.zone$1; zone$2 = $f.zone$2; zone$3 = $f.zone$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		name = "";
		offset = 0;
		isDST = false;
		start = new $Int64(0, 0);
		end = new $Int64(0, 0);
		l = this;
		_r = l.get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		l = _r;
		if (l.zone.$length === 0) {
			name = "UTC";
			offset = 0;
			isDST = false;
			start = new $Int64(-2147483648, 0);
			end = new $Int64(2147483647, 4294967295);
			$s = -1; return [name, offset, isDST, start, end];
		}
		zone$1 = l.cacheZone;
		if (!(zone$1 === ptrType.nil) && (x = l.cacheStart, (x.$high < sec.$high || (x.$high === sec.$high && x.$low <= sec.$low))) && (x$1 = l.cacheEnd, (sec.$high < x$1.$high || (sec.$high === x$1.$high && sec.$low < x$1.$low)))) {
			name = zone$1.name;
			offset = zone$1.offset;
			isDST = zone$1.isDST;
			start = l.cacheStart;
			end = l.cacheEnd;
			$s = -1; return [name, offset, isDST, start, end];
		}
		if ((l.tx.$length === 0) || (x$2 = (x$3 = l.tx, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])).when, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) {
			zone$2 = (x$4 = l.zone, x$5 = l.lookupFirstZone(), ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5]));
			name = zone$2.name;
			offset = zone$2.offset;
			isDST = zone$2.isDST;
			start = new $Int64(-2147483648, 0);
			if (l.tx.$length > 0) {
				end = (x$6 = l.tx, (0 >= x$6.$length ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + 0])).when;
			} else {
				end = new $Int64(2147483647, 4294967295);
			}
			$s = -1; return [name, offset, isDST, start, end];
		}
		tx = l.tx;
		end = new $Int64(2147483647, 4294967295);
		lo = 0;
		hi = tx.$length;
		while (true) {
			if (!((hi - lo >> 0) > 1)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			lim = ((m < 0 || m >= tx.$length) ? ($throwRuntimeError("index out of range"), undefined) : tx.$array[tx.$offset + m]).when;
			if ((sec.$high < lim.$high || (sec.$high === lim.$high && sec.$low < lim.$low))) {
				end = lim;
				hi = m;
			} else {
				lo = m;
			}
		}
		zone$3 = (x$7 = l.zone, x$8 = ((lo < 0 || lo >= tx.$length) ? ($throwRuntimeError("index out of range"), undefined) : tx.$array[tx.$offset + lo]).index, ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8]));
		name = zone$3.name;
		offset = zone$3.offset;
		isDST = zone$3.isDST;
		start = ((lo < 0 || lo >= tx.$length) ? ($throwRuntimeError("index out of range"), undefined) : tx.$array[tx.$offset + lo]).when;
		$s = -1; return [name, offset, isDST, start, end];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.lookup }; } $f._q = _q; $f._r = _r; $f.end = end; $f.hi = hi; $f.isDST = isDST; $f.l = l; $f.lim = lim; $f.lo = lo; $f.m = m; $f.name = name; $f.offset = offset; $f.sec = sec; $f.start = start; $f.tx = tx; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.zone$1 = zone$1; $f.zone$2 = zone$2; $f.zone$3 = zone$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Location.prototype.lookup = function(sec) { return this.$val.lookup(sec); };
	Location.ptr.prototype.lookupFirstZone = function() {
		var _i, _ref, l, x, x$1, x$2, x$3, x$4, x$5, zi, zi$1;
		l = this;
		if (!l.firstZoneUsed()) {
			return 0;
		}
		if (l.tx.$length > 0 && (x = l.zone, x$1 = (x$2 = l.tx, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0])).index, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).isDST) {
			zi = (((x$3 = l.tx, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])).index >> 0)) - 1 >> 0;
			while (true) {
				if (!(zi >= 0)) { break; }
				if (!(x$4 = l.zone, ((zi < 0 || zi >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + zi])).isDST) {
					return zi;
				}
				zi = zi - (1) >> 0;
			}
		}
		_ref = l.zone;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			zi$1 = _i;
			if (!(x$5 = l.zone, ((zi$1 < 0 || zi$1 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + zi$1])).isDST) {
				return zi$1;
			}
			_i++;
		}
		return 0;
	};
	Location.prototype.lookupFirstZone = function() { return this.$val.lookupFirstZone(); };
	Location.ptr.prototype.firstZoneUsed = function() {
		var _i, _ref, l, tx;
		l = this;
		_ref = l.tx;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			tx = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), zoneTrans);
			if (tx.index === 0) {
				return true;
			}
			_i++;
		}
		return false;
	};
	Location.prototype.firstZoneUsed = function() { return this.$val.firstZoneUsed(); };
	Location.ptr.prototype.lookupName = function(name, unix) {
		var _i, _i$1, _r, _r$1, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, i, i$1, isDST, isDST$1, l, nam, name, offset, offset$1, ok, unix, x, x$1, x$2, zone$1, zone$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; i = $f.i; i$1 = $f.i$1; isDST = $f.isDST; isDST$1 = $f.isDST$1; l = $f.l; nam = $f.nam; name = $f.name; offset = $f.offset; offset$1 = $f.offset$1; ok = $f.ok; unix = $f.unix; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; zone$1 = $f.zone$1; zone$2 = $f.zone$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		offset = 0;
		isDST = false;
		ok = false;
		l = this;
		_r = l.get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		l = _r;
		_ref = l.zone;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			i = _i;
			zone$1 = (x = l.zone, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			/* */ if (zone$1.name === name) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (zone$1.name === name) { */ case 4:
				_r$1 = l.lookup((x$1 = (new $Int64(0, zone$1.offset)), new $Int64(unix.$high - x$1.$high, unix.$low - x$1.$low))); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tuple = _r$1;
				nam = _tuple[0];
				offset$1 = _tuple[1];
				isDST$1 = _tuple[2];
				if (nam === zone$1.name) {
					_tmp = offset$1;
					_tmp$1 = isDST$1;
					_tmp$2 = true;
					offset = _tmp;
					isDST = _tmp$1;
					ok = _tmp$2;
					$s = -1; return [offset, isDST, ok];
				}
			/* } */ case 5:
			_i++;
		/* } */ $s = 2; continue; case 3:
		_ref$1 = l.zone;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			zone$2 = (x$2 = l.zone, ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1]));
			if (zone$2.name === name) {
				_tmp$3 = zone$2.offset;
				_tmp$4 = zone$2.isDST;
				_tmp$5 = true;
				offset = _tmp$3;
				isDST = _tmp$4;
				ok = _tmp$5;
				$s = -1; return [offset, isDST, ok];
			}
			_i$1++;
		}
		$s = -1; return [offset, isDST, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.lookupName }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.i = i; $f.i$1 = i$1; $f.isDST = isDST; $f.isDST$1 = isDST$1; $f.l = l; $f.nam = nam; $f.name = name; $f.offset = offset; $f.offset$1 = offset$1; $f.ok = ok; $f.unix = unix; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.zone$1 = zone$1; $f.zone$2 = zone$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Location.prototype.lookupName = function(name, unix) { return this.$val.lookupName(name, unix); };
	ptrType$4.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	Time.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Format", name: "Format", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "AppendFormat", name: "AppendFormat", pkg: "", typ: $funcType([sliceType$3, $String], [sliceType$3], false)}, {prop: "After", name: "After", pkg: "", typ: $funcType([Time], [$Bool], false)}, {prop: "Before", name: "Before", pkg: "", typ: $funcType([Time], [$Bool], false)}, {prop: "Equal", name: "Equal", pkg: "", typ: $funcType([Time], [$Bool], false)}, {prop: "IsZero", name: "IsZero", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "abs", name: "abs", pkg: "time", typ: $funcType([], [$Uint64], false)}, {prop: "locabs", name: "locabs", pkg: "time", typ: $funcType([], [$String, $Int, $Uint64], false)}, {prop: "Date", name: "Date", pkg: "", typ: $funcType([], [$Int, Month, $Int], false)}, {prop: "Year", name: "Year", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Month", name: "Month", pkg: "", typ: $funcType([], [Month], false)}, {prop: "Day", name: "Day", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Weekday", name: "Weekday", pkg: "", typ: $funcType([], [Weekday], false)}, {prop: "ISOWeek", name: "ISOWeek", pkg: "", typ: $funcType([], [$Int, $Int], false)}, {prop: "Clock", name: "Clock", pkg: "", typ: $funcType([], [$Int, $Int, $Int], false)}, {prop: "Hour", name: "Hour", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Minute", name: "Minute", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Second", name: "Second", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Nanosecond", name: "Nanosecond", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "YearDay", name: "YearDay", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Add", name: "Add", pkg: "", typ: $funcType([Duration], [Time], false)}, {prop: "Sub", name: "Sub", pkg: "", typ: $funcType([Time], [Duration], false)}, {prop: "AddDate", name: "AddDate", pkg: "", typ: $funcType([$Int, $Int, $Int], [Time], false)}, {prop: "date", name: "date", pkg: "time", typ: $funcType([$Bool], [$Int, Month, $Int, $Int], false)}, {prop: "UTC", name: "UTC", pkg: "", typ: $funcType([], [Time], false)}, {prop: "Local", name: "Local", pkg: "", typ: $funcType([], [Time], false)}, {prop: "In", name: "In", pkg: "", typ: $funcType([ptrType$2], [Time], false)}, {prop: "Location", name: "Location", pkg: "", typ: $funcType([], [ptrType$2], false)}, {prop: "Zone", name: "Zone", pkg: "", typ: $funcType([], [$String, $Int], false)}, {prop: "Unix", name: "Unix", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "UnixNano", name: "UnixNano", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "MarshalBinary", name: "MarshalBinary", pkg: "", typ: $funcType([], [sliceType$3, $error], false)}, {prop: "GobEncode", name: "GobEncode", pkg: "", typ: $funcType([], [sliceType$3, $error], false)}, {prop: "MarshalJSON", name: "MarshalJSON", pkg: "", typ: $funcType([], [sliceType$3, $error], false)}, {prop: "MarshalText", name: "MarshalText", pkg: "", typ: $funcType([], [sliceType$3, $error], false)}, {prop: "Truncate", name: "Truncate", pkg: "", typ: $funcType([Duration], [Time], false)}, {prop: "Round", name: "Round", pkg: "", typ: $funcType([Duration], [Time], false)}];
	ptrType$7.methods = [{prop: "nsec", name: "nsec", pkg: "time", typ: $funcType([], [$Int32], false)}, {prop: "sec", name: "sec", pkg: "time", typ: $funcType([], [$Int64], false)}, {prop: "unixSec", name: "unixSec", pkg: "time", typ: $funcType([], [$Int64], false)}, {prop: "addSec", name: "addSec", pkg: "time", typ: $funcType([$Int64], [], false)}, {prop: "setLoc", name: "setLoc", pkg: "time", typ: $funcType([ptrType$2], [], false)}, {prop: "stripMono", name: "stripMono", pkg: "time", typ: $funcType([], [], false)}, {prop: "setMono", name: "setMono", pkg: "time", typ: $funcType([$Int64], [], false)}, {prop: "mono", name: "mono", pkg: "time", typ: $funcType([], [$Int64], false)}, {prop: "UnmarshalBinary", name: "UnmarshalBinary", pkg: "", typ: $funcType([sliceType$3], [$error], false)}, {prop: "GobDecode", name: "GobDecode", pkg: "", typ: $funcType([sliceType$3], [$error], false)}, {prop: "UnmarshalJSON", name: "UnmarshalJSON", pkg: "", typ: $funcType([sliceType$3], [$error], false)}, {prop: "UnmarshalText", name: "UnmarshalText", pkg: "", typ: $funcType([sliceType$3], [$error], false)}];
	Month.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	Weekday.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	Duration.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Nanoseconds", name: "Nanoseconds", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Seconds", name: "Seconds", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Minutes", name: "Minutes", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Hours", name: "Hours", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Truncate", name: "Truncate", pkg: "", typ: $funcType([Duration], [Duration], false)}, {prop: "Round", name: "Round", pkg: "", typ: $funcType([Duration], [Duration], false)}];
	ptrType$2.methods = [{prop: "get", name: "get", pkg: "time", typ: $funcType([], [ptrType$2], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "lookup", name: "lookup", pkg: "time", typ: $funcType([$Int64], [$String, $Int, $Bool, $Int64, $Int64], false)}, {prop: "lookupFirstZone", name: "lookupFirstZone", pkg: "time", typ: $funcType([], [$Int], false)}, {prop: "firstZoneUsed", name: "firstZoneUsed", pkg: "time", typ: $funcType([], [$Bool], false)}, {prop: "lookupName", name: "lookupName", pkg: "time", typ: $funcType([$String, $Int64], [$Int, $Bool, $Bool], false)}];
	ParseError.init("", [{prop: "Layout", name: "Layout", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Value", name: "Value", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "LayoutElem", name: "LayoutElem", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "ValueElem", name: "ValueElem", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Message", name: "Message", anonymous: false, exported: true, typ: $String, tag: ""}]);
	Time.init("time", [{prop: "wall", name: "wall", anonymous: false, exported: false, typ: $Uint64, tag: ""}, {prop: "ext", name: "ext", anonymous: false, exported: false, typ: $Int64, tag: ""}, {prop: "loc", name: "loc", anonymous: false, exported: false, typ: ptrType$2, tag: ""}]);
	Location.init("time", [{prop: "name", name: "name", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "zone", name: "zone", anonymous: false, exported: false, typ: sliceType, tag: ""}, {prop: "tx", name: "tx", anonymous: false, exported: false, typ: sliceType$1, tag: ""}, {prop: "cacheStart", name: "cacheStart", anonymous: false, exported: false, typ: $Int64, tag: ""}, {prop: "cacheEnd", name: "cacheEnd", anonymous: false, exported: false, typ: $Int64, tag: ""}, {prop: "cacheZone", name: "cacheZone", anonymous: false, exported: false, typ: ptrType, tag: ""}]);
	zone.init("time", [{prop: "name", name: "name", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "offset", name: "offset", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "isDST", name: "isDST", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	zoneTrans.init("time", [{prop: "when", name: "when", anonymous: false, exported: false, typ: $Int64, tag: ""}, {prop: "index", name: "index", anonymous: false, exported: false, typ: $Uint8, tag: ""}, {prop: "isstd", name: "isstd", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "isutc", name: "isutc", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = nosync.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = syscall.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		localLoc = new Location.ptr("", sliceType.nil, sliceType$1.nil, new $Int64(0, 0), new $Int64(0, 0), ptrType.nil);
		localOnce = new nosync.Once.ptr(false, false);
		std0x = $toNativeArray($kindInt, [260, 265, 524, 526, 528, 274]);
		longDayNames = new sliceType$2(["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]);
		shortDayNames = new sliceType$2(["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]);
		shortMonthNames = new sliceType$2(["---", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]);
		longMonthNames = new sliceType$2(["---", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]);
		atoiError = errors.New("time: invalid number");
		errBad = errors.New("bad value for field");
		errLeadingInt = errors.New("time: bad [0-9]*");
		months = $toNativeArray($kindString, ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]);
		days = $toNativeArray($kindString, ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]);
		daysBefore = $toNativeArray($kindInt32, [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]);
		utcLoc = new Location.ptr("UTC", sliceType.nil, sliceType$1.nil, new $Int64(0, 0), new $Int64(0, 0), ptrType.nil);
		$pkg.UTC = utcLoc;
		$pkg.Local = localLoc;
		errLocation = errors.New("time: invalid location name");
		badData = errors.New("malformed time zone information");
		zoneDirs = new sliceType$2(["/usr/share/zoneinfo/", "/usr/share/lib/zoneinfo/", "/usr/lib/locale/TZ/", runtime.GOROOT() + "/lib/time/zoneinfo.zip"]);
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/poll"] = (function() {
	var $pkg = {}, $init, errors, io, atomic, syscall, time, pollDesc, TimeoutError, fdMutex, FD, ptrType, ptrType$1, arrayType, sliceType, ptrType$3, ptrType$4, ptrType$5, ptrType$6, ptrType$7, ptrType$8, sliceType$1, ptrType$9, funcType, funcType$1, ptrType$10, ptrType$11, ptrType$12, ptrType$13, sliceType$2, ptrType$14, errClosing, consume, runtime_Semacquire, runtime_Semrelease, accept;
	errors = $packages["errors"];
	io = $packages["io"];
	atomic = $packages["sync/atomic"];
	syscall = $packages["syscall"];
	time = $packages["time"];
	pollDesc = $pkg.pollDesc = $newType(0, $kindStruct, "poll.pollDesc", true, "internal/poll", false, function(closing_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.closing = false;
			return;
		}
		this.closing = closing_;
	});
	TimeoutError = $pkg.TimeoutError = $newType(0, $kindStruct, "poll.TimeoutError", true, "internal/poll", true, function() {
		this.$val = this;
		if (arguments.length === 0) {
			return;
		}
	});
	fdMutex = $pkg.fdMutex = $newType(0, $kindStruct, "poll.fdMutex", true, "internal/poll", false, function(state_, rsema_, wsema_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.state = new $Uint64(0, 0);
			this.rsema = 0;
			this.wsema = 0;
			return;
		}
		this.state = state_;
		this.rsema = rsema_;
		this.wsema = wsema_;
	});
	FD = $pkg.FD = $newType(0, $kindStruct, "poll.FD", true, "internal/poll", true, function(fdmu_, Sysfd_, pd_, iovecs_, IsStream_, ZeroReadIsEOF_, isFile_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.fdmu = new fdMutex.ptr(new $Uint64(0, 0), 0, 0);
			this.Sysfd = 0;
			this.pd = new pollDesc.ptr(false);
			this.iovecs = ptrType$3.nil;
			this.IsStream = false;
			this.ZeroReadIsEOF = false;
			this.isFile = false;
			return;
		}
		this.fdmu = fdmu_;
		this.Sysfd = Sysfd_;
		this.pd = pd_;
		this.iovecs = iovecs_;
		this.IsStream = IsStream_;
		this.ZeroReadIsEOF = ZeroReadIsEOF_;
		this.isFile = isFile_;
	});
	ptrType = $ptrType($Uint64);
	ptrType$1 = $ptrType($Uint32);
	arrayType = $arrayType($Uint8, 4);
	sliceType = $sliceType(syscall.Iovec);
	ptrType$3 = $ptrType(sliceType);
	ptrType$4 = $ptrType($Uint8);
	ptrType$5 = $ptrType(FD);
	ptrType$6 = $ptrType(pollDesc);
	ptrType$7 = $ptrType(TimeoutError);
	ptrType$8 = $ptrType(fdMutex);
	sliceType$1 = $sliceType($Uint8);
	ptrType$9 = $ptrType(syscall.Stat_t);
	funcType = $funcType([$Uintptr], [], false);
	funcType$1 = $funcType([$Uintptr], [$Bool], false);
	ptrType$10 = $ptrType(syscall.Linger);
	ptrType$11 = $ptrType(syscall.IPMreqn);
	ptrType$12 = $ptrType(syscall.IPMreq);
	ptrType$13 = $ptrType(syscall.IPv6Mreq);
	sliceType$2 = $sliceType(sliceType$1);
	ptrType$14 = $ptrType(sliceType$2);
	pollDesc.ptr.prototype.init = function(fd) {
		var fd, pd;
		pd = this;
		return $ifaceNil;
	};
	pollDesc.prototype.init = function(fd) { return this.$val.init(fd); };
	pollDesc.ptr.prototype.close = function() {
		var pd;
		pd = this;
	};
	pollDesc.prototype.close = function() { return this.$val.close(); };
	pollDesc.ptr.prototype.evict = function() {
		var pd;
		pd = this;
		pd.closing = true;
	};
	pollDesc.prototype.evict = function() { return this.$val.evict(); };
	pollDesc.ptr.prototype.prepare = function(mode, isFile) {
		var isFile, mode, pd;
		pd = this;
		if (pd.closing) {
			return errClosing(isFile);
		}
		return $ifaceNil;
	};
	pollDesc.prototype.prepare = function(mode, isFile) { return this.$val.prepare(mode, isFile); };
	pollDesc.ptr.prototype.prepareRead = function(isFile) {
		var isFile, pd;
		pd = this;
		return pd.prepare(114, isFile);
	};
	pollDesc.prototype.prepareRead = function(isFile) { return this.$val.prepareRead(isFile); };
	pollDesc.ptr.prototype.prepareWrite = function(isFile) {
		var isFile, pd;
		pd = this;
		return pd.prepare(119, isFile);
	};
	pollDesc.prototype.prepareWrite = function(isFile) { return this.$val.prepareWrite(isFile); };
	pollDesc.ptr.prototype.wait = function(mode, isFile) {
		var isFile, mode, pd;
		pd = this;
		if (pd.closing) {
			return errClosing(isFile);
		}
		return $pkg.ErrTimeout;
	};
	pollDesc.prototype.wait = function(mode, isFile) { return this.$val.wait(mode, isFile); };
	pollDesc.ptr.prototype.waitRead = function(isFile) {
		var isFile, pd;
		pd = this;
		return pd.wait(114, isFile);
	};
	pollDesc.prototype.waitRead = function(isFile) { return this.$val.waitRead(isFile); };
	pollDesc.ptr.prototype.waitWrite = function(isFile) {
		var isFile, pd;
		pd = this;
		return pd.wait(119, isFile);
	};
	pollDesc.prototype.waitWrite = function(isFile) { return this.$val.waitWrite(isFile); };
	pollDesc.ptr.prototype.pollable = function() {
		return true;
	};
	pollDesc.prototype.pollable = function() { return this.$val.pollable(); };
	FD.ptr.prototype.SetDeadline = function(t) {
		var t;
		return $ifaceNil;
	};
	FD.prototype.SetDeadline = function(t) { return this.$val.SetDeadline(t); };
	FD.ptr.prototype.SetReadDeadline = function(t) {
		var t;
		return $ifaceNil;
	};
	FD.prototype.SetReadDeadline = function(t) { return this.$val.SetReadDeadline(t); };
	FD.ptr.prototype.SetWriteDeadline = function(t) {
		var t;
		return $ifaceNil;
	};
	FD.prototype.SetWriteDeadline = function(t) { return this.$val.SetWriteDeadline(t); };
	errClosing = function(isFile) {
		var isFile;
		if (isFile) {
			return $pkg.ErrFileClosing;
		}
		return $pkg.ErrNetClosing;
	};
	TimeoutError.ptr.prototype.Error = function() {
		var e;
		e = this;
		return "i/o timeout";
	};
	TimeoutError.prototype.Error = function() { return this.$val.Error(); };
	TimeoutError.ptr.prototype.Timeout = function() {
		var e;
		e = this;
		return true;
	};
	TimeoutError.prototype.Timeout = function() { return this.$val.Timeout(); };
	TimeoutError.ptr.prototype.Temporary = function() {
		var e;
		e = this;
		return true;
	};
	TimeoutError.prototype.Temporary = function() { return this.$val.Temporary(); };
	consume = function(v, n) {
		var ln0, n, v, x, x$1, x$2, x$3;
		while (true) {
			if (!(v.$get().$length > 0)) { break; }
			ln0 = (new $Int64(0, (x = v.$get(), (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])).$length));
			if ((ln0.$high > n.$high || (ln0.$high === n.$high && ln0.$low > n.$low))) {
				(x$2 = v.$get(), (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0] = $subslice((x$1 = v.$get(), (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])), $flatten64(n))));
				return;
			}
			n = (x$3 = ln0, new $Int64(n.$high - x$3.$high, n.$low - x$3.$low));
			v.$set($subslice((v.$get()), 1));
		}
	};
	fdMutex.ptr.prototype.incref = function() {
		var mu, new$1, old, x, x$1;
		mu = this;
		while (true) {
			old = atomic.LoadUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))));
			if (!((x = new $Uint64(old.$high & 0, (old.$low & 1) >>> 0), (x.$high === 0 && x.$low === 0)))) {
				return false;
			}
			new$1 = new $Uint64(old.$high + 0, old.$low + 8);
			if ((x$1 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388600) >>> 0), (x$1.$high === 0 && x$1.$low === 0))) {
				$panic(new $String("inconsistent poll.fdMutex"));
			}
			if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) {
				return true;
			}
		}
	};
	fdMutex.prototype.incref = function() { return this.$val.incref(); };
	fdMutex.ptr.prototype.increfAndClose = function() {
		var mu, new$1, old, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7;
		mu = this;
		while (true) {
			old = atomic.LoadUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))));
			if (!((x = new $Uint64(old.$high & 0, (old.$low & 1) >>> 0), (x.$high === 0 && x.$low === 0)))) {
				return false;
			}
			new$1 = (x$1 = new $Uint64(old.$high | 0, (old.$low | 1) >>> 0), new $Uint64(x$1.$high + 0, x$1.$low + 8));
			if ((x$2 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388600) >>> 0), (x$2.$high === 0 && x$2.$low === 0))) {
				$panic(new $String("inconsistent poll.fdMutex"));
			}
			new$1 = (x$3 = new $Uint64(2147483647, 4286578688), new $Uint64(new$1.$high & ~x$3.$high, (new$1.$low & ~x$3.$low) >>> 0));
			if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) {
				while (true) {
					if (!(!((x$4 = new $Uint64(old.$high & 2047, (old.$low & 4286578688) >>> 0), (x$4.$high === 0 && x$4.$low === 0))))) { break; }
					old = (x$5 = new $Uint64(0, 8388608), new $Uint64(old.$high - x$5.$high, old.$low - x$5.$low));
					runtime_Semrelease((mu.$ptr_rsema || (mu.$ptr_rsema = new ptrType$1(function() { return this.$target.rsema; }, function($v) { this.$target.rsema = $v; }, mu))));
				}
				while (true) {
					if (!(!((x$6 = new $Uint64(old.$high & 2147481600, (old.$low & 0) >>> 0), (x$6.$high === 0 && x$6.$low === 0))))) { break; }
					old = (x$7 = new $Uint64(2048, 0), new $Uint64(old.$high - x$7.$high, old.$low - x$7.$low));
					runtime_Semrelease((mu.$ptr_wsema || (mu.$ptr_wsema = new ptrType$1(function() { return this.$target.wsema; }, function($v) { this.$target.wsema = $v; }, mu))));
				}
				return true;
			}
		}
	};
	fdMutex.prototype.increfAndClose = function() { return this.$val.increfAndClose(); };
	fdMutex.ptr.prototype.decref = function() {
		var mu, new$1, old, x, x$1;
		mu = this;
		while (true) {
			old = atomic.LoadUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))));
			if ((x = new $Uint64(old.$high & 0, (old.$low & 8388600) >>> 0), (x.$high === 0 && x.$low === 0))) {
				$panic(new $String("inconsistent poll.fdMutex"));
			}
			new$1 = new $Uint64(old.$high - 0, old.$low - 8);
			if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) {
				return (x$1 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388601) >>> 0), (x$1.$high === 0 && x$1.$low === 1));
			}
		}
	};
	fdMutex.prototype.decref = function() { return this.$val.decref(); };
	fdMutex.ptr.prototype.rwlock = function(read) {
		var _tmp, _tmp$1, _tmp$2, mu, mutexBit, mutexMask, mutexSema, mutexWait, new$1, old, read, x, x$1, x$2, x$3, x$4, x$5;
		mu = this;
		_tmp = new $Uint64(0, 0);
		_tmp$1 = new $Uint64(0, 0);
		_tmp$2 = new $Uint64(0, 0);
		mutexBit = _tmp;
		mutexWait = _tmp$1;
		mutexMask = _tmp$2;
		mutexSema = ptrType$1.nil;
		if (read) {
			mutexBit = new $Uint64(0, 2);
			mutexWait = new $Uint64(0, 8388608);
			mutexMask = new $Uint64(2047, 4286578688);
			mutexSema = (mu.$ptr_rsema || (mu.$ptr_rsema = new ptrType$1(function() { return this.$target.rsema; }, function($v) { this.$target.rsema = $v; }, mu)));
		} else {
			mutexBit = new $Uint64(0, 4);
			mutexWait = new $Uint64(2048, 0);
			mutexMask = new $Uint64(2147481600, 0);
			mutexSema = (mu.$ptr_wsema || (mu.$ptr_wsema = new ptrType$1(function() { return this.$target.wsema; }, function($v) { this.$target.wsema = $v; }, mu)));
		}
		while (true) {
			old = atomic.LoadUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))));
			if (!((x = new $Uint64(old.$high & 0, (old.$low & 1) >>> 0), (x.$high === 0 && x.$low === 0)))) {
				return false;
			}
			new$1 = new $Uint64(0, 0);
			if ((x$1 = new $Uint64(old.$high & mutexBit.$high, (old.$low & mutexBit.$low) >>> 0), (x$1.$high === 0 && x$1.$low === 0))) {
				new$1 = (x$2 = new $Uint64(old.$high | mutexBit.$high, (old.$low | mutexBit.$low) >>> 0), new $Uint64(x$2.$high + 0, x$2.$low + 8));
				if ((x$3 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388600) >>> 0), (x$3.$high === 0 && x$3.$low === 0))) {
					$panic(new $String("inconsistent poll.fdMutex"));
				}
			} else {
				new$1 = new $Uint64(old.$high + mutexWait.$high, old.$low + mutexWait.$low);
				if ((x$4 = new $Uint64(new$1.$high & mutexMask.$high, (new$1.$low & mutexMask.$low) >>> 0), (x$4.$high === 0 && x$4.$low === 0))) {
					$panic(new $String("inconsistent poll.fdMutex"));
				}
			}
			if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) {
				if ((x$5 = new $Uint64(old.$high & mutexBit.$high, (old.$low & mutexBit.$low) >>> 0), (x$5.$high === 0 && x$5.$low === 0))) {
					return true;
				}
				runtime_Semacquire(mutexSema);
			}
		}
	};
	fdMutex.prototype.rwlock = function(read) { return this.$val.rwlock(read); };
	fdMutex.ptr.prototype.rwunlock = function(read) {
		var _tmp, _tmp$1, _tmp$2, mu, mutexBit, mutexMask, mutexSema, mutexWait, new$1, old, read, x, x$1, x$2, x$3, x$4, x$5, x$6;
		mu = this;
		_tmp = new $Uint64(0, 0);
		_tmp$1 = new $Uint64(0, 0);
		_tmp$2 = new $Uint64(0, 0);
		mutexBit = _tmp;
		mutexWait = _tmp$1;
		mutexMask = _tmp$2;
		mutexSema = ptrType$1.nil;
		if (read) {
			mutexBit = new $Uint64(0, 2);
			mutexWait = new $Uint64(0, 8388608);
			mutexMask = new $Uint64(2047, 4286578688);
			mutexSema = (mu.$ptr_rsema || (mu.$ptr_rsema = new ptrType$1(function() { return this.$target.rsema; }, function($v) { this.$target.rsema = $v; }, mu)));
		} else {
			mutexBit = new $Uint64(0, 4);
			mutexWait = new $Uint64(2048, 0);
			mutexMask = new $Uint64(2147481600, 0);
			mutexSema = (mu.$ptr_wsema || (mu.$ptr_wsema = new ptrType$1(function() { return this.$target.wsema; }, function($v) { this.$target.wsema = $v; }, mu)));
		}
		while (true) {
			old = atomic.LoadUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))));
			if ((x = new $Uint64(old.$high & mutexBit.$high, (old.$low & mutexBit.$low) >>> 0), (x.$high === 0 && x.$low === 0)) || (x$1 = new $Uint64(old.$high & 0, (old.$low & 8388600) >>> 0), (x$1.$high === 0 && x$1.$low === 0))) {
				$panic(new $String("inconsistent poll.fdMutex"));
			}
			new$1 = (x$2 = new $Uint64(old.$high & ~mutexBit.$high, (old.$low & ~mutexBit.$low) >>> 0), new $Uint64(x$2.$high - 0, x$2.$low - 8));
			if (!((x$3 = new $Uint64(old.$high & mutexMask.$high, (old.$low & mutexMask.$low) >>> 0), (x$3.$high === 0 && x$3.$low === 0)))) {
				new$1 = (x$4 = mutexWait, new $Uint64(new$1.$high - x$4.$high, new$1.$low - x$4.$low));
			}
			if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) {
				if (!((x$5 = new $Uint64(old.$high & mutexMask.$high, (old.$low & mutexMask.$low) >>> 0), (x$5.$high === 0 && x$5.$low === 0)))) {
					runtime_Semrelease(mutexSema);
				}
				return (x$6 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388601) >>> 0), (x$6.$high === 0 && x$6.$low === 1));
			}
		}
	};
	fdMutex.prototype.rwunlock = function(read) { return this.$val.rwunlock(read); };
	runtime_Semacquire = function() {
		$throwRuntimeError("native function not implemented: internal/poll.runtime_Semacquire");
	};
	runtime_Semrelease = function() {
		$throwRuntimeError("native function not implemented: internal/poll.runtime_Semrelease");
	};
	FD.ptr.prototype.incref = function() {
		var fd;
		fd = this;
		if (!fd.fdmu.incref()) {
			return errClosing(fd.isFile);
		}
		return $ifaceNil;
	};
	FD.prototype.incref = function() { return this.$val.incref(); };
	FD.ptr.prototype.decref = function() {
		var _r, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		/* */ if (fd.fdmu.decref()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (fd.fdmu.decref()) { */ case 1:
			_r = fd.destroy(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.decref }; } $f._r = _r; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.decref = function() { return this.$val.decref(); };
	FD.ptr.prototype.readLock = function() {
		var fd;
		fd = this;
		if (!fd.fdmu.rwlock(true)) {
			return errClosing(fd.isFile);
		}
		return $ifaceNil;
	};
	FD.prototype.readLock = function() { return this.$val.readLock(); };
	FD.ptr.prototype.readUnlock = function() {
		var _r, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		/* */ if (fd.fdmu.rwunlock(true)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (fd.fdmu.rwunlock(true)) { */ case 1:
			_r = fd.destroy(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.readUnlock }; } $f._r = _r; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.readUnlock = function() { return this.$val.readUnlock(); };
	FD.ptr.prototype.writeLock = function() {
		var fd;
		fd = this;
		if (!fd.fdmu.rwlock(false)) {
			return errClosing(fd.isFile);
		}
		return $ifaceNil;
	};
	FD.prototype.writeLock = function() { return this.$val.writeLock(); };
	FD.ptr.prototype.writeUnlock = function() {
		var _r, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		/* */ if (fd.fdmu.rwunlock(false)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (fd.fdmu.rwunlock(false)) { */ case 1:
			_r = fd.destroy(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.writeUnlock }; } $f._r = _r; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.writeUnlock = function() { return this.$val.writeUnlock(); };
	FD.ptr.prototype.eofError = function(n, err) {
		var err, fd, n;
		fd = this;
		if ((n === 0) && $interfaceIsEqual(err, $ifaceNil) && fd.ZeroReadIsEOF) {
			return io.EOF;
		}
		return err;
	};
	FD.prototype.eofError = function(n, err) { return this.$val.eofError(n, err); };
	FD.ptr.prototype.Fchmod = function(mode) {
		var err, fd, mode, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; mode = $f.mode; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Fchmod(fd.Sysfd, mode);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Fchmod }; } $f.err = err; $f.fd = fd; $f.mode = mode; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Fchmod = function(mode) { return this.$val.Fchmod(mode); };
	FD.ptr.prototype.Fchown = function(uid, gid) {
		var err, fd, gid, uid, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; gid = $f.gid; uid = $f.uid; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Fchown(fd.Sysfd, uid, gid);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Fchown }; } $f.err = err; $f.fd = fd; $f.gid = gid; $f.uid = uid; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Fchown = function(uid, gid) { return this.$val.Fchown(uid, gid); };
	FD.ptr.prototype.Ftruncate = function(size) {
		var err, fd, size, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; size = $f.size; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Ftruncate(fd.Sysfd, size);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Ftruncate }; } $f.err = err; $f.fd = fd; $f.size = size; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Ftruncate = function(size) { return this.$val.Ftruncate(size); };
	FD.ptr.prototype.Fsync = function() {
		var err, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Fsync(fd.Sysfd);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Fsync }; } $f.err = err; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Fsync = function() { return this.$val.Fsync(); };
	FD.ptr.prototype.Init = function(net, pollable) {
		var fd, net, pollable;
		fd = this;
		if (net === "file") {
			fd.isFile = true;
		}
		if (!pollable) {
			return $ifaceNil;
		}
		return fd.pd.init(fd);
	};
	FD.prototype.Init = function(net, pollable) { return this.$val.Init(net, pollable); };
	FD.ptr.prototype.destroy = function() {
		var _r, err, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		fd.pd.close();
		_r = $pkg.CloseFunc(fd.Sysfd); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		fd.Sysfd = -1;
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.destroy }; } $f._r = _r; $f.err = err; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.destroy = function() { return this.$val.destroy(); };
	FD.ptr.prototype.Close = function() {
		var _r, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		if (!fd.fdmu.increfAndClose()) {
			$s = -1; return errClosing(fd.isFile);
		}
		fd.pd.evict();
		_r = fd.decref(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Close }; } $f._r = _r; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.Close = function() { return this.$val.Close(); };
	FD.ptr.prototype.Shutdown = function(how) {
		var err, fd, how, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; how = $f.how; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Shutdown(fd.Sysfd, how);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Shutdown }; } $f.err = err; $f.fd = fd; $f.how = how; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Shutdown = function(how) { return this.$val.Shutdown(how); };
	FD.ptr.prototype.Read = function(p) {
		var _tuple, err, err$1, err$2, fd, n, p, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; n = $f.n; p = $f.p; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.readLock();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		$deferred.push([$methodVal(fd, "readUnlock"), []]);
		if (p.$length === 0) {
			$s = -1; return [0, $ifaceNil];
		}
		err$1 = fd.pd.prepareRead(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, err$1];
		}
		if (fd.IsStream && p.$length > 1073741824) {
			p = $subslice(p, 0, 1073741824);
		}
		while (true) {
			_tuple = syscall.Read(fd.Sysfd, p);
			n = _tuple[0];
			err$2 = _tuple[1];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				n = 0;
				if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
					err$2 = fd.pd.waitRead(fd.isFile);
					if ($interfaceIsEqual(err$2, $ifaceNil)) {
						continue;
					}
				}
			}
			err$2 = fd.eofError(n, err$2);
			$s = -1; return [n, err$2];
		}
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Read }; } $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.n = n; $f.p = p; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Read = function(p) { return this.$val.Read(p); };
	FD.ptr.prototype.Pread = function(p, off) {
		var _r, _tuple, err, err$1, fd, n, off, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; fd = $f.fd; n = $f.n; off = $f.off; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		if (fd.IsStream && p.$length > 1073741824) {
			p = $subslice(p, 0, 1073741824);
		}
		_tuple = syscall.Pread(fd.Sysfd, p, off);
		n = _tuple[0];
		err$1 = _tuple[1];
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			n = 0;
		}
		_r = fd.decref(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		err$1 = fd.eofError(n, err$1);
		$s = -1; return [n, err$1];
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Pread }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.fd = fd; $f.n = n; $f.off = off; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.Pread = function(p, off) { return this.$val.Pread(p, off); };
	FD.ptr.prototype.ReadFrom = function(p) {
		var _tuple, err, err$1, err$2, fd, n, p, sa, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; n = $f.n; p = $f.p; sa = $f.sa; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.readLock();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, $ifaceNil, err];
		}
		$deferred.push([$methodVal(fd, "readUnlock"), []]);
		err$1 = fd.pd.prepareRead(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, $ifaceNil, err$1];
		}
		while (true) {
			_tuple = syscall.Recvfrom(fd.Sysfd, p, 0);
			n = _tuple[0];
			sa = _tuple[1];
			err$2 = _tuple[2];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				n = 0;
				if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
					err$2 = fd.pd.waitRead(fd.isFile);
					if ($interfaceIsEqual(err$2, $ifaceNil)) {
						continue;
					}
				}
			}
			err$2 = fd.eofError(n, err$2);
			$s = -1; return [n, sa, err$2];
		}
		$s = -1; return [0, $ifaceNil, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.ReadFrom }; } $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.n = n; $f.p = p; $f.sa = sa; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.ReadFrom = function(p) { return this.$val.ReadFrom(p); };
	FD.ptr.prototype.ReadMsg = function(p, oob) {
		var _tuple, err, err$1, err$2, fd, flags, n, oob, oobn, p, sa, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; flags = $f.flags; n = $f.n; oob = $f.oob; oobn = $f.oobn; p = $f.p; sa = $f.sa; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.readLock();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, 0, 0, $ifaceNil, err];
		}
		$deferred.push([$methodVal(fd, "readUnlock"), []]);
		err$1 = fd.pd.prepareRead(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, 0, 0, $ifaceNil, err$1];
		}
		while (true) {
			_tuple = syscall.Recvmsg(fd.Sysfd, p, oob, 0);
			n = _tuple[0];
			oobn = _tuple[1];
			flags = _tuple[2];
			sa = _tuple[3];
			err$2 = _tuple[4];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
					err$2 = fd.pd.waitRead(fd.isFile);
					if ($interfaceIsEqual(err$2, $ifaceNil)) {
						continue;
					}
				}
			}
			err$2 = fd.eofError(n, err$2);
			$s = -1; return [n, oobn, flags, sa, err$2];
		}
		$s = -1; return [0, 0, 0, $ifaceNil, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, 0, 0, $ifaceNil, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.ReadMsg }; } $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.flags = flags; $f.n = n; $f.oob = oob; $f.oobn = oobn; $f.p = p; $f.sa = sa; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.ReadMsg = function(p, oob) { return this.$val.ReadMsg(p, oob); };
	FD.ptr.prototype.Write = function(p) {
		var _tuple, err, err$1, err$2, fd, max, n, nn, p, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; max = $f.max; n = $f.n; nn = $f.nn; p = $f.p; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.writeLock();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		$deferred.push([$methodVal(fd, "writeUnlock"), []]);
		err$1 = fd.pd.prepareWrite(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, err$1];
		}
		nn = 0;
		while (true) {
			max = p.$length;
			if (fd.IsStream && (max - nn >> 0) > 1073741824) {
				max = nn + 1073741824 >> 0;
			}
			_tuple = syscall.Write(fd.Sysfd, $subslice(p, nn, max));
			n = _tuple[0];
			err$2 = _tuple[1];
			if (n > 0) {
				nn = nn + (n) >> 0;
			}
			if (nn === p.$length) {
				$s = -1; return [nn, err$2];
			}
			if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
				err$2 = fd.pd.waitWrite(fd.isFile);
				if ($interfaceIsEqual(err$2, $ifaceNil)) {
					continue;
				}
			}
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return [nn, err$2];
			}
			if (n === 0) {
				$s = -1; return [nn, io.ErrUnexpectedEOF];
			}
		}
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Write }; } $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.max = max; $f.n = n; $f.nn = nn; $f.p = p; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Write = function(p) { return this.$val.Write(p); };
	FD.ptr.prototype.Pwrite = function(p, off) {
		var _tuple, err, err$1, fd, max, n, nn, off, p, x, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; fd = $f.fd; max = $f.max; n = $f.n; nn = $f.nn; off = $f.off; p = $f.p; x = $f.x; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		nn = 0;
		while (true) {
			max = p.$length;
			if (fd.IsStream && (max - nn >> 0) > 1073741824) {
				max = nn + 1073741824 >> 0;
			}
			_tuple = syscall.Pwrite(fd.Sysfd, $subslice(p, nn, max), (x = (new $Int64(0, nn)), new $Int64(off.$high + x.$high, off.$low + x.$low)));
			n = _tuple[0];
			err$1 = _tuple[1];
			if (n > 0) {
				nn = nn + (n) >> 0;
			}
			if (nn === p.$length) {
				$s = -1; return [nn, err$1];
			}
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				$s = -1; return [nn, err$1];
			}
			if (n === 0) {
				$s = -1; return [nn, io.ErrUnexpectedEOF];
			}
		}
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Pwrite }; } $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.fd = fd; $f.max = max; $f.n = n; $f.nn = nn; $f.off = off; $f.p = p; $f.x = x; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Pwrite = function(p, off) { return this.$val.Pwrite(p, off); };
	FD.ptr.prototype.WriteTo = function(p, sa) {
		var _r, err, err$1, err$2, fd, p, sa, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; p = $f.p; sa = $f.sa; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.writeLock();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		$deferred.push([$methodVal(fd, "writeUnlock"), []]);
		err$1 = fd.pd.prepareWrite(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, err$1];
		}
		/* while (true) { */ case 1:
			_r = syscall.Sendto(fd.Sysfd, p, 0, sa); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			err$2 = _r;
			if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
				err$2 = fd.pd.waitWrite(fd.isFile);
				if ($interfaceIsEqual(err$2, $ifaceNil)) {
					/* continue; */ $s = 1; continue;
				}
			}
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return [0, err$2];
			}
			$s = -1; return [p.$length, $ifaceNil];
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.WriteTo }; } $f._r = _r; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.p = p; $f.sa = sa; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.WriteTo = function(p, sa) { return this.$val.WriteTo(p, sa); };
	FD.ptr.prototype.WriteMsg = function(p, oob, sa) {
		var _r, _tuple, err, err$1, err$2, fd, n, oob, p, sa, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; n = $f.n; oob = $f.oob; p = $f.p; sa = $f.sa; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.writeLock();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, 0, err];
		}
		$deferred.push([$methodVal(fd, "writeUnlock"), []]);
		err$1 = fd.pd.prepareWrite(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, 0, err$1];
		}
		/* while (true) { */ case 1:
			_r = syscall.SendmsgN(fd.Sysfd, p, oob, sa, 0); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			n = _tuple[0];
			err$2 = _tuple[1];
			if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
				err$2 = fd.pd.waitWrite(fd.isFile);
				if ($interfaceIsEqual(err$2, $ifaceNil)) {
					/* continue; */ $s = 1; continue;
				}
			}
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return [n, 0, err$2];
			}
			$s = -1; return [n, oob.$length, err$2];
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [0, 0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, 0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.WriteMsg }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.n = n; $f.oob = oob; $f.p = p; $f.sa = sa; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.WriteMsg = function(p, oob, sa) { return this.$val.WriteMsg(p, oob, sa); };
	FD.ptr.prototype.Accept = function() {
		var _1, _r, _tuple, err, err$1, err$2, errcall, fd, rsa, s, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; errcall = $f.errcall; fd = $f.fd; rsa = $f.rsa; s = $f.s; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.readLock();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [-1, $ifaceNil, "", err];
		}
		$deferred.push([$methodVal(fd, "readUnlock"), []]);
		err$1 = fd.pd.prepareRead(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [-1, $ifaceNil, "", err$1];
		}
		/* while (true) { */ case 1:
			_r = accept(fd.Sysfd); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			s = _tuple[0];
			rsa = _tuple[1];
			errcall = _tuple[2];
			err$2 = _tuple[3];
			if ($interfaceIsEqual(err$2, $ifaceNil)) {
				$s = -1; return [s, rsa, "", err$2];
			}
			_1 = err$2;
			if ($interfaceIsEqual(_1, new syscall.Errno((11)))) {
				if (fd.pd.pollable()) {
					err$2 = fd.pd.waitRead(fd.isFile);
					if ($interfaceIsEqual(err$2, $ifaceNil)) {
						/* continue; */ $s = 1; continue;
					}
				}
			} else if ($interfaceIsEqual(_1, new syscall.Errno((103)))) {
				/* continue; */ $s = 1; continue;
			}
			$s = -1; return [-1, $ifaceNil, errcall, err$2];
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [0, $ifaceNil, "", $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil, "", $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Accept }; } $f._1 = _1; $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.errcall = errcall; $f.fd = fd; $f.rsa = rsa; $f.s = s; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Accept = function() { return this.$val.Accept(); };
	FD.ptr.prototype.Seek = function(offset, whence) {
		var err, fd, offset, whence, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; offset = $f.offset; whence = $f.whence; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [new $Int64(0, 0), err];
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Seek(fd.Sysfd, offset, whence);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [new $Int64(0, 0), $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Seek }; } $f.err = err; $f.fd = fd; $f.offset = offset; $f.whence = whence; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Seek = function(offset, whence) { return this.$val.Seek(offset, whence); };
	FD.ptr.prototype.ReadDirent = function(buf) {
		var _tuple, buf, err, err$1, fd, n, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; buf = $f.buf; err = $f.err; err$1 = $f.err$1; fd = $f.fd; n = $f.n; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		while (true) {
			_tuple = syscall.ReadDirent(fd.Sysfd, buf);
			n = _tuple[0];
			err$1 = _tuple[1];
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				n = 0;
				if ($interfaceIsEqual(err$1, new syscall.Errno(11)) && fd.pd.pollable()) {
					err$1 = fd.pd.waitRead(fd.isFile);
					if ($interfaceIsEqual(err$1, $ifaceNil)) {
						continue;
					}
				}
			}
			$s = -1; return [n, err$1];
		}
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.ReadDirent }; } $f._tuple = _tuple; $f.buf = buf; $f.err = err; $f.err$1 = err$1; $f.fd = fd; $f.n = n; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.ReadDirent = function(buf) { return this.$val.ReadDirent(buf); };
	FD.ptr.prototype.Fchdir = function() {
		var err, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Fchdir(fd.Sysfd);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Fchdir }; } $f.err = err; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Fchdir = function() { return this.$val.Fchdir(); };
	FD.ptr.prototype.Fstat = function(s) {
		var err, fd, s, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; s = $f.s; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Fstat(fd.Sysfd, s);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Fstat }; } $f.err = err; $f.fd = fd; $f.s = s; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Fstat = function(s) { return this.$val.Fstat(s); };
	FD.ptr.prototype.WaitWrite = function() {
		var fd;
		fd = this;
		return fd.pd.waitWrite(fd.isFile);
	};
	FD.prototype.WaitWrite = function() { return this.$val.WaitWrite(); };
	FD.ptr.prototype.RawControl = function(f) {
		var err, f, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; f = $f.f; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$r = f(((fd.Sysfd >>> 0))); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return $ifaceNil;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.RawControl }; } $f.err = err; $f.f = f; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.RawControl = function(f) { return this.$val.RawControl(f); };
	FD.ptr.prototype.RawRead = function(f) {
		var _r, err, err$1, err$2, f, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; f = $f.f; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.readLock();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "readUnlock"), []]);
		err$1 = fd.pd.prepareRead(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return err$1;
		}
		/* while (true) { */ case 1:
			_r = f(((fd.Sysfd >>> 0))); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r) { */ case 3:
				$s = -1; return $ifaceNil;
			/* } */ case 4:
			err$2 = fd.pd.waitRead(fd.isFile);
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return err$2;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return $ifaceNil;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.RawRead }; } $f._r = _r; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.f = f; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.RawRead = function(f) { return this.$val.RawRead(f); };
	FD.ptr.prototype.RawWrite = function(f) {
		var _r, err, err$1, err$2, f, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; f = $f.f; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.writeLock();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "writeUnlock"), []]);
		err$1 = fd.pd.prepareWrite(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return err$1;
		}
		/* while (true) { */ case 1:
			_r = f(((fd.Sysfd >>> 0))); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r) { */ case 3:
				$s = -1; return $ifaceNil;
			/* } */ case 4:
			err$2 = fd.pd.waitWrite(fd.isFile);
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return err$2;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return $ifaceNil;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.RawWrite }; } $f._r = _r; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.f = f; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.RawWrite = function(f) { return this.$val.RawWrite(f); };
	accept = function(s) {
		var _1, _r, _r$1, _r$2, _tuple, _tuple$1, err, ns, s, sa, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; err = $f.err; ns = $f.ns; s = $f.s; sa = $f.sa; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = $pkg.Accept4Func(s, 526336); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		ns = _tuple[0];
		sa = _tuple[1];
		err = _tuple[2];
		_1 = err;
		if ($interfaceIsEqual(_1, $ifaceNil)) {
			$s = -1; return [ns, sa, "", $ifaceNil];
		} else if ($interfaceIsEqual(_1, new syscall.Errno((38)))) {
		} else if ($interfaceIsEqual(_1, new syscall.Errno((22)))) {
		} else if ($interfaceIsEqual(_1, new syscall.Errno((13)))) {
		} else if ($interfaceIsEqual(_1, new syscall.Errno((14)))) {
		} else {
			$s = -1; return [-1, sa, "accept4", err];
		}
		_r$1 = $pkg.AcceptFunc(s); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		ns = _tuple$1[0];
		sa = _tuple$1[1];
		err = _tuple$1[2];
		if ($interfaceIsEqual(err, $ifaceNil)) {
			syscall.CloseOnExec(ns);
		}
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [-1, $ifaceNil, "accept", err];
		}
		err = syscall.SetNonblock(ns, true);
		/* */ if (!($interfaceIsEqual(err, $ifaceNil))) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 3:
			_r$2 = $pkg.CloseFunc(ns); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_r$2;
			$s = -1; return [-1, $ifaceNil, "setnonblock", err];
		/* } */ case 4:
		$s = -1; return [ns, sa, "", $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: accept }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.err = err; $f.ns = ns; $f.s = s; $f.sa = sa; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.ptr.prototype.SetsockoptInt = function(level, name, arg) {
		var arg, err, fd, level, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; arg = $f.arg; err = $f.err; fd = $f.fd; level = $f.level; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptInt(fd.Sysfd, level, name, arg);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptInt }; } $f.arg = arg; $f.err = err; $f.fd = fd; $f.level = level; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptInt = function(level, name, arg) { return this.$val.SetsockoptInt(level, name, arg); };
	FD.ptr.prototype.SetsockoptInet4Addr = function(level, name, arg) {
		var arg, err, fd, level, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; arg = $f.arg; err = $f.err; fd = $f.fd; level = $f.level; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptInet4Addr(fd.Sysfd, level, name, $clone(arg, arrayType));
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptInet4Addr }; } $f.arg = arg; $f.err = err; $f.fd = fd; $f.level = level; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptInet4Addr = function(level, name, arg) { return this.$val.SetsockoptInet4Addr(level, name, arg); };
	FD.ptr.prototype.SetsockoptLinger = function(level, name, l) {
		var err, fd, l, level, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; l = $f.l; level = $f.level; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptLinger(fd.Sysfd, level, name, l);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptLinger }; } $f.err = err; $f.fd = fd; $f.l = l; $f.level = level; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptLinger = function(level, name, l) { return this.$val.SetsockoptLinger(level, name, l); };
	FD.ptr.prototype.SetsockoptIPMreqn = function(level, name, mreq) {
		var err, fd, level, mreq, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; level = $f.level; mreq = $f.mreq; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptIPMreqn(fd.Sysfd, level, name, mreq);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptIPMreqn }; } $f.err = err; $f.fd = fd; $f.level = level; $f.mreq = mreq; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptIPMreqn = function(level, name, mreq) { return this.$val.SetsockoptIPMreqn(level, name, mreq); };
	FD.ptr.prototype.SetsockoptByte = function(level, name, arg) {
		var arg, err, fd, level, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; arg = $f.arg; err = $f.err; fd = $f.fd; level = $f.level; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptByte(fd.Sysfd, level, name, arg);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptByte }; } $f.arg = arg; $f.err = err; $f.fd = fd; $f.level = level; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptByte = function(level, name, arg) { return this.$val.SetsockoptByte(level, name, arg); };
	FD.ptr.prototype.SetsockoptIPMreq = function(level, name, mreq) {
		var err, fd, level, mreq, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; level = $f.level; mreq = $f.mreq; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptIPMreq(fd.Sysfd, level, name, mreq);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptIPMreq }; } $f.err = err; $f.fd = fd; $f.level = level; $f.mreq = mreq; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptIPMreq = function(level, name, mreq) { return this.$val.SetsockoptIPMreq(level, name, mreq); };
	FD.ptr.prototype.SetsockoptIPv6Mreq = function(level, name, mreq) {
		var err, fd, level, mreq, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; level = $f.level; mreq = $f.mreq; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptIPv6Mreq(fd.Sysfd, level, name, mreq);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptIPv6Mreq }; } $f.err = err; $f.fd = fd; $f.level = level; $f.mreq = mreq; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptIPv6Mreq = function(level, name, mreq) { return this.$val.SetsockoptIPv6Mreq(level, name, mreq); };
	FD.ptr.prototype.Writev = function(v) {
		var _i, _ref, _tuple, chunk, e0, err, err$1, err$2, fd, iovecs, maxVec, n, v, wrote, x, x$1, x$2, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _ref = $f._ref; _tuple = $f._tuple; chunk = $f.chunk; e0 = $f.e0; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; iovecs = $f.iovecs; maxVec = $f.maxVec; n = $f.n; v = $f.v; wrote = $f.wrote; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		iovecs = [iovecs];
		fd = this;
		err = fd.writeLock();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [new $Int64(0, 0), err];
		}
		$deferred.push([$methodVal(fd, "writeUnlock"), []]);
		err$1 = fd.pd.prepareWrite(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [new $Int64(0, 0), err$1];
		}
		iovecs[0] = sliceType.nil;
		if (!(fd.iovecs === ptrType$3.nil)) {
			iovecs[0] = fd.iovecs.$get();
		}
		maxVec = 1024;
		n = new $Int64(0, 0);
		err$2 = $ifaceNil;
		/* while (true) { */ case 1:
			/* if (!(v.$get().$length > 0)) { break; } */ if(!(v.$get().$length > 0)) { $s = 2; continue; }
			iovecs[0] = $subslice(iovecs[0], 0, 0);
			_ref = v.$get();
			_i = 0;
			/* while (true) { */ case 3:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 4; continue; }
				chunk = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (chunk.$length === 0) {
					_i++;
					/* continue; */ $s = 3; continue;
				}
				iovecs[0] = $append(iovecs[0], new syscall.Iovec.ptr($indexPtr(chunk.$array, chunk.$offset + 0, ptrType$4), new $Uint64(0, 0)));
				if (fd.IsStream && chunk.$length > 1073741824) {
					(x = iovecs[0].$length - 1 >> 0, ((x < 0 || x >= iovecs[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : iovecs[0].$array[iovecs[0].$offset + x])).SetLen(1073741824);
					/* break; */ $s = 4; continue;
				}
				(x$1 = iovecs[0].$length - 1 >> 0, ((x$1 < 0 || x$1 >= iovecs[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : iovecs[0].$array[iovecs[0].$offset + x$1])).SetLen(chunk.$length);
				if (iovecs[0].$length === maxVec) {
					/* break; */ $s = 4; continue;
				}
				_i++;
			/* } */ $s = 3; continue; case 4:
			if (iovecs[0].$length === 0) {
				/* break; */ $s = 2; continue;
			}
			fd.iovecs = (iovecs.$ptr || (iovecs.$ptr = new ptrType$3(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, iovecs)));
			_tuple = syscall.Syscall(20, ((fd.Sysfd >>> 0)), (($sliceToArray(iovecs[0]))), ((iovecs[0].$length >>> 0)));
			wrote = _tuple[0];
			e0 = _tuple[2];
			if (wrote === 4294967295) {
				wrote = 0;
			}
			$r = $pkg.TestHookDidWritev(((wrote >> 0))); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			n = (x$2 = (new $Int64(0, wrote.constructor === Number ? wrote : 1)), new $Int64(n.$high + x$2.$high, n.$low + x$2.$low));
			consume(v, (new $Int64(0, wrote.constructor === Number ? wrote : 1)));
			if (e0 === 11) {
				err$2 = fd.pd.waitWrite(fd.isFile);
				if ($interfaceIsEqual(err$2, $ifaceNil)) {
					/* continue; */ $s = 1; continue;
				}
			} else if (!((e0 === 0))) {
				err$2 = new syscall.Errno((e0));
			}
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				/* break; */ $s = 2; continue;
			}
			if ((n.$high === 0 && n.$low === 0)) {
				err$2 = io.ErrUnexpectedEOF;
				/* break; */ $s = 2; continue;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [n, err$2];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [new $Int64(0, 0), $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Writev }; } $f._i = _i; $f._ref = _ref; $f._tuple = _tuple; $f.chunk = chunk; $f.e0 = e0; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.iovecs = iovecs; $f.maxVec = maxVec; $f.n = n; $f.v = v; $f.wrote = wrote; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Writev = function(v) { return this.$val.Writev(v); };
	ptrType$6.methods = [{prop: "init", name: "init", pkg: "internal/poll", typ: $funcType([ptrType$5], [$error], false)}, {prop: "close", name: "close", pkg: "internal/poll", typ: $funcType([], [], false)}, {prop: "evict", name: "evict", pkg: "internal/poll", typ: $funcType([], [], false)}, {prop: "prepare", name: "prepare", pkg: "internal/poll", typ: $funcType([$Int, $Bool], [$error], false)}, {prop: "prepareRead", name: "prepareRead", pkg: "internal/poll", typ: $funcType([$Bool], [$error], false)}, {prop: "prepareWrite", name: "prepareWrite", pkg: "internal/poll", typ: $funcType([$Bool], [$error], false)}, {prop: "wait", name: "wait", pkg: "internal/poll", typ: $funcType([$Int, $Bool], [$error], false)}, {prop: "waitRead", name: "waitRead", pkg: "internal/poll", typ: $funcType([$Bool], [$error], false)}, {prop: "waitWrite", name: "waitWrite", pkg: "internal/poll", typ: $funcType([$Bool], [$error], false)}, {prop: "waitCanceled", name: "waitCanceled", pkg: "internal/poll", typ: $funcType([$Int], [], false)}, {prop: "pollable", name: "pollable", pkg: "internal/poll", typ: $funcType([], [$Bool], false)}];
	ptrType$7.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Timeout", name: "Timeout", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Temporary", name: "Temporary", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$8.methods = [{prop: "incref", name: "incref", pkg: "internal/poll", typ: $funcType([], [$Bool], false)}, {prop: "increfAndClose", name: "increfAndClose", pkg: "internal/poll", typ: $funcType([], [$Bool], false)}, {prop: "decref", name: "decref", pkg: "internal/poll", typ: $funcType([], [$Bool], false)}, {prop: "rwlock", name: "rwlock", pkg: "internal/poll", typ: $funcType([$Bool], [$Bool], false)}, {prop: "rwunlock", name: "rwunlock", pkg: "internal/poll", typ: $funcType([$Bool], [$Bool], false)}];
	ptrType$5.methods = [{prop: "SetDeadline", name: "SetDeadline", pkg: "", typ: $funcType([time.Time], [$error], false)}, {prop: "SetReadDeadline", name: "SetReadDeadline", pkg: "", typ: $funcType([time.Time], [$error], false)}, {prop: "SetWriteDeadline", name: "SetWriteDeadline", pkg: "", typ: $funcType([time.Time], [$error], false)}, {prop: "incref", name: "incref", pkg: "internal/poll", typ: $funcType([], [$error], false)}, {prop: "decref", name: "decref", pkg: "internal/poll", typ: $funcType([], [$error], false)}, {prop: "readLock", name: "readLock", pkg: "internal/poll", typ: $funcType([], [$error], false)}, {prop: "readUnlock", name: "readUnlock", pkg: "internal/poll", typ: $funcType([], [], false)}, {prop: "writeLock", name: "writeLock", pkg: "internal/poll", typ: $funcType([], [$error], false)}, {prop: "writeUnlock", name: "writeUnlock", pkg: "internal/poll", typ: $funcType([], [], false)}, {prop: "eofError", name: "eofError", pkg: "internal/poll", typ: $funcType([$Int, $error], [$error], false)}, {prop: "Fchmod", name: "Fchmod", pkg: "", typ: $funcType([$Uint32], [$error], false)}, {prop: "Fchown", name: "Fchown", pkg: "", typ: $funcType([$Int, $Int], [$error], false)}, {prop: "Ftruncate", name: "Ftruncate", pkg: "", typ: $funcType([$Int64], [$error], false)}, {prop: "Fsync", name: "Fsync", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Init", name: "Init", pkg: "", typ: $funcType([$String, $Bool], [$error], false)}, {prop: "destroy", name: "destroy", pkg: "internal/poll", typ: $funcType([], [$error], false)}, {prop: "Close", name: "Close", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Shutdown", name: "Shutdown", pkg: "", typ: $funcType([$Int], [$error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType$1], [$Int, $error], false)}, {prop: "Pread", name: "Pread", pkg: "", typ: $funcType([sliceType$1, $Int64], [$Int, $error], false)}, {prop: "ReadFrom", name: "ReadFrom", pkg: "", typ: $funcType([sliceType$1], [$Int, syscall.Sockaddr, $error], false)}, {prop: "ReadMsg", name: "ReadMsg", pkg: "", typ: $funcType([sliceType$1, sliceType$1], [$Int, $Int, $Int, syscall.Sockaddr, $error], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$1], [$Int, $error], false)}, {prop: "Pwrite", name: "Pwrite", pkg: "", typ: $funcType([sliceType$1, $Int64], [$Int, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([sliceType$1, syscall.Sockaddr], [$Int, $error], false)}, {prop: "WriteMsg", name: "WriteMsg", pkg: "", typ: $funcType([sliceType$1, sliceType$1, syscall.Sockaddr], [$Int, $Int, $error], false)}, {prop: "Accept", name: "Accept", pkg: "", typ: $funcType([], [$Int, syscall.Sockaddr, $String, $error], false)}, {prop: "Seek", name: "Seek", pkg: "", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: "ReadDirent", name: "ReadDirent", pkg: "", typ: $funcType([sliceType$1], [$Int, $error], false)}, {prop: "Fchdir", name: "Fchdir", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Fstat", name: "Fstat", pkg: "", typ: $funcType([ptrType$9], [$error], false)}, {prop: "WaitWrite", name: "WaitWrite", pkg: "", typ: $funcType([], [$error], false)}, {prop: "RawControl", name: "RawControl", pkg: "", typ: $funcType([funcType], [$error], false)}, {prop: "RawRead", name: "RawRead", pkg: "", typ: $funcType([funcType$1], [$error], false)}, {prop: "RawWrite", name: "RawWrite", pkg: "", typ: $funcType([funcType$1], [$error], false)}, {prop: "SetsockoptInt", name: "SetsockoptInt", pkg: "", typ: $funcType([$Int, $Int, $Int], [$error], false)}, {prop: "SetsockoptInet4Addr", name: "SetsockoptInet4Addr", pkg: "", typ: $funcType([$Int, $Int, arrayType], [$error], false)}, {prop: "SetsockoptLinger", name: "SetsockoptLinger", pkg: "", typ: $funcType([$Int, $Int, ptrType$10], [$error], false)}, {prop: "SetsockoptIPMreqn", name: "SetsockoptIPMreqn", pkg: "", typ: $funcType([$Int, $Int, ptrType$11], [$error], false)}, {prop: "SetsockoptByte", name: "SetsockoptByte", pkg: "", typ: $funcType([$Int, $Int, $Uint8], [$error], false)}, {prop: "SetsockoptIPMreq", name: "SetsockoptIPMreq", pkg: "", typ: $funcType([$Int, $Int, ptrType$12], [$error], false)}, {prop: "SetsockoptIPv6Mreq", name: "SetsockoptIPv6Mreq", pkg: "", typ: $funcType([$Int, $Int, ptrType$13], [$error], false)}, {prop: "Writev", name: "Writev", pkg: "", typ: $funcType([ptrType$14], [$Int64, $error], false)}];
	pollDesc.init("internal/poll", [{prop: "closing", name: "closing", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	TimeoutError.init("", []);
	fdMutex.init("internal/poll", [{prop: "state", name: "state", anonymous: false, exported: false, typ: $Uint64, tag: ""}, {prop: "rsema", name: "rsema", anonymous: false, exported: false, typ: $Uint32, tag: ""}, {prop: "wsema", name: "wsema", anonymous: false, exported: false, typ: $Uint32, tag: ""}]);
	FD.init("internal/poll", [{prop: "fdmu", name: "fdmu", anonymous: false, exported: false, typ: fdMutex, tag: ""}, {prop: "Sysfd", name: "Sysfd", anonymous: false, exported: true, typ: $Int, tag: ""}, {prop: "pd", name: "pd", anonymous: false, exported: false, typ: pollDesc, tag: ""}, {prop: "iovecs", name: "iovecs", anonymous: false, exported: false, typ: ptrType$3, tag: ""}, {prop: "IsStream", name: "IsStream", anonymous: false, exported: true, typ: $Bool, tag: ""}, {prop: "ZeroReadIsEOF", name: "ZeroReadIsEOF", anonymous: false, exported: true, typ: $Bool, tag: ""}, {prop: "isFile", name: "isFile", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = syscall.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = time.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrNetClosing = errors.New("use of closed network connection");
		$pkg.ErrFileClosing = errors.New("use of closed file");
		$pkg.ErrTimeout = new TimeoutError.ptr();
		$pkg.TestHookDidWritev = (function(wrote) {
			var wrote;
		});
		$pkg.Accept4Func = syscall.Accept4;
		$pkg.CloseFunc = syscall.Close;
		$pkg.AcceptFunc = syscall.Accept;
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["os"] = (function() {
	var $pkg = {}, $init, errors, js, poll, io, runtime, sync, atomic, syscall, time, PathError, SyscallError, LinkError, file, dirInfo, File, FileInfo, FileMode, fileStat, sliceType, ptrType, sliceType$1, ptrType$1, sliceType$2, ptrType$2, ptrType$3, ptrType$4, sliceType$5, ptrType$12, ptrType$13, funcType$1, ptrType$15, arrayType$2, arrayType$5, ptrType$16, errFinished, lstat, runtime_args, init, NewSyscallError, IsNotExist, underlyingError, wrapSyscallError, isNotExist, sigpipe, syscallMode, NewFile, newFile, epipecheck, basename, init$1, fillFileStatFromSys, timespecToTime, Lstat;
	errors = $packages["errors"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	poll = $packages["internal/poll"];
	io = $packages["io"];
	runtime = $packages["runtime"];
	sync = $packages["sync"];
	atomic = $packages["sync/atomic"];
	syscall = $packages["syscall"];
	time = $packages["time"];
	PathError = $pkg.PathError = $newType(0, $kindStruct, "os.PathError", true, "os", true, function(Op_, Path_, Err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Op = "";
			this.Path = "";
			this.Err = $ifaceNil;
			return;
		}
		this.Op = Op_;
		this.Path = Path_;
		this.Err = Err_;
	});
	SyscallError = $pkg.SyscallError = $newType(0, $kindStruct, "os.SyscallError", true, "os", true, function(Syscall_, Err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Syscall = "";
			this.Err = $ifaceNil;
			return;
		}
		this.Syscall = Syscall_;
		this.Err = Err_;
	});
	LinkError = $pkg.LinkError = $newType(0, $kindStruct, "os.LinkError", true, "os", true, function(Op_, Old_, New_, Err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Op = "";
			this.Old = "";
			this.New = "";
			this.Err = $ifaceNil;
			return;
		}
		this.Op = Op_;
		this.Old = Old_;
		this.New = New_;
		this.Err = Err_;
	});
	file = $pkg.file = $newType(0, $kindStruct, "os.file", true, "os", false, function(pfd_, name_, dirinfo_, nonblock_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.pfd = new poll.FD.ptr(new poll.fdMutex.ptr(new $Uint64(0, 0), 0, 0), 0, new poll.pollDesc.ptr(false), ptrType$12.nil, false, false, false);
			this.name = "";
			this.dirinfo = ptrType$1.nil;
			this.nonblock = false;
			return;
		}
		this.pfd = pfd_;
		this.name = name_;
		this.dirinfo = dirinfo_;
		this.nonblock = nonblock_;
	});
	dirInfo = $pkg.dirInfo = $newType(0, $kindStruct, "os.dirInfo", true, "os", false, function(buf_, nbuf_, bufp_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = sliceType$2.nil;
			this.nbuf = 0;
			this.bufp = 0;
			return;
		}
		this.buf = buf_;
		this.nbuf = nbuf_;
		this.bufp = bufp_;
	});
	File = $pkg.File = $newType(0, $kindStruct, "os.File", true, "os", true, function(file_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.file = ptrType$13.nil;
			return;
		}
		this.file = file_;
	});
	FileInfo = $pkg.FileInfo = $newType(8, $kindInterface, "os.FileInfo", true, "os", true, null);
	FileMode = $pkg.FileMode = $newType(4, $kindUint32, "os.FileMode", true, "os", true, null);
	fileStat = $pkg.fileStat = $newType(0, $kindStruct, "os.fileStat", true, "os", false, function(name_, size_, mode_, modTime_, sys_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = "";
			this.size = new $Int64(0, 0);
			this.mode = 0;
			this.modTime = new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$15.nil);
			this.sys = new syscall.Stat_t.ptr(new $Uint64(0, 0), new $Uint64(0, 0), new $Uint64(0, 0), 0, 0, 0, 0, new $Uint64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), arrayType$2.zero());
			return;
		}
		this.name = name_;
		this.size = size_;
		this.mode = mode_;
		this.modTime = modTime_;
		this.sys = sys_;
	});
	sliceType = $sliceType($String);
	ptrType = $ptrType(File);
	sliceType$1 = $sliceType(FileInfo);
	ptrType$1 = $ptrType(dirInfo);
	sliceType$2 = $sliceType($Uint8);
	ptrType$2 = $ptrType(PathError);
	ptrType$3 = $ptrType(LinkError);
	ptrType$4 = $ptrType(SyscallError);
	sliceType$5 = $sliceType(syscall.Iovec);
	ptrType$12 = $ptrType(sliceType$5);
	ptrType$13 = $ptrType(file);
	funcType$1 = $funcType([ptrType$13], [$error], false);
	ptrType$15 = $ptrType(time.Location);
	arrayType$2 = $arrayType($Int64, 3);
	arrayType$5 = $arrayType($Uint8, 32);
	ptrType$16 = $ptrType(fileStat);
	runtime_args = function() {
		return $pkg.Args;
	};
	init = function() {
		var argv, i, process;
		process = $global.process;
		if (!(process === undefined)) {
			argv = process.argv;
			$pkg.Args = $makeSlice(sliceType, ($parseInt(argv.length) - 1 >> 0));
			i = 0;
			while (true) {
				if (!(i < ($parseInt(argv.length) - 1 >> 0))) { break; }
				((i < 0 || i >= $pkg.Args.$length) ? ($throwRuntimeError("index out of range"), undefined) : $pkg.Args.$array[$pkg.Args.$offset + i] = $internalize(argv[(i + 1 >> 0)], $String));
				i = i + (1) >> 0;
			}
		}
		if ($pkg.Args.$length === 0) {
			$pkg.Args = new sliceType(["?"]);
		}
	};
	File.ptr.prototype.Readdir = function(n) {
		var _r, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		if (f === ptrType.nil) {
			$s = -1; return [sliceType$1.nil, $pkg.ErrInvalid];
		}
		_r = f.readdir(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Readdir }; } $f._r = _r; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Readdir = function(n) { return this.$val.Readdir(n); };
	File.ptr.prototype.Readdirnames = function(n) {
		var _r, _tmp, _tmp$1, _tuple, err, f, n, names, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; err = $f.err; f = $f.f; n = $f.n; names = $f.names; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		names = sliceType.nil;
		err = $ifaceNil;
		f = this;
		if (f === ptrType.nil) {
			_tmp = sliceType.nil;
			_tmp$1 = $pkg.ErrInvalid;
			names = _tmp;
			err = _tmp$1;
			$s = -1; return [names, err];
		}
		_r = f.readdirnames(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		names = _tuple[0];
		err = _tuple[1];
		$s = -1; return [names, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Readdirnames }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.err = err; $f.f = f; $f.n = n; $f.names = names; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Readdirnames = function(n) { return this.$val.Readdirnames(n); };
	File.ptr.prototype.readdir = function(n) {
		var _i, _r, _r$1, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _tuple$1, dirname, err, f, fi, filename, fip, lerr, n, names, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; dirname = $f.dirname; err = $f.err; f = $f.f; fi = $f.fi; filename = $f.filename; fip = $f.fip; lerr = $f.lerr; n = $f.n; names = $f.names; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fi = sliceType$1.nil;
		err = $ifaceNil;
		f = this;
		dirname = f.file.name;
		if (dirname === "") {
			dirname = ".";
		}
		_r = f.Readdirnames(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		names = _tuple[0];
		err = _tuple[1];
		fi = $makeSlice(sliceType$1, 0, names.$length);
		_ref = names;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			filename = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r$1 = lstat(dirname + "/" + filename); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			fip = _tuple$1[0];
			lerr = _tuple$1[1];
			if (IsNotExist(lerr)) {
				_i++;
				/* continue; */ $s = 2; continue;
			}
			if (!($interfaceIsEqual(lerr, $ifaceNil))) {
				_tmp = fi;
				_tmp$1 = lerr;
				fi = _tmp;
				err = _tmp$1;
				$s = -1; return [fi, err];
			}
			fi = $append(fi, fip);
			_i++;
		/* } */ $s = 2; continue; case 3:
		if ((fi.$length === 0) && $interfaceIsEqual(err, $ifaceNil) && n > 0) {
			err = io.EOF;
		}
		_tmp$2 = fi;
		_tmp$3 = err;
		fi = _tmp$2;
		err = _tmp$3;
		$s = -1; return [fi, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.readdir }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.dirname = dirname; $f.err = err; $f.f = f; $f.fi = fi; $f.filename = filename; $f.fip = fip; $f.lerr = lerr; $f.n = n; $f.names = names; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.readdir = function(n) { return this.$val.readdir(n); };
	File.ptr.prototype.readdirnames = function(n) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, d, err, errno, f, n, names, nb, nc, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; d = $f.d; err = $f.err; errno = $f.errno; f = $f.f; n = $f.n; names = $f.names; nb = $f.nb; nc = $f.nc; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		names = sliceType.nil;
		err = $ifaceNil;
		f = this;
		if (f.file.dirinfo === ptrType$1.nil) {
			f.file.dirinfo = new dirInfo.ptr(sliceType$2.nil, 0, 0);
			f.file.dirinfo.buf = $makeSlice(sliceType$2, 4096);
		}
		d = f.file.dirinfo;
		size = n;
		if (size <= 0) {
			size = 100;
			n = -1;
		}
		names = $makeSlice(sliceType, 0, size);
		/* while (true) { */ case 1:
			/* if (!(!((n === 0)))) { break; } */ if(!(!((n === 0)))) { $s = 2; continue; }
			/* */ if (d.bufp >= d.nbuf) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (d.bufp >= d.nbuf) { */ case 3:
				d.bufp = 0;
				errno = $ifaceNil;
				_r = f.file.pfd.ReadDirent(d.buf); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				d.nbuf = _tuple[0];
				errno = _tuple[1];
				runtime.KeepAlive(f);
				if (!($interfaceIsEqual(errno, $ifaceNil))) {
					_tmp = names;
					_tmp$1 = wrapSyscallError("readdirent", errno);
					names = _tmp;
					err = _tmp$1;
					$s = -1; return [names, err];
				}
				if (d.nbuf <= 0) {
					/* break; */ $s = 2; continue;
				}
			/* } */ case 4:
			_tmp$2 = 0;
			_tmp$3 = 0;
			nb = _tmp$2;
			nc = _tmp$3;
			_tuple$1 = syscall.ParseDirent($subslice(d.buf, d.bufp, d.nbuf), n, names);
			nb = _tuple$1[0];
			nc = _tuple$1[1];
			names = _tuple$1[2];
			d.bufp = d.bufp + (nb) >> 0;
			n = n - (nc) >> 0;
		/* } */ $s = 1; continue; case 2:
		if (n >= 0 && (names.$length === 0)) {
			_tmp$4 = names;
			_tmp$5 = io.EOF;
			names = _tmp$4;
			err = _tmp$5;
			$s = -1; return [names, err];
		}
		_tmp$6 = names;
		_tmp$7 = $ifaceNil;
		names = _tmp$6;
		err = _tmp$7;
		$s = -1; return [names, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.readdirnames }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.d = d; $f.err = err; $f.errno = errno; $f.f = f; $f.n = n; $f.names = names; $f.nb = nb; $f.nc = nc; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.readdirnames = function(n) { return this.$val.readdirnames(n); };
	PathError.ptr.prototype.Error = function() {
		var _r, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return e.Op + " " + e.Path + ": " + _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: PathError.ptr.prototype.Error }; } $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	PathError.prototype.Error = function() { return this.$val.Error(); };
	SyscallError.ptr.prototype.Error = function() {
		var _r, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return e.Syscall + ": " + _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: SyscallError.ptr.prototype.Error }; } $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	SyscallError.prototype.Error = function() { return this.$val.Error(); };
	NewSyscallError = function(syscall$1, err) {
		var err, syscall$1;
		if ($interfaceIsEqual(err, $ifaceNil)) {
			return $ifaceNil;
		}
		return new SyscallError.ptr(syscall$1, err);
	};
	$pkg.NewSyscallError = NewSyscallError;
	IsNotExist = function(err) {
		var err;
		return isNotExist(err);
	};
	$pkg.IsNotExist = IsNotExist;
	underlyingError = function(err) {
		var _ref, err, err$1, err$2, err$3;
		_ref = err;
		if ($assertType(_ref, ptrType$2, true)[1]) {
			err$1 = _ref.$val;
			return err$1.Err;
		} else if ($assertType(_ref, ptrType$3, true)[1]) {
			err$2 = _ref.$val;
			return err$2.Err;
		} else if ($assertType(_ref, ptrType$4, true)[1]) {
			err$3 = _ref.$val;
			return err$3.Err;
		}
		return err;
	};
	wrapSyscallError = function(name, err) {
		var _tuple, err, name, ok;
		_tuple = $assertType(err, syscall.Errno, true);
		ok = _tuple[1];
		if (ok) {
			err = NewSyscallError(name, err);
		}
		return err;
	};
	isNotExist = function(err) {
		var err;
		err = underlyingError(err);
		return $interfaceIsEqual(err, new syscall.Errno(2)) || $interfaceIsEqual(err, $pkg.ErrNotExist);
	};
	File.ptr.prototype.Name = function() {
		var f;
		f = this;
		return f.file.name;
	};
	File.prototype.Name = function() { return this.$val.Name(); };
	LinkError.ptr.prototype.Error = function() {
		var _r, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return e.Op + " " + e.Old + " " + e.New + ": " + _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: LinkError.ptr.prototype.Error }; } $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	LinkError.prototype.Error = function() { return this.$val.Error(); };
	File.ptr.prototype.Read = function(b) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, err$1, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; err$1 = $f.err$1; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		err$1 = f.checkValid("read");
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			_tmp = 0;
			_tmp$1 = err$1;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		_r = f.read(b); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		e = _tuple[1];
		_tmp$2 = n;
		_tmp$3 = f.wrapErr("read", e);
		n = _tmp$2;
		err = _tmp$3;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Read }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Read = function(b) { return this.$val.Read(b); };
	File.ptr.prototype.ReadAt = function(b, off) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, err$1, f, m, n, off, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; err$1 = $f.err$1; f = $f.f; m = $f.m; n = $f.n; off = $f.off; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		err$1 = f.checkValid("read");
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			_tmp = 0;
			_tmp$1 = err$1;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		if ((off.$high < 0 || (off.$high === 0 && off.$low < 0))) {
			_tmp$2 = 0;
			_tmp$3 = new PathError.ptr("readat", f.file.name, errors.New("negative offset"));
			n = _tmp$2;
			err = _tmp$3;
			$s = -1; return [n, err];
		}
		/* while (true) { */ case 1:
			/* if (!(b.$length > 0)) { break; } */ if(!(b.$length > 0)) { $s = 2; continue; }
			_r = f.pread(b, off); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				err = f.wrapErr("read", e);
				/* break; */ $s = 2; continue;
			}
			n = n + (m) >> 0;
			b = $subslice(b, m);
			off = (x = (new $Int64(0, m)), new $Int64(off.$high + x.$high, off.$low + x.$low));
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.ReadAt }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.m = m; $f.n = n; $f.off = off; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.ReadAt = function(b, off) { return this.$val.ReadAt(b, off); };
	File.ptr.prototype.Write = function(b) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, err$1, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; err$1 = $f.err$1; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		err$1 = f.checkValid("write");
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			_tmp = 0;
			_tmp$1 = err$1;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		_r = f.write(b); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		e = _tuple[1];
		if (n < 0) {
			n = 0;
		}
		if (!((n === b.$length))) {
			err = io.ErrShortWrite;
		}
		epipecheck(f, e);
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			err = f.wrapErr("write", e);
		}
		_tmp$2 = n;
		_tmp$3 = err;
		n = _tmp$2;
		err = _tmp$3;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Write }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Write = function(b) { return this.$val.Write(b); };
	File.ptr.prototype.WriteAt = function(b, off) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, err$1, f, m, n, off, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; err$1 = $f.err$1; f = $f.f; m = $f.m; n = $f.n; off = $f.off; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		err$1 = f.checkValid("write");
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			_tmp = 0;
			_tmp$1 = err$1;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		if ((off.$high < 0 || (off.$high === 0 && off.$low < 0))) {
			_tmp$2 = 0;
			_tmp$3 = new PathError.ptr("writeat", f.file.name, errors.New("negative offset"));
			n = _tmp$2;
			err = _tmp$3;
			$s = -1; return [n, err];
		}
		/* while (true) { */ case 1:
			/* if (!(b.$length > 0)) { break; } */ if(!(b.$length > 0)) { $s = 2; continue; }
			_r = f.pwrite(b, off); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				err = f.wrapErr("write", e);
				/* break; */ $s = 2; continue;
			}
			n = n + (m) >> 0;
			b = $subslice(b, m);
			off = (x = (new $Int64(0, m)), new $Int64(off.$high + x.$high, off.$low + x.$low));
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.WriteAt }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.m = m; $f.n = n; $f.off = off; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.WriteAt = function(b, off) { return this.$val.WriteAt(b, off); };
	File.ptr.prototype.Seek = function(offset, whence) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, e, err, err$1, f, offset, r, ret, whence, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; e = $f.e; err = $f.err; err$1 = $f.err$1; f = $f.f; offset = $f.offset; r = $f.r; ret = $f.ret; whence = $f.whence; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = new $Int64(0, 0);
		err = $ifaceNil;
		f = this;
		err$1 = f.checkValid("seek");
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			_tmp = new $Int64(0, 0);
			_tmp$1 = err$1;
			ret = _tmp;
			err = _tmp$1;
			$s = -1; return [ret, err];
		}
		_r = f.seek(offset, whence); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		e = _tuple[1];
		if ($interfaceIsEqual(e, $ifaceNil) && !(f.file.dirinfo === ptrType$1.nil) && !((r.$high === 0 && r.$low === 0))) {
			e = new syscall.Errno(21);
		}
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			_tmp$2 = new $Int64(0, 0);
			_tmp$3 = f.wrapErr("seek", e);
			ret = _tmp$2;
			err = _tmp$3;
			$s = -1; return [ret, err];
		}
		_tmp$4 = r;
		_tmp$5 = $ifaceNil;
		ret = _tmp$4;
		err = _tmp$5;
		$s = -1; return [ret, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Seek }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.e = e; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.offset = offset; $f.r = r; $f.ret = ret; $f.whence = whence; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Seek = function(offset, whence) { return this.$val.Seek(offset, whence); };
	File.ptr.prototype.WriteString = function(s) {
		var _r, _tuple, err, f, n, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; f = $f.f; n = $f.n; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		_r = f.Write((new sliceType$2($stringToBytes(s)))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.WriteString }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.f = f; $f.n = n; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	File.ptr.prototype.wrapErr = function(op, err) {
		var err, f, op;
		f = this;
		if ($interfaceIsEqual(err, $ifaceNil) || $interfaceIsEqual(err, io.EOF)) {
			return err;
		}
		if ($interfaceIsEqual(err, poll.ErrFileClosing)) {
			err = $pkg.ErrClosed;
		}
		return new PathError.ptr(op, f.file.name, err);
	};
	File.prototype.wrapErr = function(op, err) { return this.$val.wrapErr(op, err); };
	File.ptr.prototype.Chmod = function(mode) {
		var _r, f, mode, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; mode = $f.mode; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		_r = f.chmod(mode); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Chmod }; } $f._r = _r; $f.f = f; $f.mode = mode; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Chmod = function(mode) { return this.$val.Chmod(mode); };
	sigpipe = function() {
		$throwRuntimeError("native function not implemented: os.sigpipe");
	};
	syscallMode = function(i) {
		var i, o;
		o = 0;
		o = (o | (((new FileMode(i).Perm() >>> 0)))) >>> 0;
		if (!((((i & 8388608) >>> 0) === 0))) {
			o = (o | (2048)) >>> 0;
		}
		if (!((((i & 4194304) >>> 0) === 0))) {
			o = (o | (1024)) >>> 0;
		}
		if (!((((i & 1048576) >>> 0) === 0))) {
			o = (o | (512)) >>> 0;
		}
		return o;
	};
	File.ptr.prototype.chmod = function(mode) {
		var _r, e, err, f, mode, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; f = $f.f; mode = $f.mode; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		err = f.checkValid("chmod");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = f.file.pfd.Fchmod(syscallMode(mode)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			$s = -1; return f.wrapErr("chmod", e);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.chmod }; } $f._r = _r; $f.e = e; $f.err = err; $f.f = f; $f.mode = mode; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.chmod = function(mode) { return this.$val.chmod(mode); };
	File.ptr.prototype.Chown = function(uid, gid) {
		var _r, e, err, f, gid, uid, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; f = $f.f; gid = $f.gid; uid = $f.uid; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		err = f.checkValid("chown");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = f.file.pfd.Fchown(uid, gid); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			$s = -1; return f.wrapErr("chown", e);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Chown }; } $f._r = _r; $f.e = e; $f.err = err; $f.f = f; $f.gid = gid; $f.uid = uid; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Chown = function(uid, gid) { return this.$val.Chown(uid, gid); };
	File.ptr.prototype.Truncate = function(size) {
		var _r, e, err, f, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; f = $f.f; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		err = f.checkValid("truncate");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = f.file.pfd.Ftruncate(size); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			$s = -1; return f.wrapErr("truncate", e);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Truncate }; } $f._r = _r; $f.e = e; $f.err = err; $f.f = f; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Truncate = function(size) { return this.$val.Truncate(size); };
	File.ptr.prototype.Sync = function() {
		var _r, e, err, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		err = f.checkValid("sync");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = f.file.pfd.Fsync(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			$s = -1; return f.wrapErr("sync", e);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Sync }; } $f._r = _r; $f.e = e; $f.err = err; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Sync = function() { return this.$val.Sync(); };
	File.ptr.prototype.Chdir = function() {
		var _r, e, err, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		err = f.checkValid("chdir");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = f.file.pfd.Fchdir(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			$s = -1; return f.wrapErr("chdir", e);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Chdir }; } $f._r = _r; $f.e = e; $f.err = err; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Chdir = function() { return this.$val.Chdir(); };
	File.ptr.prototype.checkValid = function(op) {
		var f, op;
		f = this;
		if (f === ptrType.nil) {
			return $pkg.ErrInvalid;
		}
		return $ifaceNil;
	};
	File.prototype.checkValid = function(op) { return this.$val.checkValid(op); };
	File.ptr.prototype.Fd = function() {
		var f;
		f = this;
		if (f === ptrType.nil) {
			return 4294967295;
		}
		if (f.file.nonblock) {
			syscall.SetNonblock(f.file.pfd.Sysfd, false);
		}
		return ((f.file.pfd.Sysfd >>> 0));
	};
	File.prototype.Fd = function() { return this.$val.Fd(); };
	NewFile = function(fd, name) {
		var fd, name;
		return newFile(fd, name, false);
	};
	$pkg.NewFile = NewFile;
	newFile = function(fd, name, pollable) {
		var err, err$1, f, fd, fdi, name, pollable;
		fdi = ((fd >> 0));
		if (fdi < 0) {
			return ptrType.nil;
		}
		f = new File.ptr(new file.ptr(new poll.FD.ptr(new poll.fdMutex.ptr(new $Uint64(0, 0), 0, 0), fdi, new poll.pollDesc.ptr(false), ptrType$12.nil, true, true, false), name, ptrType$1.nil, false));
		if (false) {
			pollable = false;
		}
		err = f.file.pfd.Init("file", pollable);
		if (!($interfaceIsEqual(err, $ifaceNil))) {
		} else if (pollable) {
			err$1 = syscall.SetNonblock(fdi, true);
			if ($interfaceIsEqual(err$1, $ifaceNil)) {
				f.file.nonblock = true;
			}
		}
		runtime.SetFinalizer(f.file, new funcType$1($methodExpr(ptrType$13, "close")));
		return f;
	};
	epipecheck = function(file$1, e) {
		var e, file$1;
		if ($interfaceIsEqual(e, new syscall.Errno(32)) && ((file$1.file.pfd.Sysfd === 1) || (file$1.file.pfd.Sysfd === 2))) {
			sigpipe();
		}
	};
	File.ptr.prototype.Close = function() {
		var _r, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		if (f === ptrType.nil) {
			$s = -1; return $pkg.ErrInvalid;
		}
		_r = f.file.close(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Close }; } $f._r = _r; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Close = function() { return this.$val.Close(); };
	file.ptr.prototype.close = function() {
		var _r, e, err, file$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; file$1 = $f.file$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		file$1 = this;
		if (file$1 === ptrType$13.nil) {
			$s = -1; return new syscall.Errno(22);
		}
		err = $ifaceNil;
		_r = file$1.pfd.Close(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			if ($interfaceIsEqual(e, poll.ErrFileClosing)) {
				e = $pkg.ErrClosed;
			}
			err = new PathError.ptr("close", file$1.name, e);
		}
		runtime.SetFinalizer(file$1, $ifaceNil);
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: file.ptr.prototype.close }; } $f._r = _r; $f.e = e; $f.err = err; $f.file$1 = file$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	file.prototype.close = function() { return this.$val.close(); };
	File.ptr.prototype.read = function(b) {
		var _r, _tmp, _tmp$1, _tuple, b, err, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; err = $f.err; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		_r = f.file.pfd.Read(b); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		runtime.KeepAlive(f);
		_tmp = n;
		_tmp$1 = err;
		n = _tmp;
		err = _tmp$1;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.read }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.read = function(b) { return this.$val.read(b); };
	File.ptr.prototype.pread = function(b, off) {
		var _r, _tmp, _tmp$1, _tuple, b, err, f, n, off, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; err = $f.err; f = $f.f; n = $f.n; off = $f.off; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		_r = f.file.pfd.Pread(b, off); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		runtime.KeepAlive(f);
		_tmp = n;
		_tmp$1 = err;
		n = _tmp;
		err = _tmp$1;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.pread }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.f = f; $f.n = n; $f.off = off; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.pread = function(b, off) { return this.$val.pread(b, off); };
	File.ptr.prototype.write = function(b) {
		var _r, _tmp, _tmp$1, _tuple, b, err, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; err = $f.err; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		_r = f.file.pfd.Write(b); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		runtime.KeepAlive(f);
		_tmp = n;
		_tmp$1 = err;
		n = _tmp;
		err = _tmp$1;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.write }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.write = function(b) { return this.$val.write(b); };
	File.ptr.prototype.pwrite = function(b, off) {
		var _r, _tmp, _tmp$1, _tuple, b, err, f, n, off, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; err = $f.err; f = $f.f; n = $f.n; off = $f.off; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		_r = f.file.pfd.Pwrite(b, off); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		runtime.KeepAlive(f);
		_tmp = n;
		_tmp$1 = err;
		n = _tmp;
		err = _tmp$1;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.pwrite }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.f = f; $f.n = n; $f.off = off; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.pwrite = function(b, off) { return this.$val.pwrite(b, off); };
	File.ptr.prototype.seek = function(offset, whence) {
		var _r, _tmp, _tmp$1, _tuple, err, f, offset, ret, whence, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; err = $f.err; f = $f.f; offset = $f.offset; ret = $f.ret; whence = $f.whence; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = new $Int64(0, 0);
		err = $ifaceNil;
		f = this;
		_r = f.file.pfd.Seek(offset, whence); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		ret = _tuple[0];
		err = _tuple[1];
		runtime.KeepAlive(f);
		_tmp = ret;
		_tmp$1 = err;
		ret = _tmp;
		err = _tmp$1;
		$s = -1; return [ret, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.seek }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.err = err; $f.f = f; $f.offset = offset; $f.ret = ret; $f.whence = whence; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.seek = function(offset, whence) { return this.$val.seek(offset, whence); };
	basename = function(name) {
		var i, name;
		i = name.length - 1 >> 0;
		while (true) {
			if (!(i > 0 && (name.charCodeAt(i) === 47))) { break; }
			name = $substring(name, 0, i);
			i = i - (1) >> 0;
		}
		i = i - (1) >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			if (name.charCodeAt(i) === 47) {
				name = $substring(name, (i + 1 >> 0));
				break;
			}
			i = i - (1) >> 0;
		}
		return name;
	};
	init$1 = function() {
		if (false) {
			return;
		}
		$pkg.Args = runtime_args();
	};
	fillFileStatFromSys = function(fs, name) {
		var _1, fs, name;
		fs.name = basename(name);
		fs.size = fs.sys.Size;
		time.Time.copy(fs.modTime, timespecToTime($clone(fs.sys.Mtim, syscall.Timespec)));
		fs.mode = ((((fs.sys.Mode & 511) >>> 0) >>> 0));
		_1 = (fs.sys.Mode & 61440) >>> 0;
		if (_1 === (24576)) {
			fs.mode = (fs.mode | (67108864)) >>> 0;
		} else if (_1 === (8192)) {
			fs.mode = (fs.mode | (69206016)) >>> 0;
		} else if (_1 === (16384)) {
			fs.mode = (fs.mode | (2147483648)) >>> 0;
		} else if (_1 === (4096)) {
			fs.mode = (fs.mode | (33554432)) >>> 0;
		} else if (_1 === (40960)) {
			fs.mode = (fs.mode | (134217728)) >>> 0;
		} else if (_1 === (32768)) {
		} else if (_1 === (49152)) {
			fs.mode = (fs.mode | (16777216)) >>> 0;
		}
		if (!((((fs.sys.Mode & 1024) >>> 0) === 0))) {
			fs.mode = (fs.mode | (4194304)) >>> 0;
		}
		if (!((((fs.sys.Mode & 2048) >>> 0) === 0))) {
			fs.mode = (fs.mode | (8388608)) >>> 0;
		}
		if (!((((fs.sys.Mode & 512) >>> 0) === 0))) {
			fs.mode = (fs.mode | (1048576)) >>> 0;
		}
	};
	timespecToTime = function(ts) {
		var ts;
		return time.Unix((ts.Sec), (ts.Nsec));
	};
	File.ptr.prototype.Stat = function() {
		var _r, err, f, fs, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; f = $f.f; fs = $f.fs; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fs = [fs];
		f = this;
		if (f === ptrType.nil) {
			$s = -1; return [$ifaceNil, $pkg.ErrInvalid];
		}
		fs[0] = new fileStat.ptr("", new $Int64(0, 0), 0, new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$15.nil), new syscall.Stat_t.ptr(new $Uint64(0, 0), new $Uint64(0, 0), new $Uint64(0, 0), 0, 0, 0, 0, new $Uint64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), arrayType$2.zero()));
		_r = f.file.pfd.Fstat(fs[0].sys); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [$ifaceNil, new PathError.ptr("stat", f.file.name, err)];
		}
		fillFileStatFromSys(fs[0], f.file.name);
		$s = -1; return [fs[0], $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Stat }; } $f._r = _r; $f.err = err; $f.f = f; $f.fs = fs; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Stat = function() { return this.$val.Stat(); };
	Lstat = function(name) {
		var err, fs, name;
		fs = new fileStat.ptr("", new $Int64(0, 0), 0, new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$15.nil), new syscall.Stat_t.ptr(new $Uint64(0, 0), new $Uint64(0, 0), new $Uint64(0, 0), 0, 0, 0, 0, new $Uint64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), arrayType$2.zero()));
		err = syscall.Lstat(name, fs.sys);
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [$ifaceNil, new PathError.ptr("lstat", name, err)];
		}
		fillFileStatFromSys(fs, name);
		return [fs, $ifaceNil];
	};
	$pkg.Lstat = Lstat;
	FileMode.prototype.String = function() {
		var _i, _i$1, _ref, _ref$1, _rune, _rune$1, buf, c, c$1, i, i$1, m, w, y, y$1;
		m = this.$val;
		buf = arrayType$5.zero();
		w = 0;
		_ref = "dalTLDpSugct";
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			i = _i;
			c = _rune[0];
			if (!((((m & (((y = (((31 - i >> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0) === 0))) {
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = ((c << 24 >>> 24)));
				w = w + (1) >> 0;
			}
			_i += _rune[1];
		}
		if (w === 0) {
			((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 45);
			w = w + (1) >> 0;
		}
		_ref$1 = "rwxrwxrwx";
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.length)) { break; }
			_rune$1 = $decodeRune(_ref$1, _i$1);
			i$1 = _i$1;
			c$1 = _rune$1[0];
			if (!((((m & (((y$1 = (((8 - i$1 >> 0) >>> 0)), y$1 < 32 ? (1 << y$1) : 0) >>> 0))) >>> 0) === 0))) {
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = ((c$1 << 24 >>> 24)));
			} else {
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 45);
			}
			w = w + (1) >> 0;
			_i$1 += _rune$1[1];
		}
		return ($bytesToString($subslice(new sliceType$2(buf), 0, w)));
	};
	$ptrType(FileMode).prototype.String = function() { return new FileMode(this.$get()).String(); };
	FileMode.prototype.IsDir = function() {
		var m;
		m = this.$val;
		return !((((m & 2147483648) >>> 0) === 0));
	};
	$ptrType(FileMode).prototype.IsDir = function() { return new FileMode(this.$get()).IsDir(); };
	FileMode.prototype.IsRegular = function() {
		var m;
		m = this.$val;
		return ((m & 2399141888) >>> 0) === 0;
	};
	$ptrType(FileMode).prototype.IsRegular = function() { return new FileMode(this.$get()).IsRegular(); };
	FileMode.prototype.Perm = function() {
		var m;
		m = this.$val;
		return (m & 511) >>> 0;
	};
	$ptrType(FileMode).prototype.Perm = function() { return new FileMode(this.$get()).Perm(); };
	fileStat.ptr.prototype.Name = function() {
		var fs;
		fs = this;
		return fs.name;
	};
	fileStat.prototype.Name = function() { return this.$val.Name(); };
	fileStat.ptr.prototype.IsDir = function() {
		var fs;
		fs = this;
		return new FileMode(fs.Mode()).IsDir();
	};
	fileStat.prototype.IsDir = function() { return this.$val.IsDir(); };
	fileStat.ptr.prototype.Size = function() {
		var fs;
		fs = this;
		return fs.size;
	};
	fileStat.prototype.Size = function() { return this.$val.Size(); };
	fileStat.ptr.prototype.Mode = function() {
		var fs;
		fs = this;
		return fs.mode;
	};
	fileStat.prototype.Mode = function() { return this.$val.Mode(); };
	fileStat.ptr.prototype.ModTime = function() {
		var fs;
		fs = this;
		return fs.modTime;
	};
	fileStat.prototype.ModTime = function() { return this.$val.ModTime(); };
	fileStat.ptr.prototype.Sys = function() {
		var fs;
		fs = this;
		return fs.sys;
	};
	fileStat.prototype.Sys = function() { return this.$val.Sys(); };
	ptrType$2.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$4.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$3.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$13.methods = [{prop: "close", name: "close", pkg: "os", typ: $funcType([], [$error], false)}];
	ptrType.methods = [{prop: "Readdir", name: "Readdir", pkg: "", typ: $funcType([$Int], [sliceType$1, $error], false)}, {prop: "Readdirnames", name: "Readdirnames", pkg: "", typ: $funcType([$Int], [sliceType, $error], false)}, {prop: "readdir", name: "readdir", pkg: "os", typ: $funcType([$Int], [sliceType$1, $error], false)}, {prop: "readdirnames", name: "readdirnames", pkg: "os", typ: $funcType([$Int], [sliceType, $error], false)}, {prop: "Name", name: "Name", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "ReadAt", name: "ReadAt", pkg: "", typ: $funcType([sliceType$2, $Int64], [$Int, $error], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "WriteAt", name: "WriteAt", pkg: "", typ: $funcType([sliceType$2, $Int64], [$Int, $error], false)}, {prop: "Seek", name: "Seek", pkg: "", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}, {prop: "wrapErr", name: "wrapErr", pkg: "os", typ: $funcType([$String, $error], [$error], false)}, {prop: "Chmod", name: "Chmod", pkg: "", typ: $funcType([FileMode], [$error], false)}, {prop: "chmod", name: "chmod", pkg: "os", typ: $funcType([FileMode], [$error], false)}, {prop: "Chown", name: "Chown", pkg: "", typ: $funcType([$Int, $Int], [$error], false)}, {prop: "Truncate", name: "Truncate", pkg: "", typ: $funcType([$Int64], [$error], false)}, {prop: "Sync", name: "Sync", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Chdir", name: "Chdir", pkg: "", typ: $funcType([], [$error], false)}, {prop: "checkValid", name: "checkValid", pkg: "os", typ: $funcType([$String], [$error], false)}, {prop: "Fd", name: "Fd", pkg: "", typ: $funcType([], [$Uintptr], false)}, {prop: "Close", name: "Close", pkg: "", typ: $funcType([], [$error], false)}, {prop: "read", name: "read", pkg: "os", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "pread", name: "pread", pkg: "os", typ: $funcType([sliceType$2, $Int64], [$Int, $error], false)}, {prop: "write", name: "write", pkg: "os", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "pwrite", name: "pwrite", pkg: "os", typ: $funcType([sliceType$2, $Int64], [$Int, $error], false)}, {prop: "seek", name: "seek", pkg: "os", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: "Stat", name: "Stat", pkg: "", typ: $funcType([], [FileInfo, $error], false)}];
	FileMode.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "IsDir", name: "IsDir", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "IsRegular", name: "IsRegular", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Perm", name: "Perm", pkg: "", typ: $funcType([], [FileMode], false)}];
	ptrType$16.methods = [{prop: "Name", name: "Name", pkg: "", typ: $funcType([], [$String], false)}, {prop: "IsDir", name: "IsDir", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Mode", name: "Mode", pkg: "", typ: $funcType([], [FileMode], false)}, {prop: "ModTime", name: "ModTime", pkg: "", typ: $funcType([], [time.Time], false)}, {prop: "Sys", name: "Sys", pkg: "", typ: $funcType([], [$emptyInterface], false)}];
	PathError.init("", [{prop: "Op", name: "Op", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Path", name: "Path", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Err", name: "Err", anonymous: false, exported: true, typ: $error, tag: ""}]);
	SyscallError.init("", [{prop: "Syscall", name: "Syscall", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Err", name: "Err", anonymous: false, exported: true, typ: $error, tag: ""}]);
	LinkError.init("", [{prop: "Op", name: "Op", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Old", name: "Old", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "New", name: "New", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Err", name: "Err", anonymous: false, exported: true, typ: $error, tag: ""}]);
	file.init("os", [{prop: "pfd", name: "pfd", anonymous: false, exported: false, typ: poll.FD, tag: ""}, {prop: "name", name: "name", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "dirinfo", name: "dirinfo", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "nonblock", name: "nonblock", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	dirInfo.init("os", [{prop: "buf", name: "buf", anonymous: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "nbuf", name: "nbuf", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "bufp", name: "bufp", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	File.init("os", [{prop: "file", name: "file", anonymous: true, exported: false, typ: ptrType$13, tag: ""}]);
	FileInfo.init([{prop: "IsDir", name: "IsDir", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "ModTime", name: "ModTime", pkg: "", typ: $funcType([], [time.Time], false)}, {prop: "Mode", name: "Mode", pkg: "", typ: $funcType([], [FileMode], false)}, {prop: "Name", name: "Name", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Sys", name: "Sys", pkg: "", typ: $funcType([], [$emptyInterface], false)}]);
	fileStat.init("os", [{prop: "name", name: "name", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "size", name: "size", anonymous: false, exported: false, typ: $Int64, tag: ""}, {prop: "mode", name: "mode", anonymous: false, exported: false, typ: FileMode, tag: ""}, {prop: "modTime", name: "modTime", anonymous: false, exported: false, typ: time.Time, tag: ""}, {prop: "sys", name: "sys", anonymous: false, exported: false, typ: syscall.Stat_t, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = poll.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = syscall.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = time.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.Args = sliceType.nil;
		$pkg.ErrInvalid = errors.New("invalid argument");
		$pkg.ErrPermission = errors.New("permission denied");
		$pkg.ErrExist = errors.New("file already exists");
		$pkg.ErrNotExist = errors.New("file does not exist");
		$pkg.ErrClosed = errors.New("file already closed");
		errFinished = errors.New("os: process already finished");
		$pkg.Stdin = NewFile(((syscall.Stdin >>> 0)), "/dev/stdin");
		$pkg.Stdout = NewFile(((syscall.Stdout >>> 0)), "/dev/stdout");
		$pkg.Stderr = NewFile(((syscall.Stderr >>> 0)), "/dev/stderr");
		lstat = Lstat;
		init();
		init$1();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["strconv"] = (function() {
	var $pkg = {}, $init, errors, math, utf8, NumError, decimal, leftCheat, extFloat, floatInfo, decimalSlice, sliceType, sliceType$1, sliceType$2, sliceType$3, sliceType$4, sliceType$5, arrayType, ptrType, sliceType$6, arrayType$1, arrayType$2, ptrType$1, arrayType$3, arrayType$4, ptrType$2, ptrType$3, ptrType$4, optimize, powtab, float64pow10, float32pow10, leftcheats, smallPowersOfTen, powersOfTen, uint64pow10, float32info, float32info$24ptr, float64info, float64info$24ptr, isPrint16, isNotPrint16, isPrint32, isNotPrint32, isGraphic, shifts, ParseBool, FormatBool, AppendBool, equalIgnoreCase, special, readFloat, atof64exact, atof32exact, atof32, atof64, ParseFloat, syntaxError, rangeError, ParseUint, ParseInt, Atoi, digitZero, trim, rightShift, prefixIsLessThan, leftShift, shouldRoundUp, frexp10Many, adjustLastDigitFixed, adjustLastDigit, FormatFloat, AppendFloat, genericFtoa, bigFtoa, formatDigits, roundShortest, fmtE, fmtF, fmtB, min, max, FormatUint, FormatInt, Itoa, AppendInt, AppendUint, small, formatBits, quoteWith, appendQuotedWith, appendQuotedRuneWith, appendEscapedRune, Quote, AppendQuote, QuoteToASCII, AppendQuoteToASCII, AppendQuoteRune, AppendQuoteRuneToASCII, CanBackquote, unhex, UnquoteChar, Unquote, contains, bsearch16, bsearch32, IsPrint, isInGraphicList;
	errors = $packages["errors"];
	math = $packages["math"];
	utf8 = $packages["unicode/utf8"];
	NumError = $pkg.NumError = $newType(0, $kindStruct, "strconv.NumError", true, "strconv", true, function(Func_, Num_, Err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Func = "";
			this.Num = "";
			this.Err = $ifaceNil;
			return;
		}
		this.Func = Func_;
		this.Num = Num_;
		this.Err = Err_;
	});
	decimal = $pkg.decimal = $newType(0, $kindStruct, "strconv.decimal", true, "strconv", false, function(d_, nd_, dp_, neg_, trunc_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.d = arrayType.zero();
			this.nd = 0;
			this.dp = 0;
			this.neg = false;
			this.trunc = false;
			return;
		}
		this.d = d_;
		this.nd = nd_;
		this.dp = dp_;
		this.neg = neg_;
		this.trunc = trunc_;
	});
	leftCheat = $pkg.leftCheat = $newType(0, $kindStruct, "strconv.leftCheat", true, "strconv", false, function(delta_, cutoff_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.delta = 0;
			this.cutoff = "";
			return;
		}
		this.delta = delta_;
		this.cutoff = cutoff_;
	});
	extFloat = $pkg.extFloat = $newType(0, $kindStruct, "strconv.extFloat", true, "strconv", false, function(mant_, exp_, neg_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.mant = new $Uint64(0, 0);
			this.exp = 0;
			this.neg = false;
			return;
		}
		this.mant = mant_;
		this.exp = exp_;
		this.neg = neg_;
	});
	floatInfo = $pkg.floatInfo = $newType(0, $kindStruct, "strconv.floatInfo", true, "strconv", false, function(mantbits_, expbits_, bias_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.mantbits = 0;
			this.expbits = 0;
			this.bias = 0;
			return;
		}
		this.mantbits = mantbits_;
		this.expbits = expbits_;
		this.bias = bias_;
	});
	decimalSlice = $pkg.decimalSlice = $newType(0, $kindStruct, "strconv.decimalSlice", true, "strconv", false, function(d_, nd_, dp_, neg_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.d = sliceType$6.nil;
			this.nd = 0;
			this.dp = 0;
			this.neg = false;
			return;
		}
		this.d = d_;
		this.nd = nd_;
		this.dp = dp_;
		this.neg = neg_;
	});
	sliceType = $sliceType($Int);
	sliceType$1 = $sliceType($Float64);
	sliceType$2 = $sliceType($Float32);
	sliceType$3 = $sliceType(leftCheat);
	sliceType$4 = $sliceType($Uint16);
	sliceType$5 = $sliceType($Uint32);
	arrayType = $arrayType($Uint8, 800);
	ptrType = $ptrType(NumError);
	sliceType$6 = $sliceType($Uint8);
	arrayType$1 = $arrayType($Uint8, 24);
	arrayType$2 = $arrayType($Uint8, 32);
	ptrType$1 = $ptrType(floatInfo);
	arrayType$3 = $arrayType($Uint8, 65);
	arrayType$4 = $arrayType($Uint8, 4);
	ptrType$2 = $ptrType(decimal);
	ptrType$3 = $ptrType(decimalSlice);
	ptrType$4 = $ptrType(extFloat);
	ParseBool = function(str) {
		var _1, str;
		_1 = str;
		if (_1 === ("1") || _1 === ("t") || _1 === ("T") || _1 === ("true") || _1 === ("TRUE") || _1 === ("True")) {
			return [true, $ifaceNil];
		} else if (_1 === ("0") || _1 === ("f") || _1 === ("F") || _1 === ("false") || _1 === ("FALSE") || _1 === ("False")) {
			return [false, $ifaceNil];
		}
		return [false, syntaxError("ParseBool", str)];
	};
	$pkg.ParseBool = ParseBool;
	FormatBool = function(b) {
		var b;
		if (b) {
			return "true";
		}
		return "false";
	};
	$pkg.FormatBool = FormatBool;
	AppendBool = function(dst, b) {
		var b, dst;
		if (b) {
			return $appendSlice(dst, "true");
		}
		return $appendSlice(dst, "false");
	};
	$pkg.AppendBool = AppendBool;
	equalIgnoreCase = function(s1, s2) {
		var c1, c2, i, s1, s2;
		if (!((s1.length === s2.length))) {
			return false;
		}
		i = 0;
		while (true) {
			if (!(i < s1.length)) { break; }
			c1 = s1.charCodeAt(i);
			if (65 <= c1 && c1 <= 90) {
				c1 = c1 + (32) << 24 >>> 24;
			}
			c2 = s2.charCodeAt(i);
			if (65 <= c2 && c2 <= 90) {
				c2 = c2 + (32) << 24 >>> 24;
			}
			if (!((c1 === c2))) {
				return false;
			}
			i = i + (1) >> 0;
		}
		return true;
	};
	special = function(s) {
		var _1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, f, ok, s;
		f = 0;
		ok = false;
		if (s.length === 0) {
			return [f, ok];
		}
		_1 = s.charCodeAt(0);
		if (_1 === (43)) {
			if (equalIgnoreCase(s, "+inf") || equalIgnoreCase(s, "+infinity")) {
				_tmp = math.Inf(1);
				_tmp$1 = true;
				f = _tmp;
				ok = _tmp$1;
				return [f, ok];
			}
		} else if (_1 === (45)) {
			if (equalIgnoreCase(s, "-inf") || equalIgnoreCase(s, "-infinity")) {
				_tmp$2 = math.Inf(-1);
				_tmp$3 = true;
				f = _tmp$2;
				ok = _tmp$3;
				return [f, ok];
			}
		} else if ((_1 === (110)) || (_1 === (78))) {
			if (equalIgnoreCase(s, "nan")) {
				_tmp$4 = math.NaN();
				_tmp$5 = true;
				f = _tmp$4;
				ok = _tmp$5;
				return [f, ok];
			}
		} else if ((_1 === (105)) || (_1 === (73))) {
			if (equalIgnoreCase(s, "inf") || equalIgnoreCase(s, "infinity")) {
				_tmp$6 = math.Inf(1);
				_tmp$7 = true;
				f = _tmp$6;
				ok = _tmp$7;
				return [f, ok];
			}
		} else {
			return [f, ok];
		}
		return [f, ok];
	};
	decimal.ptr.prototype.set = function(s) {
		var b, e, esign, i, ok, s, sawdigits, sawdot, x, x$1;
		ok = false;
		b = this;
		i = 0;
		b.neg = false;
		b.trunc = false;
		if (i >= s.length) {
			return ok;
		}
		if ((s.charCodeAt(i) === 43)) {
			i = i + (1) >> 0;
		} else if ((s.charCodeAt(i) === 45)) {
			b.neg = true;
			i = i + (1) >> 0;
		}
		sawdot = false;
		sawdigits = false;
		while (true) {
			if (!(i < s.length)) { break; }
			if ((s.charCodeAt(i) === 46)) {
				if (sawdot) {
					return ok;
				}
				sawdot = true;
				b.dp = b.nd;
				i = i + (1) >> 0;
				continue;
			} else if (48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) {
				sawdigits = true;
				if ((s.charCodeAt(i) === 48) && (b.nd === 0)) {
					b.dp = b.dp - (1) >> 0;
					i = i + (1) >> 0;
					continue;
				}
				if (b.nd < 800) {
					(x = b.d, x$1 = b.nd, ((x$1 < 0 || x$1 >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[x$1] = s.charCodeAt(i)));
					b.nd = b.nd + (1) >> 0;
				} else if (!((s.charCodeAt(i) === 48))) {
					b.trunc = true;
				}
				i = i + (1) >> 0;
				continue;
			}
			break;
		}
		if (!sawdigits) {
			return ok;
		}
		if (!sawdot) {
			b.dp = b.nd;
		}
		if (i < s.length && ((s.charCodeAt(i) === 101) || (s.charCodeAt(i) === 69))) {
			i = i + (1) >> 0;
			if (i >= s.length) {
				return ok;
			}
			esign = 1;
			if (s.charCodeAt(i) === 43) {
				i = i + (1) >> 0;
			} else if (s.charCodeAt(i) === 45) {
				i = i + (1) >> 0;
				esign = -1;
			}
			if (i >= s.length || s.charCodeAt(i) < 48 || s.charCodeAt(i) > 57) {
				return ok;
			}
			e = 0;
			while (true) {
				if (!(i < s.length && 48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57)) { break; }
				if (e < 10000) {
					e = (($imul(e, 10)) + ((s.charCodeAt(i) >> 0)) >> 0) - 48 >> 0;
				}
				i = i + (1) >> 0;
			}
			b.dp = b.dp + (($imul(e, esign))) >> 0;
		}
		if (!((i === s.length))) {
			return ok;
		}
		ok = true;
		return ok;
	};
	decimal.prototype.set = function(s) { return this.$val.set(s); };
	readFloat = function(s) {
		var _1, c, dp, e, esign, exp, i, mantissa, nd, ndMant, neg, ok, s, sawdigits, sawdot, trunc, x;
		mantissa = new $Uint64(0, 0);
		exp = 0;
		neg = false;
		trunc = false;
		ok = false;
		i = 0;
		if (i >= s.length) {
			return [mantissa, exp, neg, trunc, ok];
		}
		if ((s.charCodeAt(i) === 43)) {
			i = i + (1) >> 0;
		} else if ((s.charCodeAt(i) === 45)) {
			neg = true;
			i = i + (1) >> 0;
		}
		sawdot = false;
		sawdigits = false;
		nd = 0;
		ndMant = 0;
		dp = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			c = s.charCodeAt(i);
			_1 = true;
			if (_1 === ((c === 46))) {
				if (sawdot) {
					return [mantissa, exp, neg, trunc, ok];
				}
				sawdot = true;
				dp = nd;
				i = i + (1) >> 0;
				continue;
			} else if (_1 === (48 <= c && c <= 57)) {
				sawdigits = true;
				if ((c === 48) && (nd === 0)) {
					dp = dp - (1) >> 0;
					i = i + (1) >> 0;
					continue;
				}
				nd = nd + (1) >> 0;
				if (ndMant < 19) {
					mantissa = $mul64(mantissa, (new $Uint64(0, 10)));
					mantissa = (x = (new $Uint64(0, (c - 48 << 24 >>> 24))), new $Uint64(mantissa.$high + x.$high, mantissa.$low + x.$low));
					ndMant = ndMant + (1) >> 0;
				} else if (!((s.charCodeAt(i) === 48))) {
					trunc = true;
				}
				i = i + (1) >> 0;
				continue;
			}
			break;
		}
		if (!sawdigits) {
			return [mantissa, exp, neg, trunc, ok];
		}
		if (!sawdot) {
			dp = nd;
		}
		if (i < s.length && ((s.charCodeAt(i) === 101) || (s.charCodeAt(i) === 69))) {
			i = i + (1) >> 0;
			if (i >= s.length) {
				return [mantissa, exp, neg, trunc, ok];
			}
			esign = 1;
			if (s.charCodeAt(i) === 43) {
				i = i + (1) >> 0;
			} else if (s.charCodeAt(i) === 45) {
				i = i + (1) >> 0;
				esign = -1;
			}
			if (i >= s.length || s.charCodeAt(i) < 48 || s.charCodeAt(i) > 57) {
				return [mantissa, exp, neg, trunc, ok];
			}
			e = 0;
			while (true) {
				if (!(i < s.length && 48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57)) { break; }
				if (e < 10000) {
					e = (($imul(e, 10)) + ((s.charCodeAt(i) >> 0)) >> 0) - 48 >> 0;
				}
				i = i + (1) >> 0;
			}
			dp = dp + (($imul(e, esign))) >> 0;
		}
		if (!((i === s.length))) {
			return [mantissa, exp, neg, trunc, ok];
		}
		if (!((mantissa.$high === 0 && mantissa.$low === 0))) {
			exp = dp - ndMant >> 0;
		}
		ok = true;
		return [mantissa, exp, neg, trunc, ok];
	};
	decimal.ptr.prototype.floatBits = function(flt) {
		var _tmp, _tmp$1, b, bits, d, exp, flt, mant, n, n$1, n$2, overflow, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, y, y$1, y$2, y$3, $s;
		/* */ $s = 0; s: while (true) { switch ($s) { case 0:
		b = new $Uint64(0, 0);
		overflow = false;
		d = this;
		exp = 0;
		mant = new $Uint64(0, 0);
		/* */ if (d.nd === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (d.nd === 0) { */ case 1:
			mant = new $Uint64(0, 0);
			exp = flt.bias;
			/* goto out */ $s = 3; continue;
		/* } */ case 2:
		/* */ if (d.dp > 310) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (d.dp > 310) { */ case 4:
			/* goto overflow */ $s = 6; continue;
		/* } */ case 5:
		/* */ if (d.dp < -330) { $s = 7; continue; }
		/* */ $s = 8; continue;
		/* if (d.dp < -330) { */ case 7:
			mant = new $Uint64(0, 0);
			exp = flt.bias;
			/* goto out */ $s = 3; continue;
		/* } */ case 8:
		exp = 0;
		while (true) {
			if (!(d.dp > 0)) { break; }
			n = 0;
			if (d.dp >= powtab.$length) {
				n = 27;
			} else {
				n = (x = d.dp, ((x < 0 || x >= powtab.$length) ? ($throwRuntimeError("index out of range"), undefined) : powtab.$array[powtab.$offset + x]));
			}
			d.Shift(-n);
			exp = exp + (n) >> 0;
		}
		while (true) {
			if (!(d.dp < 0 || (d.dp === 0) && d.d[0] < 53)) { break; }
			n$1 = 0;
			if (-d.dp >= powtab.$length) {
				n$1 = 27;
			} else {
				n$1 = (x$1 = -d.dp, ((x$1 < 0 || x$1 >= powtab.$length) ? ($throwRuntimeError("index out of range"), undefined) : powtab.$array[powtab.$offset + x$1]));
			}
			d.Shift(n$1);
			exp = exp - (n$1) >> 0;
		}
		exp = exp - (1) >> 0;
		if (exp < (flt.bias + 1 >> 0)) {
			n$2 = (flt.bias + 1 >> 0) - exp >> 0;
			d.Shift(-n$2);
			exp = exp + (n$2) >> 0;
		}
		/* */ if ((exp - flt.bias >> 0) >= (((y = flt.expbits, y < 32 ? (1 << y) : 0) >> 0) - 1 >> 0)) { $s = 9; continue; }
		/* */ $s = 10; continue;
		/* if ((exp - flt.bias >> 0) >= (((y = flt.expbits, y < 32 ? (1 << y) : 0) >> 0) - 1 >> 0)) { */ case 9:
			/* goto overflow */ $s = 6; continue;
		/* } */ case 10:
		d.Shift((((1 + flt.mantbits >>> 0) >> 0)));
		mant = d.RoundedInteger();
		/* */ if ((x$2 = $shiftLeft64(new $Uint64(0, 2), flt.mantbits), (mant.$high === x$2.$high && mant.$low === x$2.$low))) { $s = 11; continue; }
		/* */ $s = 12; continue;
		/* if ((x$2 = $shiftLeft64(new $Uint64(0, 2), flt.mantbits), (mant.$high === x$2.$high && mant.$low === x$2.$low))) { */ case 11:
			mant = $shiftRightUint64(mant, (1));
			exp = exp + (1) >> 0;
			/* */ if ((exp - flt.bias >> 0) >= (((y$1 = flt.expbits, y$1 < 32 ? (1 << y$1) : 0) >> 0) - 1 >> 0)) { $s = 13; continue; }
			/* */ $s = 14; continue;
			/* if ((exp - flt.bias >> 0) >= (((y$1 = flt.expbits, y$1 < 32 ? (1 << y$1) : 0) >> 0) - 1 >> 0)) { */ case 13:
				/* goto overflow */ $s = 6; continue;
			/* } */ case 14:
		/* } */ case 12:
		if ((x$3 = (x$4 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), new $Uint64(mant.$high & x$4.$high, (mant.$low & x$4.$low) >>> 0)), (x$3.$high === 0 && x$3.$low === 0))) {
			exp = flt.bias;
		}
		/* goto out */ $s = 3; continue;
		/* overflow: */ case 6:
		mant = new $Uint64(0, 0);
		exp = (((y$2 = flt.expbits, y$2 < 32 ? (1 << y$2) : 0) >> 0) - 1 >> 0) + flt.bias >> 0;
		overflow = true;
		/* out: */ case 3:
		bits = (x$5 = (x$6 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), new $Uint64(x$6.$high - 0, x$6.$low - 1)), new $Uint64(mant.$high & x$5.$high, (mant.$low & x$5.$low) >>> 0));
		bits = (x$7 = $shiftLeft64((new $Uint64(0, (((exp - flt.bias >> 0)) & ((((y$3 = flt.expbits, y$3 < 32 ? (1 << y$3) : 0) >> 0) - 1 >> 0))))), flt.mantbits), new $Uint64(bits.$high | x$7.$high, (bits.$low | x$7.$low) >>> 0));
		if (d.neg) {
			bits = (x$8 = $shiftLeft64($shiftLeft64(new $Uint64(0, 1), flt.mantbits), flt.expbits), new $Uint64(bits.$high | x$8.$high, (bits.$low | x$8.$low) >>> 0));
		}
		_tmp = bits;
		_tmp$1 = overflow;
		b = _tmp;
		overflow = _tmp$1;
		$s = -1; return [b, overflow];
		/* */ } return; }
	};
	decimal.prototype.floatBits = function(flt) { return this.$val.floatBits(flt); };
	atof64exact = function(mantissa, exp, neg) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, exp, f, mantissa, neg, ok, x, x$1, x$2;
		f = 0;
		ok = false;
		if (!((x = $shiftRightUint64(mantissa, float64info.mantbits), (x.$high === 0 && x.$low === 0)))) {
			return [f, ok];
		}
		f = ($flatten64(mantissa));
		if (neg) {
			f = -f;
		}
		if ((exp === 0)) {
			_tmp = f;
			_tmp$1 = true;
			f = _tmp;
			ok = _tmp$1;
			return [f, ok];
		} else if (exp > 0 && exp <= 37) {
			if (exp > 22) {
				f = f * ((x$1 = exp - 22 >> 0, ((x$1 < 0 || x$1 >= float64pow10.$length) ? ($throwRuntimeError("index out of range"), undefined) : float64pow10.$array[float64pow10.$offset + x$1])));
				exp = 22;
			}
			if (f > 1e+15 || f < -1e+15) {
				return [f, ok];
			}
			_tmp$2 = f * ((exp < 0 || exp >= float64pow10.$length) ? ($throwRuntimeError("index out of range"), undefined) : float64pow10.$array[float64pow10.$offset + exp]);
			_tmp$3 = true;
			f = _tmp$2;
			ok = _tmp$3;
			return [f, ok];
		} else if (exp < 0 && exp >= -22) {
			_tmp$4 = f / (x$2 = -exp, ((x$2 < 0 || x$2 >= float64pow10.$length) ? ($throwRuntimeError("index out of range"), undefined) : float64pow10.$array[float64pow10.$offset + x$2]));
			_tmp$5 = true;
			f = _tmp$4;
			ok = _tmp$5;
			return [f, ok];
		}
		return [f, ok];
	};
	atof32exact = function(mantissa, exp, neg) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, exp, f, mantissa, neg, ok, x, x$1, x$2;
		f = 0;
		ok = false;
		if (!((x = $shiftRightUint64(mantissa, float32info.mantbits), (x.$high === 0 && x.$low === 0)))) {
			return [f, ok];
		}
		f = ($flatten64(mantissa));
		if (neg) {
			f = -f;
		}
		if ((exp === 0)) {
			_tmp = f;
			_tmp$1 = true;
			f = _tmp;
			ok = _tmp$1;
			return [f, ok];
		} else if (exp > 0 && exp <= 17) {
			if (exp > 10) {
				f = $fround(f * ((x$1 = exp - 10 >> 0, ((x$1 < 0 || x$1 >= float32pow10.$length) ? ($throwRuntimeError("index out of range"), undefined) : float32pow10.$array[float32pow10.$offset + x$1]))));
				exp = 10;
			}
			if (f > 1e+07 || f < -1e+07) {
				return [f, ok];
			}
			_tmp$2 = $fround(f * ((exp < 0 || exp >= float32pow10.$length) ? ($throwRuntimeError("index out of range"), undefined) : float32pow10.$array[float32pow10.$offset + exp]));
			_tmp$3 = true;
			f = _tmp$2;
			ok = _tmp$3;
			return [f, ok];
		} else if (exp < 0 && exp >= -10) {
			_tmp$4 = $fround(f / (x$2 = -exp, ((x$2 < 0 || x$2 >= float32pow10.$length) ? ($throwRuntimeError("index out of range"), undefined) : float32pow10.$array[float32pow10.$offset + x$2])));
			_tmp$5 = true;
			f = _tmp$4;
			ok = _tmp$5;
			return [f, ok];
		}
		return [f, ok];
	};
	atof32 = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, b, b$1, d, err, exp, ext, f, f$1, mantissa, neg, ok, ok$1, ok$2, ok$3, ovf, ovf$1, s, trunc, val;
		f = 0;
		err = $ifaceNil;
		_tuple = special(s);
		val = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			_tmp = ($fround(val));
			_tmp$1 = $ifaceNil;
			f = _tmp;
			err = _tmp$1;
			return [f, err];
		}
		if (optimize) {
			_tuple$1 = readFloat(s);
			mantissa = _tuple$1[0];
			exp = _tuple$1[1];
			neg = _tuple$1[2];
			trunc = _tuple$1[3];
			ok$1 = _tuple$1[4];
			if (ok$1) {
				if (!trunc) {
					_tuple$2 = atof32exact(mantissa, exp, neg);
					f$1 = _tuple$2[0];
					ok$2 = _tuple$2[1];
					if (ok$2) {
						_tmp$2 = f$1;
						_tmp$3 = $ifaceNil;
						f = _tmp$2;
						err = _tmp$3;
						return [f, err];
					}
				}
				ext = new extFloat.ptr(new $Uint64(0, 0), 0, false);
				ok$3 = ext.AssignDecimal(mantissa, exp, neg, trunc, float32info);
				if (ok$3) {
					_tuple$3 = ext.floatBits(float32info);
					b = _tuple$3[0];
					ovf = _tuple$3[1];
					f = math.Float32frombits(((b.$low >>> 0)));
					if (ovf) {
						err = rangeError("ParseFloat", s);
					}
					_tmp$4 = f;
					_tmp$5 = err;
					f = _tmp$4;
					err = _tmp$5;
					return [f, err];
				}
			}
		}
		d = new decimal.ptr(arrayType.zero(), 0, 0, false, false);
		if (!d.set(s)) {
			_tmp$6 = 0;
			_tmp$7 = syntaxError("ParseFloat", s);
			f = _tmp$6;
			err = _tmp$7;
			return [f, err];
		}
		_tuple$4 = d.floatBits(float32info);
		b$1 = _tuple$4[0];
		ovf$1 = _tuple$4[1];
		f = math.Float32frombits(((b$1.$low >>> 0)));
		if (ovf$1) {
			err = rangeError("ParseFloat", s);
		}
		_tmp$8 = f;
		_tmp$9 = err;
		f = _tmp$8;
		err = _tmp$9;
		return [f, err];
	};
	atof64 = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, b, b$1, d, err, exp, ext, f, f$1, mantissa, neg, ok, ok$1, ok$2, ok$3, ovf, ovf$1, s, trunc, val;
		f = 0;
		err = $ifaceNil;
		_tuple = special(s);
		val = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			_tmp = val;
			_tmp$1 = $ifaceNil;
			f = _tmp;
			err = _tmp$1;
			return [f, err];
		}
		if (optimize) {
			_tuple$1 = readFloat(s);
			mantissa = _tuple$1[0];
			exp = _tuple$1[1];
			neg = _tuple$1[2];
			trunc = _tuple$1[3];
			ok$1 = _tuple$1[4];
			if (ok$1) {
				if (!trunc) {
					_tuple$2 = atof64exact(mantissa, exp, neg);
					f$1 = _tuple$2[0];
					ok$2 = _tuple$2[1];
					if (ok$2) {
						_tmp$2 = f$1;
						_tmp$3 = $ifaceNil;
						f = _tmp$2;
						err = _tmp$3;
						return [f, err];
					}
				}
				ext = new extFloat.ptr(new $Uint64(0, 0), 0, false);
				ok$3 = ext.AssignDecimal(mantissa, exp, neg, trunc, float64info);
				if (ok$3) {
					_tuple$3 = ext.floatBits(float64info);
					b = _tuple$3[0];
					ovf = _tuple$3[1];
					f = math.Float64frombits(b);
					if (ovf) {
						err = rangeError("ParseFloat", s);
					}
					_tmp$4 = f;
					_tmp$5 = err;
					f = _tmp$4;
					err = _tmp$5;
					return [f, err];
				}
			}
		}
		d = new decimal.ptr(arrayType.zero(), 0, 0, false, false);
		if (!d.set(s)) {
			_tmp$6 = 0;
			_tmp$7 = syntaxError("ParseFloat", s);
			f = _tmp$6;
			err = _tmp$7;
			return [f, err];
		}
		_tuple$4 = d.floatBits(float64info);
		b$1 = _tuple$4[0];
		ovf$1 = _tuple$4[1];
		f = math.Float64frombits(b$1);
		if (ovf$1) {
			err = rangeError("ParseFloat", s);
		}
		_tmp$8 = f;
		_tmp$9 = err;
		f = _tmp$8;
		err = _tmp$9;
		return [f, err];
	};
	ParseFloat = function(s, bitSize) {
		var _tuple, bitSize, err, f, s;
		if (bitSize === 32) {
			_tuple = atof32(s);
			f = _tuple[0];
			err = _tuple[1];
			return [(f), err];
		}
		return atof64(s);
	};
	$pkg.ParseFloat = ParseFloat;
	NumError.ptr.prototype.Error = function() {
		var _r, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return "strconv." + e.Func + ": " + "parsing " + Quote(e.Num) + ": " + _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: NumError.ptr.prototype.Error }; } $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	NumError.prototype.Error = function() { return this.$val.Error(); };
	syntaxError = function(fn, str) {
		var fn, str;
		return new NumError.ptr(fn, str, $pkg.ErrSyntax);
	};
	rangeError = function(fn, str) {
		var fn, str;
		return new NumError.ptr(fn, str, $pkg.ErrRange);
	};
	ParseUint = function(s, base, bitSize) {
		var _1, _tmp, _tmp$1, base, bitSize, cutoff, d, err, i, maxVal, n, n1, s, v, x, x$1, x$2, $s;
		/* */ $s = 0; s: while (true) { switch ($s) { case 0:
		n = new $Uint64(0, 0);
		err = $ifaceNil;
		_tmp = new $Uint64(0, 0);
		_tmp$1 = new $Uint64(0, 0);
		cutoff = _tmp;
		maxVal = _tmp$1;
		if (bitSize === 0) {
			bitSize = 32;
		}
		i = 0;
			/* */ if (s.length < 1) { $s = 2; continue; }
			/* */ if (2 <= base && base <= 36) { $s = 3; continue; }
			/* */ if ((base === 0)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (s.length < 1) { */ case 2:
				err = $pkg.ErrSyntax;
				/* goto Error */ $s = 7; continue;
				$s = 6; continue;
			/* } else if (2 <= base && base <= 36) { */ case 3:
				$s = 6; continue;
			/* } else if ((base === 0)) { */ case 4:
					/* */ if ((s.charCodeAt(0) === 48) && s.length > 1 && ((s.charCodeAt(1) === 120) || (s.charCodeAt(1) === 88))) { $s = 9; continue; }
					/* */ if ((s.charCodeAt(0) === 48)) { $s = 10; continue; }
					/* */ $s = 11; continue;
					/* if ((s.charCodeAt(0) === 48) && s.length > 1 && ((s.charCodeAt(1) === 120) || (s.charCodeAt(1) === 88))) { */ case 9:
						/* */ if (s.length < 3) { $s = 13; continue; }
						/* */ $s = 14; continue;
						/* if (s.length < 3) { */ case 13:
							err = $pkg.ErrSyntax;
							/* goto Error */ $s = 7; continue;
						/* } */ case 14:
						base = 16;
						i = 2;
						$s = 12; continue;
					/* } else if ((s.charCodeAt(0) === 48)) { */ case 10:
						base = 8;
						i = 1;
						$s = 12; continue;
					/* } else { */ case 11:
						base = 10;
					/* } */ case 12:
				case 8:
				$s = 6; continue;
			/* } else { */ case 5:
				err = errors.New("invalid base " + Itoa(base));
				/* goto Error */ $s = 7; continue;
			/* } */ case 6:
		case 1:
		_1 = base;
		if (_1 === (10)) {
			cutoff = new $Uint64(429496729, 2576980378);
		} else if (_1 === (16)) {
			cutoff = new $Uint64(268435456, 0);
		} else {
			cutoff = (x = $div64(new $Uint64(4294967295, 4294967295), (new $Uint64(0, base)), false), new $Uint64(x.$high + 0, x.$low + 1));
		}
		maxVal = (x$1 = $shiftLeft64(new $Uint64(0, 1), ((bitSize >>> 0))), new $Uint64(x$1.$high - 0, x$1.$low - 1));
		/* while (true) { */ case 15:
			/* if (!(i < s.length)) { break; } */ if(!(i < s.length)) { $s = 16; continue; }
			v = 0;
			d = s.charCodeAt(i);
				/* */ if (48 <= d && d <= 57) { $s = 18; continue; }
				/* */ if (97 <= d && d <= 122) { $s = 19; continue; }
				/* */ if (65 <= d && d <= 90) { $s = 20; continue; }
				/* */ $s = 21; continue;
				/* if (48 <= d && d <= 57) { */ case 18:
					v = d - 48 << 24 >>> 24;
					$s = 22; continue;
				/* } else if (97 <= d && d <= 122) { */ case 19:
					v = (d - 97 << 24 >>> 24) + 10 << 24 >>> 24;
					$s = 22; continue;
				/* } else if (65 <= d && d <= 90) { */ case 20:
					v = (d - 65 << 24 >>> 24) + 10 << 24 >>> 24;
					$s = 22; continue;
				/* } else { */ case 21:
					n = new $Uint64(0, 0);
					err = $pkg.ErrSyntax;
					/* goto Error */ $s = 7; continue;
				/* } */ case 22:
			case 17:
			/* */ if (v >= ((base << 24 >>> 24))) { $s = 23; continue; }
			/* */ $s = 24; continue;
			/* if (v >= ((base << 24 >>> 24))) { */ case 23:
				n = new $Uint64(0, 0);
				err = $pkg.ErrSyntax;
				/* goto Error */ $s = 7; continue;
			/* } */ case 24:
			/* */ if ((n.$high > cutoff.$high || (n.$high === cutoff.$high && n.$low >= cutoff.$low))) { $s = 25; continue; }
			/* */ $s = 26; continue;
			/* if ((n.$high > cutoff.$high || (n.$high === cutoff.$high && n.$low >= cutoff.$low))) { */ case 25:
				n = new $Uint64(4294967295, 4294967295);
				err = $pkg.ErrRange;
				/* goto Error */ $s = 7; continue;
			/* } */ case 26:
			n = $mul64(n, ((new $Uint64(0, base))));
			n1 = (x$2 = (new $Uint64(0, v)), new $Uint64(n.$high + x$2.$high, n.$low + x$2.$low));
			/* */ if ((n1.$high < n.$high || (n1.$high === n.$high && n1.$low < n.$low)) || (n1.$high > maxVal.$high || (n1.$high === maxVal.$high && n1.$low > maxVal.$low))) { $s = 27; continue; }
			/* */ $s = 28; continue;
			/* if ((n1.$high < n.$high || (n1.$high === n.$high && n1.$low < n.$low)) || (n1.$high > maxVal.$high || (n1.$high === maxVal.$high && n1.$low > maxVal.$low))) { */ case 27:
				n = new $Uint64(4294967295, 4294967295);
				err = $pkg.ErrRange;
				/* goto Error */ $s = 7; continue;
			/* } */ case 28:
			n = n1;
			i = i + (1) >> 0;
		/* } */ $s = 15; continue; case 16:
		$s = -1; return [n, $ifaceNil];
		/* Error: */ case 7:
		$s = -1; return [n, new NumError.ptr("ParseUint", s, err)];
		$s = -1; return [new $Uint64(0, 0), $ifaceNil];
		/* */ } return; }
	};
	$pkg.ParseUint = ParseUint;
	ParseInt = function(s, base, bitSize) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, base, bitSize, cutoff, err, i, n, neg, s, s0, un, x, x$1;
		i = new $Int64(0, 0);
		err = $ifaceNil;
		if (bitSize === 0) {
			bitSize = 32;
		}
		if (s.length === 0) {
			_tmp = new $Int64(0, 0);
			_tmp$1 = syntaxError("ParseInt", s);
			i = _tmp;
			err = _tmp$1;
			return [i, err];
		}
		s0 = s;
		neg = false;
		if (s.charCodeAt(0) === 43) {
			s = $substring(s, 1);
		} else if (s.charCodeAt(0) === 45) {
			neg = true;
			s = $substring(s, 1);
		}
		un = new $Uint64(0, 0);
		_tuple = ParseUint(s, base, bitSize);
		un = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil)) && !($interfaceIsEqual($assertType(err, ptrType).Err, $pkg.ErrRange))) {
			$assertType(err, ptrType).Func = "ParseInt";
			$assertType(err, ptrType).Num = s0;
			_tmp$2 = new $Int64(0, 0);
			_tmp$3 = err;
			i = _tmp$2;
			err = _tmp$3;
			return [i, err];
		}
		cutoff = ($shiftLeft64(new $Uint64(0, 1), (((bitSize - 1 >> 0) >>> 0))));
		if (!neg && (un.$high > cutoff.$high || (un.$high === cutoff.$high && un.$low >= cutoff.$low))) {
			_tmp$4 = ((x = new $Uint64(cutoff.$high - 0, cutoff.$low - 1), new $Int64(x.$high, x.$low)));
			_tmp$5 = rangeError("ParseInt", s0);
			i = _tmp$4;
			err = _tmp$5;
			return [i, err];
		}
		if (neg && (un.$high > cutoff.$high || (un.$high === cutoff.$high && un.$low > cutoff.$low))) {
			_tmp$6 = (x$1 = (new $Int64(cutoff.$high, cutoff.$low)), new $Int64(-x$1.$high, -x$1.$low));
			_tmp$7 = rangeError("ParseInt", s0);
			i = _tmp$6;
			err = _tmp$7;
			return [i, err];
		}
		n = (new $Int64(un.$high, un.$low));
		if (neg) {
			n = new $Int64(-n.$high, -n.$low);
		}
		_tmp$8 = n;
		_tmp$9 = $ifaceNil;
		i = _tmp$8;
		err = _tmp$9;
		return [i, err];
	};
	$pkg.ParseInt = ParseInt;
	Atoi = function(s) {
		var _tuple, _tuple$1, err, i64, nerr, ok, s;
		_tuple = ParseInt(s, 10, 0);
		i64 = _tuple[0];
		err = _tuple[1];
		_tuple$1 = $assertType(err, ptrType, true);
		nerr = _tuple$1[0];
		ok = _tuple$1[1];
		if (ok) {
			nerr.Func = "Atoi";
		}
		return [(((i64.$low + ((i64.$high >> 31) * 4294967296)) >> 0)), err];
	};
	$pkg.Atoi = Atoi;
	decimal.ptr.prototype.String = function() {
		var a, buf, n, w;
		a = this;
		n = 10 + a.nd >> 0;
		if (a.dp > 0) {
			n = n + (a.dp) >> 0;
		}
		if (a.dp < 0) {
			n = n + (-a.dp) >> 0;
		}
		buf = $makeSlice(sliceType$6, n);
		w = 0;
		if ((a.nd === 0)) {
			return "0";
		} else if (a.dp <= 0) {
			((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = 48);
			w = w + (1) >> 0;
			((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = 46);
			w = w + (1) >> 0;
			w = w + (digitZero($subslice(buf, w, (w + -a.dp >> 0)))) >> 0;
			w = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), 0, a.nd))) >> 0;
		} else if (a.dp < a.nd) {
			w = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), 0, a.dp))) >> 0;
			((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = 46);
			w = w + (1) >> 0;
			w = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), a.dp, a.nd))) >> 0;
		} else {
			w = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), 0, a.nd))) >> 0;
			w = w + (digitZero($subslice(buf, w, ((w + a.dp >> 0) - a.nd >> 0)))) >> 0;
		}
		return ($bytesToString($subslice(buf, 0, w)));
	};
	decimal.prototype.String = function() { return this.$val.String(); };
	digitZero = function(dst) {
		var _i, _ref, dst, i;
		_ref = dst;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			((i < 0 || i >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + i] = 48);
			_i++;
		}
		return dst.$length;
	};
	trim = function(a) {
		var a, x, x$1;
		while (true) {
			if (!(a.nd > 0 && ((x = a.d, x$1 = a.nd - 1 >> 0, ((x$1 < 0 || x$1 >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[x$1])) === 48))) { break; }
			a.nd = a.nd - (1) >> 0;
		}
		if (a.nd === 0) {
			a.dp = 0;
		}
	};
	decimal.ptr.prototype.Assign = function(v) {
		var a, buf, n, v, v1, x, x$1, x$2;
		a = this;
		buf = arrayType$1.zero();
		n = 0;
		while (true) {
			if (!((v.$high > 0 || (v.$high === 0 && v.$low > 0)))) { break; }
			v1 = $div64(v, new $Uint64(0, 10), false);
			v = (x = $mul64(new $Uint64(0, 10), v1), new $Uint64(v.$high - x.$high, v.$low - x.$low));
			((n < 0 || n >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[n] = ((new $Uint64(v.$high + 0, v.$low + 48).$low << 24 >>> 24)));
			n = n + (1) >> 0;
			v = v1;
		}
		a.nd = 0;
		n = n - (1) >> 0;
		while (true) {
			if (!(n >= 0)) { break; }
			(x$1 = a.d, x$2 = a.nd, ((x$2 < 0 || x$2 >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[x$2] = ((n < 0 || n >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[n])));
			a.nd = a.nd + (1) >> 0;
			n = n - (1) >> 0;
		}
		a.dp = a.nd;
		trim(a);
	};
	decimal.prototype.Assign = function(v) { return this.$val.Assign(v); };
	rightShift = function(a, k) {
		var a, c, c$1, dig, dig$1, k, mask, n, r, w, x, x$1, x$2, x$3, y, y$1, y$2, y$3, y$4;
		r = 0;
		w = 0;
		n = 0;
		while (true) {
			if (!(((y = k, y < 32 ? (n >>> y) : 0) >>> 0) === 0)) { break; }
			if (r >= a.nd) {
				if (n === 0) {
					a.nd = 0;
					return;
				}
				while (true) {
					if (!(((y$1 = k, y$1 < 32 ? (n >>> y$1) : 0) >>> 0) === 0)) { break; }
					n = n * 10 >>> 0;
					r = r + (1) >> 0;
				}
				break;
			}
			c = (((x = a.d, ((r < 0 || r >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[r])) >>> 0));
			n = ((n * 10 >>> 0) + c >>> 0) - 48 >>> 0;
			r = r + (1) >> 0;
		}
		a.dp = a.dp - ((r - 1 >> 0)) >> 0;
		mask = (((y$2 = k, y$2 < 32 ? (1 << y$2) : 0) >>> 0)) - 1 >>> 0;
		while (true) {
			if (!(r < a.nd)) { break; }
			c$1 = (((x$1 = a.d, ((r < 0 || r >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[r])) >>> 0));
			dig = (y$3 = k, y$3 < 32 ? (n >>> y$3) : 0) >>> 0;
			n = (n & (mask)) >>> 0;
			(x$2 = a.d, ((w < 0 || w >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[w] = (((dig + 48 >>> 0) << 24 >>> 24))));
			w = w + (1) >> 0;
			n = ((n * 10 >>> 0) + c$1 >>> 0) - 48 >>> 0;
			r = r + (1) >> 0;
		}
		while (true) {
			if (!(n > 0)) { break; }
			dig$1 = (y$4 = k, y$4 < 32 ? (n >>> y$4) : 0) >>> 0;
			n = (n & (mask)) >>> 0;
			if (w < 800) {
				(x$3 = a.d, ((w < 0 || w >= x$3.length) ? ($throwRuntimeError("index out of range"), undefined) : x$3[w] = (((dig$1 + 48 >>> 0) << 24 >>> 24))));
				w = w + (1) >> 0;
			} else if (dig$1 > 0) {
				a.trunc = true;
			}
			n = n * 10 >>> 0;
		}
		a.nd = w;
		trim(a);
	};
	prefixIsLessThan = function(b, s) {
		var b, i, s;
		i = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			if (i >= b.$length) {
				return true;
			}
			if (!((((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i]) === s.charCodeAt(i)))) {
				return ((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i]) < s.charCodeAt(i);
			}
			i = i + (1) >> 0;
		}
		return false;
	};
	leftShift = function(a, k) {
		var _q, _q$1, a, delta, k, n, quo, quo$1, r, rem, rem$1, w, x, x$1, x$2, y;
		delta = ((k < 0 || k >= leftcheats.$length) ? ($throwRuntimeError("index out of range"), undefined) : leftcheats.$array[leftcheats.$offset + k]).delta;
		if (prefixIsLessThan($subslice(new sliceType$6(a.d), 0, a.nd), ((k < 0 || k >= leftcheats.$length) ? ($throwRuntimeError("index out of range"), undefined) : leftcheats.$array[leftcheats.$offset + k]).cutoff)) {
			delta = delta - (1) >> 0;
		}
		r = a.nd;
		w = a.nd + delta >> 0;
		n = 0;
		r = r - (1) >> 0;
		while (true) {
			if (!(r >= 0)) { break; }
			n = n + (((y = k, y < 32 ? ((((((x = a.d, ((r < 0 || r >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[r])) >>> 0)) - 48 >>> 0)) << y) : 0) >>> 0)) >>> 0;
			quo = (_q = n / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
			rem = n - (10 * quo >>> 0) >>> 0;
			w = w - (1) >> 0;
			if (w < 800) {
				(x$1 = a.d, ((w < 0 || w >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[w] = (((rem + 48 >>> 0) << 24 >>> 24))));
			} else if (!((rem === 0))) {
				a.trunc = true;
			}
			n = quo;
			r = r - (1) >> 0;
		}
		while (true) {
			if (!(n > 0)) { break; }
			quo$1 = (_q$1 = n / 10, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
			rem$1 = n - (10 * quo$1 >>> 0) >>> 0;
			w = w - (1) >> 0;
			if (w < 800) {
				(x$2 = a.d, ((w < 0 || w >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[w] = (((rem$1 + 48 >>> 0) << 24 >>> 24))));
			} else if (!((rem$1 === 0))) {
				a.trunc = true;
			}
			n = quo$1;
		}
		a.nd = a.nd + (delta) >> 0;
		if (a.nd >= 800) {
			a.nd = 800;
		}
		a.dp = a.dp + (delta) >> 0;
		trim(a);
	};
	decimal.ptr.prototype.Shift = function(k) {
		var a, k;
		a = this;
		if ((a.nd === 0)) {
		} else if (k > 0) {
			while (true) {
				if (!(k > 28)) { break; }
				leftShift(a, 28);
				k = k - (28) >> 0;
			}
			leftShift(a, ((k >>> 0)));
		} else if (k < 0) {
			while (true) {
				if (!(k < -28)) { break; }
				rightShift(a, 28);
				k = k + (28) >> 0;
			}
			rightShift(a, ((-k >>> 0)));
		}
	};
	decimal.prototype.Shift = function(k) { return this.$val.Shift(k); };
	shouldRoundUp = function(a, nd) {
		var _r, a, nd, x, x$1, x$2, x$3;
		if (nd < 0 || nd >= a.nd) {
			return false;
		}
		if (((x = a.d, ((nd < 0 || nd >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[nd])) === 53) && ((nd + 1 >> 0) === a.nd)) {
			if (a.trunc) {
				return true;
			}
			return nd > 0 && !(((_r = (((x$1 = a.d, x$2 = nd - 1 >> 0, ((x$2 < 0 || x$2 >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[x$2])) - 48 << 24 >>> 24)) % 2, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0));
		}
		return (x$3 = a.d, ((nd < 0 || nd >= x$3.length) ? ($throwRuntimeError("index out of range"), undefined) : x$3[nd])) >= 53;
	};
	decimal.ptr.prototype.Round = function(nd) {
		var a, nd;
		a = this;
		if (nd < 0 || nd >= a.nd) {
			return;
		}
		if (shouldRoundUp(a, nd)) {
			a.RoundUp(nd);
		} else {
			a.RoundDown(nd);
		}
	};
	decimal.prototype.Round = function(nd) { return this.$val.Round(nd); };
	decimal.ptr.prototype.RoundDown = function(nd) {
		var a, nd;
		a = this;
		if (nd < 0 || nd >= a.nd) {
			return;
		}
		a.nd = nd;
		trim(a);
	};
	decimal.prototype.RoundDown = function(nd) { return this.$val.RoundDown(nd); };
	decimal.ptr.prototype.RoundUp = function(nd) {
		var a, c, i, nd, x, x$1, x$2;
		a = this;
		if (nd < 0 || nd >= a.nd) {
			return;
		}
		i = nd - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			c = (x = a.d, ((i < 0 || i >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i]));
			if (c < 57) {
				(x$2 = a.d, ((i < 0 || i >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[i] = ((x$1 = a.d, ((i < 0 || i >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[i])) + (1) << 24 >>> 24)));
				a.nd = i + 1 >> 0;
				return;
			}
			i = i - (1) >> 0;
		}
		a.d[0] = 49;
		a.nd = 1;
		a.dp = a.dp + (1) >> 0;
	};
	decimal.prototype.RoundUp = function(nd) { return this.$val.RoundUp(nd); };
	decimal.ptr.prototype.RoundedInteger = function() {
		var a, i, n, x, x$1, x$2, x$3;
		a = this;
		if (a.dp > 20) {
			return new $Uint64(4294967295, 4294967295);
		}
		i = 0;
		n = new $Uint64(0, 0);
		i = 0;
		while (true) {
			if (!(i < a.dp && i < a.nd)) { break; }
			n = (x = $mul64(n, new $Uint64(0, 10)), x$1 = (new $Uint64(0, ((x$2 = a.d, ((i < 0 || i >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[i])) - 48 << 24 >>> 24))), new $Uint64(x.$high + x$1.$high, x.$low + x$1.$low));
			i = i + (1) >> 0;
		}
		while (true) {
			if (!(i < a.dp)) { break; }
			n = $mul64(n, (new $Uint64(0, 10)));
			i = i + (1) >> 0;
		}
		if (shouldRoundUp(a, a.dp)) {
			n = (x$3 = new $Uint64(0, 1), new $Uint64(n.$high + x$3.$high, n.$low + x$3.$low));
		}
		return n;
	};
	decimal.prototype.RoundedInteger = function() { return this.$val.RoundedInteger(); };
	extFloat.ptr.prototype.floatBits = function(flt) {
		var bits, exp, f, flt, mant, n, overflow, x, x$1, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y, y$1, y$2;
		bits = new $Uint64(0, 0);
		overflow = false;
		f = this;
		f.Normalize();
		exp = f.exp + 63 >> 0;
		if (exp < (flt.bias + 1 >> 0)) {
			n = (flt.bias + 1 >> 0) - exp >> 0;
			f.mant = $shiftRightUint64(f.mant, (((n >>> 0))));
			exp = exp + (n) >> 0;
		}
		mant = $shiftRightUint64(f.mant, ((63 - flt.mantbits >>> 0)));
		if (!((x = (x$1 = f.mant, x$2 = $shiftLeft64(new $Uint64(0, 1), ((62 - flt.mantbits >>> 0))), new $Uint64(x$1.$high & x$2.$high, (x$1.$low & x$2.$low) >>> 0)), (x.$high === 0 && x.$low === 0)))) {
			mant = (x$3 = new $Uint64(0, 1), new $Uint64(mant.$high + x$3.$high, mant.$low + x$3.$low));
		}
		if ((x$4 = $shiftLeft64(new $Uint64(0, 2), flt.mantbits), (mant.$high === x$4.$high && mant.$low === x$4.$low))) {
			mant = $shiftRightUint64(mant, (1));
			exp = exp + (1) >> 0;
		}
		if ((exp - flt.bias >> 0) >= (((y = flt.expbits, y < 32 ? (1 << y) : 0) >> 0) - 1 >> 0)) {
			mant = new $Uint64(0, 0);
			exp = (((y$1 = flt.expbits, y$1 < 32 ? (1 << y$1) : 0) >> 0) - 1 >> 0) + flt.bias >> 0;
			overflow = true;
		} else if ((x$5 = (x$6 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), new $Uint64(mant.$high & x$6.$high, (mant.$low & x$6.$low) >>> 0)), (x$5.$high === 0 && x$5.$low === 0))) {
			exp = flt.bias;
		}
		bits = (x$7 = (x$8 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), new $Uint64(x$8.$high - 0, x$8.$low - 1)), new $Uint64(mant.$high & x$7.$high, (mant.$low & x$7.$low) >>> 0));
		bits = (x$9 = $shiftLeft64((new $Uint64(0, (((exp - flt.bias >> 0)) & ((((y$2 = flt.expbits, y$2 < 32 ? (1 << y$2) : 0) >> 0) - 1 >> 0))))), flt.mantbits), new $Uint64(bits.$high | x$9.$high, (bits.$low | x$9.$low) >>> 0));
		if (f.neg) {
			bits = (x$10 = $shiftLeft64(new $Uint64(0, 1), ((flt.mantbits + flt.expbits >>> 0))), new $Uint64(bits.$high | x$10.$high, (bits.$low | x$10.$low) >>> 0));
		}
		return [bits, overflow];
	};
	extFloat.prototype.floatBits = function(flt) { return this.$val.floatBits(flt); };
	extFloat.ptr.prototype.AssignComputeBounds = function(mant, exp, neg, flt) {
		var _tmp, _tmp$1, exp, expBiased, f, flt, lower, mant, neg, upper, x, x$1, x$2, x$3, x$4;
		lower = new extFloat.ptr(new $Uint64(0, 0), 0, false);
		upper = new extFloat.ptr(new $Uint64(0, 0), 0, false);
		f = this;
		f.mant = mant;
		f.exp = exp - ((flt.mantbits >> 0)) >> 0;
		f.neg = neg;
		if (f.exp <= 0 && (x = $shiftLeft64(($shiftRightUint64(mant, ((-f.exp >>> 0)))), ((-f.exp >>> 0))), (mant.$high === x.$high && mant.$low === x.$low))) {
			f.mant = $shiftRightUint64(f.mant, (((-f.exp >>> 0))));
			f.exp = 0;
			_tmp = $clone(f, extFloat);
			_tmp$1 = $clone(f, extFloat);
			extFloat.copy(lower, _tmp);
			extFloat.copy(upper, _tmp$1);
			return [lower, upper];
		}
		expBiased = exp - flt.bias >> 0;
		extFloat.copy(upper, new extFloat.ptr((x$1 = $mul64(new $Uint64(0, 2), f.mant), new $Uint64(x$1.$high + 0, x$1.$low + 1)), f.exp - 1 >> 0, f.neg));
		if (!((x$2 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), (mant.$high === x$2.$high && mant.$low === x$2.$low))) || (expBiased === 1)) {
			extFloat.copy(lower, new extFloat.ptr((x$3 = $mul64(new $Uint64(0, 2), f.mant), new $Uint64(x$3.$high - 0, x$3.$low - 1)), f.exp - 1 >> 0, f.neg));
		} else {
			extFloat.copy(lower, new extFloat.ptr((x$4 = $mul64(new $Uint64(0, 4), f.mant), new $Uint64(x$4.$high - 0, x$4.$low - 1)), f.exp - 2 >> 0, f.neg));
		}
		return [lower, upper];
	};
	extFloat.prototype.AssignComputeBounds = function(mant, exp, neg, flt) { return this.$val.AssignComputeBounds(mant, exp, neg, flt); };
	extFloat.ptr.prototype.Normalize = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, exp, f, mant, shift, x, x$1, x$2, x$3, x$4, x$5;
		shift = 0;
		f = this;
		_tmp = f.mant;
		_tmp$1 = f.exp;
		mant = _tmp;
		exp = _tmp$1;
		if ((mant.$high === 0 && mant.$low === 0)) {
			shift = 0;
			return shift;
		}
		if ((x = $shiftRightUint64(mant, 32), (x.$high === 0 && x.$low === 0))) {
			mant = $shiftLeft64(mant, (32));
			exp = exp - (32) >> 0;
		}
		if ((x$1 = $shiftRightUint64(mant, 48), (x$1.$high === 0 && x$1.$low === 0))) {
			mant = $shiftLeft64(mant, (16));
			exp = exp - (16) >> 0;
		}
		if ((x$2 = $shiftRightUint64(mant, 56), (x$2.$high === 0 && x$2.$low === 0))) {
			mant = $shiftLeft64(mant, (8));
			exp = exp - (8) >> 0;
		}
		if ((x$3 = $shiftRightUint64(mant, 60), (x$3.$high === 0 && x$3.$low === 0))) {
			mant = $shiftLeft64(mant, (4));
			exp = exp - (4) >> 0;
		}
		if ((x$4 = $shiftRightUint64(mant, 62), (x$4.$high === 0 && x$4.$low === 0))) {
			mant = $shiftLeft64(mant, (2));
			exp = exp - (2) >> 0;
		}
		if ((x$5 = $shiftRightUint64(mant, 63), (x$5.$high === 0 && x$5.$low === 0))) {
			mant = $shiftLeft64(mant, (1));
			exp = exp - (1) >> 0;
		}
		shift = (((f.exp - exp >> 0) >>> 0));
		_tmp$2 = mant;
		_tmp$3 = exp;
		f.mant = _tmp$2;
		f.exp = _tmp$3;
		return shift;
	};
	extFloat.prototype.Normalize = function() { return this.$val.Normalize(); };
	extFloat.ptr.prototype.Multiply = function(g) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, cross1, cross2, f, fhi, flo, g, ghi, glo, rem, x, x$1, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		f = this;
		_tmp = $shiftRightUint64(f.mant, 32);
		_tmp$1 = (new $Uint64(0, ((f.mant.$low >>> 0))));
		fhi = _tmp;
		flo = _tmp$1;
		_tmp$2 = $shiftRightUint64(g.mant, 32);
		_tmp$3 = (new $Uint64(0, ((g.mant.$low >>> 0))));
		ghi = _tmp$2;
		glo = _tmp$3;
		cross1 = $mul64(fhi, glo);
		cross2 = $mul64(flo, ghi);
		f.mant = (x = (x$1 = $mul64(fhi, ghi), x$2 = $shiftRightUint64(cross1, 32), new $Uint64(x$1.$high + x$2.$high, x$1.$low + x$2.$low)), x$3 = $shiftRightUint64(cross2, 32), new $Uint64(x.$high + x$3.$high, x.$low + x$3.$low));
		rem = (x$4 = (x$5 = (new $Uint64(0, ((cross1.$low >>> 0)))), x$6 = (new $Uint64(0, ((cross2.$low >>> 0)))), new $Uint64(x$5.$high + x$6.$high, x$5.$low + x$6.$low)), x$7 = $shiftRightUint64(($mul64(flo, glo)), 32), new $Uint64(x$4.$high + x$7.$high, x$4.$low + x$7.$low));
		rem = (x$8 = new $Uint64(0, 2147483648), new $Uint64(rem.$high + x$8.$high, rem.$low + x$8.$low));
		f.mant = (x$9 = f.mant, x$10 = ($shiftRightUint64(rem, 32)), new $Uint64(x$9.$high + x$10.$high, x$9.$low + x$10.$low));
		f.exp = (f.exp + g.exp >> 0) + 64 >> 0;
	};
	extFloat.prototype.Multiply = function(g) { return this.$val.Multiply(g); };
	extFloat.ptr.prototype.AssignDecimal = function(mantissa, exp10, neg, trunc, flt) {
		var _q, _r, adjExp, denormalExp, errors$1, exp10, extrabits, f, flt, halfway, i, mant_extra, mantissa, neg, ok, shift, trunc, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y;
		ok = false;
		f = this;
		errors$1 = 0;
		if (trunc) {
			errors$1 = errors$1 + (4) >> 0;
		}
		f.mant = mantissa;
		f.exp = 0;
		f.neg = neg;
		i = (_q = ((exp10 - -348 >> 0)) / 8, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		if (exp10 < -348 || i >= 87) {
			ok = false;
			return ok;
		}
		adjExp = (_r = ((exp10 - -348 >> 0)) % 8, _r === _r ? _r : $throwRuntimeError("integer divide by zero"));
		if (adjExp < 19 && (x = (x$1 = 19 - adjExp >> 0, ((x$1 < 0 || x$1 >= uint64pow10.length) ? ($throwRuntimeError("index out of range"), undefined) : uint64pow10[x$1])), (mantissa.$high < x.$high || (mantissa.$high === x.$high && mantissa.$low < x.$low)))) {
			f.mant = $mul64(f.mant, (((adjExp < 0 || adjExp >= uint64pow10.length) ? ($throwRuntimeError("index out of range"), undefined) : uint64pow10[adjExp])));
			f.Normalize();
		} else {
			f.Normalize();
			f.Multiply($clone(((adjExp < 0 || adjExp >= smallPowersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : smallPowersOfTen[adjExp]), extFloat));
			errors$1 = errors$1 + (4) >> 0;
		}
		f.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : powersOfTen[i]), extFloat));
		if (errors$1 > 0) {
			errors$1 = errors$1 + (1) >> 0;
		}
		errors$1 = errors$1 + (4) >> 0;
		shift = f.Normalize();
		errors$1 = (y = (shift), y < 32 ? (errors$1 << y) : 0) >> 0;
		denormalExp = flt.bias - 63 >> 0;
		extrabits = 0;
		if (f.exp <= denormalExp) {
			extrabits = ((63 - flt.mantbits >>> 0) + 1 >>> 0) + (((denormalExp - f.exp >> 0) >>> 0)) >>> 0;
		} else {
			extrabits = 63 - flt.mantbits >>> 0;
		}
		halfway = $shiftLeft64(new $Uint64(0, 1), ((extrabits - 1 >>> 0)));
		mant_extra = (x$2 = f.mant, x$3 = (x$4 = $shiftLeft64(new $Uint64(0, 1), extrabits), new $Uint64(x$4.$high - 0, x$4.$low - 1)), new $Uint64(x$2.$high & x$3.$high, (x$2.$low & x$3.$low) >>> 0));
		if ((x$5 = (x$6 = (new $Int64(halfway.$high, halfway.$low)), x$7 = (new $Int64(0, errors$1)), new $Int64(x$6.$high - x$7.$high, x$6.$low - x$7.$low)), x$8 = (new $Int64(mant_extra.$high, mant_extra.$low)), (x$5.$high < x$8.$high || (x$5.$high === x$8.$high && x$5.$low < x$8.$low))) && (x$9 = (new $Int64(mant_extra.$high, mant_extra.$low)), x$10 = (x$11 = (new $Int64(halfway.$high, halfway.$low)), x$12 = (new $Int64(0, errors$1)), new $Int64(x$11.$high + x$12.$high, x$11.$low + x$12.$low)), (x$9.$high < x$10.$high || (x$9.$high === x$10.$high && x$9.$low < x$10.$low)))) {
			ok = false;
			return ok;
		}
		ok = true;
		return ok;
	};
	extFloat.prototype.AssignDecimal = function(mantissa, exp10, neg, trunc, flt) { return this.$val.AssignDecimal(mantissa, exp10, neg, trunc, flt); };
	extFloat.ptr.prototype.frexp10 = function() {
		var _q, _q$1, _tmp, _tmp$1, approxExp10, exp, exp10, f, i, index;
		exp10 = 0;
		index = 0;
		f = this;
		approxExp10 = (_q = ($imul(((-46 - f.exp >> 0)), 28)) / 93, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		i = (_q$1 = ((approxExp10 - -348 >> 0)) / 8, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"));
		Loop:
		while (true) {
			exp = (f.exp + ((i < 0 || i >= powersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : powersOfTen[i]).exp >> 0) + 64 >> 0;
			if (exp < -60) {
				i = i + (1) >> 0;
			} else if (exp > -32) {
				i = i - (1) >> 0;
			} else {
				break Loop;
			}
		}
		f.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : powersOfTen[i]), extFloat));
		_tmp = -((-348 + ($imul(i, 8)) >> 0));
		_tmp$1 = i;
		exp10 = _tmp;
		index = _tmp$1;
		return [exp10, index];
	};
	extFloat.prototype.frexp10 = function() { return this.$val.frexp10(); };
	frexp10Many = function(a, b, c) {
		var _tuple, a, b, c, exp10, i;
		exp10 = 0;
		_tuple = c.frexp10();
		exp10 = _tuple[0];
		i = _tuple[1];
		a.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : powersOfTen[i]), extFloat));
		b.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : powersOfTen[i]), extFloat));
		return exp10;
	};
	extFloat.ptr.prototype.FixedDecimal = function(d, n) {
		var $CE$B5, _q, _q$1, _tmp, _tmp$1, _tuple, buf, d, digit, exp10, f, fraction, i, i$1, i$2, integer, integerDigits, n, nd, needed, ok, pos, pow, pow10, rest, shift, v, v1, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		f = this;
		if ((x = f.mant, (x.$high === 0 && x.$low === 0))) {
			d.nd = 0;
			d.dp = 0;
			d.neg = f.neg;
			return true;
		}
		if (n === 0) {
			$panic(new $String("strconv: internal error: extFloat.FixedDecimal called with n == 0"));
		}
		f.Normalize();
		_tuple = f.frexp10();
		exp10 = _tuple[0];
		shift = ((-f.exp >>> 0));
		integer = (($shiftRightUint64(f.mant, shift).$low >>> 0));
		fraction = (x$1 = f.mant, x$2 = $shiftLeft64((new $Uint64(0, integer)), shift), new $Uint64(x$1.$high - x$2.$high, x$1.$low - x$2.$low));
		$CE$B5 = new $Uint64(0, 1);
		needed = n;
		integerDigits = 0;
		pow10 = new $Uint64(0, 1);
		_tmp = 0;
		_tmp$1 = new $Uint64(0, 1);
		i = _tmp;
		pow = _tmp$1;
		while (true) {
			if (!(i < 20)) { break; }
			if ((x$3 = (new $Uint64(0, integer)), (pow.$high > x$3.$high || (pow.$high === x$3.$high && pow.$low > x$3.$low)))) {
				integerDigits = i;
				break;
			}
			pow = $mul64(pow, (new $Uint64(0, 10)));
			i = i + (1) >> 0;
		}
		rest = integer;
		if (integerDigits > needed) {
			pow10 = (x$4 = integerDigits - needed >> 0, ((x$4 < 0 || x$4 >= uint64pow10.length) ? ($throwRuntimeError("index out of range"), undefined) : uint64pow10[x$4]));
			integer = (_q = integer / (((pow10.$low >>> 0))), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
			rest = rest - (($imul(integer, ((pow10.$low >>> 0))) >>> 0)) >>> 0;
		} else {
			rest = 0;
		}
		buf = arrayType$2.zero();
		pos = 32;
		v = integer;
		while (true) {
			if (!(v > 0)) { break; }
			v1 = (_q$1 = v / 10, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
			v = v - (($imul(10, v1) >>> 0)) >>> 0;
			pos = pos - (1) >> 0;
			((pos < 0 || pos >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[pos] = (((v + 48 >>> 0) << 24 >>> 24)));
			v = v1;
		}
		i$1 = pos;
		while (true) {
			if (!(i$1 < 32)) { break; }
			(x$5 = d.d, x$6 = i$1 - pos >> 0, ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6] = ((i$1 < 0 || i$1 >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[i$1])));
			i$1 = i$1 + (1) >> 0;
		}
		nd = 32 - pos >> 0;
		d.nd = nd;
		d.dp = integerDigits + exp10 >> 0;
		needed = needed - (nd) >> 0;
		if (needed > 0) {
			if (!((rest === 0)) || !((pow10.$high === 0 && pow10.$low === 1))) {
				$panic(new $String("strconv: internal error, rest != 0 but needed > 0"));
			}
			while (true) {
				if (!(needed > 0)) { break; }
				fraction = $mul64(fraction, (new $Uint64(0, 10)));
				$CE$B5 = $mul64($CE$B5, (new $Uint64(0, 10)));
				if ((x$7 = $mul64(new $Uint64(0, 2), $CE$B5), x$8 = $shiftLeft64(new $Uint64(0, 1), shift), (x$7.$high > x$8.$high || (x$7.$high === x$8.$high && x$7.$low > x$8.$low)))) {
					return false;
				}
				digit = $shiftRightUint64(fraction, shift);
				(x$9 = d.d, ((nd < 0 || nd >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + nd] = ((new $Uint64(digit.$high + 0, digit.$low + 48).$low << 24 >>> 24))));
				fraction = (x$10 = $shiftLeft64(digit, shift), new $Uint64(fraction.$high - x$10.$high, fraction.$low - x$10.$low));
				nd = nd + (1) >> 0;
				needed = needed - (1) >> 0;
			}
			d.nd = nd;
		}
		ok = adjustLastDigitFixed(d, (x$11 = $shiftLeft64((new $Uint64(0, rest)), shift), new $Uint64(x$11.$high | fraction.$high, (x$11.$low | fraction.$low) >>> 0)), pow10, shift, $CE$B5);
		if (!ok) {
			return false;
		}
		i$2 = d.nd - 1 >> 0;
		while (true) {
			if (!(i$2 >= 0)) { break; }
			if (!(((x$12 = d.d, ((i$2 < 0 || i$2 >= x$12.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$12.$array[x$12.$offset + i$2])) === 48))) {
				d.nd = i$2 + 1 >> 0;
				break;
			}
			i$2 = i$2 - (1) >> 0;
		}
		return true;
	};
	extFloat.prototype.FixedDecimal = function(d, n) { return this.$val.FixedDecimal(d, n); };
	adjustLastDigitFixed = function(d, num, den, shift, $CE$B5) {
		var $CE$B5, d, den, i, num, shift, x, x$1, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		if ((x = $shiftLeft64(den, shift), (num.$high > x.$high || (num.$high === x.$high && num.$low > x.$low)))) {
			$panic(new $String("strconv: num > den<<shift in adjustLastDigitFixed"));
		}
		if ((x$1 = $mul64(new $Uint64(0, 2), $CE$B5), x$2 = $shiftLeft64(den, shift), (x$1.$high > x$2.$high || (x$1.$high === x$2.$high && x$1.$low > x$2.$low)))) {
			$panic(new $String("strconv: \xCE\xB5 > (den<<shift)/2"));
		}
		if ((x$3 = $mul64(new $Uint64(0, 2), (new $Uint64(num.$high + $CE$B5.$high, num.$low + $CE$B5.$low))), x$4 = $shiftLeft64(den, shift), (x$3.$high < x$4.$high || (x$3.$high === x$4.$high && x$3.$low < x$4.$low)))) {
			return true;
		}
		if ((x$5 = $mul64(new $Uint64(0, 2), (new $Uint64(num.$high - $CE$B5.$high, num.$low - $CE$B5.$low))), x$6 = $shiftLeft64(den, shift), (x$5.$high > x$6.$high || (x$5.$high === x$6.$high && x$5.$low > x$6.$low)))) {
			i = d.nd - 1 >> 0;
			while (true) {
				if (!(i >= 0)) { break; }
				if ((x$7 = d.d, ((i < 0 || i >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + i])) === 57) {
					d.nd = d.nd - (1) >> 0;
				} else {
					break;
				}
				i = i - (1) >> 0;
			}
			if (i < 0) {
				(x$8 = d.d, (0 >= x$8.$length ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + 0] = 49));
				d.nd = 1;
				d.dp = d.dp + (1) >> 0;
			} else {
				(x$10 = d.d, ((i < 0 || i >= x$10.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + i] = ((x$9 = d.d, ((i < 0 || i >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + i])) + (1) << 24 >>> 24)));
			}
			return true;
		}
		return false;
	};
	extFloat.ptr.prototype.ShortestDecimal = function(d, lower, upper) {
		var _q, _tmp, _tmp$1, _tmp$2, _tmp$3, allowance, buf, currentDiff, d, digit, digit$1, exp10, f, fraction, i, i$1, i$2, integer, integerDigits, lower, multiplier, n, nd, pow, pow$1, shift, targetDiff, upper, v, v1, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$22, x$23, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		f = this;
		if ((x = f.mant, (x.$high === 0 && x.$low === 0))) {
			d.nd = 0;
			d.dp = 0;
			d.neg = f.neg;
			return true;
		}
		if ((f.exp === 0) && $equal(lower, f, extFloat) && $equal(lower, upper, extFloat)) {
			buf = arrayType$1.zero();
			n = 23;
			v = f.mant;
			while (true) {
				if (!((v.$high > 0 || (v.$high === 0 && v.$low > 0)))) { break; }
				v1 = $div64(v, new $Uint64(0, 10), false);
				v = (x$1 = $mul64(new $Uint64(0, 10), v1), new $Uint64(v.$high - x$1.$high, v.$low - x$1.$low));
				((n < 0 || n >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[n] = ((new $Uint64(v.$high + 0, v.$low + 48).$low << 24 >>> 24)));
				n = n - (1) >> 0;
				v = v1;
			}
			nd = (24 - n >> 0) - 1 >> 0;
			i = 0;
			while (true) {
				if (!(i < nd)) { break; }
				(x$3 = d.d, ((i < 0 || i >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i] = (x$2 = (n + 1 >> 0) + i >> 0, ((x$2 < 0 || x$2 >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[x$2]))));
				i = i + (1) >> 0;
			}
			_tmp = nd;
			_tmp$1 = nd;
			d.nd = _tmp;
			d.dp = _tmp$1;
			while (true) {
				if (!(d.nd > 0 && ((x$4 = d.d, x$5 = d.nd - 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])) === 48))) { break; }
				d.nd = d.nd - (1) >> 0;
			}
			if (d.nd === 0) {
				d.dp = 0;
			}
			d.neg = f.neg;
			return true;
		}
		upper.Normalize();
		if (f.exp > upper.exp) {
			f.mant = $shiftLeft64(f.mant, ((((f.exp - upper.exp >> 0) >>> 0))));
			f.exp = upper.exp;
		}
		if (lower.exp > upper.exp) {
			lower.mant = $shiftLeft64(lower.mant, ((((lower.exp - upper.exp >> 0) >>> 0))));
			lower.exp = upper.exp;
		}
		exp10 = frexp10Many(lower, f, upper);
		upper.mant = (x$6 = upper.mant, x$7 = new $Uint64(0, 1), new $Uint64(x$6.$high + x$7.$high, x$6.$low + x$7.$low));
		lower.mant = (x$8 = lower.mant, x$9 = new $Uint64(0, 1), new $Uint64(x$8.$high - x$9.$high, x$8.$low - x$9.$low));
		shift = ((-upper.exp >>> 0));
		integer = (($shiftRightUint64(upper.mant, shift).$low >>> 0));
		fraction = (x$10 = upper.mant, x$11 = $shiftLeft64((new $Uint64(0, integer)), shift), new $Uint64(x$10.$high - x$11.$high, x$10.$low - x$11.$low));
		allowance = (x$12 = upper.mant, x$13 = lower.mant, new $Uint64(x$12.$high - x$13.$high, x$12.$low - x$13.$low));
		targetDiff = (x$14 = upper.mant, x$15 = f.mant, new $Uint64(x$14.$high - x$15.$high, x$14.$low - x$15.$low));
		integerDigits = 0;
		_tmp$2 = 0;
		_tmp$3 = new $Uint64(0, 1);
		i$1 = _tmp$2;
		pow = _tmp$3;
		while (true) {
			if (!(i$1 < 20)) { break; }
			if ((x$16 = (new $Uint64(0, integer)), (pow.$high > x$16.$high || (pow.$high === x$16.$high && pow.$low > x$16.$low)))) {
				integerDigits = i$1;
				break;
			}
			pow = $mul64(pow, (new $Uint64(0, 10)));
			i$1 = i$1 + (1) >> 0;
		}
		i$2 = 0;
		while (true) {
			if (!(i$2 < integerDigits)) { break; }
			pow$1 = (x$17 = (integerDigits - i$2 >> 0) - 1 >> 0, ((x$17 < 0 || x$17 >= uint64pow10.length) ? ($throwRuntimeError("index out of range"), undefined) : uint64pow10[x$17]));
			digit = (_q = integer / ((pow$1.$low >>> 0)), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
			(x$18 = d.d, ((i$2 < 0 || i$2 >= x$18.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$18.$array[x$18.$offset + i$2] = (((digit + 48 >>> 0) << 24 >>> 24))));
			integer = integer - (($imul(digit, ((pow$1.$low >>> 0))) >>> 0)) >>> 0;
			currentDiff = (x$19 = $shiftLeft64((new $Uint64(0, integer)), shift), new $Uint64(x$19.$high + fraction.$high, x$19.$low + fraction.$low));
			if ((currentDiff.$high < allowance.$high || (currentDiff.$high === allowance.$high && currentDiff.$low < allowance.$low))) {
				d.nd = i$2 + 1 >> 0;
				d.dp = integerDigits + exp10 >> 0;
				d.neg = f.neg;
				return adjustLastDigit(d, currentDiff, targetDiff, allowance, $shiftLeft64(pow$1, shift), new $Uint64(0, 2));
			}
			i$2 = i$2 + (1) >> 0;
		}
		d.nd = integerDigits;
		d.dp = d.nd + exp10 >> 0;
		d.neg = f.neg;
		digit$1 = 0;
		multiplier = new $Uint64(0, 1);
		while (true) {
			fraction = $mul64(fraction, (new $Uint64(0, 10)));
			multiplier = $mul64(multiplier, (new $Uint64(0, 10)));
			digit$1 = (($shiftRightUint64(fraction, shift).$low >> 0));
			(x$20 = d.d, x$21 = d.nd, ((x$21 < 0 || x$21 >= x$20.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$20.$array[x$20.$offset + x$21] = (((digit$1 + 48 >> 0) << 24 >>> 24))));
			d.nd = d.nd + (1) >> 0;
			fraction = (x$22 = $shiftLeft64((new $Uint64(0, digit$1)), shift), new $Uint64(fraction.$high - x$22.$high, fraction.$low - x$22.$low));
			if ((x$23 = $mul64(allowance, multiplier), (fraction.$high < x$23.$high || (fraction.$high === x$23.$high && fraction.$low < x$23.$low)))) {
				return adjustLastDigit(d, fraction, $mul64(targetDiff, multiplier), $mul64(allowance, multiplier), $shiftLeft64(new $Uint64(0, 1), shift), $mul64(multiplier, new $Uint64(0, 2)));
			}
		}
	};
	extFloat.prototype.ShortestDecimal = function(d, lower, upper) { return this.$val.ShortestDecimal(d, lower, upper); };
	adjustLastDigit = function(d, currentDiff, targetDiff, maxDiff, ulpDecimal, ulpBinary) {
		var _index, currentDiff, d, maxDiff, targetDiff, ulpBinary, ulpDecimal, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		if ((x = $mul64(new $Uint64(0, 2), ulpBinary), (ulpDecimal.$high < x.$high || (ulpDecimal.$high === x.$high && ulpDecimal.$low < x.$low)))) {
			return false;
		}
		while (true) {
			if (!((x$1 = (x$2 = (x$3 = $div64(ulpDecimal, new $Uint64(0, 2), false), new $Uint64(currentDiff.$high + x$3.$high, currentDiff.$low + x$3.$low)), new $Uint64(x$2.$high + ulpBinary.$high, x$2.$low + ulpBinary.$low)), (x$1.$high < targetDiff.$high || (x$1.$high === targetDiff.$high && x$1.$low < targetDiff.$low))))) { break; }
			_index = d.nd - 1 >> 0;
			(x$5 = d.d, ((_index < 0 || _index >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + _index] = ((x$4 = d.d, ((_index < 0 || _index >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + _index])) - (1) << 24 >>> 24)));
			currentDiff = (x$6 = ulpDecimal, new $Uint64(currentDiff.$high + x$6.$high, currentDiff.$low + x$6.$low));
		}
		if ((x$7 = new $Uint64(currentDiff.$high + ulpDecimal.$high, currentDiff.$low + ulpDecimal.$low), x$8 = (x$9 = (x$10 = $div64(ulpDecimal, new $Uint64(0, 2), false), new $Uint64(targetDiff.$high + x$10.$high, targetDiff.$low + x$10.$low)), new $Uint64(x$9.$high + ulpBinary.$high, x$9.$low + ulpBinary.$low)), (x$7.$high < x$8.$high || (x$7.$high === x$8.$high && x$7.$low <= x$8.$low)))) {
			return false;
		}
		if ((currentDiff.$high < ulpBinary.$high || (currentDiff.$high === ulpBinary.$high && currentDiff.$low < ulpBinary.$low)) || (x$11 = new $Uint64(maxDiff.$high - ulpBinary.$high, maxDiff.$low - ulpBinary.$low), (currentDiff.$high > x$11.$high || (currentDiff.$high === x$11.$high && currentDiff.$low > x$11.$low)))) {
			return false;
		}
		if ((d.nd === 1) && ((x$12 = d.d, (0 >= x$12.$length ? ($throwRuntimeError("index out of range"), undefined) : x$12.$array[x$12.$offset + 0])) === 48)) {
			d.nd = 0;
			d.dp = 0;
		}
		return true;
	};
	FormatFloat = function(f, fmt, prec, bitSize) {
		var bitSize, f, fmt, prec;
		return ($bytesToString(genericFtoa($makeSlice(sliceType$6, 0, max(prec + 4 >> 0, 24)), f, fmt, prec, bitSize)));
	};
	$pkg.FormatFloat = FormatFloat;
	AppendFloat = function(dst, f, fmt, prec, bitSize) {
		var bitSize, dst, f, fmt, prec;
		return genericFtoa(dst, f, fmt, prec, bitSize);
	};
	$pkg.AppendFloat = AppendFloat;
	genericFtoa = function(dst, val, fmt, prec, bitSize) {
		var _1, _2, _3, _4, _tuple, bitSize, bits, buf, buf$1, digits, digs, dst, exp, f, f$1, flt, fmt, lower, mant, neg, ok, prec, s, shortest, upper, val, x, x$1, x$2, x$3, y, y$1;
		bits = new $Uint64(0, 0);
		flt = ptrType$1.nil;
		_1 = bitSize;
		if (_1 === (32)) {
			bits = (new $Uint64(0, math.Float32bits(($fround(val)))));
			flt = float32info;
		} else if (_1 === (64)) {
			bits = math.Float64bits(val);
			flt = float64info;
		} else {
			$panic(new $String("strconv: illegal AppendFloat/FormatFloat bitSize"));
		}
		neg = !((x = $shiftRightUint64(bits, ((flt.expbits + flt.mantbits >>> 0))), (x.$high === 0 && x.$low === 0)));
		exp = (($shiftRightUint64(bits, flt.mantbits).$low >> 0)) & ((((y = flt.expbits, y < 32 ? (1 << y) : 0) >> 0) - 1 >> 0));
		mant = (x$1 = (x$2 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), new $Uint64(x$2.$high - 0, x$2.$low - 1)), new $Uint64(bits.$high & x$1.$high, (bits.$low & x$1.$low) >>> 0));
		_2 = exp;
		if (_2 === ((((y$1 = flt.expbits, y$1 < 32 ? (1 << y$1) : 0) >> 0) - 1 >> 0))) {
			s = "";
			if (!((mant.$high === 0 && mant.$low === 0))) {
				s = "NaN";
			} else if (neg) {
				s = "-Inf";
			} else {
				s = "+Inf";
			}
			return $appendSlice(dst, s);
		} else if (_2 === (0)) {
			exp = exp + (1) >> 0;
		} else {
			mant = (x$3 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), new $Uint64(mant.$high | x$3.$high, (mant.$low | x$3.$low) >>> 0));
		}
		exp = exp + (flt.bias) >> 0;
		if (fmt === 98) {
			return fmtB(dst, neg, mant, exp, flt);
		}
		if (!optimize) {
			return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
		}
		digs = new decimalSlice.ptr(sliceType$6.nil, 0, 0, false);
		ok = false;
		shortest = prec < 0;
		if (shortest) {
			f = new extFloat.ptr(new $Uint64(0, 0), 0, false);
			_tuple = f.AssignComputeBounds(mant, exp, neg, flt);
			lower = $clone(_tuple[0], extFloat);
			upper = $clone(_tuple[1], extFloat);
			buf = arrayType$2.zero();
			digs.d = new sliceType$6(buf);
			ok = f.ShortestDecimal(digs, lower, upper);
			if (!ok) {
				return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
			}
			_3 = fmt;
			if ((_3 === (101)) || (_3 === (69))) {
				prec = max(digs.nd - 1 >> 0, 0);
			} else if (_3 === (102)) {
				prec = max(digs.nd - digs.dp >> 0, 0);
			} else if ((_3 === (103)) || (_3 === (71))) {
				prec = digs.nd;
			}
		} else if (!((fmt === 102))) {
			digits = prec;
			_4 = fmt;
			if ((_4 === (101)) || (_4 === (69))) {
				digits = digits + (1) >> 0;
			} else if ((_4 === (103)) || (_4 === (71))) {
				if (prec === 0) {
					prec = 1;
				}
				digits = prec;
			}
			if (digits <= 15) {
				buf$1 = arrayType$1.zero();
				digs.d = new sliceType$6(buf$1);
				f$1 = new extFloat.ptr(mant, exp - ((flt.mantbits >> 0)) >> 0, neg);
				ok = f$1.FixedDecimal(digs, digits);
			}
		}
		if (!ok) {
			return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
		}
		return formatDigits(dst, shortest, neg, $clone(digs, decimalSlice), prec, fmt);
	};
	bigFtoa = function(dst, prec, fmt, neg, mant, exp, flt) {
		var _1, _2, d, digs, dst, exp, flt, fmt, mant, neg, prec, shortest;
		d = new decimal.ptr(arrayType.zero(), 0, 0, false, false);
		d.Assign(mant);
		d.Shift(exp - ((flt.mantbits >> 0)) >> 0);
		digs = new decimalSlice.ptr(sliceType$6.nil, 0, 0, false);
		shortest = prec < 0;
		if (shortest) {
			roundShortest(d, mant, exp, flt);
			decimalSlice.copy(digs, new decimalSlice.ptr(new sliceType$6(d.d), d.nd, d.dp, false));
			_1 = fmt;
			if ((_1 === (101)) || (_1 === (69))) {
				prec = digs.nd - 1 >> 0;
			} else if (_1 === (102)) {
				prec = max(digs.nd - digs.dp >> 0, 0);
			} else if ((_1 === (103)) || (_1 === (71))) {
				prec = digs.nd;
			}
		} else {
			_2 = fmt;
			if ((_2 === (101)) || (_2 === (69))) {
				d.Round(prec + 1 >> 0);
			} else if (_2 === (102)) {
				d.Round(d.dp + prec >> 0);
			} else if ((_2 === (103)) || (_2 === (71))) {
				if (prec === 0) {
					prec = 1;
				}
				d.Round(prec);
			}
			decimalSlice.copy(digs, new decimalSlice.ptr(new sliceType$6(d.d), d.nd, d.dp, false));
		}
		return formatDigits(dst, shortest, neg, $clone(digs, decimalSlice), prec, fmt);
	};
	formatDigits = function(dst, shortest, neg, digs, prec, fmt) {
		var _1, digs, dst, eprec, exp, fmt, neg, prec, shortest;
		_1 = fmt;
		if ((_1 === (101)) || (_1 === (69))) {
			return fmtE(dst, neg, $clone(digs, decimalSlice), prec, fmt);
		} else if (_1 === (102)) {
			return fmtF(dst, neg, $clone(digs, decimalSlice), prec);
		} else if ((_1 === (103)) || (_1 === (71))) {
			eprec = prec;
			if (eprec > digs.nd && digs.nd >= digs.dp) {
				eprec = digs.nd;
			}
			if (shortest) {
				eprec = 6;
			}
			exp = digs.dp - 1 >> 0;
			if (exp < -4 || exp >= eprec) {
				if (prec > digs.nd) {
					prec = digs.nd;
				}
				return fmtE(dst, neg, $clone(digs, decimalSlice), prec - 1 >> 0, (fmt + 101 << 24 >>> 24) - 103 << 24 >>> 24);
			}
			if (prec > digs.dp) {
				prec = digs.nd;
			}
			return fmtF(dst, neg, $clone(digs, decimalSlice), max(prec - digs.dp >> 0, 0));
		}
		return $append(dst, 37, fmt);
	};
	roundShortest = function(d, mant, exp, flt) {
		var d, exp, explo, flt, i, inclusive, l, lower, m, mant, mantlo, minexp, okdown, okup, u, upper, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7;
		if ((mant.$high === 0 && mant.$low === 0)) {
			d.nd = 0;
			return;
		}
		minexp = flt.bias + 1 >> 0;
		if (exp > minexp && ($imul(332, ((d.dp - d.nd >> 0)))) >= ($imul(100, ((exp - ((flt.mantbits >> 0)) >> 0))))) {
			return;
		}
		upper = new decimal.ptr(arrayType.zero(), 0, 0, false, false);
		upper.Assign((x = $mul64(mant, new $Uint64(0, 2)), new $Uint64(x.$high + 0, x.$low + 1)));
		upper.Shift((exp - ((flt.mantbits >> 0)) >> 0) - 1 >> 0);
		mantlo = new $Uint64(0, 0);
		explo = 0;
		if ((x$1 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), (mant.$high > x$1.$high || (mant.$high === x$1.$high && mant.$low > x$1.$low))) || (exp === minexp)) {
			mantlo = new $Uint64(mant.$high - 0, mant.$low - 1);
			explo = exp;
		} else {
			mantlo = (x$2 = $mul64(mant, new $Uint64(0, 2)), new $Uint64(x$2.$high - 0, x$2.$low - 1));
			explo = exp - 1 >> 0;
		}
		lower = new decimal.ptr(arrayType.zero(), 0, 0, false, false);
		lower.Assign((x$3 = $mul64(mantlo, new $Uint64(0, 2)), new $Uint64(x$3.$high + 0, x$3.$low + 1)));
		lower.Shift((explo - ((flt.mantbits >> 0)) >> 0) - 1 >> 0);
		inclusive = (x$4 = $div64(mant, new $Uint64(0, 2), true), (x$4.$high === 0 && x$4.$low === 0));
		i = 0;
		while (true) {
			if (!(i < d.nd)) { break; }
			l = 48;
			if (i < lower.nd) {
				l = (x$5 = lower.d, ((i < 0 || i >= x$5.length) ? ($throwRuntimeError("index out of range"), undefined) : x$5[i]));
			}
			m = (x$6 = d.d, ((i < 0 || i >= x$6.length) ? ($throwRuntimeError("index out of range"), undefined) : x$6[i]));
			u = 48;
			if (i < upper.nd) {
				u = (x$7 = upper.d, ((i < 0 || i >= x$7.length) ? ($throwRuntimeError("index out of range"), undefined) : x$7[i]));
			}
			okdown = !((l === m)) || inclusive && ((i + 1 >> 0) === lower.nd);
			okup = !((m === u)) && (inclusive || (m + 1 << 24 >>> 24) < u || (i + 1 >> 0) < upper.nd);
			if (okdown && okup) {
				d.Round(i + 1 >> 0);
				return;
			} else if (okdown) {
				d.RoundDown(i + 1 >> 0);
				return;
			} else if (okup) {
				d.RoundUp(i + 1 >> 0);
				return;
			}
			i = i + (1) >> 0;
		}
	};
	fmtE = function(dst, neg, d, prec, fmt) {
		var _q, _q$1, _q$2, _r, _r$1, _r$2, ch, d, dst, exp, fmt, i, m, neg, prec, x;
		if (neg) {
			dst = $append(dst, 45);
		}
		ch = 48;
		if (!((d.nd === 0))) {
			ch = (x = d.d, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
		}
		dst = $append(dst, ch);
		if (prec > 0) {
			dst = $append(dst, 46);
			i = 1;
			m = min(d.nd, prec + 1 >> 0);
			if (i < m) {
				dst = $appendSlice(dst, $subslice(d.d, i, m));
				i = m;
			}
			while (true) {
				if (!(i <= prec)) { break; }
				dst = $append(dst, 48);
				i = i + (1) >> 0;
			}
		}
		dst = $append(dst, fmt);
		exp = d.dp - 1 >> 0;
		if (d.nd === 0) {
			exp = 0;
		}
		if (exp < 0) {
			ch = 45;
			exp = -exp;
		} else {
			ch = 43;
		}
		dst = $append(dst, ch);
		if (exp < 10) {
			dst = $append(dst, 48, ((exp << 24 >>> 24)) + 48 << 24 >>> 24);
		} else if (exp < 100) {
			dst = $append(dst, (((_q = exp / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) << 24 >>> 24)) + 48 << 24 >>> 24, (((_r = exp % 10, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) << 24 >>> 24)) + 48 << 24 >>> 24);
		} else {
			dst = $append(dst, (((_q$1 = exp / 100, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")) << 24 >>> 24)) + 48 << 24 >>> 24, (_r$1 = (((_q$2 = exp / 10, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero")) << 24 >>> 24)) % 10, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) + 48 << 24 >>> 24, (((_r$2 = exp % 10, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero")) << 24 >>> 24)) + 48 << 24 >>> 24);
		}
		return dst;
	};
	fmtF = function(dst, neg, d, prec) {
		var ch, d, dst, i, j, m, neg, prec, x;
		if (neg) {
			dst = $append(dst, 45);
		}
		if (d.dp > 0) {
			m = min(d.nd, d.dp);
			dst = $appendSlice(dst, $subslice(d.d, 0, m));
			while (true) {
				if (!(m < d.dp)) { break; }
				dst = $append(dst, 48);
				m = m + (1) >> 0;
			}
		} else {
			dst = $append(dst, 48);
		}
		if (prec > 0) {
			dst = $append(dst, 46);
			i = 0;
			while (true) {
				if (!(i < prec)) { break; }
				ch = 48;
				j = d.dp + i >> 0;
				if (0 <= j && j < d.nd) {
					ch = (x = d.d, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]));
				}
				dst = $append(dst, ch);
				i = i + (1) >> 0;
			}
		}
		return dst;
	};
	fmtB = function(dst, neg, mant, exp, flt) {
		var _tuple, _tuple$1, dst, exp, flt, mant, neg;
		if (neg) {
			dst = $append(dst, 45);
		}
		_tuple = formatBits(dst, mant, 10, false, true);
		dst = _tuple[0];
		dst = $append(dst, 112);
		exp = exp - (((flt.mantbits >> 0))) >> 0;
		if (exp >= 0) {
			dst = $append(dst, 43);
		}
		_tuple$1 = formatBits(dst, (new $Uint64(0, exp)), 10, exp < 0, true);
		dst = _tuple$1[0];
		return dst;
	};
	min = function(a, b) {
		var a, b;
		if (a < b) {
			return a;
		}
		return b;
	};
	max = function(a, b) {
		var a, b;
		if (a > b) {
			return a;
		}
		return b;
	};
	FormatUint = function(i, base) {
		var _tuple, base, i, s;
		if (true && (i.$high < 0 || (i.$high === 0 && i.$low < 100)) && (base === 10)) {
			return small(((i.$low >> 0)));
		}
		_tuple = formatBits(sliceType$6.nil, i, base, false, false);
		s = _tuple[1];
		return s;
	};
	$pkg.FormatUint = FormatUint;
	FormatInt = function(i, base) {
		var _tuple, base, i, s;
		if (true && (0 < i.$high || (0 === i.$high && 0 <= i.$low)) && (i.$high < 0 || (i.$high === 0 && i.$low < 100)) && (base === 10)) {
			return small((((i.$low + ((i.$high >> 31) * 4294967296)) >> 0)));
		}
		_tuple = formatBits(sliceType$6.nil, (new $Uint64(i.$high, i.$low)), base, (i.$high < 0 || (i.$high === 0 && i.$low < 0)), false);
		s = _tuple[1];
		return s;
	};
	$pkg.FormatInt = FormatInt;
	Itoa = function(i) {
		var i;
		return FormatInt((new $Int64(0, i)), 10);
	};
	$pkg.Itoa = Itoa;
	AppendInt = function(dst, i, base) {
		var _tuple, base, dst, i;
		if (true && (0 < i.$high || (0 === i.$high && 0 <= i.$low)) && (i.$high < 0 || (i.$high === 0 && i.$low < 100)) && (base === 10)) {
			return $appendSlice(dst, small((((i.$low + ((i.$high >> 31) * 4294967296)) >> 0))));
		}
		_tuple = formatBits(dst, (new $Uint64(i.$high, i.$low)), base, (i.$high < 0 || (i.$high === 0 && i.$low < 0)), true);
		dst = _tuple[0];
		return dst;
	};
	$pkg.AppendInt = AppendInt;
	AppendUint = function(dst, i, base) {
		var _tuple, base, dst, i;
		if (true && (i.$high < 0 || (i.$high === 0 && i.$low < 100)) && (base === 10)) {
			return $appendSlice(dst, small(((i.$low >> 0))));
		}
		_tuple = formatBits(dst, i, base, false, true);
		dst = _tuple[0];
		return dst;
	};
	$pkg.AppendUint = AppendUint;
	small = function(i) {
		var i, off;
		off = 0;
		if (i < 10) {
			off = 1;
		}
		return $substring("00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", (($imul(i, 2)) + off >> 0), (($imul(i, 2)) + 2 >> 0));
	};
	formatBits = function(dst, u, base, neg, append_) {
		var _q, _q$1, _r, _r$1, a, append_, b, b$1, base, d, dst, i, is, is$1, is$2, j, m, neg, q, q$1, s, s$1, u, us, us$1, x, x$1, x$2, x$3, x$4, x$5;
		d = sliceType$6.nil;
		s = "";
		if (base < 2 || base > 36) {
			$panic(new $String("strconv: illegal AppendInt/FormatInt base"));
		}
		a = arrayType$3.zero();
		i = 65;
		if (neg) {
			u = new $Uint64(-u.$high, -u.$low);
		}
		if (base === 10) {
			if (true) {
				while (true) {
					if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 1000000000)))) { break; }
					q = $div64(u, new $Uint64(0, 1000000000), false);
					us = (((x = $mul64(q, new $Uint64(0, 1000000000)), new $Uint64(u.$high - x.$high, u.$low - x.$low)).$low >>> 0));
					j = 4;
					while (true) {
						if (!(j > 0)) { break; }
						is = (_r = us % 100, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) * 2 >>> 0;
						us = (_q = us / (100), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
						i = i - (2) >> 0;
						(x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$1] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is + 1 >>> 0))));
						(x$2 = i + 0 >> 0, ((x$2 < 0 || x$2 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$2] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is + 0 >>> 0))));
						j = j - (1) >> 0;
					}
					i = i - (1) >> 0;
					((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(((us * 2 >>> 0) + 1 >>> 0)));
					u = q;
				}
			}
			us$1 = ((u.$low >>> 0));
			while (true) {
				if (!(us$1 >= 100)) { break; }
				is$1 = (_r$1 = us$1 % 100, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) * 2 >>> 0;
				us$1 = (_q$1 = us$1 / (100), (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
				i = i - (2) >> 0;
				(x$3 = i + 1 >> 0, ((x$3 < 0 || x$3 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$3] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$1 + 1 >>> 0))));
				(x$4 = i + 0 >> 0, ((x$4 < 0 || x$4 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$4] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$1 + 0 >>> 0))));
			}
			is$2 = us$1 * 2 >>> 0;
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$2 + 1 >>> 0)));
			if (us$1 >= 10) {
				i = i - (1) >> 0;
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(is$2));
			}
		} else {
			s$1 = ((base < 0 || base >= shifts.length) ? ($throwRuntimeError("index out of range"), undefined) : shifts[base]);
			if (s$1 > 0) {
				b = (new $Uint64(0, base));
				m = ((base >>> 0)) - 1 >>> 0;
				while (true) {
					if (!((u.$high > b.$high || (u.$high === b.$high && u.$low >= b.$low)))) { break; }
					i = i - (1) >> 0;
					((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((((u.$low >>> 0)) & m) >>> 0)));
					u = $shiftRightUint64(u, (s$1));
				}
				i = i - (1) >> 0;
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((u.$low >>> 0))));
			} else {
				b$1 = (new $Uint64(0, base));
				while (true) {
					if (!((u.$high > b$1.$high || (u.$high === b$1.$high && u.$low >= b$1.$low)))) { break; }
					i = i - (1) >> 0;
					q$1 = $div64(u, b$1, false);
					((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt((((x$5 = $mul64(q$1, b$1), new $Uint64(u.$high - x$5.$high, u.$low - x$5.$low)).$low >>> 0))));
					u = q$1;
				}
				i = i - (1) >> 0;
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((u.$low >>> 0))));
			}
		}
		if (neg) {
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = 45);
		}
		if (append_) {
			d = $appendSlice(dst, $subslice(new sliceType$6(a), i));
			return [d, s];
		}
		s = ($bytesToString($subslice(new sliceType$6(a), i)));
		return [d, s];
	};
	quoteWith = function(s, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _q, graphicOnly, quote, s;
		return ($bytesToString(appendQuotedWith($makeSlice(sliceType$6, 0, (_q = ($imul(3, s.length)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"))), s, quote, ASCIIonly, graphicOnly)));
	};
	appendQuotedWith = function(buf, s, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _tuple, buf, graphicOnly, quote, r, s, width;
		buf = $append(buf, quote);
		width = 0;
		while (true) {
			if (!(s.length > 0)) { break; }
			r = ((s.charCodeAt(0) >> 0));
			width = 1;
			if (r >= 128) {
				_tuple = utf8.DecodeRuneInString(s);
				r = _tuple[0];
				width = _tuple[1];
			}
			if ((width === 1) && (r === 65533)) {
				buf = $appendSlice(buf, "\\x");
				buf = $append(buf, "0123456789abcdef".charCodeAt((s.charCodeAt(0) >>> 4 << 24 >>> 24)));
				buf = $append(buf, "0123456789abcdef".charCodeAt(((s.charCodeAt(0) & 15) >>> 0)));
				s = $substring(s, width);
				continue;
			}
			buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
			s = $substring(s, width);
		}
		buf = $append(buf, quote);
		return buf;
	};
	appendQuotedRuneWith = function(buf, r, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, buf, graphicOnly, quote, r;
		buf = $append(buf, quote);
		if (!utf8.ValidRune(r)) {
			r = 65533;
		}
		buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
		buf = $append(buf, quote);
		return buf;
	};
	appendEscapedRune = function(buf, r, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _1, buf, graphicOnly, n, quote, r, runeTmp, s, s$1;
		runeTmp = arrayType$4.zero();
		if ((r === ((quote >> 0))) || (r === 92)) {
			buf = $append(buf, 92);
			buf = $append(buf, ((r << 24 >>> 24)));
			return buf;
		}
		if (ASCIIonly) {
			if (r < 128 && IsPrint(r)) {
				buf = $append(buf, ((r << 24 >>> 24)));
				return buf;
			}
		} else if (IsPrint(r) || graphicOnly && isInGraphicList(r)) {
			n = utf8.EncodeRune(new sliceType$6(runeTmp), r);
			buf = $appendSlice(buf, $subslice(new sliceType$6(runeTmp), 0, n));
			return buf;
		}
		_1 = r;
		if (_1 === (7)) {
			buf = $appendSlice(buf, "\\a");
		} else if (_1 === (8)) {
			buf = $appendSlice(buf, "\\b");
		} else if (_1 === (12)) {
			buf = $appendSlice(buf, "\\f");
		} else if (_1 === (10)) {
			buf = $appendSlice(buf, "\\n");
		} else if (_1 === (13)) {
			buf = $appendSlice(buf, "\\r");
		} else if (_1 === (9)) {
			buf = $appendSlice(buf, "\\t");
		} else if (_1 === (11)) {
			buf = $appendSlice(buf, "\\v");
		} else {
			if (r < 32) {
				buf = $appendSlice(buf, "\\x");
				buf = $append(buf, "0123456789abcdef".charCodeAt((((r << 24 >>> 24)) >>> 4 << 24 >>> 24)));
				buf = $append(buf, "0123456789abcdef".charCodeAt(((((r << 24 >>> 24)) & 15) >>> 0)));
			} else if (r > 1114111) {
				r = 65533;
				buf = $appendSlice(buf, "\\u");
				s = 12;
				while (true) {
					if (!(s >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s >>> 0)), 31)) >> 0) & 15)));
					s = s - (4) >> 0;
				}
			} else if (r < 65536) {
				buf = $appendSlice(buf, "\\u");
				s = 12;
				while (true) {
					if (!(s >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s >>> 0)), 31)) >> 0) & 15)));
					s = s - (4) >> 0;
				}
			} else {
				buf = $appendSlice(buf, "\\U");
				s$1 = 28;
				while (true) {
					if (!(s$1 >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s$1 >>> 0)), 31)) >> 0) & 15)));
					s$1 = s$1 - (4) >> 0;
				}
			}
		}
		return buf;
	};
	Quote = function(s) {
		var s;
		return quoteWith(s, 34, false, false);
	};
	$pkg.Quote = Quote;
	AppendQuote = function(dst, s) {
		var dst, s;
		return appendQuotedWith(dst, s, 34, false, false);
	};
	$pkg.AppendQuote = AppendQuote;
	QuoteToASCII = function(s) {
		var s;
		return quoteWith(s, 34, true, false);
	};
	$pkg.QuoteToASCII = QuoteToASCII;
	AppendQuoteToASCII = function(dst, s) {
		var dst, s;
		return appendQuotedWith(dst, s, 34, true, false);
	};
	$pkg.AppendQuoteToASCII = AppendQuoteToASCII;
	AppendQuoteRune = function(dst, r) {
		var dst, r;
		return appendQuotedRuneWith(dst, r, 39, false, false);
	};
	$pkg.AppendQuoteRune = AppendQuoteRune;
	AppendQuoteRuneToASCII = function(dst, r) {
		var dst, r;
		return appendQuotedRuneWith(dst, r, 39, true, false);
	};
	$pkg.AppendQuoteRuneToASCII = AppendQuoteRuneToASCII;
	CanBackquote = function(s) {
		var _tuple, r, s, wid;
		while (true) {
			if (!(s.length > 0)) { break; }
			_tuple = utf8.DecodeRuneInString(s);
			r = _tuple[0];
			wid = _tuple[1];
			s = $substring(s, wid);
			if (wid > 1) {
				if (r === 65279) {
					return false;
				}
				continue;
			}
			if (r === 65533) {
				return false;
			}
			if ((r < 32 && !((r === 9))) || (r === 96) || (r === 127)) {
				return false;
			}
		}
		return true;
	};
	$pkg.CanBackquote = CanBackquote;
	unhex = function(b) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, c, ok, v;
		v = 0;
		ok = false;
		c = ((b >> 0));
		if (48 <= c && c <= 57) {
			_tmp = c - 48 >> 0;
			_tmp$1 = true;
			v = _tmp;
			ok = _tmp$1;
			return [v, ok];
		} else if (97 <= c && c <= 102) {
			_tmp$2 = (c - 97 >> 0) + 10 >> 0;
			_tmp$3 = true;
			v = _tmp$2;
			ok = _tmp$3;
			return [v, ok];
		} else if (65 <= c && c <= 70) {
			_tmp$4 = (c - 65 >> 0) + 10 >> 0;
			_tmp$5 = true;
			v = _tmp$4;
			ok = _tmp$5;
			return [v, ok];
		}
		return [v, ok];
	};
	UnquoteChar = function(s, quote) {
		var _1, _2, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, c, c$1, err, j, j$1, multibyte, n, ok, quote, r, s, size, tail, v, v$1, value, x, x$1;
		value = 0;
		multibyte = false;
		tail = "";
		err = $ifaceNil;
		c = s.charCodeAt(0);
		if ((c === quote) && ((quote === 39) || (quote === 34))) {
			err = $pkg.ErrSyntax;
			return [value, multibyte, tail, err];
		} else if (c >= 128) {
			_tuple = utf8.DecodeRuneInString(s);
			r = _tuple[0];
			size = _tuple[1];
			_tmp = r;
			_tmp$1 = true;
			_tmp$2 = $substring(s, size);
			_tmp$3 = $ifaceNil;
			value = _tmp;
			multibyte = _tmp$1;
			tail = _tmp$2;
			err = _tmp$3;
			return [value, multibyte, tail, err];
		} else if (!((c === 92))) {
			_tmp$4 = ((s.charCodeAt(0) >> 0));
			_tmp$5 = false;
			_tmp$6 = $substring(s, 1);
			_tmp$7 = $ifaceNil;
			value = _tmp$4;
			multibyte = _tmp$5;
			tail = _tmp$6;
			err = _tmp$7;
			return [value, multibyte, tail, err];
		}
		if (s.length <= 1) {
			err = $pkg.ErrSyntax;
			return [value, multibyte, tail, err];
		}
		c$1 = s.charCodeAt(1);
		s = $substring(s, 2);
		switch (0) { default:
			_1 = c$1;
			if (_1 === (97)) {
				value = 7;
			} else if (_1 === (98)) {
				value = 8;
			} else if (_1 === (102)) {
				value = 12;
			} else if (_1 === (110)) {
				value = 10;
			} else if (_1 === (114)) {
				value = 13;
			} else if (_1 === (116)) {
				value = 9;
			} else if (_1 === (118)) {
				value = 11;
			} else if ((_1 === (120)) || (_1 === (117)) || (_1 === (85))) {
				n = 0;
				_2 = c$1;
				if (_2 === (120)) {
					n = 2;
				} else if (_2 === (117)) {
					n = 4;
				} else if (_2 === (85)) {
					n = 8;
				}
				v = 0;
				if (s.length < n) {
					err = $pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				j = 0;
				while (true) {
					if (!(j < n)) { break; }
					_tuple$1 = unhex(s.charCodeAt(j));
					x = _tuple$1[0];
					ok = _tuple$1[1];
					if (!ok) {
						err = $pkg.ErrSyntax;
						return [value, multibyte, tail, err];
					}
					v = (v << 4 >> 0) | x;
					j = j + (1) >> 0;
				}
				s = $substring(s, n);
				if (c$1 === 120) {
					value = v;
					break;
				}
				if (v > 1114111) {
					err = $pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				value = v;
				multibyte = true;
			} else if ((_1 === (48)) || (_1 === (49)) || (_1 === (50)) || (_1 === (51)) || (_1 === (52)) || (_1 === (53)) || (_1 === (54)) || (_1 === (55))) {
				v$1 = ((c$1 >> 0)) - 48 >> 0;
				if (s.length < 2) {
					err = $pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				j$1 = 0;
				while (true) {
					if (!(j$1 < 2)) { break; }
					x$1 = ((s.charCodeAt(j$1) >> 0)) - 48 >> 0;
					if (x$1 < 0 || x$1 > 7) {
						err = $pkg.ErrSyntax;
						return [value, multibyte, tail, err];
					}
					v$1 = ((v$1 << 3 >> 0)) | x$1;
					j$1 = j$1 + (1) >> 0;
				}
				s = $substring(s, 2);
				if (v$1 > 255) {
					err = $pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				value = v$1;
			} else if (_1 === (92)) {
				value = 92;
			} else if ((_1 === (39)) || (_1 === (34))) {
				if (!((c$1 === quote))) {
					err = $pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				value = ((c$1 >> 0));
			} else {
				err = $pkg.ErrSyntax;
				return [value, multibyte, tail, err];
			}
		}
		tail = s;
		return [value, multibyte, tail, err];
	};
	$pkg.UnquoteChar = UnquoteChar;
	Unquote = function(s) {
		var _1, _q, _tuple, _tuple$1, buf, buf$1, c, err, i, multibyte, n, n$1, quote, r, runeTmp, s, size, ss;
		n = s.length;
		if (n < 2) {
			return ["", $pkg.ErrSyntax];
		}
		quote = s.charCodeAt(0);
		if (!((quote === s.charCodeAt((n - 1 >> 0))))) {
			return ["", $pkg.ErrSyntax];
		}
		s = $substring(s, 1, (n - 1 >> 0));
		if (quote === 96) {
			if (contains(s, 96)) {
				return ["", $pkg.ErrSyntax];
			}
			if (contains(s, 13)) {
				buf = $makeSlice(sliceType$6, 0, (s.length - 1 >> 0));
				i = 0;
				while (true) {
					if (!(i < s.length)) { break; }
					if (!((s.charCodeAt(i) === 13))) {
						buf = $append(buf, s.charCodeAt(i));
					}
					i = i + (1) >> 0;
				}
				return [($bytesToString(buf)), $ifaceNil];
			}
			return [s, $ifaceNil];
		}
		if (!((quote === 34)) && !((quote === 39))) {
			return ["", $pkg.ErrSyntax];
		}
		if (contains(s, 10)) {
			return ["", $pkg.ErrSyntax];
		}
		if (!contains(s, 92) && !contains(s, quote)) {
			_1 = quote;
			if (_1 === (34)) {
				return [s, $ifaceNil];
			} else if (_1 === (39)) {
				_tuple = utf8.DecodeRuneInString(s);
				r = _tuple[0];
				size = _tuple[1];
				if ((size === s.length) && (!((r === 65533)) || !((size === 1)))) {
					return [s, $ifaceNil];
				}
			}
		}
		runeTmp = arrayType$4.zero();
		buf$1 = $makeSlice(sliceType$6, 0, (_q = ($imul(3, s.length)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")));
		while (true) {
			if (!(s.length > 0)) { break; }
			_tuple$1 = UnquoteChar(s, quote);
			c = _tuple$1[0];
			multibyte = _tuple$1[1];
			ss = _tuple$1[2];
			err = _tuple$1[3];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				return ["", err];
			}
			s = ss;
			if (c < 128 || !multibyte) {
				buf$1 = $append(buf$1, ((c << 24 >>> 24)));
			} else {
				n$1 = utf8.EncodeRune(new sliceType$6(runeTmp), c);
				buf$1 = $appendSlice(buf$1, $subslice(new sliceType$6(runeTmp), 0, n$1));
			}
			if ((quote === 39) && !((s.length === 0))) {
				return ["", $pkg.ErrSyntax];
			}
		}
		return [($bytesToString(buf$1)), $ifaceNil];
	};
	$pkg.Unquote = Unquote;
	contains = function(s, c) {
		var c, i, s;
		i = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			if (s.charCodeAt(i) === c) {
				return true;
			}
			i = i + (1) >> 0;
		}
		return false;
	};
	bsearch16 = function(a, x) {
		var _q, _tmp, _tmp$1, a, h, i, j, x;
		_tmp = 0;
		_tmp$1 = a.$length;
		i = _tmp;
		j = _tmp$1;
		while (true) {
			if (!(i < j)) { break; }
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((h < 0 || h >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + h]) < x) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		return i;
	};
	bsearch32 = function(a, x) {
		var _q, _tmp, _tmp$1, a, h, i, j, x;
		_tmp = 0;
		_tmp$1 = a.$length;
		i = _tmp;
		j = _tmp$1;
		while (true) {
			if (!(i < j)) { break; }
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((h < 0 || h >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + h]) < x) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		return i;
	};
	IsPrint = function(r) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, i, i$1, isNotPrint, isNotPrint$1, isPrint, isPrint$1, j, j$1, r, rr, rr$1, x, x$1, x$2, x$3;
		if (r <= 255) {
			if (32 <= r && r <= 126) {
				return true;
			}
			if (161 <= r && r <= 255) {
				return !((r === 173));
			}
			return false;
		}
		if (0 <= r && r < 65536) {
			_tmp = ((r << 16 >>> 16));
			_tmp$1 = isPrint16;
			_tmp$2 = isNotPrint16;
			rr = _tmp;
			isPrint = _tmp$1;
			isNotPrint = _tmp$2;
			i = bsearch16(isPrint, rr);
			if (i >= isPrint.$length || rr < (x = (i & ~1) >> 0, ((x < 0 || x >= isPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint.$array[isPrint.$offset + x])) || (x$1 = i | 1, ((x$1 < 0 || x$1 >= isPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint.$array[isPrint.$offset + x$1])) < rr) {
				return false;
			}
			j = bsearch16(isNotPrint, rr);
			return j >= isNotPrint.$length || !((((j < 0 || j >= isNotPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isNotPrint.$array[isNotPrint.$offset + j]) === rr));
		}
		_tmp$3 = ((r >>> 0));
		_tmp$4 = isPrint32;
		_tmp$5 = isNotPrint32;
		rr$1 = _tmp$3;
		isPrint$1 = _tmp$4;
		isNotPrint$1 = _tmp$5;
		i$1 = bsearch32(isPrint$1, rr$1);
		if (i$1 >= isPrint$1.$length || rr$1 < (x$2 = (i$1 & ~1) >> 0, ((x$2 < 0 || x$2 >= isPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint$1.$array[isPrint$1.$offset + x$2])) || (x$3 = i$1 | 1, ((x$3 < 0 || x$3 >= isPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint$1.$array[isPrint$1.$offset + x$3])) < rr$1) {
			return false;
		}
		if (r >= 131072) {
			return true;
		}
		r = r - (65536) >> 0;
		j$1 = bsearch16(isNotPrint$1, ((r << 16 >>> 16)));
		return j$1 >= isNotPrint$1.$length || !((((j$1 < 0 || j$1 >= isNotPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isNotPrint$1.$array[isNotPrint$1.$offset + j$1]) === ((r << 16 >>> 16))));
	};
	$pkg.IsPrint = IsPrint;
	isInGraphicList = function(r) {
		var i, r, rr;
		if (r > 65535) {
			return false;
		}
		rr = ((r << 16 >>> 16));
		i = bsearch16(isGraphic, rr);
		return i < isGraphic.$length && (rr === ((i < 0 || i >= isGraphic.$length) ? ($throwRuntimeError("index out of range"), undefined) : isGraphic.$array[isGraphic.$offset + i]));
	};
	ptrType.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$2.methods = [{prop: "set", name: "set", pkg: "strconv", typ: $funcType([$String], [$Bool], false)}, {prop: "floatBits", name: "floatBits", pkg: "strconv", typ: $funcType([ptrType$1], [$Uint64, $Bool], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Assign", name: "Assign", pkg: "", typ: $funcType([$Uint64], [], false)}, {prop: "Shift", name: "Shift", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Round", name: "Round", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "RoundDown", name: "RoundDown", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "RoundUp", name: "RoundUp", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "RoundedInteger", name: "RoundedInteger", pkg: "", typ: $funcType([], [$Uint64], false)}];
	ptrType$4.methods = [{prop: "floatBits", name: "floatBits", pkg: "strconv", typ: $funcType([ptrType$1], [$Uint64, $Bool], false)}, {prop: "AssignComputeBounds", name: "AssignComputeBounds", pkg: "", typ: $funcType([$Uint64, $Int, $Bool, ptrType$1], [extFloat, extFloat], false)}, {prop: "Normalize", name: "Normalize", pkg: "", typ: $funcType([], [$Uint], false)}, {prop: "Multiply", name: "Multiply", pkg: "", typ: $funcType([extFloat], [], false)}, {prop: "AssignDecimal", name: "AssignDecimal", pkg: "", typ: $funcType([$Uint64, $Int, $Bool, $Bool, ptrType$1], [$Bool], false)}, {prop: "frexp10", name: "frexp10", pkg: "strconv", typ: $funcType([], [$Int, $Int], false)}, {prop: "FixedDecimal", name: "FixedDecimal", pkg: "", typ: $funcType([ptrType$3, $Int], [$Bool], false)}, {prop: "ShortestDecimal", name: "ShortestDecimal", pkg: "", typ: $funcType([ptrType$3, ptrType$4, ptrType$4], [$Bool], false)}];
	NumError.init("", [{prop: "Func", name: "Func", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Num", name: "Num", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Err", name: "Err", anonymous: false, exported: true, typ: $error, tag: ""}]);
	decimal.init("strconv", [{prop: "d", name: "d", anonymous: false, exported: false, typ: arrayType, tag: ""}, {prop: "nd", name: "nd", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "dp", name: "dp", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "neg", name: "neg", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "trunc", name: "trunc", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	leftCheat.init("strconv", [{prop: "delta", name: "delta", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "cutoff", name: "cutoff", anonymous: false, exported: false, typ: $String, tag: ""}]);
	extFloat.init("strconv", [{prop: "mant", name: "mant", anonymous: false, exported: false, typ: $Uint64, tag: ""}, {prop: "exp", name: "exp", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "neg", name: "neg", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	floatInfo.init("strconv", [{prop: "mantbits", name: "mantbits", anonymous: false, exported: false, typ: $Uint, tag: ""}, {prop: "expbits", name: "expbits", anonymous: false, exported: false, typ: $Uint, tag: ""}, {prop: "bias", name: "bias", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	decimalSlice.init("strconv", [{prop: "d", name: "d", anonymous: false, exported: false, typ: sliceType$6, tag: ""}, {prop: "nd", name: "nd", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "dp", name: "dp", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "neg", name: "neg", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		optimize = true;
		powtab = new sliceType([1, 3, 6, 9, 13, 16, 19, 23, 26]);
		float64pow10 = new sliceType$1([1, 10, 100, 1000, 10000, 100000, 1e+06, 1e+07, 1e+08, 1e+09, 1e+10, 1e+11, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16, 1e+17, 1e+18, 1e+19, 1e+20, 1e+21, 1e+22]);
		float32pow10 = new sliceType$2([1, 10, 100, 1000, 10000, 100000, 1e+06, 1e+07, 1e+08, 1e+09, 1e+10]);
		$pkg.ErrRange = errors.New("value out of range");
		$pkg.ErrSyntax = errors.New("invalid syntax");
		leftcheats = new sliceType$3([new leftCheat.ptr(0, ""), new leftCheat.ptr(1, "5"), new leftCheat.ptr(1, "25"), new leftCheat.ptr(1, "125"), new leftCheat.ptr(2, "625"), new leftCheat.ptr(2, "3125"), new leftCheat.ptr(2, "15625"), new leftCheat.ptr(3, "78125"), new leftCheat.ptr(3, "390625"), new leftCheat.ptr(3, "1953125"), new leftCheat.ptr(4, "9765625"), new leftCheat.ptr(4, "48828125"), new leftCheat.ptr(4, "244140625"), new leftCheat.ptr(4, "1220703125"), new leftCheat.ptr(5, "6103515625"), new leftCheat.ptr(5, "30517578125"), new leftCheat.ptr(5, "152587890625"), new leftCheat.ptr(6, "762939453125"), new leftCheat.ptr(6, "3814697265625"), new leftCheat.ptr(6, "19073486328125"), new leftCheat.ptr(7, "95367431640625"), new leftCheat.ptr(7, "476837158203125"), new leftCheat.ptr(7, "2384185791015625"), new leftCheat.ptr(7, "11920928955078125"), new leftCheat.ptr(8, "59604644775390625"), new leftCheat.ptr(8, "298023223876953125"), new leftCheat.ptr(8, "1490116119384765625"), new leftCheat.ptr(9, "7450580596923828125"), new leftCheat.ptr(9, "37252902984619140625"), new leftCheat.ptr(9, "186264514923095703125"), new leftCheat.ptr(10, "931322574615478515625"), new leftCheat.ptr(10, "4656612873077392578125"), new leftCheat.ptr(10, "23283064365386962890625"), new leftCheat.ptr(10, "116415321826934814453125"), new leftCheat.ptr(11, "582076609134674072265625"), new leftCheat.ptr(11, "2910383045673370361328125"), new leftCheat.ptr(11, "14551915228366851806640625"), new leftCheat.ptr(12, "72759576141834259033203125"), new leftCheat.ptr(12, "363797880709171295166015625"), new leftCheat.ptr(12, "1818989403545856475830078125"), new leftCheat.ptr(13, "9094947017729282379150390625"), new leftCheat.ptr(13, "45474735088646411895751953125"), new leftCheat.ptr(13, "227373675443232059478759765625"), new leftCheat.ptr(13, "1136868377216160297393798828125"), new leftCheat.ptr(14, "5684341886080801486968994140625"), new leftCheat.ptr(14, "28421709430404007434844970703125"), new leftCheat.ptr(14, "142108547152020037174224853515625"), new leftCheat.ptr(15, "710542735760100185871124267578125"), new leftCheat.ptr(15, "3552713678800500929355621337890625"), new leftCheat.ptr(15, "17763568394002504646778106689453125"), new leftCheat.ptr(16, "88817841970012523233890533447265625"), new leftCheat.ptr(16, "444089209850062616169452667236328125"), new leftCheat.ptr(16, "2220446049250313080847263336181640625"), new leftCheat.ptr(16, "11102230246251565404236316680908203125"), new leftCheat.ptr(17, "55511151231257827021181583404541015625"), new leftCheat.ptr(17, "277555756156289135105907917022705078125"), new leftCheat.ptr(17, "1387778780781445675529539585113525390625"), new leftCheat.ptr(18, "6938893903907228377647697925567626953125"), new leftCheat.ptr(18, "34694469519536141888238489627838134765625"), new leftCheat.ptr(18, "173472347597680709441192448139190673828125"), new leftCheat.ptr(19, "867361737988403547205962240695953369140625")]);
		smallPowersOfTen = $toNativeArray($kindStruct, [new extFloat.ptr(new $Uint64(2147483648, 0), -63, false), new extFloat.ptr(new $Uint64(2684354560, 0), -60, false), new extFloat.ptr(new $Uint64(3355443200, 0), -57, false), new extFloat.ptr(new $Uint64(4194304000, 0), -54, false), new extFloat.ptr(new $Uint64(2621440000, 0), -50, false), new extFloat.ptr(new $Uint64(3276800000, 0), -47, false), new extFloat.ptr(new $Uint64(4096000000, 0), -44, false), new extFloat.ptr(new $Uint64(2560000000, 0), -40, false)]);
		powersOfTen = $toNativeArray($kindStruct, [new extFloat.ptr(new $Uint64(4203730336, 136053384), -1220, false), new extFloat.ptr(new $Uint64(3132023167, 2722021238), -1193, false), new extFloat.ptr(new $Uint64(2333539104, 810921078), -1166, false), new extFloat.ptr(new $Uint64(3477244234, 1573795306), -1140, false), new extFloat.ptr(new $Uint64(2590748842, 1432697645), -1113, false), new extFloat.ptr(new $Uint64(3860516611, 1025131999), -1087, false), new extFloat.ptr(new $Uint64(2876309015, 3348809418), -1060, false), new extFloat.ptr(new $Uint64(4286034428, 3200048207), -1034, false), new extFloat.ptr(new $Uint64(3193344495, 1097586188), -1007, false), new extFloat.ptr(new $Uint64(2379227053, 2424306748), -980, false), new extFloat.ptr(new $Uint64(3545324584, 827693699), -954, false), new extFloat.ptr(new $Uint64(2641472655, 2913388981), -927, false), new extFloat.ptr(new $Uint64(3936100983, 602835915), -901, false), new extFloat.ptr(new $Uint64(2932623761, 1081627501), -874, false), new extFloat.ptr(new $Uint64(2184974969, 1572261463), -847, false), new extFloat.ptr(new $Uint64(3255866422, 1308317239), -821, false), new extFloat.ptr(new $Uint64(2425809519, 944281679), -794, false), new extFloat.ptr(new $Uint64(3614737867, 629291719), -768, false), new extFloat.ptr(new $Uint64(2693189581, 2545915892), -741, false), new extFloat.ptr(new $Uint64(4013165208, 388672741), -715, false), new extFloat.ptr(new $Uint64(2990041083, 708162190), -688, false), new extFloat.ptr(new $Uint64(2227754207, 3536207675), -661, false), new extFloat.ptr(new $Uint64(3319612455, 450088378), -635, false), new extFloat.ptr(new $Uint64(2473304014, 3139815830), -608, false), new extFloat.ptr(new $Uint64(3685510180, 2103616900), -582, false), new extFloat.ptr(new $Uint64(2745919064, 224385782), -555, false), new extFloat.ptr(new $Uint64(4091738259, 3737383206), -529, false), new extFloat.ptr(new $Uint64(3048582568, 2868871352), -502, false), new extFloat.ptr(new $Uint64(2271371013, 1820084875), -475, false), new extFloat.ptr(new $Uint64(3384606560, 885076051), -449, false), new extFloat.ptr(new $Uint64(2521728396, 2444895829), -422, false), new extFloat.ptr(new $Uint64(3757668132, 1881767613), -396, false), new extFloat.ptr(new $Uint64(2799680927, 3102062735), -369, false), new extFloat.ptr(new $Uint64(4171849679, 2289335700), -343, false), new extFloat.ptr(new $Uint64(3108270227, 2410191823), -316, false), new extFloat.ptr(new $Uint64(2315841784, 3205436779), -289, false), new extFloat.ptr(new $Uint64(3450873173, 1697722806), -263, false), new extFloat.ptr(new $Uint64(2571100870, 3497754540), -236, false), new extFloat.ptr(new $Uint64(3831238852, 707476230), -210, false), new extFloat.ptr(new $Uint64(2854495385, 1769181907), -183, false), new extFloat.ptr(new $Uint64(4253529586, 2197867022), -157, false), new extFloat.ptr(new $Uint64(3169126500, 2450594539), -130, false), new extFloat.ptr(new $Uint64(2361183241, 1867548876), -103, false), new extFloat.ptr(new $Uint64(3518437208, 3793315116), -77, false), new extFloat.ptr(new $Uint64(2621440000, 0), -50, false), new extFloat.ptr(new $Uint64(3906250000, 0), -24, false), new extFloat.ptr(new $Uint64(2910383045, 2892103680), 3, false), new extFloat.ptr(new $Uint64(2168404344, 4170451332), 30, false), new extFloat.ptr(new $Uint64(3231174267, 3372684723), 56, false), new extFloat.ptr(new $Uint64(2407412430, 2078956656), 83, false), new extFloat.ptr(new $Uint64(3587324068, 2884206696), 109, false), new extFloat.ptr(new $Uint64(2672764710, 395977285), 136, false), new extFloat.ptr(new $Uint64(3982729777, 3569679143), 162, false), new extFloat.ptr(new $Uint64(2967364920, 2361961896), 189, false), new extFloat.ptr(new $Uint64(2210859150, 447440347), 216, false), new extFloat.ptr(new $Uint64(3294436857, 1114709402), 242, false), new extFloat.ptr(new $Uint64(2454546732, 2786846552), 269, false), new extFloat.ptr(new $Uint64(3657559652, 443583978), 295, false), new extFloat.ptr(new $Uint64(2725094297, 2599384906), 322, false), new extFloat.ptr(new $Uint64(4060706939, 3028118405), 348, false), new extFloat.ptr(new $Uint64(3025462433, 2044532855), 375, false), new extFloat.ptr(new $Uint64(2254145170, 1536935362), 402, false), new extFloat.ptr(new $Uint64(3358938053, 3365297469), 428, false), new extFloat.ptr(new $Uint64(2502603868, 4204241075), 455, false), new extFloat.ptr(new $Uint64(3729170365, 2577424355), 481, false), new extFloat.ptr(new $Uint64(2778448436, 3677981733), 508, false), new extFloat.ptr(new $Uint64(4140210802, 2744688476), 534, false), new extFloat.ptr(new $Uint64(3084697427, 1424604878), 561, false), new extFloat.ptr(new $Uint64(2298278679, 4062331362), 588, false), new extFloat.ptr(new $Uint64(3424702107, 3546052773), 614, false), new extFloat.ptr(new $Uint64(2551601907, 2065781727), 641, false), new extFloat.ptr(new $Uint64(3802183132, 2535403578), 667, false), new extFloat.ptr(new $Uint64(2832847187, 1558426518), 694, false), new extFloat.ptr(new $Uint64(4221271257, 2762425404), 720, false), new extFloat.ptr(new $Uint64(3145092172, 2812560400), 747, false), new extFloat.ptr(new $Uint64(2343276271, 3057687578), 774, false), new extFloat.ptr(new $Uint64(3491753744, 2790753324), 800, false), new extFloat.ptr(new $Uint64(2601559269, 3918606633), 827, false), new extFloat.ptr(new $Uint64(3876625403, 2711358621), 853, false), new extFloat.ptr(new $Uint64(2888311001, 1648096297), 880, false), new extFloat.ptr(new $Uint64(2151959390, 2057817989), 907, false), new extFloat.ptr(new $Uint64(3206669376, 61660461), 933, false), new extFloat.ptr(new $Uint64(2389154863, 1581580175), 960, false), new extFloat.ptr(new $Uint64(3560118173, 2626467905), 986, false), new extFloat.ptr(new $Uint64(2652494738, 3034782633), 1013, false), new extFloat.ptr(new $Uint64(3952525166, 3135207385), 1039, false), new extFloat.ptr(new $Uint64(2944860731, 2616258155), 1066, false)]);
		uint64pow10 = $toNativeArray($kindUint64, [new $Uint64(0, 1), new $Uint64(0, 10), new $Uint64(0, 100), new $Uint64(0, 1000), new $Uint64(0, 10000), new $Uint64(0, 100000), new $Uint64(0, 1000000), new $Uint64(0, 10000000), new $Uint64(0, 100000000), new $Uint64(0, 1000000000), new $Uint64(2, 1410065408), new $Uint64(23, 1215752192), new $Uint64(232, 3567587328), new $Uint64(2328, 1316134912), new $Uint64(23283, 276447232), new $Uint64(232830, 2764472320), new $Uint64(2328306, 1874919424), new $Uint64(23283064, 1569325056), new $Uint64(232830643, 2808348672), new $Uint64(2328306436, 2313682944)]);
		float32info = new floatInfo.ptr(23, 8, -127);
		float64info = new floatInfo.ptr(52, 11, -1023);
		isPrint16 = new sliceType$4([32, 126, 161, 887, 890, 895, 900, 1366, 1369, 1418, 1421, 1479, 1488, 1514, 1520, 1524, 1542, 1563, 1566, 1805, 1808, 1866, 1869, 1969, 1984, 2042, 2048, 2093, 2096, 2139, 2142, 2142, 2208, 2237, 2260, 2444, 2447, 2448, 2451, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2531, 2534, 2555, 2561, 2570, 2575, 2576, 2579, 2617, 2620, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2654, 2662, 2677, 2689, 2745, 2748, 2765, 2768, 2768, 2784, 2787, 2790, 2801, 2809, 2809, 2817, 2828, 2831, 2832, 2835, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2915, 2918, 2935, 2946, 2954, 2958, 2965, 2969, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3021, 3024, 3024, 3031, 3031, 3046, 3066, 3072, 3129, 3133, 3149, 3157, 3162, 3168, 3171, 3174, 3183, 3192, 3257, 3260, 3277, 3285, 3286, 3294, 3299, 3302, 3314, 3329, 3386, 3389, 3407, 3412, 3427, 3430, 3455, 3458, 3478, 3482, 3517, 3520, 3526, 3530, 3530, 3535, 3551, 3558, 3567, 3570, 3572, 3585, 3642, 3647, 3675, 3713, 3716, 3719, 3722, 3725, 3725, 3732, 3751, 3754, 3773, 3776, 3789, 3792, 3801, 3804, 3807, 3840, 3948, 3953, 4058, 4096, 4295, 4301, 4301, 4304, 4685, 4688, 4701, 4704, 4749, 4752, 4789, 4792, 4805, 4808, 4885, 4888, 4954, 4957, 4988, 4992, 5017, 5024, 5109, 5112, 5117, 5120, 5788, 5792, 5880, 5888, 5908, 5920, 5942, 5952, 5971, 5984, 6003, 6016, 6109, 6112, 6121, 6128, 6137, 6144, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6443, 6448, 6459, 6464, 6464, 6468, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6622, 6683, 6686, 6780, 6783, 6793, 6800, 6809, 6816, 6829, 6832, 6846, 6912, 6987, 6992, 7036, 7040, 7155, 7164, 7223, 7227, 7241, 7245, 7304, 7360, 7367, 7376, 7417, 7424, 7669, 7675, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8061, 8064, 8147, 8150, 8175, 8178, 8190, 8208, 8231, 8240, 8286, 8304, 8305, 8308, 8348, 8352, 8382, 8400, 8432, 8448, 8587, 8592, 9254, 9280, 9290, 9312, 11123, 11126, 11157, 11160, 11193, 11197, 11217, 11244, 11247, 11264, 11507, 11513, 11559, 11565, 11565, 11568, 11623, 11631, 11632, 11647, 11670, 11680, 11844, 11904, 12019, 12032, 12245, 12272, 12283, 12289, 12438, 12441, 12543, 12549, 12589, 12593, 12730, 12736, 12771, 12784, 19893, 19904, 40917, 40960, 42124, 42128, 42182, 42192, 42539, 42560, 42743, 42752, 42935, 42999, 43051, 43056, 43065, 43072, 43127, 43136, 43205, 43214, 43225, 43232, 43261, 43264, 43347, 43359, 43388, 43392, 43481, 43486, 43574, 43584, 43597, 43600, 43609, 43612, 43714, 43739, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43877, 43888, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64449, 64467, 64831, 64848, 64911, 64914, 64967, 65008, 65021, 65024, 65049, 65056, 65131, 65136, 65276, 65281, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65504, 65518, 65532, 65533]);
		isNotPrint16 = new sliceType$4([173, 907, 909, 930, 1328, 1376, 1416, 1424, 1757, 2111, 2229, 2274, 2436, 2473, 2481, 2526, 2564, 2601, 2609, 2612, 2615, 2621, 2653, 2692, 2702, 2706, 2729, 2737, 2740, 2758, 2762, 2820, 2857, 2865, 2868, 2910, 2948, 2961, 2971, 2973, 3017, 3076, 3085, 3089, 3113, 3141, 3145, 3159, 3204, 3213, 3217, 3241, 3252, 3269, 3273, 3295, 3312, 3332, 3341, 3345, 3397, 3401, 3460, 3506, 3516, 3541, 3543, 3715, 3721, 3736, 3744, 3748, 3750, 3756, 3770, 3781, 3783, 3912, 3992, 4029, 4045, 4294, 4681, 4695, 4697, 4745, 4785, 4799, 4801, 4823, 4881, 5760, 5901, 5997, 6001, 6431, 6751, 7415, 8024, 8026, 8028, 8030, 8117, 8133, 8156, 8181, 8335, 9215, 11209, 11311, 11359, 11558, 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, 11930, 12352, 12687, 12831, 13055, 42927, 43470, 43519, 43815, 43823, 64311, 64317, 64319, 64322, 64325, 65107, 65127, 65141, 65511]);
		isPrint32 = new sliceType$5([65536, 65613, 65616, 65629, 65664, 65786, 65792, 65794, 65799, 65843, 65847, 65947, 65952, 65952, 66000, 66045, 66176, 66204, 66208, 66256, 66272, 66299, 66304, 66339, 66352, 66378, 66384, 66426, 66432, 66499, 66504, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66927, 66927, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67640, 67644, 67644, 67647, 67742, 67751, 67759, 67808, 67829, 67835, 67867, 67871, 67897, 67903, 67903, 67968, 68023, 68028, 68047, 68050, 68102, 68108, 68147, 68152, 68154, 68159, 68167, 68176, 68184, 68192, 68255, 68288, 68326, 68331, 68342, 68352, 68405, 68409, 68437, 68440, 68466, 68472, 68497, 68505, 68508, 68521, 68527, 68608, 68680, 68736, 68786, 68800, 68850, 68858, 68863, 69216, 69246, 69632, 69709, 69714, 69743, 69759, 69825, 69840, 69864, 69872, 69881, 69888, 69955, 69968, 70006, 70016, 70093, 70096, 70132, 70144, 70206, 70272, 70313, 70320, 70378, 70384, 70393, 70400, 70412, 70415, 70416, 70419, 70457, 70460, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70749, 70784, 70855, 70864, 70873, 71040, 71093, 71096, 71133, 71168, 71236, 71248, 71257, 71264, 71276, 71296, 71351, 71360, 71369, 71424, 71449, 71453, 71467, 71472, 71487, 71840, 71922, 71935, 71935, 72384, 72440, 72704, 72773, 72784, 72812, 72816, 72847, 72850, 72886, 73728, 74649, 74752, 74868, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92777, 92782, 92783, 92880, 92909, 92912, 92917, 92928, 92997, 93008, 93047, 93053, 93071, 93952, 94020, 94032, 94078, 94095, 94111, 94176, 94176, 94208, 100332, 100352, 101106, 110592, 110593, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113820, 113823, 118784, 119029, 119040, 119078, 119081, 119154, 119163, 119272, 119296, 119365, 119552, 119638, 119648, 119665, 119808, 119967, 119970, 119970, 119973, 119974, 119977, 120074, 120077, 120134, 120138, 120485, 120488, 120779, 120782, 121483, 121499, 121519, 122880, 122904, 122907, 122922, 124928, 125124, 125127, 125142, 125184, 125258, 125264, 125273, 125278, 125279, 126464, 126500, 126503, 126523, 126530, 126530, 126535, 126548, 126551, 126564, 126567, 126619, 126625, 126651, 126704, 126705, 126976, 127019, 127024, 127123, 127136, 127150, 127153, 127221, 127232, 127244, 127248, 127339, 127344, 127404, 127462, 127490, 127504, 127547, 127552, 127560, 127568, 127569, 127744, 128722, 128736, 128748, 128752, 128758, 128768, 128883, 128896, 128980, 129024, 129035, 129040, 129095, 129104, 129113, 129120, 129159, 129168, 129197, 129296, 129319, 129328, 129328, 129331, 129355, 129360, 129374, 129408, 129425, 129472, 129472, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 194560, 195101, 917760, 917999]);
		isNotPrint32 = new sliceType$4([12, 39, 59, 62, 399, 926, 2057, 2102, 2134, 2291, 2564, 2580, 2584, 4285, 4405, 4576, 4626, 4743, 4745, 4750, 4766, 4868, 4905, 4913, 4916, 5210, 5212, 7177, 7223, 7336, 9327, 27231, 27482, 27490, 54357, 54429, 54445, 54458, 54460, 54468, 54534, 54549, 54557, 54586, 54591, 54597, 54609, 55968, 57351, 57378, 57381, 60932, 60960, 60963, 60968, 60979, 60984, 60986, 61000, 61002, 61004, 61008, 61011, 61016, 61018, 61020, 61022, 61024, 61027, 61035, 61043, 61048, 61053, 61055, 61066, 61092, 61098, 61632, 61648, 61743, 63775, 63807]);
		isGraphic = new sliceType$4([160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288]);
		shifts = $toNativeArray($kindUint, [0, 0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["reflect"] = (function() {
	var $pkg = {}, $init, errors, js, math, runtime, strconv, sync, unicode, utf8, uncommonType, funcType, name, nameData, mapIter, Type, Kind, tflag, rtype, typeAlg, method, ChanDir, arrayType, chanType, imethod, interfaceType, mapType, ptrType, sliceType, structField, structType, Method, nameOff, typeOff, textOff, StructField, StructTag, fieldScan, Value, flag, ValueError, sliceType$1, ptrType$1, sliceType$2, sliceType$3, ptrType$2, funcType$1, sliceType$4, ptrType$3, ptrType$4, sliceType$5, sliceType$6, sliceType$7, ptrType$5, ptrType$6, structType$3, sliceType$8, sliceType$9, sliceType$10, sliceType$11, ptrType$7, ptrType$8, sliceType$13, sliceType$14, ptrType$9, sliceType$15, ptrType$15, sliceType$17, ptrType$16, funcType$3, funcType$4, funcType$5, ptrType$17, arrayType$12, ptrType$18, initialized, uncommonTypeMap, nameMap, nameOffList, typeOffList, callHelper, jsObjectPtr, selectHelper, kindNames, methodCache, uint8Type, init, jsType, reflectType, setKindType, newName, newNameOff, newTypeOff, internalStr, isWrapped, copyStruct, makeValue, MakeSlice, TypeOf, ValueOf, FuncOf, SliceOf, Zero, unsafe_New, makeInt, typedmemmove, keyFor, mapaccess, mapassign, mapdelete, mapiterinit, mapiterkey, mapiternext, maplen, cvtDirect, Copy, methodReceiver, valueInterface, ifaceE2I, methodName, makeMethodValue, wrapJsObject, unwrapJsObject, getJsTag, chanrecv, chansend, Swapper, PtrTo, implements$1, directlyAssignable, haveIdenticalType, haveIdenticalUnderlyingType, toType, ifaceIndir, overflowFloat32, typesMustMatch, grow, Append, New, convertOp, makeFloat, makeComplex, makeString, makeBytes, makeRunes, cvtInt, cvtUint, cvtFloatInt, cvtFloatUint, cvtIntFloat, cvtUintFloat, cvtFloat, cvtComplex, cvtIntString, cvtUintString, cvtBytesString, cvtStringBytes, cvtRunesString, cvtStringRunes, cvtT2I, cvtI2I;
	errors = $packages["errors"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	math = $packages["math"];
	runtime = $packages["runtime"];
	strconv = $packages["strconv"];
	sync = $packages["sync"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	uncommonType = $pkg.uncommonType = $newType(0, $kindStruct, "reflect.uncommonType", true, "reflect", false, function(pkgPath_, mcount_, _$2_, moff_, _$4_, _methods_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.pkgPath = 0;
			this.mcount = 0;
			this._$2 = 0;
			this.moff = 0;
			this._$4 = 0;
			this._methods = sliceType$5.nil;
			return;
		}
		this.pkgPath = pkgPath_;
		this.mcount = mcount_;
		this._$2 = _$2_;
		this.moff = moff_;
		this._$4 = _$4_;
		this._methods = _methods_;
	});
	funcType = $pkg.funcType = $newType(0, $kindStruct, "reflect.funcType", true, "reflect", false, function(rtype_, inCount_, outCount_, _in_, _out_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.inCount = 0;
			this.outCount = 0;
			this._in = sliceType$2.nil;
			this._out = sliceType$2.nil;
			return;
		}
		this.rtype = rtype_;
		this.inCount = inCount_;
		this.outCount = outCount_;
		this._in = _in_;
		this._out = _out_;
	});
	name = $pkg.name = $newType(0, $kindStruct, "reflect.name", true, "reflect", false, function(bytes_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.bytes = ptrType$4.nil;
			return;
		}
		this.bytes = bytes_;
	});
	nameData = $pkg.nameData = $newType(0, $kindStruct, "reflect.nameData", true, "reflect", false, function(name_, tag_, pkgPath_, exported_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = "";
			this.tag = "";
			this.pkgPath = "";
			this.exported = false;
			return;
		}
		this.name = name_;
		this.tag = tag_;
		this.pkgPath = pkgPath_;
		this.exported = exported_;
	});
	mapIter = $pkg.mapIter = $newType(0, $kindStruct, "reflect.mapIter", true, "reflect", false, function(t_, m_, keys_, i_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.t = $ifaceNil;
			this.m = null;
			this.keys = null;
			this.i = 0;
			return;
		}
		this.t = t_;
		this.m = m_;
		this.keys = keys_;
		this.i = i_;
	});
	Type = $pkg.Type = $newType(8, $kindInterface, "reflect.Type", true, "reflect", true, null);
	Kind = $pkg.Kind = $newType(4, $kindUint, "reflect.Kind", true, "reflect", true, null);
	tflag = $pkg.tflag = $newType(1, $kindUint8, "reflect.tflag", true, "reflect", false, null);
	rtype = $pkg.rtype = $newType(0, $kindStruct, "reflect.rtype", true, "reflect", false, function(size_, ptrdata_, hash_, tflag_, align_, fieldAlign_, kind_, alg_, gcdata_, str_, ptrToThis_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.size = 0;
			this.ptrdata = 0;
			this.hash = 0;
			this.tflag = 0;
			this.align = 0;
			this.fieldAlign = 0;
			this.kind = 0;
			this.alg = ptrType$3.nil;
			this.gcdata = ptrType$4.nil;
			this.str = 0;
			this.ptrToThis = 0;
			return;
		}
		this.size = size_;
		this.ptrdata = ptrdata_;
		this.hash = hash_;
		this.tflag = tflag_;
		this.align = align_;
		this.fieldAlign = fieldAlign_;
		this.kind = kind_;
		this.alg = alg_;
		this.gcdata = gcdata_;
		this.str = str_;
		this.ptrToThis = ptrToThis_;
	});
	typeAlg = $pkg.typeAlg = $newType(0, $kindStruct, "reflect.typeAlg", true, "reflect", false, function(hash_, equal_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.hash = $throwNilPointerError;
			this.equal = $throwNilPointerError;
			return;
		}
		this.hash = hash_;
		this.equal = equal_;
	});
	method = $pkg.method = $newType(0, $kindStruct, "reflect.method", true, "reflect", false, function(name_, mtyp_, ifn_, tfn_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = 0;
			this.mtyp = 0;
			this.ifn = 0;
			this.tfn = 0;
			return;
		}
		this.name = name_;
		this.mtyp = mtyp_;
		this.ifn = ifn_;
		this.tfn = tfn_;
	});
	ChanDir = $pkg.ChanDir = $newType(4, $kindInt, "reflect.ChanDir", true, "reflect", true, null);
	arrayType = $pkg.arrayType = $newType(0, $kindStruct, "reflect.arrayType", true, "reflect", false, function(rtype_, elem_, slice_, len_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.elem = ptrType$1.nil;
			this.slice = ptrType$1.nil;
			this.len = 0;
			return;
		}
		this.rtype = rtype_;
		this.elem = elem_;
		this.slice = slice_;
		this.len = len_;
	});
	chanType = $pkg.chanType = $newType(0, $kindStruct, "reflect.chanType", true, "reflect", false, function(rtype_, elem_, dir_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.elem = ptrType$1.nil;
			this.dir = 0;
			return;
		}
		this.rtype = rtype_;
		this.elem = elem_;
		this.dir = dir_;
	});
	imethod = $pkg.imethod = $newType(0, $kindStruct, "reflect.imethod", true, "reflect", false, function(name_, typ_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = 0;
			this.typ = 0;
			return;
		}
		this.name = name_;
		this.typ = typ_;
	});
	interfaceType = $pkg.interfaceType = $newType(0, $kindStruct, "reflect.interfaceType", true, "reflect", false, function(rtype_, pkgPath_, methods_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.pkgPath = new name.ptr(ptrType$4.nil);
			this.methods = sliceType$6.nil;
			return;
		}
		this.rtype = rtype_;
		this.pkgPath = pkgPath_;
		this.methods = methods_;
	});
	mapType = $pkg.mapType = $newType(0, $kindStruct, "reflect.mapType", true, "reflect", false, function(rtype_, key_, elem_, bucket_, hmap_, keysize_, indirectkey_, valuesize_, indirectvalue_, bucketsize_, reflexivekey_, needkeyupdate_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.key = ptrType$1.nil;
			this.elem = ptrType$1.nil;
			this.bucket = ptrType$1.nil;
			this.hmap = ptrType$1.nil;
			this.keysize = 0;
			this.indirectkey = 0;
			this.valuesize = 0;
			this.indirectvalue = 0;
			this.bucketsize = 0;
			this.reflexivekey = false;
			this.needkeyupdate = false;
			return;
		}
		this.rtype = rtype_;
		this.key = key_;
		this.elem = elem_;
		this.bucket = bucket_;
		this.hmap = hmap_;
		this.keysize = keysize_;
		this.indirectkey = indirectkey_;
		this.valuesize = valuesize_;
		this.indirectvalue = indirectvalue_;
		this.bucketsize = bucketsize_;
		this.reflexivekey = reflexivekey_;
		this.needkeyupdate = needkeyupdate_;
	});
	ptrType = $pkg.ptrType = $newType(0, $kindStruct, "reflect.ptrType", true, "reflect", false, function(rtype_, elem_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.elem = ptrType$1.nil;
			return;
		}
		this.rtype = rtype_;
		this.elem = elem_;
	});
	sliceType = $pkg.sliceType = $newType(0, $kindStruct, "reflect.sliceType", true, "reflect", false, function(rtype_, elem_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.elem = ptrType$1.nil;
			return;
		}
		this.rtype = rtype_;
		this.elem = elem_;
	});
	structField = $pkg.structField = $newType(0, $kindStruct, "reflect.structField", true, "reflect", false, function(name_, typ_, offsetAnon_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = new name.ptr(ptrType$4.nil);
			this.typ = ptrType$1.nil;
			this.offsetAnon = 0;
			return;
		}
		this.name = name_;
		this.typ = typ_;
		this.offsetAnon = offsetAnon_;
	});
	structType = $pkg.structType = $newType(0, $kindStruct, "reflect.structType", true, "reflect", false, function(rtype_, pkgPath_, fields_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.pkgPath = new name.ptr(ptrType$4.nil);
			this.fields = sliceType$7.nil;
			return;
		}
		this.rtype = rtype_;
		this.pkgPath = pkgPath_;
		this.fields = fields_;
	});
	Method = $pkg.Method = $newType(0, $kindStruct, "reflect.Method", true, "reflect", true, function(Name_, PkgPath_, Type_, Func_, Index_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = "";
			this.PkgPath = "";
			this.Type = $ifaceNil;
			this.Func = new Value.ptr(ptrType$1.nil, 0, 0);
			this.Index = 0;
			return;
		}
		this.Name = Name_;
		this.PkgPath = PkgPath_;
		this.Type = Type_;
		this.Func = Func_;
		this.Index = Index_;
	});
	nameOff = $pkg.nameOff = $newType(4, $kindInt32, "reflect.nameOff", true, "reflect", false, null);
	typeOff = $pkg.typeOff = $newType(4, $kindInt32, "reflect.typeOff", true, "reflect", false, null);
	textOff = $pkg.textOff = $newType(4, $kindInt32, "reflect.textOff", true, "reflect", false, null);
	StructField = $pkg.StructField = $newType(0, $kindStruct, "reflect.StructField", true, "reflect", true, function(Name_, PkgPath_, Type_, Tag_, Offset_, Index_, Anonymous_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = "";
			this.PkgPath = "";
			this.Type = $ifaceNil;
			this.Tag = "";
			this.Offset = 0;
			this.Index = sliceType$13.nil;
			this.Anonymous = false;
			return;
		}
		this.Name = Name_;
		this.PkgPath = PkgPath_;
		this.Type = Type_;
		this.Tag = Tag_;
		this.Offset = Offset_;
		this.Index = Index_;
		this.Anonymous = Anonymous_;
	});
	StructTag = $pkg.StructTag = $newType(8, $kindString, "reflect.StructTag", true, "reflect", true, null);
	fieldScan = $pkg.fieldScan = $newType(0, $kindStruct, "reflect.fieldScan", true, "reflect", false, function(typ_, index_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.typ = ptrType$9.nil;
			this.index = sliceType$13.nil;
			return;
		}
		this.typ = typ_;
		this.index = index_;
	});
	Value = $pkg.Value = $newType(0, $kindStruct, "reflect.Value", true, "reflect", true, function(typ_, ptr_, flag_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.typ = ptrType$1.nil;
			this.ptr = 0;
			this.flag = 0;
			return;
		}
		this.typ = typ_;
		this.ptr = ptr_;
		this.flag = flag_;
	});
	flag = $pkg.flag = $newType(4, $kindUintptr, "reflect.flag", true, "reflect", false, null);
	ValueError = $pkg.ValueError = $newType(0, $kindStruct, "reflect.ValueError", true, "reflect", true, function(Method_, Kind_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Method = "";
			this.Kind = 0;
			return;
		}
		this.Method = Method_;
		this.Kind = Kind_;
	});
	sliceType$1 = $sliceType(name);
	ptrType$1 = $ptrType(rtype);
	sliceType$2 = $sliceType(ptrType$1);
	sliceType$3 = $sliceType($emptyInterface);
	ptrType$2 = $ptrType(js.Object);
	funcType$1 = $funcType([sliceType$3], [ptrType$2], true);
	sliceType$4 = $sliceType($String);
	ptrType$3 = $ptrType(typeAlg);
	ptrType$4 = $ptrType($Uint8);
	sliceType$5 = $sliceType(method);
	sliceType$6 = $sliceType(imethod);
	sliceType$7 = $sliceType(structField);
	ptrType$5 = $ptrType(uncommonType);
	ptrType$6 = $ptrType(nameData);
	structType$3 = $structType("reflect", [{prop: "str", name: "str", anonymous: false, exported: false, typ: $String, tag: ""}]);
	sliceType$8 = $sliceType(ptrType$2);
	sliceType$9 = $sliceType(Value);
	sliceType$10 = $sliceType(Type);
	sliceType$11 = $sliceType(sliceType$8);
	ptrType$7 = $ptrType(interfaceType);
	ptrType$8 = $ptrType(imethod);
	sliceType$13 = $sliceType($Int);
	sliceType$14 = $sliceType(fieldScan);
	ptrType$9 = $ptrType(structType);
	sliceType$15 = $sliceType($Uint8);
	ptrType$15 = $ptrType($UnsafePointer);
	sliceType$17 = $sliceType($Int32);
	ptrType$16 = $ptrType(funcType);
	funcType$3 = $funcType([$String], [$Bool], false);
	funcType$4 = $funcType([$UnsafePointer, $Uintptr], [$Uintptr], false);
	funcType$5 = $funcType([$UnsafePointer, $UnsafePointer], [$Bool], false);
	ptrType$17 = $ptrType(structField);
	arrayType$12 = $arrayType($Uintptr, 2);
	ptrType$18 = $ptrType(ValueError);
	init = function() {
		var used, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; used = $f.used; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		used = (function(i) {
			var i;
		});
		$r = used((x = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), new x.constructor.elem(x))); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$1 = new uncommonType.ptr(0, 0, 0, 0, 0, sliceType$5.nil), new x$1.constructor.elem(x$1))); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$2 = new method.ptr(0, 0, 0, 0), new x$2.constructor.elem(x$2))); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$3 = new arrayType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), ptrType$1.nil, ptrType$1.nil, 0), new x$3.constructor.elem(x$3))); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$4 = new chanType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), ptrType$1.nil, 0), new x$4.constructor.elem(x$4))); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$5 = new funcType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), 0, 0, sliceType$2.nil, sliceType$2.nil), new x$5.constructor.elem(x$5))); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$6 = new interfaceType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), new name.ptr(ptrType$4.nil), sliceType$6.nil), new x$6.constructor.elem(x$6))); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$7 = new mapType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, 0, 0, 0, 0, 0, false, false), new x$7.constructor.elem(x$7))); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$8 = new ptrType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), ptrType$1.nil), new x$8.constructor.elem(x$8))); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$9 = new sliceType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), ptrType$1.nil), new x$9.constructor.elem(x$9))); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$10 = new structType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), new name.ptr(ptrType$4.nil), sliceType$7.nil), new x$10.constructor.elem(x$10))); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$11 = new imethod.ptr(0, 0), new x$11.constructor.elem(x$11))); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$12 = new structField.ptr(new name.ptr(ptrType$4.nil), ptrType$1.nil, 0), new x$12.constructor.elem(x$12))); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		initialized = true;
		uint8Type = $assertType(TypeOf(new $Uint8(0)), ptrType$1);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init }; } $f.used = used; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	jsType = function(typ) {
		var typ;
		return typ.jsType;
	};
	reflectType = function(typ) {
		var _1, _i, _i$1, _i$2, _i$3, _i$4, _key, _ref, _ref$1, _ref$2, _ref$3, _ref$4, dir, f, fields, i, i$1, i$2, i$3, i$4, imethods, in$1, m, m$1, methodSet, methods, offsetAnon, out, outCount, params, reflectFields, reflectMethods, results, rt, typ, ut;
		if (typ.reflectType === undefined) {
			rt = new rtype.ptr(((($parseInt(typ.size) >> 0) >>> 0)), 0, 0, 0, 0, 0, ((($parseInt(typ.kind) >> 0) << 24 >>> 24)), ptrType$3.nil, ptrType$4.nil, newNameOff($clone(newName(internalStr(typ.string), "", "", !!(typ.exported)), name)), 0);
			rt.jsType = typ;
			typ.reflectType = rt;
			methodSet = $methodSet(typ);
			if (!(($parseInt(methodSet.length) === 0)) || !!(typ.named)) {
				rt.tflag = (rt.tflag | (1)) >>> 0;
				if (!!(typ.named)) {
					rt.tflag = (rt.tflag | (4)) >>> 0;
				}
				reflectMethods = $makeSlice(sliceType$5, $parseInt(methodSet.length));
				_ref = reflectMethods;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					i = _i;
					m = methodSet[i];
					method.copy(((i < 0 || i >= reflectMethods.$length) ? ($throwRuntimeError("index out of range"), undefined) : reflectMethods.$array[reflectMethods.$offset + i]), new method.ptr(newNameOff($clone(newName(internalStr(m.name), "", "", internalStr(m.pkg) === ""), name)), newTypeOff(reflectType(m.typ)), 0, 0));
					_i++;
				}
				ut = new uncommonType.ptr(newNameOff($clone(newName(internalStr(typ.pkg), "", "", false), name)), (($parseInt(methodSet.length) << 16 >>> 16)), 0, 0, 0, reflectMethods);
				_key = rt; (uncommonTypeMap || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key)] = { k: _key, v: ut };
				ut.jsType = typ;
			}
			_1 = rt.Kind();
			if (_1 === (17)) {
				setKindType(rt, new arrayType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), reflectType(typ.elem), ptrType$1.nil, ((($parseInt(typ.len) >> 0) >>> 0))));
			} else if (_1 === (18)) {
				dir = 3;
				if (!!(typ.sendOnly)) {
					dir = 2;
				}
				if (!!(typ.recvOnly)) {
					dir = 1;
				}
				setKindType(rt, new chanType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), reflectType(typ.elem), ((dir >>> 0))));
			} else if (_1 === (19)) {
				params = typ.params;
				in$1 = $makeSlice(sliceType$2, $parseInt(params.length));
				_ref$1 = in$1;
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					i$1 = _i$1;
					((i$1 < 0 || i$1 >= in$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : in$1.$array[in$1.$offset + i$1] = reflectType(params[i$1]));
					_i$1++;
				}
				results = typ.results;
				out = $makeSlice(sliceType$2, $parseInt(results.length));
				_ref$2 = out;
				_i$2 = 0;
				while (true) {
					if (!(_i$2 < _ref$2.$length)) { break; }
					i$2 = _i$2;
					((i$2 < 0 || i$2 >= out.$length) ? ($throwRuntimeError("index out of range"), undefined) : out.$array[out.$offset + i$2] = reflectType(results[i$2]));
					_i$2++;
				}
				outCount = (($parseInt(results.length) << 16 >>> 16));
				if (!!(typ.variadic)) {
					outCount = (outCount | (32768)) >>> 0;
				}
				setKindType(rt, new funcType.ptr($clone(rt, rtype), (($parseInt(params.length) << 16 >>> 16)), outCount, in$1, out));
			} else if (_1 === (20)) {
				methods = typ.methods;
				imethods = $makeSlice(sliceType$6, $parseInt(methods.length));
				_ref$3 = imethods;
				_i$3 = 0;
				while (true) {
					if (!(_i$3 < _ref$3.$length)) { break; }
					i$3 = _i$3;
					m$1 = methods[i$3];
					imethod.copy(((i$3 < 0 || i$3 >= imethods.$length) ? ($throwRuntimeError("index out of range"), undefined) : imethods.$array[imethods.$offset + i$3]), new imethod.ptr(newNameOff($clone(newName(internalStr(m$1.name), "", "", internalStr(m$1.pkg) === ""), name)), newTypeOff(reflectType(m$1.typ))));
					_i$3++;
				}
				setKindType(rt, new interfaceType.ptr($clone(rt, rtype), $clone(newName(internalStr(typ.pkg), "", "", false), name), imethods));
			} else if (_1 === (21)) {
				setKindType(rt, new mapType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), reflectType(typ.key), reflectType(typ.elem), ptrType$1.nil, ptrType$1.nil, 0, 0, 0, 0, 0, false, false));
			} else if (_1 === (22)) {
				setKindType(rt, new ptrType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), reflectType(typ.elem)));
			} else if (_1 === (23)) {
				setKindType(rt, new sliceType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), reflectType(typ.elem)));
			} else if (_1 === (25)) {
				fields = typ.fields;
				reflectFields = $makeSlice(sliceType$7, $parseInt(fields.length));
				_ref$4 = reflectFields;
				_i$4 = 0;
				while (true) {
					if (!(_i$4 < _ref$4.$length)) { break; }
					i$4 = _i$4;
					f = fields[i$4];
					offsetAnon = ((i$4 >>> 0)) << 1 >>> 0;
					if (!!(f.anonymous)) {
						offsetAnon = (offsetAnon | (1)) >>> 0;
					}
					structField.copy(((i$4 < 0 || i$4 >= reflectFields.$length) ? ($throwRuntimeError("index out of range"), undefined) : reflectFields.$array[reflectFields.$offset + i$4]), new structField.ptr($clone(newName(internalStr(f.name), internalStr(f.tag), "", !!(f.exported)), name), reflectType(f.typ), offsetAnon));
					_i$4++;
				}
				setKindType(rt, new structType.ptr($clone(rt, rtype), $clone(newName(internalStr(typ.pkgPath), "", "", false), name), reflectFields));
			}
		}
		return ((typ.reflectType));
	};
	setKindType = function(rt, kindType) {
		var kindType, rt;
		rt.kindType = kindType;
		kindType.rtype = rt;
	};
	uncommonType.ptr.prototype.methods = function() {
		var t;
		t = this;
		return t._methods;
	};
	uncommonType.prototype.methods = function() { return this.$val.methods(); };
	rtype.ptr.prototype.uncommon = function() {
		var _entry, t;
		t = this;
		return (_entry = uncommonTypeMap[ptrType$1.keyFor(t)], _entry !== undefined ? _entry.v : ptrType$5.nil);
	};
	rtype.prototype.uncommon = function() { return this.$val.uncommon(); };
	funcType.ptr.prototype.in$ = function() {
		var t;
		t = this;
		return t._in;
	};
	funcType.prototype.in$ = function() { return this.$val.in$(); };
	funcType.ptr.prototype.out = function() {
		var t;
		t = this;
		return t._out;
	};
	funcType.prototype.out = function() { return this.$val.out(); };
	name.ptr.prototype.name = function() {
		var _entry, n, s;
		s = "";
		n = this;
		s = (_entry = nameMap[ptrType$4.keyFor(n.bytes)], _entry !== undefined ? _entry.v : ptrType$6.nil).name;
		return s;
	};
	name.prototype.name = function() { return this.$val.name(); };
	name.ptr.prototype.tag = function() {
		var _entry, n, s;
		s = "";
		n = this;
		s = (_entry = nameMap[ptrType$4.keyFor(n.bytes)], _entry !== undefined ? _entry.v : ptrType$6.nil).tag;
		return s;
	};
	name.prototype.tag = function() { return this.$val.tag(); };
	name.ptr.prototype.pkgPath = function() {
		var _entry, n;
		n = this;
		return (_entry = nameMap[ptrType$4.keyFor(n.bytes)], _entry !== undefined ? _entry.v : ptrType$6.nil).pkgPath;
	};
	name.prototype.pkgPath = function() { return this.$val.pkgPath(); };
	name.ptr.prototype.isExported = function() {
		var _entry, n;
		n = this;
		return (_entry = nameMap[ptrType$4.keyFor(n.bytes)], _entry !== undefined ? _entry.v : ptrType$6.nil).exported;
	};
	name.prototype.isExported = function() { return this.$val.isExported(); };
	newName = function(n, tag, pkgPath, exported) {
		var _key, b, exported, n, pkgPath, tag;
		b = $newDataPointer(0, ptrType$4);
		_key = b; (nameMap || $throwRuntimeError("assignment to entry in nil map"))[ptrType$4.keyFor(_key)] = { k: _key, v: new nameData.ptr(n, tag, pkgPath, exported) };
		return new name.ptr(b);
	};
	rtype.ptr.prototype.nameOff = function(off) {
		var off, t, x;
		t = this;
		return (x = ((off >> 0)), ((x < 0 || x >= nameOffList.$length) ? ($throwRuntimeError("index out of range"), undefined) : nameOffList.$array[nameOffList.$offset + x]));
	};
	rtype.prototype.nameOff = function(off) { return this.$val.nameOff(off); };
	newNameOff = function(n) {
		var i, n;
		i = nameOffList.$length;
		nameOffList = $append(nameOffList, n);
		return ((i >> 0));
	};
	rtype.ptr.prototype.typeOff = function(off) {
		var off, t, x;
		t = this;
		return (x = ((off >> 0)), ((x < 0 || x >= typeOffList.$length) ? ($throwRuntimeError("index out of range"), undefined) : typeOffList.$array[typeOffList.$offset + x]));
	};
	rtype.prototype.typeOff = function(off) { return this.$val.typeOff(off); };
	newTypeOff = function(t) {
		var i, t;
		i = typeOffList.$length;
		typeOffList = $append(typeOffList, t);
		return ((i >> 0));
	};
	internalStr = function(strObj) {
		var c, strObj;
		c = new structType$3.ptr("");
		c.str = strObj;
		return c.str;
	};
	isWrapped = function(typ) {
		var typ;
		return !!(jsType(typ).wrapped);
	};
	copyStruct = function(dst, src, typ) {
		var dst, fields, i, prop, src, typ;
		fields = jsType(typ).fields;
		i = 0;
		while (true) {
			if (!(i < $parseInt(fields.length))) { break; }
			prop = $internalize(fields[i].prop, $String);
			dst[$externalize(prop, $String)] = src[$externalize(prop, $String)];
			i = i + (1) >> 0;
		}
	};
	makeValue = function(t, v, fl) {
		var _r, _r$1, _r$2, _r$3, _r$4, _r$5, _v, _v$1, fl, rt, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _v = $f._v; _v$1 = $f._v$1; fl = $f.fl; rt = $f.rt; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		rt = _r;
		_r$1 = t.Kind(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		if (_r$1 === 17) { _v$1 = true; $s = 5; continue s; }
		_r$2 = t.Kind(); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_v$1 = _r$2 === 25; case 5:
		if (_v$1) { _v = true; $s = 4; continue s; }
		_r$3 = t.Kind(); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_v = _r$3 === 22; case 4:
		/* */ if (_v) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (_v) { */ case 2:
			_r$4 = t.Kind(); /* */ $s = 9; case 9: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			$s = -1; return new Value.ptr(rt, (v), (fl | ((_r$4 >>> 0))) >>> 0);
		/* } */ case 3:
		_r$5 = t.Kind(); /* */ $s = 10; case 10: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		$s = -1; return new Value.ptr(rt, ($newDataPointer(v, jsType(rt.ptrTo()))), (((fl | ((_r$5 >>> 0))) >>> 0) | 128) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeValue }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._v = _v; $f._v$1 = _v$1; $f.fl = fl; $f.rt = rt; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	MakeSlice = function(typ, len, cap) {
		var _r, _r$1, cap, len, typ, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; cap = $f.cap; len = $f.len; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		typ = [typ];
		_r = typ[0].Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 23))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 23))) { */ case 1:
			$panic(new $String("reflect.MakeSlice of non-slice type"));
		/* } */ case 2:
		if (len < 0) {
			$panic(new $String("reflect.MakeSlice: negative len"));
		}
		if (cap < 0) {
			$panic(new $String("reflect.MakeSlice: negative cap"));
		}
		if (len > cap) {
			$panic(new $String("reflect.MakeSlice: len > cap"));
		}
		_r$1 = makeValue(typ[0], $makeSlice(jsType(typ[0]), len, cap, (function(typ) { return function $b() {
			var _r$1, _r$2, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r$1 = typ[0].Elem(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$2 = jsType(_r$1); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			$s = -1; return _r$2.zero();
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f.$s = $s; $f.$r = $r; return $f;
		}; })(typ)), 0); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MakeSlice }; } $f._r = _r; $f._r$1 = _r$1; $f.cap = cap; $f.len = len; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MakeSlice = MakeSlice;
	TypeOf = function(i) {
		var i;
		if (!initialized) {
			return new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
		}
		if ($interfaceIsEqual(i, $ifaceNil)) {
			return $ifaceNil;
		}
		return reflectType(i.constructor);
	};
	$pkg.TypeOf = TypeOf;
	ValueOf = function(i) {
		var _r, i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if ($interfaceIsEqual(i, $ifaceNil)) {
			$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		}
		_r = makeValue(reflectType(i.constructor), i.$val, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ValueOf }; } $f._r = _r; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ValueOf = ValueOf;
	FuncOf = function(in$1, out, variadic) {
		var _i, _i$1, _r, _ref, _ref$1, _v, _v$1, i, i$1, in$1, jsIn, jsOut, out, v, v$1, variadic, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; _v = $f._v; _v$1 = $f._v$1; i = $f.i; i$1 = $f.i$1; in$1 = $f.in$1; jsIn = $f.jsIn; jsOut = $f.jsOut; out = $f.out; v = $f.v; v$1 = $f.v$1; variadic = $f.variadic; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (!(variadic)) { _v = false; $s = 3; continue s; }
		if (in$1.$length === 0) { _v$1 = true; $s = 4; continue s; }
		_r = (x = in$1.$length - 1 >> 0, ((x < 0 || x >= in$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : in$1.$array[in$1.$offset + x])).Kind(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_v$1 = !((_r === 23)); case 4:
		_v = _v$1; case 3:
		/* */ if (_v) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_v) { */ case 1:
			$panic(new $String("reflect.FuncOf: last arg of variadic func must be slice"));
		/* } */ case 2:
		jsIn = $makeSlice(sliceType$8, in$1.$length);
		_ref = in$1;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			v = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			((i < 0 || i >= jsIn.$length) ? ($throwRuntimeError("index out of range"), undefined) : jsIn.$array[jsIn.$offset + i] = jsType(v));
			_i++;
		}
		jsOut = $makeSlice(sliceType$8, out.$length);
		_ref$1 = out;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			v$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			((i$1 < 0 || i$1 >= jsOut.$length) ? ($throwRuntimeError("index out of range"), undefined) : jsOut.$array[jsOut.$offset + i$1] = jsType(v$1));
			_i$1++;
		}
		$s = -1; return reflectType($funcType($externalize(jsIn, sliceType$8), $externalize(jsOut, sliceType$8), $externalize(variadic, $Bool)));
		/* */ } return; } if ($f === undefined) { $f = { $blk: FuncOf }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f._v = _v; $f._v$1 = _v$1; $f.i = i; $f.i$1 = i$1; $f.in$1 = in$1; $f.jsIn = jsIn; $f.jsOut = jsOut; $f.out = out; $f.v = v; $f.v$1 = v$1; $f.variadic = variadic; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.FuncOf = FuncOf;
	rtype.ptr.prototype.ptrTo = function() {
		var t;
		t = this;
		return reflectType($ptrType(jsType(t)));
	};
	rtype.prototype.ptrTo = function() { return this.$val.ptrTo(); };
	SliceOf = function(t) {
		var t;
		return reflectType($sliceType(jsType(t)));
	};
	$pkg.SliceOf = SliceOf;
	Zero = function(typ) {
		var _r, typ, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeValue(typ, jsType(typ).zero(), 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Zero }; } $f._r = _r; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Zero = Zero;
	unsafe_New = function(typ) {
		var _1, typ;
		_1 = typ.Kind();
		if (_1 === (25)) {
			return (new (jsType(typ).ptr)());
		} else if (_1 === (17)) {
			return (jsType(typ).zero());
		} else {
			return ($newDataPointer(jsType(typ).zero(), jsType(typ.ptrTo())));
		}
	};
	makeInt = function(f, bits, t) {
		var _1, _r, bits, f, ptr, t, typ, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; bits = $f.bits; f = $f.f; ptr = $f.ptr; t = $f.t; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		typ = _r;
		ptr = unsafe_New(typ);
		_1 = typ.Kind();
		if (_1 === (3)) {
			(ptr).$set(((bits.$low << 24 >> 24)));
		} else if (_1 === (4)) {
			(ptr).$set(((bits.$low << 16 >> 16)));
		} else if ((_1 === (2)) || (_1 === (5))) {
			(ptr).$set(((bits.$low >> 0)));
		} else if (_1 === (6)) {
			(ptr).$set((new $Int64(bits.$high, bits.$low)));
		} else if (_1 === (8)) {
			(ptr).$set(((bits.$low << 24 >>> 24)));
		} else if (_1 === (9)) {
			(ptr).$set(((bits.$low << 16 >>> 16)));
		} else if ((_1 === (7)) || (_1 === (10)) || (_1 === (12))) {
			(ptr).$set(((bits.$low >>> 0)));
		} else if (_1 === (11)) {
			(ptr).$set((bits));
		}
		$s = -1; return new Value.ptr(typ, ptr, (((f | 128) >>> 0) | ((typ.Kind() >>> 0))) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeInt }; } $f._1 = _1; $f._r = _r; $f.bits = bits; $f.f = f; $f.ptr = ptr; $f.t = t; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;
	};
	typedmemmove = function(t, dst, src) {
		var dst, src, t;
		dst.$set(src.$get());
	};
	keyFor = function(t, key) {
		var k, key, kv, t;
		kv = key;
		if (!(kv.$get === undefined)) {
			kv = kv.$get();
		}
		k = $internalize(jsType(t.Key()).keyFor(kv), $String);
		return [kv, k];
	};
	mapaccess = function(t, m, key) {
		var _tuple, entry, k, key, m, t;
		_tuple = keyFor(t, key);
		k = _tuple[1];
		entry = m[$externalize(k, $String)];
		if (entry === undefined) {
			return 0;
		}
		return ($newDataPointer(entry.v, jsType(PtrTo(t.Elem()))));
	};
	mapassign = function(t, m, key, val) {
		var _r, _tuple, entry, et, jsVal, k, key, kv, m, newVal, t, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; entry = $f.entry; et = $f.et; jsVal = $f.jsVal; k = $f.k; key = $f.key; kv = $f.kv; m = $f.m; newVal = $f.newVal; t = $f.t; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = keyFor(t, key);
		kv = _tuple[0];
		k = _tuple[1];
		jsVal = val.$get();
		et = t.Elem();
		_r = et.Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (_r === 25) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r === 25) { */ case 1:
			newVal = jsType(et).zero();
			copyStruct(newVal, jsVal, et);
			jsVal = newVal;
		/* } */ case 2:
		entry = new ($global.Object)();
		entry.k = kv;
		entry.v = jsVal;
		m[$externalize(k, $String)] = entry;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: mapassign }; } $f._r = _r; $f._tuple = _tuple; $f.entry = entry; $f.et = et; $f.jsVal = jsVal; $f.k = k; $f.key = key; $f.kv = kv; $f.m = m; $f.newVal = newVal; $f.t = t; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	mapdelete = function(t, m, key) {
		var _tuple, k, key, m, t;
		_tuple = keyFor(t, key);
		k = _tuple[1];
		delete m[$externalize(k, $String)];
	};
	mapiterinit = function(t, m) {
		var m, t;
		return ((new mapIter.ptr(t, m, $keys(m), 0)));
	};
	mapiterkey = function(it) {
		var _r, _r$1, _r$2, it, iter, k, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; it = $f.it; iter = $f.iter; k = $f.k; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		iter = ((it));
		k = iter.keys[iter.i];
		_r = iter.t.Key(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = PtrTo(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = jsType(_r$1); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return ($newDataPointer(iter.m[$externalize($internalize(k, $String), $String)].k, _r$2));
		/* */ } return; } if ($f === undefined) { $f = { $blk: mapiterkey }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.it = it; $f.iter = iter; $f.k = k; $f.$s = $s; $f.$r = $r; return $f;
	};
	mapiternext = function(it) {
		var it, iter;
		iter = ((it));
		iter.i = iter.i + (1) >> 0;
	};
	maplen = function(m) {
		var m;
		return $parseInt($keys(m).length);
	};
	cvtDirect = function(v, typ) {
		var _1, _arg, _arg$1, _arg$2, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, k, slice, srcVal, typ, v, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; k = $f.k; slice = $f.slice; srcVal = $f.srcVal; typ = $f.typ; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		srcVal = $clone(v, Value).object();
		/* */ if (srcVal === jsType(v.typ).nil) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (srcVal === jsType(v.typ).nil) { */ case 1:
			_r = makeValue(typ, jsType(typ).nil, v.flag); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		val = null;
			_r$1 = typ.Kind(); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			k = _r$1;
			_1 = k;
			/* */ if (_1 === (23)) { $s = 6; continue; }
			/* */ if (_1 === (22)) { $s = 7; continue; }
			/* */ if (_1 === (25)) { $s = 8; continue; }
			/* */ if ((_1 === (17)) || (_1 === (1)) || (_1 === (18)) || (_1 === (19)) || (_1 === (20)) || (_1 === (21)) || (_1 === (24))) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_1 === (23)) { */ case 6:
				slice = new (jsType(typ))(srcVal.$array);
				slice.$offset = srcVal.$offset;
				slice.$length = srcVal.$length;
				slice.$capacity = srcVal.$capacity;
				val = $newDataPointer(slice, jsType(PtrTo(typ)));
				$s = 11; continue;
			/* } else if (_1 === (22)) { */ case 7:
				_r$2 = typ.Elem(); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$3 = _r$2.Kind(); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				/* */ if (_r$3 === 25) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if (_r$3 === 25) { */ case 12:
					_r$4 = typ.Elem(); /* */ $s = 18; case 18: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					/* */ if ($interfaceIsEqual(_r$4, v.typ.Elem())) { $s = 16; continue; }
					/* */ $s = 17; continue;
					/* if ($interfaceIsEqual(_r$4, v.typ.Elem())) { */ case 16:
						val = srcVal;
						/* break; */ $s = 4; continue;
					/* } */ case 17:
					val = new (jsType(typ))();
					_arg = val;
					_arg$1 = srcVal;
					_r$5 = typ.Elem(); /* */ $s = 19; case 19: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
					_arg$2 = _r$5;
					$r = copyStruct(_arg, _arg$1, _arg$2); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					/* break; */ $s = 4; continue;
				/* } */ case 13:
				val = new (jsType(typ))(srcVal.$get, srcVal.$set);
				$s = 11; continue;
			/* } else if (_1 === (25)) { */ case 8:
				val = new (jsType(typ).ptr)();
				copyStruct(val, srcVal, typ);
				$s = 11; continue;
			/* } else if ((_1 === (17)) || (_1 === (1)) || (_1 === (18)) || (_1 === (19)) || (_1 === (20)) || (_1 === (21)) || (_1 === (24))) { */ case 9:
				val = v.ptr;
				$s = 11; continue;
			/* } else { */ case 10:
				$panic(new ValueError.ptr("reflect.Convert", k));
			/* } */ case 11:
		case 4:
		_r$6 = typ.common(); /* */ $s = 21; case 21: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_r$7 = typ.Kind(); /* */ $s = 22; case 22: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		$s = -1; return new Value.ptr(_r$6, (val), (((v.flag & 224) >>> 0) | ((_r$7 >>> 0))) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtDirect }; } $f._1 = _1; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f.k = k; $f.slice = slice; $f.srcVal = srcVal; $f.typ = typ; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Copy = function(dst, src) {
		var dk, dst, dstVal, sk, src, srcVal, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; dk = $f.dk; dst = $f.dst; dstVal = $f.dstVal; sk = $f.sk; src = $f.src; srcVal = $f.srcVal; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		dk = new flag(dst.flag).kind();
		if (!((dk === 17)) && !((dk === 23))) {
			$panic(new ValueError.ptr("reflect.Copy", dk));
		}
		if (dk === 17) {
			new flag(dst.flag).mustBeAssignable();
		}
		new flag(dst.flag).mustBeExported();
		sk = new flag(src.flag).kind();
		if (!((sk === 17)) && !((sk === 23))) {
			$panic(new ValueError.ptr("reflect.Copy", sk));
		}
		new flag(src.flag).mustBeExported();
		$r = typesMustMatch("reflect.Copy", dst.typ.Elem(), src.typ.Elem()); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		dstVal = $clone(dst, Value).object();
		if (dk === 17) {
			dstVal = new (jsType(SliceOf(dst.typ.Elem())))(dstVal);
		}
		srcVal = $clone(src, Value).object();
		if (sk === 17) {
			srcVal = new (jsType(SliceOf(src.typ.Elem())))(srcVal);
		}
		$s = -1; return $parseInt($copySlice(dstVal, srcVal)) >> 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Copy }; } $f.dk = dk; $f.dst = dst; $f.dstVal = dstVal; $f.sk = sk; $f.src = src; $f.srcVal = srcVal; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Copy = Copy;
	methodReceiver = function(op, v, i) {
		var _$38, fn, i, m, m$1, op, prop, rcvr, t, tt, ut, v, x, x$1;
		_$38 = ptrType$1.nil;
		t = ptrType$1.nil;
		fn = 0;
		prop = "";
		if (v.typ.Kind() === 20) {
			tt = (v.typ.kindType);
			if (i < 0 || i >= tt.methods.$length) {
				$panic(new $String("reflect: internal error: invalid method index"));
			}
			m = (x = tt.methods, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			if (!$clone(tt.rtype.nameOff(m.name), name).isExported()) {
				$panic(new $String("reflect: " + op + " of unexported method"));
			}
			t = tt.rtype.typeOff(m.typ);
			prop = $clone(tt.rtype.nameOff(m.name), name).name();
		} else {
			ut = v.typ.uncommon();
			if (ut === ptrType$5.nil || ((i >>> 0)) >= ((ut.mcount >>> 0))) {
				$panic(new $String("reflect: internal error: invalid method index"));
			}
			m$1 = $clone((x$1 = ut.methods(), ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])), method);
			if (!$clone(v.typ.nameOff(m$1.name), name).isExported()) {
				$panic(new $String("reflect: " + op + " of unexported method"));
			}
			t = v.typ.typeOff(m$1.mtyp);
			prop = $internalize($methodSet(jsType(v.typ))[i].prop, $String);
		}
		rcvr = $clone(v, Value).object();
		if (isWrapped(v.typ)) {
			rcvr = new (jsType(v.typ))(rcvr);
		}
		fn = (rcvr[$externalize(prop, $String)]);
		return [_$38, t, fn];
	};
	valueInterface = function(v, safe) {
		var _r, safe, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; safe = $f.safe; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (v.flag === 0) {
			$panic(new ValueError.ptr("reflect.Value.Interface", 0));
		}
		if (safe && !((((v.flag & 96) >>> 0) === 0))) {
			$panic(new $String("reflect.Value.Interface: cannot return value obtained from unexported field or method"));
		}
		/* */ if (!((((v.flag & 512) >>> 0) === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:
			_r = makeMethodValue("Interface", $clone(v, Value)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			v = _r;
		/* } */ case 2:
		if (isWrapped(v.typ)) {
			$s = -1; return ((new (jsType(v.typ))($clone(v, Value).object())));
		}
		$s = -1; return (($clone(v, Value).object()));
		/* */ } return; } if ($f === undefined) { $f = { $blk: valueInterface }; } $f._r = _r; $f.safe = safe; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	ifaceE2I = function(t, src, dst) {
		var dst, src, t;
		dst.$set(src);
	};
	methodName = function() {
		return "?FIXME?";
	};
	makeMethodValue = function(op, v) {
		var _r, _tuple, fn, fv, op, rcvr, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; fn = $f.fn; fv = $f.fv; op = $f.op; rcvr = $f.rcvr; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fn = [fn];
		rcvr = [rcvr];
		if (((v.flag & 512) >>> 0) === 0) {
			$panic(new $String("reflect: internal error: invalid use of makePartialFunc"));
		}
		_tuple = methodReceiver(op, $clone(v, Value), ((v.flag >> 0)) >> 10 >> 0);
		fn[0] = _tuple[2];
		rcvr[0] = $clone(v, Value).object();
		if (isWrapped(v.typ)) {
			rcvr[0] = new (jsType(v.typ))(rcvr[0]);
		}
		fv = js.MakeFunc((function(fn, rcvr) { return function(this$1, arguments$1) {
			var arguments$1, this$1;
			return new $jsObjectPtr(fn[0].apply(rcvr[0], $externalize(arguments$1, sliceType$8)));
		}; })(fn, rcvr));
		_r = $clone(v, Value).Type().common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return new Value.ptr(_r, (fv), (((v.flag & 96) >>> 0) | 19) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeMethodValue }; } $f._r = _r; $f._tuple = _tuple; $f.fn = fn; $f.fv = fv; $f.op = op; $f.rcvr = rcvr; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.ptr.prototype.pointers = function() {
		var _1, t;
		t = this;
		_1 = t.Kind();
		if ((_1 === (22)) || (_1 === (21)) || (_1 === (18)) || (_1 === (19)) || (_1 === (25)) || (_1 === (17))) {
			return true;
		} else {
			return false;
		}
	};
	rtype.prototype.pointers = function() { return this.$val.pointers(); };
	rtype.ptr.prototype.Comparable = function() {
		var _1, _r, _r$1, i, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; i = $f.i; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
			_1 = t.Kind();
			/* */ if ((_1 === (19)) || (_1 === (23)) || (_1 === (21))) { $s = 2; continue; }
			/* */ if (_1 === (17)) { $s = 3; continue; }
			/* */ if (_1 === (25)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if ((_1 === (19)) || (_1 === (23)) || (_1 === (21))) { */ case 2:
				$s = -1; return false;
			/* } else if (_1 === (17)) { */ case 3:
				_r = t.Elem().Comparable(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (25)) { */ case 4:
				i = 0;
				/* while (true) { */ case 7:
					/* if (!(i < t.NumField())) { break; } */ if(!(i < t.NumField())) { $s = 8; continue; }
					_r$1 = t.Field(i).Type.Comparable(); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					/* */ if (!_r$1) { $s = 9; continue; }
					/* */ $s = 10; continue;
					/* if (!_r$1) { */ case 9:
						$s = -1; return false;
					/* } */ case 10:
					i = i + (1) >> 0;
				/* } */ $s = 7; continue; case 8:
			/* } */ case 5:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.Comparable }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.Comparable = function() { return this.$val.Comparable(); };
	rtype.ptr.prototype.Method = function(i) {
		var _i, _i$1, _r, _r$1, _ref, _ref$1, arg, fl, fn, ft, i, in$1, m, methods, mt, mtyp, out, p, pname, prop, ret, t, tt, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; arg = $f.arg; fl = $f.fl; fn = $f.fn; ft = $f.ft; i = $f.i; in$1 = $f.in$1; m = $f.m; methods = $f.methods; mt = $f.mt; mtyp = $f.mtyp; out = $f.out; p = $f.p; pname = $f.pname; prop = $f.prop; ret = $f.ret; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		prop = [prop];
		m = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
		t = this;
		if (t.Kind() === 20) {
			tt = (t.kindType);
			Method.copy(m, tt.Method(i));
			$s = -1; return m;
		}
		_r = t.exportedMethods(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		methods = _r;
		if (i < 0 || i >= methods.$length) {
			$panic(new $String("reflect: Method index out of range"));
		}
		p = $clone(((i < 0 || i >= methods.$length) ? ($throwRuntimeError("index out of range"), undefined) : methods.$array[methods.$offset + i]), method);
		pname = $clone(t.nameOff(p.name), name);
		m.Name = $clone(pname, name).name();
		fl = 19;
		mtyp = t.typeOff(p.mtyp);
		ft = (mtyp.kindType);
		in$1 = $makeSlice(sliceType$10, 0, (1 + ft.in$().$length >> 0));
		in$1 = $append(in$1, t);
		_ref = ft.in$();
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			arg = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			in$1 = $append(in$1, arg);
			_i++;
		}
		out = $makeSlice(sliceType$10, 0, ft.out().$length);
		_ref$1 = ft.out();
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			ret = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			out = $append(out, ret);
			_i$1++;
		}
		_r$1 = FuncOf(in$1, out, ft.rtype.IsVariadic()); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		mt = _r$1;
		m.Type = mt;
		prop[0] = $internalize($methodSet(t.jsType)[i].prop, $String);
		fn = js.MakeFunc((function(prop) { return function(this$1, arguments$1) {
			var arguments$1, rcvr, this$1;
			rcvr = (0 >= arguments$1.$length ? ($throwRuntimeError("index out of range"), undefined) : arguments$1.$array[arguments$1.$offset + 0]);
			return new $jsObjectPtr(rcvr[$externalize(prop[0], $String)].apply(rcvr, $externalize($subslice(arguments$1, 1), sliceType$8)));
		}; })(prop));
		m.Func = new Value.ptr($assertType(mt, ptrType$1), (fn), fl);
		m.Index = i;
		Method.copy(m, m);
		$s = -1; return m;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.Method }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f.arg = arg; $f.fl = fl; $f.fn = fn; $f.ft = ft; $f.i = i; $f.in$1 = in$1; $f.m = m; $f.methods = methods; $f.mt = mt; $f.mtyp = mtyp; $f.out = out; $f.p = p; $f.pname = pname; $f.prop = prop; $f.ret = ret; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.Method = function(i) { return this.$val.Method(i); };
	Value.ptr.prototype.object = function() {
		var _1, newVal, v, val;
		v = this;
		if ((v.typ.Kind() === 17) || (v.typ.Kind() === 25)) {
			return v.ptr;
		}
		if (!((((v.flag & 128) >>> 0) === 0))) {
			val = v.ptr.$get();
			if (!(val === $ifaceNil) && !(val.constructor === jsType(v.typ))) {
				switch (0) { default:
					_1 = v.typ.Kind();
					if ((_1 === (11)) || (_1 === (6))) {
						val = new (jsType(v.typ))(val.$high, val.$low);
					} else if ((_1 === (15)) || (_1 === (16))) {
						val = new (jsType(v.typ))(val.$real, val.$imag);
					} else if (_1 === (23)) {
						if (val === val.constructor.nil) {
							val = jsType(v.typ).nil;
							break;
						}
						newVal = new (jsType(v.typ))(val.$array);
						newVal.$offset = val.$offset;
						newVal.$length = val.$length;
						newVal.$capacity = val.$capacity;
						val = newVal;
					}
				}
			}
			return val;
		}
		return v.ptr;
	};
	Value.prototype.object = function() { return this.$val.object(); };
	Value.ptr.prototype.call = function(op, in$1) {
		var _1, _arg, _arg$1, _arg$2, _arg$3, _i, _i$1, _i$2, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, _ref$2, _tmp, _tmp$1, _tuple, arg, argsArray, elem, fn, i, i$1, i$2, i$3, in$1, isSlice, m, n, nin, nout, op, origIn, rcvr, results, ret, slice, t, targ, v, x, x$1, x$2, xt, xt$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _arg$3 = $f._arg$3; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; arg = $f.arg; argsArray = $f.argsArray; elem = $f.elem; fn = $f.fn; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; in$1 = $f.in$1; isSlice = $f.isSlice; m = $f.m; n = $f.n; nin = $f.nin; nout = $f.nout; op = $f.op; origIn = $f.origIn; rcvr = $f.rcvr; results = $f.results; ret = $f.ret; slice = $f.slice; t = $f.t; targ = $f.targ; v = $f.v; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; xt = $f.xt; xt$1 = $f.xt$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		t = ptrType$1.nil;
		fn = 0;
		rcvr = null;
		if (!((((v.flag & 512) >>> 0) === 0))) {
			_tuple = methodReceiver(op, $clone(v, Value), ((v.flag >> 0)) >> 10 >> 0);
			t = _tuple[1];
			fn = _tuple[2];
			rcvr = $clone(v, Value).object();
			if (isWrapped(v.typ)) {
				rcvr = new (jsType(v.typ))(rcvr);
			}
		} else {
			t = v.typ;
			fn = ($clone(v, Value).object());
			rcvr = undefined;
		}
		if (fn === 0) {
			$panic(new $String("reflect.Value.Call: call of nil function"));
		}
		isSlice = op === "CallSlice";
		n = t.NumIn();
		if (isSlice) {
			if (!t.IsVariadic()) {
				$panic(new $String("reflect: CallSlice of non-variadic function"));
			}
			if (in$1.$length < n) {
				$panic(new $String("reflect: CallSlice with too few input arguments"));
			}
			if (in$1.$length > n) {
				$panic(new $String("reflect: CallSlice with too many input arguments"));
			}
		} else {
			if (t.IsVariadic()) {
				n = n - (1) >> 0;
			}
			if (in$1.$length < n) {
				$panic(new $String("reflect: Call with too few input arguments"));
			}
			if (!t.IsVariadic() && in$1.$length > n) {
				$panic(new $String("reflect: Call with too many input arguments"));
			}
		}
		_ref = in$1;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			x = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if ($clone(x, Value).Kind() === 0) {
				$panic(new $String("reflect: " + op + " using zero Value argument"));
			}
			_i++;
		}
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < n)) { break; } */ if(!(i < n)) { $s = 2; continue; }
			_tmp = $clone(((i < 0 || i >= in$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : in$1.$array[in$1.$offset + i]), Value).Type();
			_tmp$1 = t.In(i);
			xt = _tmp;
			targ = _tmp$1;
			_r = xt.AssignableTo(targ); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (!_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!_r) { */ case 3:
				_r$1 = xt.String(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_r$2 = targ.String(); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				$panic(new $String("reflect: " + op + " using " + _r$1 + " as type " + _r$2));
			/* } */ case 4:
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		/* */ if (!isSlice && t.IsVariadic()) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if (!isSlice && t.IsVariadic()) { */ case 8:
			m = in$1.$length - n >> 0;
			_r$3 = MakeSlice(t.In(n), m, m); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			slice = _r$3;
			_r$4 = t.In(n).Elem(); /* */ $s = 11; case 11: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			elem = _r$4;
			i$1 = 0;
			/* while (true) { */ case 12:
				/* if (!(i$1 < m)) { break; } */ if(!(i$1 < m)) { $s = 13; continue; }
				x$2 = (x$1 = n + i$1 >> 0, ((x$1 < 0 || x$1 >= in$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : in$1.$array[in$1.$offset + x$1]));
				xt$1 = $clone(x$2, Value).Type();
				_r$5 = xt$1.AssignableTo(elem); /* */ $s = 16; case 16: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				/* */ if (!_r$5) { $s = 14; continue; }
				/* */ $s = 15; continue;
				/* if (!_r$5) { */ case 14:
					_r$6 = xt$1.String(); /* */ $s = 17; case 17: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
					_r$7 = elem.String(); /* */ $s = 18; case 18: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
					$panic(new $String("reflect: cannot use " + _r$6 + " as type " + _r$7 + " in " + op));
				/* } */ case 15:
				_r$8 = $clone(slice, Value).Index(i$1); /* */ $s = 19; case 19: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				$r = $clone(_r$8, Value).Set($clone(x$2, Value)); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				i$1 = i$1 + (1) >> 0;
			/* } */ $s = 12; continue; case 13:
			origIn = in$1;
			in$1 = $makeSlice(sliceType$9, (n + 1 >> 0));
			$copySlice($subslice(in$1, 0, n), origIn);
			((n < 0 || n >= in$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : in$1.$array[in$1.$offset + n] = slice);
		/* } */ case 9:
		nin = in$1.$length;
		if (!((nin === t.NumIn()))) {
			$panic(new $String("reflect.Value.Call: wrong argument count"));
		}
		nout = t.NumOut();
		argsArray = new ($global.Array)(t.NumIn());
		_ref$1 = in$1;
		_i$1 = 0;
		/* while (true) { */ case 21:
			/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 22; continue; }
			i$2 = _i$1;
			arg = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			_arg = t.In(i$2);
			_r$9 = t.In(i$2).common(); /* */ $s = 23; case 23: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
			_arg$1 = _r$9;
			_arg$2 = 0;
			_r$10 = $clone(arg, Value).assignTo("reflect.Value.Call", _arg$1, _arg$2); /* */ $s = 24; case 24: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			_r$11 = $clone(_r$10, Value).object(); /* */ $s = 25; case 25: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
			_arg$3 = _r$11;
			_r$12 = unwrapJsObject(_arg, _arg$3); /* */ $s = 26; case 26: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
			argsArray[i$2] = _r$12;
			_i$1++;
		/* } */ $s = 21; continue; case 22:
		_r$13 = callHelper(new sliceType$3([new $jsObjectPtr(fn), new $jsObjectPtr(rcvr), new $jsObjectPtr(argsArray)])); /* */ $s = 27; case 27: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
		results = _r$13;
			_1 = nout;
			/* */ if (_1 === (0)) { $s = 29; continue; }
			/* */ if (_1 === (1)) { $s = 30; continue; }
			/* */ $s = 31; continue;
			/* if (_1 === (0)) { */ case 29:
				$s = -1; return sliceType$9.nil;
			/* } else if (_1 === (1)) { */ case 30:
				_r$14 = makeValue(t.Out(0), wrapJsObject(t.Out(0), results), 0); /* */ $s = 33; case 33: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
				$s = -1; return new sliceType$9([$clone(_r$14, Value)]);
			/* } else { */ case 31:
				ret = $makeSlice(sliceType$9, nout);
				_ref$2 = ret;
				_i$2 = 0;
				/* while (true) { */ case 34:
					/* if (!(_i$2 < _ref$2.$length)) { break; } */ if(!(_i$2 < _ref$2.$length)) { $s = 35; continue; }
					i$3 = _i$2;
					_r$15 = makeValue(t.Out(i$3), wrapJsObject(t.Out(i$3), results[i$3]), 0); /* */ $s = 36; case 36: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
					((i$3 < 0 || i$3 >= ret.$length) ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + i$3] = _r$15);
					_i$2++;
				/* } */ $s = 34; continue; case 35:
				$s = -1; return ret;
			/* } */ case 32:
		case 28:
		$s = -1; return sliceType$9.nil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.call }; } $f._1 = _1; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._arg$3 = _arg$3; $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.arg = arg; $f.argsArray = argsArray; $f.elem = elem; $f.fn = fn; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.in$1 = in$1; $f.isSlice = isSlice; $f.m = m; $f.n = n; $f.nin = nin; $f.nout = nout; $f.op = op; $f.origIn = origIn; $f.rcvr = rcvr; $f.results = results; $f.ret = ret; $f.slice = slice; $f.t = t; $f.targ = targ; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.xt = xt; $f.xt$1 = xt$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.call = function(op, in$1) { return this.$val.call(op, in$1); };
	Value.ptr.prototype.Cap = function() {
		var _1, k, v;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (17)) {
			return v.typ.Len();
		} else if ((_1 === (18)) || (_1 === (23))) {
			return $parseInt($clone(v, Value).object().$capacity) >> 0;
		}
		$panic(new ValueError.ptr("reflect.Value.Cap", k));
	};
	Value.prototype.Cap = function() { return this.$val.Cap(); };
	wrapJsObject = function(typ, val) {
		var typ, val;
		if ($interfaceIsEqual(typ, jsObjectPtr)) {
			return new (jsType(jsObjectPtr))(val);
		}
		return val;
	};
	unwrapJsObject = function(typ, val) {
		var typ, val;
		if ($interfaceIsEqual(typ, jsObjectPtr)) {
			return val.object;
		}
		return val;
	};
	Value.ptr.prototype.Elem = function() {
		var _1, _r, fl, k, tt, typ, v, val, val$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; fl = $f.fl; k = $f.k; tt = $f.tt; typ = $f.typ; v = $f.v; val = $f.val; val$1 = $f.val$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
			k = new flag(v.flag).kind();
			_1 = k;
			/* */ if (_1 === (20)) { $s = 2; continue; }
			/* */ if (_1 === (22)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_1 === (20)) { */ case 2:
				val = $clone(v, Value).object();
				if (val === $ifaceNil) {
					$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
				}
				typ = reflectType(val.constructor);
				_r = makeValue(typ, val.$val, (v.flag & 96) >>> 0); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (22)) { */ case 3:
				if ($clone(v, Value).IsNil()) {
					$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
				}
				val$1 = $clone(v, Value).object();
				tt = (v.typ.kindType);
				fl = (((((v.flag & 96) >>> 0) | 128) >>> 0) | 256) >>> 0;
				fl = (fl | (((tt.elem.Kind() >>> 0)))) >>> 0;
				$s = -1; return new Value.ptr(tt.elem, (wrapJsObject(tt.elem, val$1)), fl);
			/* } else { */ case 4:
				$panic(new ValueError.ptr("reflect.Value.Elem", k));
			/* } */ case 5:
		case 1:
		$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Elem }; } $f._1 = _1; $f._r = _r; $f.fl = fl; $f.k = k; $f.tt = tt; $f.typ = typ; $f.v = v; $f.val = val; $f.val$1 = val$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Elem = function() { return this.$val.Elem(); };
	Value.ptr.prototype.Field = function(i) {
		var _r, _r$1, _r$2, field, fl, i, jsTag, o, prop, s, tag, tt, typ, v, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; field = $f.field; fl = $f.fl; i = $f.i; jsTag = $f.jsTag; o = $f.o; prop = $f.prop; s = $f.s; tag = $f.tag; tt = $f.tt; typ = $f.typ; v = $f.v; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		jsTag = [jsTag];
		prop = [prop];
		s = [s];
		typ = [typ];
		v = this;
		if (!((new flag(v.flag).kind() === 25))) {
			$panic(new ValueError.ptr("reflect.Value.Field", new flag(v.flag).kind()));
		}
		tt = (v.typ.kindType);
		if (((i >>> 0)) >= ((tt.fields.$length >>> 0))) {
			$panic(new $String("reflect: Field index out of range"));
		}
		prop[0] = $internalize(jsType(v.typ).fields[i].prop, $String);
		field = (x = tt.fields, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
		typ[0] = field.typ;
		fl = (((v.flag & 416) >>> 0) | ((typ[0].Kind() >>> 0))) >>> 0;
		if (!$clone(field.name, name).isExported()) {
			if (field.anon()) {
				fl = (fl | (64)) >>> 0;
			} else {
				fl = (fl | (32)) >>> 0;
			}
		}
		tag = $clone((x$1 = tt.fields, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])).name, name).tag();
		/* */ if (!(tag === "") && !((i === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(tag === "") && !((i === 0))) { */ case 1:
			jsTag[0] = getJsTag(tag);
			/* */ if (!(jsTag[0] === "")) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(jsTag[0] === "")) { */ case 3:
				/* while (true) { */ case 5:
					o = [o];
					_r = $clone(v, Value).Field(0); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					v = _r;
					/* */ if (v.typ === jsObjectPtr) { $s = 8; continue; }
					/* */ $s = 9; continue;
					/* if (v.typ === jsObjectPtr) { */ case 8:
						o[0] = $clone(v, Value).object().object;
						$s = -1; return new Value.ptr(typ[0], (new (jsType(PtrTo(typ[0])))((function(jsTag, o, prop, s, typ) { return function() {
							return $internalize(o[0][$externalize(jsTag[0], $String)], jsType(typ[0]));
						}; })(jsTag, o, prop, s, typ), (function(jsTag, o, prop, s, typ) { return function(x$2) {
							var x$2;
							o[0][$externalize(jsTag[0], $String)] = $externalize(x$2, jsType(typ[0]));
						}; })(jsTag, o, prop, s, typ))), fl);
					/* } */ case 9:
					/* */ if (v.typ.Kind() === 22) { $s = 10; continue; }
					/* */ $s = 11; continue;
					/* if (v.typ.Kind() === 22) { */ case 10:
						_r$1 = $clone(v, Value).Elem(); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						v = _r$1;
					/* } */ case 11:
				/* } */ $s = 5; continue; case 6:
			/* } */ case 4:
		/* } */ case 2:
		s[0] = v.ptr;
		/* */ if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { $s = 13; continue; }
		/* */ $s = 14; continue;
		/* if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { */ case 13:
			$s = -1; return new Value.ptr(typ[0], (new (jsType(PtrTo(typ[0])))((function(jsTag, prop, s, typ) { return function() {
				return wrapJsObject(typ[0], s[0][$externalize(prop[0], $String)]);
			}; })(jsTag, prop, s, typ), (function(jsTag, prop, s, typ) { return function(x$2) {
				var x$2;
				s[0][$externalize(prop[0], $String)] = unwrapJsObject(typ[0], x$2);
			}; })(jsTag, prop, s, typ))), fl);
		/* } */ case 14:
		_r$2 = makeValue(typ[0], wrapJsObject(typ[0], s[0][$externalize(prop[0], $String)]), fl); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Field }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.field = field; $f.fl = fl; $f.i = i; $f.jsTag = jsTag; $f.o = o; $f.prop = prop; $f.s = s; $f.tag = tag; $f.tt = tt; $f.typ = typ; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Field = function(i) { return this.$val.Field(i); };
	getJsTag = function(tag) {
		var _tuple, i, name$1, qvalue, tag, value;
		while (true) {
			if (!(!(tag === ""))) { break; }
			i = 0;
			while (true) {
				if (!(i < tag.length && (tag.charCodeAt(i) === 32))) { break; }
				i = i + (1) >> 0;
			}
			tag = $substring(tag, i);
			if (tag === "") {
				break;
			}
			i = 0;
			while (true) {
				if (!(i < tag.length && !((tag.charCodeAt(i) === 32)) && !((tag.charCodeAt(i) === 58)) && !((tag.charCodeAt(i) === 34)))) { break; }
				i = i + (1) >> 0;
			}
			if ((i + 1 >> 0) >= tag.length || !((tag.charCodeAt(i) === 58)) || !((tag.charCodeAt((i + 1 >> 0)) === 34))) {
				break;
			}
			name$1 = ($substring(tag, 0, i));
			tag = $substring(tag, (i + 1 >> 0));
			i = 1;
			while (true) {
				if (!(i < tag.length && !((tag.charCodeAt(i) === 34)))) { break; }
				if (tag.charCodeAt(i) === 92) {
					i = i + (1) >> 0;
				}
				i = i + (1) >> 0;
			}
			if (i >= tag.length) {
				break;
			}
			qvalue = ($substring(tag, 0, (i + 1 >> 0)));
			tag = $substring(tag, (i + 1 >> 0));
			if (name$1 === "js") {
				_tuple = strconv.Unquote(qvalue);
				value = _tuple[0];
				return value;
			}
		}
		return "";
	};
	Value.ptr.prototype.Index = function(i) {
		var _1, _r, _r$1, a, a$1, c, fl, fl$1, fl$2, i, k, s, str, tt, tt$1, typ, typ$1, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; a = $f.a; a$1 = $f.a$1; c = $f.c; fl = $f.fl; fl$1 = $f.fl$1; fl$2 = $f.fl$2; i = $f.i; k = $f.k; s = $f.s; str = $f.str; tt = $f.tt; tt$1 = $f.tt$1; typ = $f.typ; typ$1 = $f.typ$1; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		a = [a];
		a$1 = [a$1];
		c = [c];
		i = [i];
		typ = [typ];
		typ$1 = [typ$1];
		v = this;
			k = new flag(v.flag).kind();
			_1 = k;
			/* */ if (_1 === (17)) { $s = 2; continue; }
			/* */ if (_1 === (23)) { $s = 3; continue; }
			/* */ if (_1 === (24)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_1 === (17)) { */ case 2:
				tt = (v.typ.kindType);
				if (i[0] < 0 || i[0] > ((tt.len >> 0))) {
					$panic(new $String("reflect: array index out of range"));
				}
				typ[0] = tt.elem;
				fl = (v.flag & 480) >>> 0;
				fl = (fl | (((typ[0].Kind() >>> 0)))) >>> 0;
				a[0] = v.ptr;
				/* */ if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { $s = 7; continue; }
				/* */ $s = 8; continue;
				/* if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { */ case 7:
					$s = -1; return new Value.ptr(typ[0], (new (jsType(PtrTo(typ[0])))((function(a, a$1, c, i, typ, typ$1) { return function() {
						return wrapJsObject(typ[0], a[0][i[0]]);
					}; })(a, a$1, c, i, typ, typ$1), (function(a, a$1, c, i, typ, typ$1) { return function(x) {
						var x;
						a[0][i[0]] = unwrapJsObject(typ[0], x);
					}; })(a, a$1, c, i, typ, typ$1))), fl);
				/* } */ case 8:
				_r = makeValue(typ[0], wrapJsObject(typ[0], a[0][i[0]]), fl); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (23)) { */ case 3:
				s = $clone(v, Value).object();
				if (i[0] < 0 || i[0] >= ($parseInt(s.$length) >> 0)) {
					$panic(new $String("reflect: slice index out of range"));
				}
				tt$1 = (v.typ.kindType);
				typ$1[0] = tt$1.elem;
				fl$1 = (384 | ((v.flag & 96) >>> 0)) >>> 0;
				fl$1 = (fl$1 | (((typ$1[0].Kind() >>> 0)))) >>> 0;
				i[0] = i[0] + (($parseInt(s.$offset) >> 0)) >> 0;
				a$1[0] = s.$array;
				/* */ if (!((((fl$1 & 128) >>> 0) === 0)) && !((typ$1[0].Kind() === 17)) && !((typ$1[0].Kind() === 25))) { $s = 10; continue; }
				/* */ $s = 11; continue;
				/* if (!((((fl$1 & 128) >>> 0) === 0)) && !((typ$1[0].Kind() === 17)) && !((typ$1[0].Kind() === 25))) { */ case 10:
					$s = -1; return new Value.ptr(typ$1[0], (new (jsType(PtrTo(typ$1[0])))((function(a, a$1, c, i, typ, typ$1) { return function() {
						return wrapJsObject(typ$1[0], a$1[0][i[0]]);
					}; })(a, a$1, c, i, typ, typ$1), (function(a, a$1, c, i, typ, typ$1) { return function(x) {
						var x;
						a$1[0][i[0]] = unwrapJsObject(typ$1[0], x);
					}; })(a, a$1, c, i, typ, typ$1))), fl$1);
				/* } */ case 11:
				_r$1 = makeValue(typ$1[0], wrapJsObject(typ$1[0], a$1[0][i[0]]), fl$1); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$s = -1; return _r$1;
			/* } else if (_1 === (24)) { */ case 4:
				str = (v.ptr).$get();
				if (i[0] < 0 || i[0] >= str.length) {
					$panic(new $String("reflect: string index out of range"));
				}
				fl$2 = (((v.flag & 96) >>> 0) | 8) >>> 0;
				c[0] = str.charCodeAt(i[0]);
				$s = -1; return new Value.ptr(uint8Type, ((c.$ptr || (c.$ptr = new ptrType$4(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, c)))), (fl$2 | 128) >>> 0);
			/* } else { */ case 5:
				$panic(new ValueError.ptr("reflect.Value.Index", k));
			/* } */ case 6:
		case 1:
		$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Index }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.a = a; $f.a$1 = a$1; $f.c = c; $f.fl = fl; $f.fl$1 = fl$1; $f.fl$2 = fl$2; $f.i = i; $f.k = k; $f.s = s; $f.str = str; $f.tt = tt; $f.tt$1 = tt$1; $f.typ = typ; $f.typ$1 = typ$1; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Index = function(i) { return this.$val.Index(i); };
	Value.ptr.prototype.InterfaceData = function() {
		var v;
		v = this;
		$panic(errors.New("InterfaceData is not supported by GopherJS"));
	};
	Value.prototype.InterfaceData = function() { return this.$val.InterfaceData(); };
	Value.ptr.prototype.IsNil = function() {
		var _1, k, v;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if ((_1 === (22)) || (_1 === (23))) {
			return $clone(v, Value).object() === jsType(v.typ).nil;
		} else if (_1 === (18)) {
			return $clone(v, Value).object() === $chanNil;
		} else if (_1 === (19)) {
			return $clone(v, Value).object() === $throwNilPointerError;
		} else if (_1 === (21)) {
			return $clone(v, Value).object() === false;
		} else if (_1 === (20)) {
			return $clone(v, Value).object() === $ifaceNil;
		} else {
			$panic(new ValueError.ptr("reflect.Value.IsNil", k));
		}
	};
	Value.prototype.IsNil = function() { return this.$val.IsNil(); };
	Value.ptr.prototype.Len = function() {
		var _1, k, v;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if ((_1 === (17)) || (_1 === (24))) {
			return $parseInt($clone(v, Value).object().length);
		} else if (_1 === (23)) {
			return $parseInt($clone(v, Value).object().$length) >> 0;
		} else if (_1 === (18)) {
			return $parseInt($clone(v, Value).object().$buffer.length) >> 0;
		} else if (_1 === (21)) {
			return $parseInt($keys($clone(v, Value).object()).length);
		} else {
			$panic(new ValueError.ptr("reflect.Value.Len", k));
		}
	};
	Value.prototype.Len = function() { return this.$val.Len(); };
	Value.ptr.prototype.Pointer = function() {
		var _1, k, v;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if ((_1 === (18)) || (_1 === (21)) || (_1 === (22)) || (_1 === (26))) {
			if ($clone(v, Value).IsNil()) {
				return 0;
			}
			return $clone(v, Value).object();
		} else if (_1 === (19)) {
			if ($clone(v, Value).IsNil()) {
				return 0;
			}
			return 1;
		} else if (_1 === (23)) {
			if ($clone(v, Value).IsNil()) {
				return 0;
			}
			return $clone(v, Value).object().$array;
		} else {
			$panic(new ValueError.ptr("reflect.Value.Pointer", k));
		}
	};
	Value.prototype.Pointer = function() { return this.$val.Pointer(); };
	Value.ptr.prototype.Set = function(x) {
		var _1, _r, _r$1, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(x.flag).mustBeExported();
		_r = $clone(x, Value).assignTo("reflect.Set", v.typ, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		x = _r;
		/* */ if (!((((v.flag & 128) >>> 0) === 0))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((((v.flag & 128) >>> 0) === 0))) { */ case 2:
				_1 = v.typ.Kind();
				/* */ if (_1 === (17)) { $s = 5; continue; }
				/* */ if (_1 === (20)) { $s = 6; continue; }
				/* */ if (_1 === (25)) { $s = 7; continue; }
				/* */ $s = 8; continue;
				/* if (_1 === (17)) { */ case 5:
					jsType(v.typ).copy(v.ptr, x.ptr);
					$s = 9; continue;
				/* } else if (_1 === (20)) { */ case 6:
					_r$1 = valueInterface($clone(x, Value), false); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					v.ptr.$set(_r$1);
					$s = 9; continue;
				/* } else if (_1 === (25)) { */ case 7:
					copyStruct(v.ptr, x.ptr, v.typ);
					$s = 9; continue;
				/* } else { */ case 8:
					v.ptr.$set($clone(x, Value).object());
				/* } */ case 9:
			case 4:
			$s = -1; return;
		/* } */ case 3:
		v.ptr = x.ptr;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Set }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Set = function(x) { return this.$val.Set(x); };
	Value.ptr.prototype.SetBytes = function(x) {
		var _r, _r$1, _v, slice, typedSlice, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _v = $f._v; slice = $f.slice; typedSlice = $f.typedSlice; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(23);
		_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 8))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 8))) { */ case 1:
			$panic(new $String("reflect.Value.SetBytes of non-byte slice"));
		/* } */ case 2:
		slice = x;
		if (!(v.typ.Name() === "")) { _v = true; $s = 6; continue s; }
		_r$1 = v.typ.Elem().Name(); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_v = !(_r$1 === ""); case 6:
		/* */ if (_v) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (_v) { */ case 4:
			typedSlice = new (jsType(v.typ))(slice.$array);
			typedSlice.$offset = slice.$offset;
			typedSlice.$length = slice.$length;
			typedSlice.$capacity = slice.$capacity;
			slice = typedSlice;
		/* } */ case 5:
		v.ptr.$set(slice);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.SetBytes }; } $f._r = _r; $f._r$1 = _r$1; $f._v = _v; $f.slice = slice; $f.typedSlice = typedSlice; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.SetBytes = function(x) { return this.$val.SetBytes(x); };
	Value.ptr.prototype.SetCap = function(n) {
		var n, newSlice, s, v;
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(23);
		s = v.ptr.$get();
		if (n < ($parseInt(s.$length) >> 0) || n > ($parseInt(s.$capacity) >> 0)) {
			$panic(new $String("reflect: slice capacity out of range in SetCap"));
		}
		newSlice = new (jsType(v.typ))(s.$array);
		newSlice.$offset = s.$offset;
		newSlice.$length = s.$length;
		newSlice.$capacity = n;
		v.ptr.$set(newSlice);
	};
	Value.prototype.SetCap = function(n) { return this.$val.SetCap(n); };
	Value.ptr.prototype.SetLen = function(n) {
		var n, newSlice, s, v;
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(23);
		s = v.ptr.$get();
		if (n < 0 || n > ($parseInt(s.$capacity) >> 0)) {
			$panic(new $String("reflect: slice length out of range in SetLen"));
		}
		newSlice = new (jsType(v.typ))(s.$array);
		newSlice.$offset = s.$offset;
		newSlice.$length = n;
		newSlice.$capacity = s.$capacity;
		v.ptr.$set(newSlice);
	};
	Value.prototype.SetLen = function(n) { return this.$val.SetLen(n); };
	Value.ptr.prototype.Slice = function(i, j) {
		var _1, _r, _r$1, cap, i, j, kind, s, str, tt, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; cap = $f.cap; i = $f.i; j = $f.j; kind = $f.kind; s = $f.s; str = $f.str; tt = $f.tt; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		cap = 0;
		typ = $ifaceNil;
		s = null;
			kind = new flag(v.flag).kind();
			_1 = kind;
			/* */ if (_1 === (17)) { $s = 2; continue; }
			/* */ if (_1 === (23)) { $s = 3; continue; }
			/* */ if (_1 === (24)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_1 === (17)) { */ case 2:
				if (((v.flag & 256) >>> 0) === 0) {
					$panic(new $String("reflect.Value.Slice: slice of unaddressable array"));
				}
				tt = (v.typ.kindType);
				cap = ((tt.len >> 0));
				typ = SliceOf(tt.elem);
				s = new (jsType(typ))($clone(v, Value).object());
				$s = 6; continue;
			/* } else if (_1 === (23)) { */ case 3:
				typ = v.typ;
				s = $clone(v, Value).object();
				cap = $parseInt(s.$capacity) >> 0;
				$s = 6; continue;
			/* } else if (_1 === (24)) { */ case 4:
				str = (v.ptr).$get();
				if (i < 0 || j < i || j > str.length) {
					$panic(new $String("reflect.Value.Slice: string slice index out of bounds"));
				}
				_r = ValueOf(new $String($substring(str, i, j))); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else { */ case 5:
				$panic(new ValueError.ptr("reflect.Value.Slice", kind));
			/* } */ case 6:
		case 1:
		if (i < 0 || j < i || j > cap) {
			$panic(new $String("reflect.Value.Slice: slice index out of bounds"));
		}
		_r$1 = makeValue(typ, $subslice(s, i, j), (v.flag & 96) >>> 0); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Slice }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.cap = cap; $f.i = i; $f.j = j; $f.kind = kind; $f.s = s; $f.str = str; $f.tt = tt; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Slice = function(i, j) { return this.$val.Slice(i, j); };
	Value.ptr.prototype.Slice3 = function(i, j, k) {
		var _1, _r, cap, i, j, k, kind, s, tt, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; cap = $f.cap; i = $f.i; j = $f.j; k = $f.k; kind = $f.kind; s = $f.s; tt = $f.tt; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		cap = 0;
		typ = $ifaceNil;
		s = null;
		kind = new flag(v.flag).kind();
		_1 = kind;
		if (_1 === (17)) {
			if (((v.flag & 256) >>> 0) === 0) {
				$panic(new $String("reflect.Value.Slice: slice of unaddressable array"));
			}
			tt = (v.typ.kindType);
			cap = ((tt.len >> 0));
			typ = SliceOf(tt.elem);
			s = new (jsType(typ))($clone(v, Value).object());
		} else if (_1 === (23)) {
			typ = v.typ;
			s = $clone(v, Value).object();
			cap = $parseInt(s.$capacity) >> 0;
		} else {
			$panic(new ValueError.ptr("reflect.Value.Slice3", kind));
		}
		if (i < 0 || j < i || k < j || k > cap) {
			$panic(new $String("reflect.Value.Slice3: slice index out of bounds"));
		}
		_r = makeValue(typ, $subslice(s, i, j, k), (v.flag & 96) >>> 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Slice3 }; } $f._1 = _1; $f._r = _r; $f.cap = cap; $f.i = i; $f.j = j; $f.k = k; $f.kind = kind; $f.s = s; $f.tt = tt; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Slice3 = function(i, j, k) { return this.$val.Slice3(i, j, k); };
	Value.ptr.prototype.Close = function() {
		var v;
		v = this;
		new flag(v.flag).mustBe(18);
		new flag(v.flag).mustBeExported();
		$close($clone(v, Value).object());
	};
	Value.prototype.Close = function() { return this.$val.Close(); };
	chanrecv = function(ch, nb, val) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, ch, comms, nb, received, recvRes, selectRes, selected, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; ch = $f.ch; comms = $f.comms; nb = $f.nb; received = $f.received; recvRes = $f.recvRes; selectRes = $f.selectRes; selected = $f.selected; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		selected = false;
		received = false;
		comms = new sliceType$11([new sliceType$8([ch])]);
		if (nb) {
			comms = $append(comms, new sliceType$8([]));
		}
		_r = selectHelper(new sliceType$3([comms])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		selectRes = _r;
		if (nb && (($parseInt(selectRes[0]) >> 0) === 1)) {
			_tmp = false;
			_tmp$1 = false;
			selected = _tmp;
			received = _tmp$1;
			$s = -1; return [selected, received];
		}
		recvRes = selectRes[1];
		val.$set(recvRes[0]);
		_tmp$2 = true;
		_tmp$3 = !!(recvRes[1]);
		selected = _tmp$2;
		received = _tmp$3;
		$s = -1; return [selected, received];
		/* */ } return; } if ($f === undefined) { $f = { $blk: chanrecv }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.ch = ch; $f.comms = comms; $f.nb = nb; $f.received = received; $f.recvRes = recvRes; $f.selectRes = selectRes; $f.selected = selected; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	chansend = function(ch, val, nb) {
		var _r, ch, comms, nb, selectRes, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; ch = $f.ch; comms = $f.comms; nb = $f.nb; selectRes = $f.selectRes; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		comms = new sliceType$11([new sliceType$8([ch, val.$get()])]);
		if (nb) {
			comms = $append(comms, new sliceType$8([]));
		}
		_r = selectHelper(new sliceType$3([comms])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		selectRes = _r;
		if (nb && (($parseInt(selectRes[0]) >> 0) === 1)) {
			$s = -1; return false;
		}
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: chansend }; } $f._r = _r; $f.ch = ch; $f.comms = comms; $f.nb = nb; $f.selectRes = selectRes; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Swapper = function(slice) {
		var _1, _r, _r$1, _r$2, _r$3, slice, tmp, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; slice = $f.slice; tmp = $f.tmp; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		tmp = [tmp];
		v = [v];
		_r = ValueOf(slice); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		v[0] = _r;
		if (!(($clone(v[0], Value).Kind() === 23))) {
			$panic(new ValueError.ptr("Swapper", $clone(v[0], Value).Kind()));
		}
			_1 = $clone(v[0], Value).Len();
			if (_1 === (0)) {
				$s = -1; return (function(tmp, v) { return function(i, j) {
					var i, j;
					$panic(new $String("reflect: slice index out of range"));
				}; })(tmp, v);
			} else if (_1 === (1)) {
				$s = -1; return (function(tmp, v) { return function(i, j) {
					var i, j;
					if (!((i === 0)) || !((j === 0))) {
						$panic(new $String("reflect: slice index out of range"));
					}
				}; })(tmp, v);
			}
		case 2:
		_r$1 = $clone(v[0], Value).Type().Elem(); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = New(_r$1); /* */ $s = 4; case 4: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$3 = $clone(_r$2, Value).Elem(); /* */ $s = 5; case 5: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		tmp[0] = _r$3;
		$s = -1; return (function(tmp, v) { return function $b(i, j) {
			var _r$4, _r$5, i, j, v1, v2, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$4 = $f._r$4; _r$5 = $f._r$5; i = $f.i; j = $f.j; v1 = $f.v1; v2 = $f.v2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r$4 = $clone(v[0], Value).Index(i); /* */ $s = 1; case 1: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			v1 = _r$4;
			_r$5 = $clone(v[0], Value).Index(j); /* */ $s = 2; case 2: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			v2 = _r$5;
			$r = $clone(tmp[0], Value).Set($clone(v1, Value)); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = $clone(v1, Value).Set($clone(v2, Value)); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = $clone(v2, Value).Set($clone(tmp[0], Value)); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$4 = _r$4; $f._r$5 = _r$5; $f.i = i; $f.j = j; $f.v1 = v1; $f.v2 = v2; $f.$s = $s; $f.$r = $r; return $f;
		}; })(tmp, v);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Swapper }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.slice = slice; $f.tmp = tmp; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Swapper = Swapper;
	structField.ptr.prototype.offset = function() {
		var f;
		f = this;
		return f.offsetAnon >>> 1 >>> 0;
	};
	structField.prototype.offset = function() { return this.$val.offset(); };
	structField.ptr.prototype.anon = function() {
		var f;
		f = this;
		return !((((f.offsetAnon & 1) >>> 0) === 0));
	};
	structField.prototype.anon = function() { return this.$val.anon(); };
	Kind.prototype.String = function() {
		var k;
		k = this.$val;
		if (((k >> 0)) < kindNames.$length) {
			return ((k < 0 || k >= kindNames.$length) ? ($throwRuntimeError("index out of range"), undefined) : kindNames.$array[kindNames.$offset + k]);
		}
		return "kind" + strconv.Itoa(((k >> 0)));
	};
	$ptrType(Kind).prototype.String = function() { return new Kind(this.$get()).String(); };
	rtype.ptr.prototype.String = function() {
		var s, t;
		t = this;
		s = $clone(t.nameOff(t.str), name).name();
		if (!((((t.tflag & 2) >>> 0) === 0))) {
			return $substring(s, 1);
		}
		return s;
	};
	rtype.prototype.String = function() { return this.$val.String(); };
	rtype.ptr.prototype.Size = function() {
		var t;
		t = this;
		return t.size;
	};
	rtype.prototype.Size = function() { return this.$val.Size(); };
	rtype.ptr.prototype.Bits = function() {
		var k, t;
		t = this;
		if (t === ptrType$1.nil) {
			$panic(new $String("reflect: Bits of nil Type"));
		}
		k = t.Kind();
		if (k < 2 || k > 16) {
			$panic(new $String("reflect: Bits of non-arithmetic Type " + t.String()));
		}
		return $imul(((t.size >> 0)), 8);
	};
	rtype.prototype.Bits = function() { return this.$val.Bits(); };
	rtype.ptr.prototype.Align = function() {
		var t;
		t = this;
		return ((t.align >> 0));
	};
	rtype.prototype.Align = function() { return this.$val.Align(); };
	rtype.ptr.prototype.FieldAlign = function() {
		var t;
		t = this;
		return ((t.fieldAlign >> 0));
	};
	rtype.prototype.FieldAlign = function() { return this.$val.FieldAlign(); };
	rtype.ptr.prototype.Kind = function() {
		var t;
		t = this;
		return ((((t.kind & 31) >>> 0) >>> 0));
	};
	rtype.prototype.Kind = function() { return this.$val.Kind(); };
	rtype.ptr.prototype.common = function() {
		var t;
		t = this;
		return t;
	};
	rtype.prototype.common = function() { return this.$val.common(); };
	rtype.ptr.prototype.exportedMethods = function() {
		var _i, _i$1, _r, _r$1, _ref, _ref$1, _tuple, _tuple$1, allExported, allm, found, m, m$1, methods, methodsi, name$1, name$2, t, ut, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; allExported = $f.allExported; allm = $f.allm; found = $f.found; m = $f.m; m$1 = $f.m$1; methods = $f.methods; methodsi = $f.methodsi; name$1 = $f.name$1; name$2 = $f.name$2; t = $f.t; ut = $f.ut; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = methodCache.Load(t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		methodsi = _tuple[0];
		found = _tuple[1];
		if (found) {
			$s = -1; return $assertType(methodsi, sliceType$5);
		}
		ut = t.uncommon();
		if (ut === ptrType$5.nil) {
			$s = -1; return sliceType$5.nil;
		}
		allm = ut.methods();
		allExported = true;
		_ref = allm;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			m = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), method);
			name$1 = $clone(t.nameOff(m.name), name);
			if (!$clone(name$1, name).isExported()) {
				allExported = false;
				break;
			}
			_i++;
		}
		methods = sliceType$5.nil;
		if (allExported) {
			methods = allm;
		} else {
			methods = $makeSlice(sliceType$5, 0, allm.$length);
			_ref$1 = allm;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$1.$length)) { break; }
				m$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), method);
				name$2 = $clone(t.nameOff(m$1.name), name);
				if ($clone(name$2, name).isExported()) {
					methods = $append(methods, m$1);
				}
				_i$1++;
			}
			methods = $subslice(methods, 0, methods.$length, methods.$length);
		}
		_r$1 = methodCache.LoadOrStore(t, methods); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		methodsi = _tuple$1[0];
		$s = -1; return $assertType(methodsi, sliceType$5);
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.exportedMethods }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.allExported = allExported; $f.allm = allm; $f.found = found; $f.m = m; $f.m$1 = m$1; $f.methods = methods; $f.methodsi = methodsi; $f.name$1 = name$1; $f.name$2 = name$2; $f.t = t; $f.ut = ut; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.exportedMethods = function() { return this.$val.exportedMethods(); };
	rtype.ptr.prototype.NumMethod = function() {
		var _r, t, tt, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (t.Kind() === 20) {
			tt = (t.kindType);
			$s = -1; return tt.NumMethod();
		}
		if (((t.tflag & 1) >>> 0) === 0) {
			$s = -1; return 0;
		}
		_r = t.exportedMethods(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r.$length;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.NumMethod }; } $f._r = _r; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.NumMethod = function() { return this.$val.NumMethod(); };
	rtype.ptr.prototype.MethodByName = function(name$1) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, i, m, name$1, ok, p, pname, t, tt, ut, utmethods, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; i = $f.i; m = $f.m; name$1 = $f.name$1; ok = $f.ok; p = $f.p; pname = $f.pname; t = $f.t; tt = $f.tt; ut = $f.ut; utmethods = $f.utmethods; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
		ok = false;
		t = this;
		if (t.Kind() === 20) {
			tt = (t.kindType);
			_tuple = tt.MethodByName(name$1);
			Method.copy(m, _tuple[0]);
			ok = _tuple[1];
			$s = -1; return [m, ok];
		}
		ut = t.uncommon();
		if (ut === ptrType$5.nil) {
			_tmp = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
			_tmp$1 = false;
			Method.copy(m, _tmp);
			ok = _tmp$1;
			$s = -1; return [m, ok];
		}
		utmethods = ut.methods();
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < ((ut.mcount >> 0)))) { break; } */ if(!(i < ((ut.mcount >> 0)))) { $s = 2; continue; }
			p = $clone(((i < 0 || i >= utmethods.$length) ? ($throwRuntimeError("index out of range"), undefined) : utmethods.$array[utmethods.$offset + i]), method);
			pname = $clone(t.nameOff(p.name), name);
			/* */ if ($clone(pname, name).isExported() && $clone(pname, name).name() === name$1) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if ($clone(pname, name).isExported() && $clone(pname, name).name() === name$1) { */ case 3:
				_r = t.Method(i); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tmp$2 = $clone(_r, Method);
				_tmp$3 = true;
				Method.copy(m, _tmp$2);
				ok = _tmp$3;
				$s = -1; return [m, ok];
			/* } */ case 4:
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		_tmp$4 = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
		_tmp$5 = false;
		Method.copy(m, _tmp$4);
		ok = _tmp$5;
		$s = -1; return [m, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.MethodByName }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.i = i; $f.m = m; $f.name$1 = name$1; $f.ok = ok; $f.p = p; $f.pname = pname; $f.t = t; $f.tt = tt; $f.ut = ut; $f.utmethods = utmethods; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.MethodByName = function(name$1) { return this.$val.MethodByName(name$1); };
	rtype.ptr.prototype.PkgPath = function() {
		var t, ut;
		t = this;
		if (((t.tflag & 4) >>> 0) === 0) {
			return "";
		}
		ut = t.uncommon();
		if (ut === ptrType$5.nil) {
			return "";
		}
		return $clone(t.nameOff(ut.pkgPath), name).name();
	};
	rtype.prototype.PkgPath = function() { return this.$val.PkgPath(); };
	rtype.ptr.prototype.Name = function() {
		var i, s, t;
		t = this;
		if (((t.tflag & 4) >>> 0) === 0) {
			return "";
		}
		s = t.String();
		i = s.length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			if (s.charCodeAt(i) === 46) {
				break;
			}
			i = i - (1) >> 0;
		}
		return $substring(s, (i + 1 >> 0));
	};
	rtype.prototype.Name = function() { return this.$val.Name(); };
	rtype.ptr.prototype.ChanDir = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 18))) {
			$panic(new $String("reflect: ChanDir of non-chan type"));
		}
		tt = (t.kindType);
		return ((tt.dir >> 0));
	};
	rtype.prototype.ChanDir = function() { return this.$val.ChanDir(); };
	rtype.ptr.prototype.IsVariadic = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			$panic(new $String("reflect: IsVariadic of non-func type"));
		}
		tt = (t.kindType);
		return !((((tt.outCount & 32768) >>> 0) === 0));
	};
	rtype.prototype.IsVariadic = function() { return this.$val.IsVariadic(); };
	rtype.ptr.prototype.Elem = function() {
		var _1, t, tt, tt$1, tt$2, tt$3, tt$4;
		t = this;
		_1 = t.Kind();
		if (_1 === (17)) {
			tt = (t.kindType);
			return toType(tt.elem);
		} else if (_1 === (18)) {
			tt$1 = (t.kindType);
			return toType(tt$1.elem);
		} else if (_1 === (21)) {
			tt$2 = (t.kindType);
			return toType(tt$2.elem);
		} else if (_1 === (22)) {
			tt$3 = (t.kindType);
			return toType(tt$3.elem);
		} else if (_1 === (23)) {
			tt$4 = (t.kindType);
			return toType(tt$4.elem);
		}
		$panic(new $String("reflect: Elem of invalid type"));
	};
	rtype.prototype.Elem = function() { return this.$val.Elem(); };
	rtype.ptr.prototype.Field = function(i) {
		var i, t, tt;
		t = this;
		if (!((t.Kind() === 25))) {
			$panic(new $String("reflect: Field of non-struct type"));
		}
		tt = (t.kindType);
		return tt.Field(i);
	};
	rtype.prototype.Field = function(i) { return this.$val.Field(i); };
	rtype.ptr.prototype.FieldByIndex = function(index) {
		var _r, index, t, tt, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; index = $f.index; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (!((t.Kind() === 25))) {
			$panic(new $String("reflect: FieldByIndex of non-struct type"));
		}
		tt = (t.kindType);
		_r = tt.FieldByIndex(index); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.FieldByIndex }; } $f._r = _r; $f.index = index; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.FieldByIndex = function(index) { return this.$val.FieldByIndex(index); };
	rtype.ptr.prototype.FieldByName = function(name$1) {
		var _r, name$1, t, tt, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; name$1 = $f.name$1; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (!((t.Kind() === 25))) {
			$panic(new $String("reflect: FieldByName of non-struct type"));
		}
		tt = (t.kindType);
		_r = tt.FieldByName(name$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.FieldByName }; } $f._r = _r; $f.name$1 = name$1; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.FieldByName = function(name$1) { return this.$val.FieldByName(name$1); };
	rtype.ptr.prototype.FieldByNameFunc = function(match) {
		var _r, match, t, tt, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; match = $f.match; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (!((t.Kind() === 25))) {
			$panic(new $String("reflect: FieldByNameFunc of non-struct type"));
		}
		tt = (t.kindType);
		_r = tt.FieldByNameFunc(match); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.FieldByNameFunc }; } $f._r = _r; $f.match = match; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.FieldByNameFunc = function(match) { return this.$val.FieldByNameFunc(match); };
	rtype.ptr.prototype.In = function(i) {
		var i, t, tt, x;
		t = this;
		if (!((t.Kind() === 19))) {
			$panic(new $String("reflect: In of non-func type"));
		}
		tt = (t.kindType);
		return toType((x = tt.in$(), ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])));
	};
	rtype.prototype.In = function(i) { return this.$val.In(i); };
	rtype.ptr.prototype.Key = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 21))) {
			$panic(new $String("reflect: Key of non-map type"));
		}
		tt = (t.kindType);
		return toType(tt.key);
	};
	rtype.prototype.Key = function() { return this.$val.Key(); };
	rtype.ptr.prototype.Len = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 17))) {
			$panic(new $String("reflect: Len of non-array type"));
		}
		tt = (t.kindType);
		return ((tt.len >> 0));
	};
	rtype.prototype.Len = function() { return this.$val.Len(); };
	rtype.ptr.prototype.NumField = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 25))) {
			$panic(new $String("reflect: NumField of non-struct type"));
		}
		tt = (t.kindType);
		return tt.fields.$length;
	};
	rtype.prototype.NumField = function() { return this.$val.NumField(); };
	rtype.ptr.prototype.NumIn = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			$panic(new $String("reflect: NumIn of non-func type"));
		}
		tt = (t.kindType);
		return ((tt.inCount >> 0));
	};
	rtype.prototype.NumIn = function() { return this.$val.NumIn(); };
	rtype.ptr.prototype.NumOut = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			$panic(new $String("reflect: NumOut of non-func type"));
		}
		tt = (t.kindType);
		return tt.out().$length;
	};
	rtype.prototype.NumOut = function() { return this.$val.NumOut(); };
	rtype.ptr.prototype.Out = function(i) {
		var i, t, tt, x;
		t = this;
		if (!((t.Kind() === 19))) {
			$panic(new $String("reflect: Out of non-func type"));
		}
		tt = (t.kindType);
		return toType((x = tt.out(), ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])));
	};
	rtype.prototype.Out = function(i) { return this.$val.Out(i); };
	ChanDir.prototype.String = function() {
		var _1, d;
		d = this.$val;
		_1 = d;
		if (_1 === (2)) {
			return "chan<-";
		} else if (_1 === (1)) {
			return "<-chan";
		} else if (_1 === (3)) {
			return "chan";
		}
		return "ChanDir" + strconv.Itoa(((d >> 0)));
	};
	$ptrType(ChanDir).prototype.String = function() { return new ChanDir(this.$get()).String(); };
	interfaceType.ptr.prototype.Method = function(i) {
		var i, m, p, pname, t, x;
		m = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
		t = this;
		if (i < 0 || i >= t.methods.$length) {
			return m;
		}
		p = (x = t.methods, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
		pname = $clone(t.rtype.nameOff(p.name), name);
		m.Name = $clone(pname, name).name();
		if (!$clone(pname, name).isExported()) {
			m.PkgPath = $clone(pname, name).pkgPath();
			if (m.PkgPath === "") {
				m.PkgPath = $clone(t.pkgPath, name).name();
			}
		}
		m.Type = toType(t.rtype.typeOff(p.typ));
		m.Index = i;
		return m;
	};
	interfaceType.prototype.Method = function(i) { return this.$val.Method(i); };
	interfaceType.ptr.prototype.NumMethod = function() {
		var t;
		t = this;
		return t.methods.$length;
	};
	interfaceType.prototype.NumMethod = function() { return this.$val.NumMethod(); };
	interfaceType.ptr.prototype.MethodByName = function(name$1) {
		var _i, _ref, _tmp, _tmp$1, i, m, name$1, ok, p, t, x;
		m = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
		ok = false;
		t = this;
		if (t === ptrType$7.nil) {
			return [m, ok];
		}
		p = ptrType$8.nil;
		_ref = t.methods;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			p = (x = t.methods, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			if ($clone(t.rtype.nameOff(p.name), name).name() === name$1) {
				_tmp = $clone(t.Method(i), Method);
				_tmp$1 = true;
				Method.copy(m, _tmp);
				ok = _tmp$1;
				return [m, ok];
			}
			_i++;
		}
		return [m, ok];
	};
	interfaceType.prototype.MethodByName = function(name$1) { return this.$val.MethodByName(name$1); };
	StructTag.prototype.Get = function(key) {
		var _tuple, key, tag, v;
		tag = this.$val;
		_tuple = new StructTag(tag).Lookup(key);
		v = _tuple[0];
		return v;
	};
	$ptrType(StructTag).prototype.Get = function(key) { return new StructTag(this.$get()).Get(key); };
	StructTag.prototype.Lookup = function(key) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, err, i, key, name$1, ok, qvalue, tag, value, value$1;
		value = "";
		ok = false;
		tag = this.$val;
		while (true) {
			if (!(!(tag === ""))) { break; }
			i = 0;
			while (true) {
				if (!(i < tag.length && (tag.charCodeAt(i) === 32))) { break; }
				i = i + (1) >> 0;
			}
			tag = $substring(tag, i);
			if (tag === "") {
				break;
			}
			i = 0;
			while (true) {
				if (!(i < tag.length && tag.charCodeAt(i) > 32 && !((tag.charCodeAt(i) === 58)) && !((tag.charCodeAt(i) === 34)) && !((tag.charCodeAt(i) === 127)))) { break; }
				i = i + (1) >> 0;
			}
			if ((i === 0) || (i + 1 >> 0) >= tag.length || !((tag.charCodeAt(i) === 58)) || !((tag.charCodeAt((i + 1 >> 0)) === 34))) {
				break;
			}
			name$1 = ($substring(tag, 0, i));
			tag = $substring(tag, (i + 1 >> 0));
			i = 1;
			while (true) {
				if (!(i < tag.length && !((tag.charCodeAt(i) === 34)))) { break; }
				if (tag.charCodeAt(i) === 92) {
					i = i + (1) >> 0;
				}
				i = i + (1) >> 0;
			}
			if (i >= tag.length) {
				break;
			}
			qvalue = ($substring(tag, 0, (i + 1 >> 0)));
			tag = $substring(tag, (i + 1 >> 0));
			if (key === name$1) {
				_tuple = strconv.Unquote(qvalue);
				value$1 = _tuple[0];
				err = _tuple[1];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					break;
				}
				_tmp = value$1;
				_tmp$1 = true;
				value = _tmp;
				ok = _tmp$1;
				return [value, ok];
			}
		}
		_tmp$2 = "";
		_tmp$3 = false;
		value = _tmp$2;
		ok = _tmp$3;
		return [value, ok];
	};
	$ptrType(StructTag).prototype.Lookup = function(key) { return new StructTag(this.$get()).Lookup(key); };
	structType.ptr.prototype.Field = function(i) {
		var f, i, p, t, tag, x;
		f = new StructField.ptr("", "", $ifaceNil, "", 0, sliceType$13.nil, false);
		t = this;
		if (i < 0 || i >= t.fields.$length) {
			$panic(new $String("reflect: Field index out of bounds"));
		}
		p = (x = t.fields, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
		f.Type = toType(p.typ);
		f.Name = $clone(p.name, name).name();
		f.Anonymous = p.anon();
		if (!$clone(p.name, name).isExported()) {
			f.PkgPath = $clone(p.name, name).pkgPath();
			if (f.PkgPath === "") {
				f.PkgPath = $clone(t.pkgPath, name).name();
			}
		}
		tag = $clone(p.name, name).tag();
		if (!(tag === "")) {
			f.Tag = (tag);
		}
		f.Offset = p.offset();
		f.Index = new sliceType$13([i]);
		return f;
	};
	structType.prototype.Field = function(i) { return this.$val.Field(i); };
	structType.ptr.prototype.FieldByIndex = function(index) {
		var _i, _r, _r$1, _r$2, _r$3, _r$4, _ref, _v, f, ft, i, index, t, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; _v = $f._v; f = $f.f; ft = $f.ft; i = $f.i; index = $f.index; t = $f.t; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = new StructField.ptr("", "", $ifaceNil, "", 0, sliceType$13.nil, false);
		t = this;
		f.Type = toType(t.rtype);
		_ref = index;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			x = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			/* */ if (i > 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (i > 0) { */ case 3:
				ft = f.Type;
				_r = ft.Kind(); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				if (!(_r === 22)) { _v = false; $s = 7; continue s; }
				_r$1 = ft.Elem(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_r$2 = _r$1.Kind(); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_v = _r$2 === 25; case 7:
				/* */ if (_v) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (_v) { */ case 5:
					_r$3 = ft.Elem(); /* */ $s = 11; case 11: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					ft = _r$3;
				/* } */ case 6:
				f.Type = ft;
			/* } */ case 4:
			_r$4 = f.Type.Field(x); /* */ $s = 12; case 12: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			StructField.copy(f, _r$4);
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return f;
		/* */ } return; } if ($f === undefined) { $f = { $blk: structType.ptr.prototype.FieldByIndex }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f._v = _v; $f.f = f; $f.ft = ft; $f.i = i; $f.index = index; $f.t = t; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	structType.prototype.FieldByIndex = function(index) { return this.$val.FieldByIndex(index); };
	structType.ptr.prototype.FieldByNameFunc = function(match) {
		var _entry, _entry$1, _entry$2, _entry$3, _i, _i$1, _key, _key$1, _key$2, _key$3, _r, _r$1, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, count, current, f, fname, i, index, match, next, nextCount, ntyp, ok, result, scan, styp, t, t$1, visited, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _i = $f._i; _i$1 = $f._i$1; _key = $f._key; _key$1 = $f._key$1; _key$2 = $f._key$2; _key$3 = $f._key$3; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; count = $f.count; current = $f.current; f = $f.f; fname = $f.fname; i = $f.i; index = $f.index; match = $f.match; next = $f.next; nextCount = $f.nextCount; ntyp = $f.ntyp; ok = $f.ok; result = $f.result; scan = $f.scan; styp = $f.styp; t = $f.t; t$1 = $f.t$1; visited = $f.visited; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = new StructField.ptr("", "", $ifaceNil, "", 0, sliceType$13.nil, false);
		ok = false;
		t = this;
		current = new sliceType$14([]);
		next = new sliceType$14([new fieldScan.ptr(t, sliceType$13.nil)]);
		nextCount = false;
		visited = $makeMap(ptrType$9.keyFor, []);
		/* while (true) { */ case 1:
			/* if (!(next.$length > 0)) { break; } */ if(!(next.$length > 0)) { $s = 2; continue; }
			_tmp = next;
			_tmp$1 = $subslice(current, 0, 0);
			current = _tmp;
			next = _tmp$1;
			count = nextCount;
			nextCount = false;
			_ref = current;
			_i = 0;
			/* while (true) { */ case 3:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 4; continue; }
				scan = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), fieldScan);
				t$1 = scan.typ;
				/* */ if ((_entry = visited[ptrType$9.keyFor(t$1)], _entry !== undefined ? _entry.v : false)) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if ((_entry = visited[ptrType$9.keyFor(t$1)], _entry !== undefined ? _entry.v : false)) { */ case 5:
					_i++;
					/* continue; */ $s = 3; continue;
				/* } */ case 6:
				_key = t$1; (visited || $throwRuntimeError("assignment to entry in nil map"))[ptrType$9.keyFor(_key)] = { k: _key, v: true };
				_ref$1 = t$1.fields;
				_i$1 = 0;
				/* while (true) { */ case 7:
					/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 8; continue; }
					i = _i$1;
					f = (x = t$1.fields, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
					fname = $clone(f.name, name).name();
					ntyp = ptrType$1.nil;
					/* */ if (f.anon()) { $s = 9; continue; }
					/* */ $s = 10; continue;
					/* if (f.anon()) { */ case 9:
						ntyp = f.typ;
						/* */ if (ntyp.Kind() === 22) { $s = 11; continue; }
						/* */ $s = 12; continue;
						/* if (ntyp.Kind() === 22) { */ case 11:
							_r = ntyp.Elem().common(); /* */ $s = 13; case 13: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
							ntyp = _r;
						/* } */ case 12:
					/* } */ case 10:
					_r$1 = match(fname); /* */ $s = 16; case 16: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					/* */ if (_r$1) { $s = 14; continue; }
					/* */ $s = 15; continue;
					/* if (_r$1) { */ case 14:
						if ((_entry$1 = count[ptrType$9.keyFor(t$1)], _entry$1 !== undefined ? _entry$1.v : 0) > 1 || ok) {
							_tmp$2 = new StructField.ptr("", "", $ifaceNil, "", 0, sliceType$13.nil, false);
							_tmp$3 = false;
							StructField.copy(result, _tmp$2);
							ok = _tmp$3;
							$s = -1; return [result, ok];
						}
						StructField.copy(result, t$1.Field(i));
						result.Index = sliceType$13.nil;
						result.Index = $appendSlice(result.Index, scan.index);
						result.Index = $append(result.Index, i);
						ok = true;
						_i$1++;
						/* continue; */ $s = 7; continue;
					/* } */ case 15:
					if (ok || ntyp === ptrType$1.nil || !((ntyp.Kind() === 25))) {
						_i$1++;
						/* continue; */ $s = 7; continue;
					}
					styp = (ntyp.kindType);
					if ((_entry$2 = nextCount[ptrType$9.keyFor(styp)], _entry$2 !== undefined ? _entry$2.v : 0) > 0) {
						_key$1 = styp; (nextCount || $throwRuntimeError("assignment to entry in nil map"))[ptrType$9.keyFor(_key$1)] = { k: _key$1, v: 2 };
						_i$1++;
						/* continue; */ $s = 7; continue;
					}
					if (nextCount === false) {
						nextCount = $makeMap(ptrType$9.keyFor, []);
					}
					_key$2 = styp; (nextCount || $throwRuntimeError("assignment to entry in nil map"))[ptrType$9.keyFor(_key$2)] = { k: _key$2, v: 1 };
					if ((_entry$3 = count[ptrType$9.keyFor(t$1)], _entry$3 !== undefined ? _entry$3.v : 0) > 1) {
						_key$3 = styp; (nextCount || $throwRuntimeError("assignment to entry in nil map"))[ptrType$9.keyFor(_key$3)] = { k: _key$3, v: 2 };
					}
					index = sliceType$13.nil;
					index = $appendSlice(index, scan.index);
					index = $append(index, i);
					next = $append(next, new fieldScan.ptr(styp, index));
					_i$1++;
				/* } */ $s = 7; continue; case 8:
				_i++;
			/* } */ $s = 3; continue; case 4:
			if (ok) {
				/* break; */ $s = 2; continue;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [result, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: structType.ptr.prototype.FieldByNameFunc }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._i = _i; $f._i$1 = _i$1; $f._key = _key; $f._key$1 = _key$1; $f._key$2 = _key$2; $f._key$3 = _key$3; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.count = count; $f.current = current; $f.f = f; $f.fname = fname; $f.i = i; $f.index = index; $f.match = match; $f.next = next; $f.nextCount = nextCount; $f.ntyp = ntyp; $f.ok = ok; $f.result = result; $f.scan = scan; $f.styp = styp; $f.t = t; $f.t$1 = t$1; $f.visited = visited; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	structType.prototype.FieldByNameFunc = function(match) { return this.$val.FieldByNameFunc(match); };
	structType.ptr.prototype.FieldByName = function(name$1) {
		var _i, _r, _ref, _tmp, _tmp$1, _tuple, f, hasAnon, i, name$1, present, t, tf, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; f = $f.f; hasAnon = $f.hasAnon; i = $f.i; name$1 = $f.name$1; present = $f.present; t = $f.t; tf = $f.tf; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		name$1 = [name$1];
		f = new StructField.ptr("", "", $ifaceNil, "", 0, sliceType$13.nil, false);
		present = false;
		t = this;
		hasAnon = false;
		if (!(name$1[0] === "")) {
			_ref = t.fields;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				tf = (x = t.fields, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
				if ($clone(tf.name, name).name() === name$1[0]) {
					_tmp = $clone(t.Field(i), StructField);
					_tmp$1 = true;
					StructField.copy(f, _tmp);
					present = _tmp$1;
					$s = -1; return [f, present];
				}
				if (tf.anon()) {
					hasAnon = true;
				}
				_i++;
			}
		}
		if (!hasAnon) {
			$s = -1; return [f, present];
		}
		_r = t.FieldByNameFunc((function(name$1) { return function(s) {
			var s;
			return s === name$1[0];
		}; })(name$1)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		StructField.copy(f, _tuple[0]);
		present = _tuple[1];
		$s = -1; return [f, present];
		/* */ } return; } if ($f === undefined) { $f = { $blk: structType.ptr.prototype.FieldByName }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.f = f; $f.hasAnon = hasAnon; $f.i = i; $f.name$1 = name$1; $f.present = present; $f.t = t; $f.tf = tf; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	structType.prototype.FieldByName = function(name$1) { return this.$val.FieldByName(name$1); };
	PtrTo = function(t) {
		var t;
		return $assertType(t, ptrType$1).ptrTo();
	};
	$pkg.PtrTo = PtrTo;
	rtype.ptr.prototype.Implements = function(u) {
		var _r, t, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if ($interfaceIsEqual(u, $ifaceNil)) {
			$panic(new $String("reflect: nil type passed to Type.Implements"));
		}
		_r = u.Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 20))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 20))) { */ case 1:
			$panic(new $String("reflect: non-interface type passed to Type.Implements"));
		/* } */ case 2:
		$s = -1; return implements$1($assertType(u, ptrType$1), t);
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.Implements }; } $f._r = _r; $f.t = t; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.Implements = function(u) { return this.$val.Implements(u); };
	rtype.ptr.prototype.AssignableTo = function(u) {
		var _r, t, u, uu, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; u = $f.u; uu = $f.uu; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if ($interfaceIsEqual(u, $ifaceNil)) {
			$panic(new $String("reflect: nil type passed to Type.AssignableTo"));
		}
		uu = $assertType(u, ptrType$1);
		_r = directlyAssignable(uu, t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r || implements$1(uu, t);
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.AssignableTo }; } $f._r = _r; $f.t = t; $f.u = u; $f.uu = uu; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.AssignableTo = function(u) { return this.$val.AssignableTo(u); };
	rtype.ptr.prototype.ConvertibleTo = function(u) {
		var _r, t, u, uu, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; u = $f.u; uu = $f.uu; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if ($interfaceIsEqual(u, $ifaceNil)) {
			$panic(new $String("reflect: nil type passed to Type.ConvertibleTo"));
		}
		uu = $assertType(u, ptrType$1);
		_r = convertOp(uu, t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return !(_r === $throwNilPointerError);
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.ConvertibleTo }; } $f._r = _r; $f.t = t; $f.u = u; $f.uu = uu; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.ConvertibleTo = function(u) { return this.$val.ConvertibleTo(u); };
	implements$1 = function(T, V) {
		var T, V, i, i$1, j, j$1, t, tm, tm$1, tmName, tmName$1, tmPkgPath, tmPkgPath$1, v, v$1, vm, vm$1, vmName, vmName$1, vmPkgPath, vmPkgPath$1, vmethods, x, x$1, x$2;
		if (!((T.Kind() === 20))) {
			return false;
		}
		t = (T.kindType);
		if (t.methods.$length === 0) {
			return true;
		}
		if (V.Kind() === 20) {
			v = (V.kindType);
			i = 0;
			j = 0;
			while (true) {
				if (!(j < v.methods.$length)) { break; }
				tm = (x = t.methods, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
				tmName = $clone(t.rtype.nameOff(tm.name), name);
				vm = (x$1 = v.methods, ((j < 0 || j >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + j]));
				vmName = $clone(V.nameOff(vm.name), name);
				if ($clone(vmName, name).name() === $clone(tmName, name).name() && V.typeOff(vm.typ) === t.rtype.typeOff(tm.typ)) {
					if (!$clone(tmName, name).isExported()) {
						tmPkgPath = $clone(tmName, name).pkgPath();
						if (tmPkgPath === "") {
							tmPkgPath = $clone(t.pkgPath, name).name();
						}
						vmPkgPath = $clone(vmName, name).pkgPath();
						if (vmPkgPath === "") {
							vmPkgPath = $clone(v.pkgPath, name).name();
						}
						if (!(tmPkgPath === vmPkgPath)) {
							j = j + (1) >> 0;
							continue;
						}
					}
					i = i + (1) >> 0;
					if (i >= t.methods.$length) {
						return true;
					}
				}
				j = j + (1) >> 0;
			}
			return false;
		}
		v$1 = V.uncommon();
		if (v$1 === ptrType$5.nil) {
			return false;
		}
		i$1 = 0;
		vmethods = v$1.methods();
		j$1 = 0;
		while (true) {
			if (!(j$1 < ((v$1.mcount >> 0)))) { break; }
			tm$1 = (x$2 = t.methods, ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1]));
			tmName$1 = $clone(t.rtype.nameOff(tm$1.name), name);
			vm$1 = $clone(((j$1 < 0 || j$1 >= vmethods.$length) ? ($throwRuntimeError("index out of range"), undefined) : vmethods.$array[vmethods.$offset + j$1]), method);
			vmName$1 = $clone(V.nameOff(vm$1.name), name);
			if ($clone(vmName$1, name).name() === $clone(tmName$1, name).name() && V.typeOff(vm$1.mtyp) === t.rtype.typeOff(tm$1.typ)) {
				if (!$clone(tmName$1, name).isExported()) {
					tmPkgPath$1 = $clone(tmName$1, name).pkgPath();
					if (tmPkgPath$1 === "") {
						tmPkgPath$1 = $clone(t.pkgPath, name).name();
					}
					vmPkgPath$1 = $clone(vmName$1, name).pkgPath();
					if (vmPkgPath$1 === "") {
						vmPkgPath$1 = $clone(V.nameOff(v$1.pkgPath), name).name();
					}
					if (!(tmPkgPath$1 === vmPkgPath$1)) {
						j$1 = j$1 + (1) >> 0;
						continue;
					}
				}
				i$1 = i$1 + (1) >> 0;
				if (i$1 >= t.methods.$length) {
					return true;
				}
			}
			j$1 = j$1 + (1) >> 0;
		}
		return false;
	};
	directlyAssignable = function(T, V) {
		var T, V, _r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; T = $f.T; V = $f.V; _r = $f._r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (T === V) {
			$s = -1; return true;
		}
		if (!(T.Name() === "") && !(V.Name() === "") || !((T.Kind() === V.Kind()))) {
			$s = -1; return false;
		}
		_r = haveIdenticalUnderlyingType(T, V, true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: directlyAssignable }; } $f.T = T; $f.V = V; $f._r = _r; $f.$s = $s; $f.$r = $r; return $f;
	};
	haveIdenticalType = function(T, V, cmpTags) {
		var T, V, _arg, _arg$1, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _v, cmpTags, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; T = $f.T; V = $f.V; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _v = $f._v; cmpTags = $f.cmpTags; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (cmpTags) {
			$s = -1; return $interfaceIsEqual(T, V);
		}
		_r = T.Name(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = V.Name(); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		if (!(_r === _r$1)) { _v = true; $s = 3; continue s; }
		_r$2 = T.Kind(); /* */ $s = 6; case 6: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$3 = V.Kind(); /* */ $s = 7; case 7: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_v = !((_r$2 === _r$3)); case 3:
		/* */ if (_v) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_v) { */ case 1:
			$s = -1; return false;
		/* } */ case 2:
		_r$4 = T.common(); /* */ $s = 8; case 8: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_arg = _r$4;
		_r$5 = V.common(); /* */ $s = 9; case 9: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_arg$1 = _r$5;
		_r$6 = haveIdenticalUnderlyingType(_arg, _arg$1, false); /* */ $s = 10; case 10: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		$s = -1; return _r$6;
		/* */ } return; } if ($f === undefined) { $f = { $blk: haveIdenticalType }; } $f.T = T; $f.V = V; $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._v = _v; $f.cmpTags = cmpTags; $f.$s = $s; $f.$r = $r; return $f;
	};
	haveIdenticalUnderlyingType = function(T, V, cmpTags) {
		var T, V, _1, _i, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _ref, _v, _v$1, _v$2, _v$3, cmpTags, i, i$1, i$2, kind, t, t$1, t$2, tf, tp, v, v$1, v$2, vf, vp, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; T = $f.T; V = $f.V; _1 = $f._1; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _ref = $f._ref; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; _v$3 = $f._v$3; cmpTags = $f.cmpTags; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; kind = $f.kind; t = $f.t; t$1 = $f.t$1; t$2 = $f.t$2; tf = $f.tf; tp = $f.tp; v = $f.v; v$1 = $f.v$1; v$2 = $f.v$2; vf = $f.vf; vp = $f.vp; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (T === V) {
			$s = -1; return true;
		}
		kind = T.Kind();
		if (!((kind === V.Kind()))) {
			$s = -1; return false;
		}
		if (1 <= kind && kind <= 16 || (kind === 24) || (kind === 26)) {
			$s = -1; return true;
		}
			_1 = kind;
			/* */ if (_1 === (17)) { $s = 2; continue; }
			/* */ if (_1 === (18)) { $s = 3; continue; }
			/* */ if (_1 === (19)) { $s = 4; continue; }
			/* */ if (_1 === (20)) { $s = 5; continue; }
			/* */ if (_1 === (21)) { $s = 6; continue; }
			/* */ if ((_1 === (22)) || (_1 === (23))) { $s = 7; continue; }
			/* */ if (_1 === (25)) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (_1 === (17)) { */ case 2:
				if (!(T.Len() === V.Len())) { _v = false; $s = 10; continue s; }
				_r = haveIdenticalType(T.Elem(), V.Elem(), cmpTags); /* */ $s = 11; case 11: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_v = _r; case 10:
				$s = -1; return _v;
			/* } else if (_1 === (18)) { */ case 3:
				if (!(V.ChanDir() === 3)) { _v$1 = false; $s = 14; continue s; }
				_r$1 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags); /* */ $s = 15; case 15: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_v$1 = _r$1; case 14:
				/* */ if (_v$1) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if (_v$1) { */ case 12:
					$s = -1; return true;
				/* } */ case 13:
				if (!(V.ChanDir() === T.ChanDir())) { _v$2 = false; $s = 16; continue s; }
				_r$2 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags); /* */ $s = 17; case 17: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_v$2 = _r$2; case 16:
				$s = -1; return _v$2;
			/* } else if (_1 === (19)) { */ case 4:
				t = (T.kindType);
				v = (V.kindType);
				if (!((t.outCount === v.outCount)) || !((t.inCount === v.inCount))) {
					$s = -1; return false;
				}
				i = 0;
				/* while (true) { */ case 18:
					/* if (!(i < t.rtype.NumIn())) { break; } */ if(!(i < t.rtype.NumIn())) { $s = 19; continue; }
					_r$3 = haveIdenticalType(t.rtype.In(i), v.rtype.In(i), cmpTags); /* */ $s = 22; case 22: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					/* */ if (!_r$3) { $s = 20; continue; }
					/* */ $s = 21; continue;
					/* if (!_r$3) { */ case 20:
						$s = -1; return false;
					/* } */ case 21:
					i = i + (1) >> 0;
				/* } */ $s = 18; continue; case 19:
				i$1 = 0;
				/* while (true) { */ case 23:
					/* if (!(i$1 < t.rtype.NumOut())) { break; } */ if(!(i$1 < t.rtype.NumOut())) { $s = 24; continue; }
					_r$4 = haveIdenticalType(t.rtype.Out(i$1), v.rtype.Out(i$1), cmpTags); /* */ $s = 27; case 27: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					/* */ if (!_r$4) { $s = 25; continue; }
					/* */ $s = 26; continue;
					/* if (!_r$4) { */ case 25:
						$s = -1; return false;
					/* } */ case 26:
					i$1 = i$1 + (1) >> 0;
				/* } */ $s = 23; continue; case 24:
				$s = -1; return true;
			/* } else if (_1 === (20)) { */ case 5:
				t$1 = (T.kindType);
				v$1 = (V.kindType);
				if ((t$1.methods.$length === 0) && (v$1.methods.$length === 0)) {
					$s = -1; return true;
				}
				$s = -1; return false;
			/* } else if (_1 === (21)) { */ case 6:
				_r$5 = haveIdenticalType(T.Key(), V.Key(), cmpTags); /* */ $s = 29; case 29: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				if (!(_r$5)) { _v$3 = false; $s = 28; continue s; }
				_r$6 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags); /* */ $s = 30; case 30: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_v$3 = _r$6; case 28:
				$s = -1; return _v$3;
			/* } else if ((_1 === (22)) || (_1 === (23))) { */ case 7:
				_r$7 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags); /* */ $s = 31; case 31: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				$s = -1; return _r$7;
			/* } else if (_1 === (25)) { */ case 8:
				t$2 = (T.kindType);
				v$2 = (V.kindType);
				if (!((t$2.fields.$length === v$2.fields.$length))) {
					$s = -1; return false;
				}
				_ref = t$2.fields;
				_i = 0;
				/* while (true) { */ case 32:
					/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 33; continue; }
					i$2 = _i;
					tf = (x = t$2.fields, ((i$2 < 0 || i$2 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i$2]));
					vf = (x$1 = v$2.fields, ((i$2 < 0 || i$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i$2]));
					if (!($clone(tf.name, name).name() === $clone(vf.name, name).name())) {
						$s = -1; return false;
					}
					_r$8 = haveIdenticalType(tf.typ, vf.typ, cmpTags); /* */ $s = 36; case 36: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
					/* */ if (!_r$8) { $s = 34; continue; }
					/* */ $s = 35; continue;
					/* if (!_r$8) { */ case 34:
						$s = -1; return false;
					/* } */ case 35:
					if (cmpTags && !($clone(tf.name, name).tag() === $clone(vf.name, name).tag())) {
						$s = -1; return false;
					}
					if (!((tf.offsetAnon === vf.offsetAnon))) {
						$s = -1; return false;
					}
					if (!$clone(tf.name, name).isExported()) {
						tp = $clone(tf.name, name).pkgPath();
						if (tp === "") {
							tp = $clone(t$2.pkgPath, name).name();
						}
						vp = $clone(vf.name, name).pkgPath();
						if (vp === "") {
							vp = $clone(v$2.pkgPath, name).name();
						}
						if (!(tp === vp)) {
							$s = -1; return false;
						}
					}
					_i++;
				/* } */ $s = 32; continue; case 33:
				$s = -1; return true;
			/* } */ case 9:
		case 1:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: haveIdenticalUnderlyingType }; } $f.T = T; $f.V = V; $f._1 = _1; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._ref = _ref; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f._v$3 = _v$3; $f.cmpTags = cmpTags; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.kind = kind; $f.t = t; $f.t$1 = t$1; $f.t$2 = t$2; $f.tf = tf; $f.tp = tp; $f.v = v; $f.v$1 = v$1; $f.v$2 = v$2; $f.vf = vf; $f.vp = vp; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	toType = function(t) {
		var t;
		if (t === ptrType$1.nil) {
			return $ifaceNil;
		}
		return t;
	};
	ifaceIndir = function(t) {
		var t;
		return ((t.kind & 32) >>> 0) === 0;
	};
	flag.prototype.kind = function() {
		var f;
		f = this.$val;
		return ((((f & 31) >>> 0) >>> 0));
	};
	$ptrType(flag).prototype.kind = function() { return new flag(this.$get()).kind(); };
	Value.ptr.prototype.pointer = function() {
		var v;
		v = this;
		if (!((v.typ.size === 4)) || !v.typ.pointers()) {
			$panic(new $String("can't call pointer on a non-pointer Value"));
		}
		if (!((((v.flag & 128) >>> 0) === 0))) {
			return (v.ptr).$get();
		}
		return v.ptr;
	};
	Value.prototype.pointer = function() { return this.$val.pointer(); };
	ValueError.ptr.prototype.Error = function() {
		var e;
		e = this;
		if (e.Kind === 0) {
			return "reflect: call of " + e.Method + " on zero Value";
		}
		return "reflect: call of " + e.Method + " on " + new Kind(e.Kind).String() + " Value";
	};
	ValueError.prototype.Error = function() { return this.$val.Error(); };
	flag.prototype.mustBe = function(expected) {
		var expected, f;
		f = this.$val;
		if (!((new flag(f).kind() === expected))) {
			$panic(new ValueError.ptr(methodName(), new flag(f).kind()));
		}
	};
	$ptrType(flag).prototype.mustBe = function(expected) { return new flag(this.$get()).mustBe(expected); };
	flag.prototype.mustBeExported = function() {
		var f;
		f = this.$val;
		if (f === 0) {
			$panic(new ValueError.ptr(methodName(), 0));
		}
		if (!((((f & 96) >>> 0) === 0))) {
			$panic(new $String("reflect: " + methodName() + " using value obtained using unexported field"));
		}
	};
	$ptrType(flag).prototype.mustBeExported = function() { return new flag(this.$get()).mustBeExported(); };
	flag.prototype.mustBeAssignable = function() {
		var f;
		f = this.$val;
		if (f === 0) {
			$panic(new ValueError.ptr(methodName(), 0));
		}
		if (!((((f & 96) >>> 0) === 0))) {
			$panic(new $String("reflect: " + methodName() + " using value obtained using unexported field"));
		}
		if (((f & 256) >>> 0) === 0) {
			$panic(new $String("reflect: " + methodName() + " using unaddressable value"));
		}
	};
	$ptrType(flag).prototype.mustBeAssignable = function() { return new flag(this.$get()).mustBeAssignable(); };
	Value.ptr.prototype.Addr = function() {
		var v;
		v = this;
		if (((v.flag & 256) >>> 0) === 0) {
			$panic(new $String("reflect.Value.Addr of unaddressable value"));
		}
		return new Value.ptr(v.typ.ptrTo(), v.ptr, ((((v.flag & 96) >>> 0)) | 22) >>> 0);
	};
	Value.prototype.Addr = function() { return this.$val.Addr(); };
	Value.ptr.prototype.Bool = function() {
		var v;
		v = this;
		new flag(v.flag).mustBe(1);
		return (v.ptr).$get();
	};
	Value.prototype.Bool = function() { return this.$val.Bool(); };
	Value.ptr.prototype.Bytes = function() {
		var _r, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(23);
		_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 8))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 8))) { */ case 1:
			$panic(new $String("reflect.Value.Bytes of non-byte slice"));
		/* } */ case 2:
		$s = -1; return (v.ptr).$get();
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Bytes }; } $f._r = _r; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Bytes = function() { return this.$val.Bytes(); };
	Value.ptr.prototype.runes = function() {
		var _r, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(23);
		_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 5))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 5))) { */ case 1:
			$panic(new $String("reflect.Value.Bytes of non-rune slice"));
		/* } */ case 2:
		$s = -1; return (v.ptr).$get();
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.runes }; } $f._r = _r; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.runes = function() { return this.$val.runes(); };
	Value.ptr.prototype.CanAddr = function() {
		var v;
		v = this;
		return !((((v.flag & 256) >>> 0) === 0));
	};
	Value.prototype.CanAddr = function() { return this.$val.CanAddr(); };
	Value.ptr.prototype.CanSet = function() {
		var v;
		v = this;
		return ((v.flag & 352) >>> 0) === 256;
	};
	Value.prototype.CanSet = function() { return this.$val.CanSet(); };
	Value.ptr.prototype.Call = function(in$1) {
		var _r, in$1, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; in$1 = $f.in$1; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(19);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).call("Call", in$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Call }; } $f._r = _r; $f.in$1 = in$1; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Call = function(in$1) { return this.$val.Call(in$1); };
	Value.ptr.prototype.CallSlice = function(in$1) {
		var _r, in$1, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; in$1 = $f.in$1; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(19);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).call("CallSlice", in$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.CallSlice }; } $f._r = _r; $f.in$1 = in$1; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.CallSlice = function(in$1) { return this.$val.CallSlice(in$1); };
	Value.ptr.prototype.Complex = function() {
		var _1, k, v, x;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (15)) {
			return ((x = (v.ptr).$get(), new $Complex128(x.$real, x.$imag)));
		} else if (_1 === (16)) {
			return (v.ptr).$get();
		}
		$panic(new ValueError.ptr("reflect.Value.Complex", new flag(v.flag).kind()));
	};
	Value.prototype.Complex = function() { return this.$val.Complex(); };
	Value.ptr.prototype.FieldByIndex = function(index) {
		var _i, _r, _r$1, _r$2, _r$3, _ref, _v, i, index, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; _v = $f._v; i = $f.i; index = $f.index; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		/* */ if (index.$length === 1) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (index.$length === 1) { */ case 1:
			_r = $clone(v, Value).Field((0 >= index.$length ? ($throwRuntimeError("index out of range"), undefined) : index.$array[index.$offset + 0])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		new flag(v.flag).mustBe(25);
		_ref = index;
		_i = 0;
		/* while (true) { */ case 4:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
			i = _i;
			x = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			/* */ if (i > 0) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (i > 0) { */ case 6:
				if (!($clone(v, Value).Kind() === 22)) { _v = false; $s = 10; continue s; }
				_r$1 = v.typ.Elem().Kind(); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_v = _r$1 === 25; case 10:
				/* */ if (_v) { $s = 8; continue; }
				/* */ $s = 9; continue;
				/* if (_v) { */ case 8:
					if ($clone(v, Value).IsNil()) {
						$panic(new $String("reflect: indirection through nil pointer to embedded struct"));
					}
					_r$2 = $clone(v, Value).Elem(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					v = _r$2;
				/* } */ case 9:
			/* } */ case 7:
			_r$3 = $clone(v, Value).Field(x); /* */ $s = 13; case 13: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			v = _r$3;
			_i++;
		/* } */ $s = 4; continue; case 5:
		$s = -1; return v;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.FieldByIndex }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f._v = _v; $f.i = i; $f.index = index; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.FieldByIndex = function(index) { return this.$val.FieldByIndex(index); };
	Value.ptr.prototype.FieldByName = function(name$1) {
		var _r, _r$1, _tuple, f, name$1, ok, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; f = $f.f; name$1 = $f.name$1; ok = $f.ok; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(25);
		_r = v.typ.FieldByName(name$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		f = $clone(_tuple[0], StructField);
		ok = _tuple[1];
		/* */ if (ok) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (ok) { */ case 2:
			_r$1 = $clone(v, Value).FieldByIndex(f.Index); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
		/* } */ case 3:
		$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.FieldByName }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.f = f; $f.name$1 = name$1; $f.ok = ok; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.FieldByName = function(name$1) { return this.$val.FieldByName(name$1); };
	Value.ptr.prototype.FieldByNameFunc = function(match) {
		var _r, _r$1, _tuple, f, match, ok, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; f = $f.f; match = $f.match; ok = $f.ok; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		_r = v.typ.FieldByNameFunc(match); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		f = $clone(_tuple[0], StructField);
		ok = _tuple[1];
		/* */ if (ok) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (ok) { */ case 2:
			_r$1 = $clone(v, Value).FieldByIndex(f.Index); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
		/* } */ case 3:
		$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.FieldByNameFunc }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.f = f; $f.match = match; $f.ok = ok; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.FieldByNameFunc = function(match) { return this.$val.FieldByNameFunc(match); };
	Value.ptr.prototype.Float = function() {
		var _1, k, v;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (13)) {
			return ((v.ptr).$get());
		} else if (_1 === (14)) {
			return (v.ptr).$get();
		}
		$panic(new ValueError.ptr("reflect.Value.Float", new flag(v.flag).kind()));
	};
	Value.prototype.Float = function() { return this.$val.Float(); };
	Value.ptr.prototype.Int = function() {
		var _1, k, p, v;
		v = this;
		k = new flag(v.flag).kind();
		p = v.ptr;
		_1 = k;
		if (_1 === (2)) {
			return (new $Int64(0, (p).$get()));
		} else if (_1 === (3)) {
			return (new $Int64(0, (p).$get()));
		} else if (_1 === (4)) {
			return (new $Int64(0, (p).$get()));
		} else if (_1 === (5)) {
			return (new $Int64(0, (p).$get()));
		} else if (_1 === (6)) {
			return (p).$get();
		}
		$panic(new ValueError.ptr("reflect.Value.Int", new flag(v.flag).kind()));
	};
	Value.prototype.Int = function() { return this.$val.Int(); };
	Value.ptr.prototype.CanInterface = function() {
		var v;
		v = this;
		if (v.flag === 0) {
			$panic(new ValueError.ptr("reflect.Value.CanInterface", 0));
		}
		return ((v.flag & 96) >>> 0) === 0;
	};
	Value.prototype.CanInterface = function() { return this.$val.CanInterface(); };
	Value.ptr.prototype.Interface = function() {
		var _r, i, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = $ifaceNil;
		v = this;
		_r = valueInterface($clone(v, Value), true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		$s = -1; return i;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Interface }; } $f._r = _r; $f.i = i; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Interface = function() { return this.$val.Interface(); };
	Value.ptr.prototype.IsValid = function() {
		var v;
		v = this;
		return !((v.flag === 0));
	};
	Value.prototype.IsValid = function() { return this.$val.IsValid(); };
	Value.ptr.prototype.Kind = function() {
		var v;
		v = this;
		return new flag(v.flag).kind();
	};
	Value.prototype.Kind = function() { return this.$val.Kind(); };
	Value.ptr.prototype.MapIndex = function(key) {
		var _r, c, e, fl, k, key, tt, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; e = $f.e; fl = $f.fl; k = $f.k; key = $f.key; tt = $f.tt; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(21);
		tt = (v.typ.kindType);
		_r = $clone(key, Value).assignTo("reflect.Value.MapIndex", tt.key, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		key = _r;
		k = 0;
		if (!((((key.flag & 128) >>> 0) === 0))) {
			k = key.ptr;
		} else {
			k = ((key.$ptr_ptr || (key.$ptr_ptr = new ptrType$15(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, key))));
		}
		e = mapaccess(v.typ, $clone(v, Value).pointer(), k);
		if (e === 0) {
			$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		}
		typ = tt.elem;
		fl = ((((v.flag | key.flag) >>> 0)) & 96) >>> 0;
		fl = (fl | (((typ.Kind() >>> 0)))) >>> 0;
		if (ifaceIndir(typ)) {
			c = unsafe_New(typ);
			typedmemmove(typ, c, e);
			$s = -1; return new Value.ptr(typ, c, (fl | 128) >>> 0);
		} else {
			$s = -1; return new Value.ptr(typ, (e).$get(), fl);
		}
		$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.MapIndex }; } $f._r = _r; $f.c = c; $f.e = e; $f.fl = fl; $f.k = k; $f.key = key; $f.tt = tt; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.MapIndex = function(key) { return this.$val.MapIndex(key); };
	Value.ptr.prototype.MapKeys = function() {
		var _r, a, c, fl, i, it, key, keyType, m, mlen, tt, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; c = $f.c; fl = $f.fl; i = $f.i; it = $f.it; key = $f.key; keyType = $f.keyType; m = $f.m; mlen = $f.mlen; tt = $f.tt; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(21);
		tt = (v.typ.kindType);
		keyType = tt.key;
		fl = (((v.flag & 96) >>> 0) | ((keyType.Kind() >>> 0))) >>> 0;
		m = $clone(v, Value).pointer();
		mlen = 0;
		if (!(m === 0)) {
			mlen = maplen(m);
		}
		it = mapiterinit(v.typ, m);
		a = $makeSlice(sliceType$9, mlen);
		i = 0;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < a.$length)) { break; } */ if(!(i < a.$length)) { $s = 2; continue; }
			_r = mapiterkey(it); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			key = _r;
			if (key === 0) {
				/* break; */ $s = 2; continue;
			}
			if (ifaceIndir(keyType)) {
				c = unsafe_New(keyType);
				typedmemmove(keyType, c, key);
				((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = new Value.ptr(keyType, c, (fl | 128) >>> 0));
			} else {
				((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = new Value.ptr(keyType, (key).$get(), fl));
			}
			mapiternext(it);
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return $subslice(a, 0, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.MapKeys }; } $f._r = _r; $f.a = a; $f.c = c; $f.fl = fl; $f.i = i; $f.it = it; $f.key = key; $f.keyType = keyType; $f.m = m; $f.mlen = mlen; $f.tt = tt; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.MapKeys = function() { return this.$val.MapKeys(); };
	Value.ptr.prototype.Method = function(i) {
		var _r, _v, fl, i, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _v = $f._v; fl = $f.fl; i = $f.i; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		if (v.typ === ptrType$1.nil) {
			$panic(new ValueError.ptr("reflect.Value.Method", 0));
		}
		if (!((((v.flag & 512) >>> 0) === 0))) { _v = true; $s = 3; continue s; }
		_r = v.typ.NumMethod(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_v = ((i >>> 0)) >= ((_r >>> 0)); case 3:
		/* */ if (_v) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_v) { */ case 1:
			$panic(new $String("reflect: Method index out of range"));
		/* } */ case 2:
		if ((v.typ.Kind() === 20) && $clone(v, Value).IsNil()) {
			$panic(new $String("reflect: Method on nil interface value"));
		}
		fl = (v.flag & 160) >>> 0;
		fl = (fl | (19)) >>> 0;
		fl = (fl | ((((((i >>> 0)) << 10 >>> 0) | 512) >>> 0))) >>> 0;
		$s = -1; return new Value.ptr(v.typ, v.ptr, fl);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Method }; } $f._r = _r; $f._v = _v; $f.fl = fl; $f.i = i; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Method = function(i) { return this.$val.Method(i); };
	Value.ptr.prototype.NumMethod = function() {
		var _r, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		if (v.typ === ptrType$1.nil) {
			$panic(new ValueError.ptr("reflect.Value.NumMethod", 0));
		}
		if (!((((v.flag & 512) >>> 0) === 0))) {
			$s = -1; return 0;
		}
		_r = v.typ.NumMethod(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.NumMethod }; } $f._r = _r; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.NumMethod = function() { return this.$val.NumMethod(); };
	Value.ptr.prototype.MethodByName = function(name$1) {
		var _r, _r$1, _tuple, m, name$1, ok, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; m = $f.m; name$1 = $f.name$1; ok = $f.ok; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		if (v.typ === ptrType$1.nil) {
			$panic(new ValueError.ptr("reflect.Value.MethodByName", 0));
		}
		if (!((((v.flag & 512) >>> 0) === 0))) {
			$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		}
		_r = v.typ.MethodByName(name$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		m = $clone(_tuple[0], Method);
		ok = _tuple[1];
		if (!ok) {
			$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		}
		_r$1 = $clone(v, Value).Method(m.Index); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.MethodByName }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.m = m; $f.name$1 = name$1; $f.ok = ok; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.MethodByName = function(name$1) { return this.$val.MethodByName(name$1); };
	Value.ptr.prototype.NumField = function() {
		var tt, v;
		v = this;
		new flag(v.flag).mustBe(25);
		tt = (v.typ.kindType);
		return tt.fields.$length;
	};
	Value.prototype.NumField = function() { return this.$val.NumField(); };
	Value.ptr.prototype.OverflowComplex = function(x) {
		var _1, k, v, x;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (15)) {
			return overflowFloat32(x.$real) || overflowFloat32(x.$imag);
		} else if (_1 === (16)) {
			return false;
		}
		$panic(new ValueError.ptr("reflect.Value.OverflowComplex", new flag(v.flag).kind()));
	};
	Value.prototype.OverflowComplex = function(x) { return this.$val.OverflowComplex(x); };
	Value.ptr.prototype.OverflowFloat = function(x) {
		var _1, k, v, x;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (13)) {
			return overflowFloat32(x);
		} else if (_1 === (14)) {
			return false;
		}
		$panic(new ValueError.ptr("reflect.Value.OverflowFloat", new flag(v.flag).kind()));
	};
	Value.prototype.OverflowFloat = function(x) { return this.$val.OverflowFloat(x); };
	overflowFloat32 = function(x) {
		var x;
		if (x < 0) {
			x = -x;
		}
		return 3.4028234663852886e+38 < x && x <= 1.7976931348623157e+308;
	};
	Value.ptr.prototype.OverflowInt = function(x) {
		var _1, bitSize, k, trunc, v, x;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) {
			bitSize = $imul(v.typ.size, 8) >>> 0;
			trunc = $shiftRightInt64(($shiftLeft64(x, ((64 - bitSize >>> 0)))), ((64 - bitSize >>> 0)));
			return !((x.$high === trunc.$high && x.$low === trunc.$low));
		}
		$panic(new ValueError.ptr("reflect.Value.OverflowInt", new flag(v.flag).kind()));
	};
	Value.prototype.OverflowInt = function(x) { return this.$val.OverflowInt(x); };
	Value.ptr.prototype.OverflowUint = function(x) {
		var _1, bitSize, k, trunc, v, x;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if ((_1 === (7)) || (_1 === (12)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11))) {
			bitSize = $imul(v.typ.size, 8) >>> 0;
			trunc = $shiftRightUint64(($shiftLeft64(x, ((64 - bitSize >>> 0)))), ((64 - bitSize >>> 0)));
			return !((x.$high === trunc.$high && x.$low === trunc.$low));
		}
		$panic(new ValueError.ptr("reflect.Value.OverflowUint", new flag(v.flag).kind()));
	};
	Value.prototype.OverflowUint = function(x) { return this.$val.OverflowUint(x); };
	Value.ptr.prototype.Recv = function() {
		var _r, _tuple, ok, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; ok = $f.ok; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = new Value.ptr(ptrType$1.nil, 0, 0);
		ok = false;
		v = this;
		new flag(v.flag).mustBe(18);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).recv(false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		x = _tuple[0];
		ok = _tuple[1];
		$s = -1; return [x, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Recv }; } $f._r = _r; $f._tuple = _tuple; $f.ok = ok; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Recv = function() { return this.$val.Recv(); };
	Value.ptr.prototype.recv = function(nb) {
		var _r, _tuple, nb, ok, p, selected, t, tt, v, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; nb = $f.nb; ok = $f.ok; p = $f.p; selected = $f.selected; t = $f.t; tt = $f.tt; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		val = new Value.ptr(ptrType$1.nil, 0, 0);
		ok = false;
		v = this;
		tt = (v.typ.kindType);
		if ((((tt.dir >> 0)) & 1) === 0) {
			$panic(new $String("reflect: recv on send-only channel"));
		}
		t = tt.elem;
		val = new Value.ptr(t, 0, ((t.Kind() >>> 0)));
		p = 0;
		if (ifaceIndir(t)) {
			p = unsafe_New(t);
			val.ptr = p;
			val.flag = (val.flag | (128)) >>> 0;
		} else {
			p = ((val.$ptr_ptr || (val.$ptr_ptr = new ptrType$15(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, val))));
		}
		_r = chanrecv($clone(v, Value).pointer(), nb, p); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		selected = _tuple[0];
		ok = _tuple[1];
		if (!selected) {
			val = new Value.ptr(ptrType$1.nil, 0, 0);
		}
		$s = -1; return [val, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.recv }; } $f._r = _r; $f._tuple = _tuple; $f.nb = nb; $f.ok = ok; $f.p = p; $f.selected = selected; $f.t = t; $f.tt = tt; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.recv = function(nb) { return this.$val.recv(nb); };
	Value.ptr.prototype.Send = function(x) {
		var _r, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(18);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).send($clone(x, Value), false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Send }; } $f._r = _r; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Send = function(x) { return this.$val.Send(x); };
	Value.ptr.prototype.send = function(x, nb) {
		var _r, _r$1, nb, p, selected, tt, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; nb = $f.nb; p = $f.p; selected = $f.selected; tt = $f.tt; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		selected = false;
		v = this;
		tt = (v.typ.kindType);
		if ((((tt.dir >> 0)) & 2) === 0) {
			$panic(new $String("reflect: send on recv-only channel"));
		}
		new flag(x.flag).mustBeExported();
		_r = $clone(x, Value).assignTo("reflect.Value.Send", tt.elem, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		x = _r;
		p = 0;
		if (!((((x.flag & 128) >>> 0) === 0))) {
			p = x.ptr;
		} else {
			p = ((x.$ptr_ptr || (x.$ptr_ptr = new ptrType$15(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, x))));
		}
		_r$1 = chansend($clone(v, Value).pointer(), p, nb); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		selected = _r$1;
		$s = -1; return selected;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.send }; } $f._r = _r; $f._r$1 = _r$1; $f.nb = nb; $f.p = p; $f.selected = selected; $f.tt = tt; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.send = function(x, nb) { return this.$val.send(x, nb); };
	Value.ptr.prototype.SetBool = function(x) {
		var v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(1);
		(v.ptr).$set(x);
	};
	Value.prototype.SetBool = function(x) { return this.$val.SetBool(x); };
	Value.ptr.prototype.setRunes = function(x) {
		var _r, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(23);
		_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 5))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 5))) { */ case 1:
			$panic(new $String("reflect.Value.setRunes of non-rune slice"));
		/* } */ case 2:
		(v.ptr).$set(x);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.setRunes }; } $f._r = _r; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.setRunes = function(x) { return this.$val.setRunes(x); };
	Value.ptr.prototype.SetComplex = function(x) {
		var _1, k, v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (15)) {
			(v.ptr).$set((new $Complex64(x.$real, x.$imag)));
		} else if (_1 === (16)) {
			(v.ptr).$set(x);
		} else {
			$panic(new ValueError.ptr("reflect.Value.SetComplex", new flag(v.flag).kind()));
		}
	};
	Value.prototype.SetComplex = function(x) { return this.$val.SetComplex(x); };
	Value.ptr.prototype.SetFloat = function(x) {
		var _1, k, v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (13)) {
			(v.ptr).$set(($fround(x)));
		} else if (_1 === (14)) {
			(v.ptr).$set(x);
		} else {
			$panic(new ValueError.ptr("reflect.Value.SetFloat", new flag(v.flag).kind()));
		}
	};
	Value.prototype.SetFloat = function(x) { return this.$val.SetFloat(x); };
	Value.ptr.prototype.SetInt = function(x) {
		var _1, k, v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (2)) {
			(v.ptr).$set((((x.$low + ((x.$high >> 31) * 4294967296)) >> 0)));
		} else if (_1 === (3)) {
			(v.ptr).$set((((x.$low + ((x.$high >> 31) * 4294967296)) << 24 >> 24)));
		} else if (_1 === (4)) {
			(v.ptr).$set((((x.$low + ((x.$high >> 31) * 4294967296)) << 16 >> 16)));
		} else if (_1 === (5)) {
			(v.ptr).$set((((x.$low + ((x.$high >> 31) * 4294967296)) >> 0)));
		} else if (_1 === (6)) {
			(v.ptr).$set(x);
		} else {
			$panic(new ValueError.ptr("reflect.Value.SetInt", new flag(v.flag).kind()));
		}
	};
	Value.prototype.SetInt = function(x) { return this.$val.SetInt(x); };
	Value.ptr.prototype.SetMapIndex = function(key, val) {
		var _r, _r$1, e, k, key, tt, v, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; e = $f.e; k = $f.k; key = $f.key; tt = $f.tt; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(21);
		new flag(v.flag).mustBeExported();
		new flag(key.flag).mustBeExported();
		tt = (v.typ.kindType);
		_r = $clone(key, Value).assignTo("reflect.Value.SetMapIndex", tt.key, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		key = _r;
		k = 0;
		if (!((((key.flag & 128) >>> 0) === 0))) {
			k = key.ptr;
		} else {
			k = ((key.$ptr_ptr || (key.$ptr_ptr = new ptrType$15(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, key))));
		}
		if (val.typ === ptrType$1.nil) {
			mapdelete(v.typ, $clone(v, Value).pointer(), k);
			$s = -1; return;
		}
		new flag(val.flag).mustBeExported();
		_r$1 = $clone(val, Value).assignTo("reflect.Value.SetMapIndex", tt.elem, 0); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		val = _r$1;
		e = 0;
		if (!((((val.flag & 128) >>> 0) === 0))) {
			e = val.ptr;
		} else {
			e = ((val.$ptr_ptr || (val.$ptr_ptr = new ptrType$15(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, val))));
		}
		$r = mapassign(v.typ, $clone(v, Value).pointer(), k, e); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.SetMapIndex }; } $f._r = _r; $f._r$1 = _r$1; $f.e = e; $f.k = k; $f.key = key; $f.tt = tt; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.SetMapIndex = function(key, val) { return this.$val.SetMapIndex(key, val); };
	Value.ptr.prototype.SetUint = function(x) {
		var _1, k, v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (7)) {
			(v.ptr).$set(((x.$low >>> 0)));
		} else if (_1 === (8)) {
			(v.ptr).$set(((x.$low << 24 >>> 24)));
		} else if (_1 === (9)) {
			(v.ptr).$set(((x.$low << 16 >>> 16)));
		} else if (_1 === (10)) {
			(v.ptr).$set(((x.$low >>> 0)));
		} else if (_1 === (11)) {
			(v.ptr).$set(x);
		} else if (_1 === (12)) {
			(v.ptr).$set(((x.$low >>> 0)));
		} else {
			$panic(new ValueError.ptr("reflect.Value.SetUint", new flag(v.flag).kind()));
		}
	};
	Value.prototype.SetUint = function(x) { return this.$val.SetUint(x); };
	Value.ptr.prototype.SetPointer = function(x) {
		var v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(26);
		(v.ptr).$set(x);
	};
	Value.prototype.SetPointer = function(x) { return this.$val.SetPointer(x); };
	Value.ptr.prototype.SetString = function(x) {
		var v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(24);
		(v.ptr).$set(x);
	};
	Value.prototype.SetString = function(x) { return this.$val.SetString(x); };
	Value.ptr.prototype.String = function() {
		var _1, _r, k, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; k = $f.k; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (0)) {
			$s = -1; return "<invalid Value>";
		} else if (_1 === (24)) {
			$s = -1; return (v.ptr).$get();
		}
		_r = $clone(v, Value).Type().String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return "<" + _r + " Value>";
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.String }; } $f._1 = _1; $f._r = _r; $f.k = k; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.String = function() { return this.$val.String(); };
	Value.ptr.prototype.TryRecv = function() {
		var _r, _tuple, ok, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; ok = $f.ok; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = new Value.ptr(ptrType$1.nil, 0, 0);
		ok = false;
		v = this;
		new flag(v.flag).mustBe(18);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).recv(true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		x = _tuple[0];
		ok = _tuple[1];
		$s = -1; return [x, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.TryRecv }; } $f._r = _r; $f._tuple = _tuple; $f.ok = ok; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.TryRecv = function() { return this.$val.TryRecv(); };
	Value.ptr.prototype.TrySend = function(x) {
		var _r, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(18);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).send($clone(x, Value), true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.TrySend }; } $f._r = _r; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.TrySend = function(x) { return this.$val.TrySend(x); };
	Value.ptr.prototype.Type = function() {
		var f, i, m, m$1, tt, ut, v, x, x$1;
		v = this;
		f = v.flag;
		if (f === 0) {
			$panic(new ValueError.ptr("reflect.Value.Type", 0));
		}
		if (((f & 512) >>> 0) === 0) {
			return v.typ;
		}
		i = ((v.flag >> 0)) >> 10 >> 0;
		if (v.typ.Kind() === 20) {
			tt = (v.typ.kindType);
			if (((i >>> 0)) >= ((tt.methods.$length >>> 0))) {
				$panic(new $String("reflect: internal error: invalid method index"));
			}
			m = (x = tt.methods, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			return v.typ.typeOff(m.typ);
		}
		ut = v.typ.uncommon();
		if (ut === ptrType$5.nil || ((i >>> 0)) >= ((ut.mcount >>> 0))) {
			$panic(new $String("reflect: internal error: invalid method index"));
		}
		m$1 = $clone((x$1 = ut.methods(), ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])), method);
		return v.typ.typeOff(m$1.mtyp);
	};
	Value.prototype.Type = function() { return this.$val.Type(); };
	Value.ptr.prototype.Uint = function() {
		var _1, k, p, v, x;
		v = this;
		k = new flag(v.flag).kind();
		p = v.ptr;
		_1 = k;
		if (_1 === (7)) {
			return (new $Uint64(0, (p).$get()));
		} else if (_1 === (8)) {
			return (new $Uint64(0, (p).$get()));
		} else if (_1 === (9)) {
			return (new $Uint64(0, (p).$get()));
		} else if (_1 === (10)) {
			return (new $Uint64(0, (p).$get()));
		} else if (_1 === (11)) {
			return (p).$get();
		} else if (_1 === (12)) {
			return ((x = (p).$get(), new $Uint64(0, x.constructor === Number ? x : 1)));
		}
		$panic(new ValueError.ptr("reflect.Value.Uint", new flag(v.flag).kind()));
	};
	Value.prototype.Uint = function() { return this.$val.Uint(); };
	Value.ptr.prototype.UnsafeAddr = function() {
		var v;
		v = this;
		if (v.typ === ptrType$1.nil) {
			$panic(new ValueError.ptr("reflect.Value.UnsafeAddr", 0));
		}
		if (((v.flag & 256) >>> 0) === 0) {
			$panic(new $String("reflect.Value.UnsafeAddr of unaddressable value"));
		}
		return (v.ptr);
	};
	Value.prototype.UnsafeAddr = function() { return this.$val.UnsafeAddr(); };
	typesMustMatch = function(what, t1, t2) {
		var _r, _r$1, t1, t2, what, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; t1 = $f.t1; t2 = $f.t2; what = $f.what; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ if (!($interfaceIsEqual(t1, t2))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!($interfaceIsEqual(t1, t2))) { */ case 1:
			_r = t1.String(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r$1 = t2.String(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$panic(new $String(what + ": " + _r + " != " + _r$1));
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: typesMustMatch }; } $f._r = _r; $f._r$1 = _r$1; $f.t1 = t1; $f.t2 = t2; $f.what = what; $f.$s = $s; $f.$r = $r; return $f;
	};
	grow = function(s, extra) {
		var _q, _r, _r$1, _r$2, extra, i0, i1, m, s, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; extra = $f.extra; i0 = $f.i0; i1 = $f.i1; m = $f.m; s = $f.s; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i0 = $clone(s, Value).Len();
		i1 = i0 + extra >> 0;
		if (i1 < i0) {
			$panic(new $String("reflect.Append: slice overflow"));
		}
		m = $clone(s, Value).Cap();
		/* */ if (i1 <= m) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (i1 <= m) { */ case 1:
			_r = $clone(s, Value).Slice(0, i1); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return [_r, i0, i1];
		/* } */ case 2:
		if (m === 0) {
			m = extra;
		} else {
			while (true) {
				if (!(m < i1)) { break; }
				if (i0 < 1024) {
					m = m + (m) >> 0;
				} else {
					m = m + ((_q = m / 4, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"))) >> 0;
				}
			}
		}
		_r$1 = MakeSlice($clone(s, Value).Type(), i1, m); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		t = _r$1;
		_r$2 = Copy($clone(t, Value), $clone(s, Value)); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		$s = -1; return [t, i0, i1];
		/* */ } return; } if ($f === undefined) { $f = { $blk: grow }; } $f._q = _q; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.extra = extra; $f.i0 = i0; $f.i1 = i1; $f.m = m; $f.s = s; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Append = function(s, x) {
		var _r, _r$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, i, i0, i1, j, s, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; i = $f.i; i0 = $f.i0; i1 = $f.i1; j = $f.j; s = $f.s; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		new flag(s.flag).mustBe(23);
		_r = grow($clone(s, Value), x.$length); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		s = _tuple[0];
		i0 = _tuple[1];
		i1 = _tuple[2];
		_tmp = i0;
		_tmp$1 = 0;
		i = _tmp;
		j = _tmp$1;
		/* while (true) { */ case 2:
			/* if (!(i < i1)) { break; } */ if(!(i < i1)) { $s = 3; continue; }
			_r$1 = $clone(s, Value).Index(i); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$r = $clone(_r$1, Value).Set($clone(((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]), Value)); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_tmp$2 = i + 1 >> 0;
			_tmp$3 = j + 1 >> 0;
			i = _tmp$2;
			j = _tmp$3;
		/* } */ $s = 2; continue; case 3:
		$s = -1; return s;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Append }; } $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.i = i; $f.i0 = i0; $f.i1 = i1; $f.j = j; $f.s = s; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Append = Append;
	New = function(typ) {
		var _r, _r$1, fl, ptr, typ, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; fl = $f.fl; ptr = $f.ptr; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if ($interfaceIsEqual(typ, $ifaceNil)) {
			$panic(new $String("reflect: New(nil)"));
		}
		ptr = unsafe_New($assertType(typ, ptrType$1));
		fl = 22;
		_r = typ.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = _r.ptrTo(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return new Value.ptr(_r$1, ptr, fl);
		/* */ } return; } if ($f === undefined) { $f = { $blk: New }; } $f._r = _r; $f._r$1 = _r$1; $f.fl = fl; $f.ptr = ptr; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.New = New;
	Value.ptr.prototype.assignTo = function(context, dst, target) {
		var _r, _r$1, _r$2, _r$3, context, dst, fl, target, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; context = $f.context; dst = $f.dst; fl = $f.fl; target = $f.target; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		/* */ if (!((((v.flag & 512) >>> 0) === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:
			_r = makeMethodValue(context, $clone(v, Value)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			v = _r;
		/* } */ case 2:
			_r$1 = directlyAssignable(dst, v.typ); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (_r$1) { $s = 5; continue; }
			/* */ if (implements$1(dst, v.typ)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_r$1) { */ case 5:
				fl = (v.flag & 480) >>> 0;
				fl = (fl | (((dst.Kind() >>> 0)))) >>> 0;
				$s = -1; return new Value.ptr(dst, v.ptr, fl);
			/* } else if (implements$1(dst, v.typ)) { */ case 6:
				if (target === 0) {
					target = unsafe_New(dst);
				}
				_r$2 = valueInterface($clone(v, Value), false); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				x = _r$2;
				_r$3 = dst.NumMethod(); /* */ $s = 13; case 13: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				/* */ if (_r$3 === 0) { $s = 10; continue; }
				/* */ $s = 11; continue;
				/* if (_r$3 === 0) { */ case 10:
					(target).$set(x);
					$s = 12; continue;
				/* } else { */ case 11:
					ifaceE2I(dst, x, target);
				/* } */ case 12:
				$s = -1; return new Value.ptr(dst, target, 148);
			/* } */ case 7:
		case 4:
		$panic(new $String(context + ": value of type " + v.typ.String() + " is not assignable to type " + dst.String()));
		$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.assignTo }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.context = context; $f.dst = dst; $f.fl = fl; $f.target = target; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.assignTo = function(context, dst, target) { return this.$val.assignTo(context, dst, target); };
	Value.ptr.prototype.Convert = function(t) {
		var _r, _r$1, _r$2, _r$3, _r$4, op, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; op = $f.op; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		/* */ if (!((((v.flag & 512) >>> 0) === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:
			_r = makeMethodValue("Convert", $clone(v, Value)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			v = _r;
		/* } */ case 2:
		_r$1 = t.common(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = convertOp(_r$1, v.typ); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		op = _r$2;
		/* */ if (op === $throwNilPointerError) { $s = 6; continue; }
		/* */ $s = 7; continue;
		/* if (op === $throwNilPointerError) { */ case 6:
			_r$3 = t.String(); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			$panic(new $String("reflect.Value.Convert: value of type " + v.typ.String() + " cannot be converted to type " + _r$3));
		/* } */ case 7:
		_r$4 = op($clone(v, Value), t); /* */ $s = 9; case 9: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		$s = -1; return _r$4;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Convert }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.op = op; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Convert = function(t) { return this.$val.Convert(t); };
	convertOp = function(dst, src) {
		var _1, _2, _3, _4, _5, _6, _7, _arg, _arg$1, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _v, _v$1, _v$2, dst, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _6 = $f._6; _7 = $f._7; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; dst = $f.dst; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = src.Kind();
			/* */ if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { $s = 2; continue; }
			/* */ if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { $s = 3; continue; }
			/* */ if ((_1 === (13)) || (_1 === (14))) { $s = 4; continue; }
			/* */ if ((_1 === (15)) || (_1 === (16))) { $s = 5; continue; }
			/* */ if (_1 === (24)) { $s = 6; continue; }
			/* */ if (_1 === (23)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 2:
				_2 = dst.Kind();
				if ((_2 === (2)) || (_2 === (3)) || (_2 === (4)) || (_2 === (5)) || (_2 === (6)) || (_2 === (7)) || (_2 === (8)) || (_2 === (9)) || (_2 === (10)) || (_2 === (11)) || (_2 === (12))) {
					$s = -1; return cvtInt;
				} else if ((_2 === (13)) || (_2 === (14))) {
					$s = -1; return cvtIntFloat;
				} else if (_2 === (24)) {
					$s = -1; return cvtIntString;
				}
				$s = 8; continue;
			/* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 3:
				_3 = dst.Kind();
				if ((_3 === (2)) || (_3 === (3)) || (_3 === (4)) || (_3 === (5)) || (_3 === (6)) || (_3 === (7)) || (_3 === (8)) || (_3 === (9)) || (_3 === (10)) || (_3 === (11)) || (_3 === (12))) {
					$s = -1; return cvtUint;
				} else if ((_3 === (13)) || (_3 === (14))) {
					$s = -1; return cvtUintFloat;
				} else if (_3 === (24)) {
					$s = -1; return cvtUintString;
				}
				$s = 8; continue;
			/* } else if ((_1 === (13)) || (_1 === (14))) { */ case 4:
				_4 = dst.Kind();
				if ((_4 === (2)) || (_4 === (3)) || (_4 === (4)) || (_4 === (5)) || (_4 === (6))) {
					$s = -1; return cvtFloatInt;
				} else if ((_4 === (7)) || (_4 === (8)) || (_4 === (9)) || (_4 === (10)) || (_4 === (11)) || (_4 === (12))) {
					$s = -1; return cvtFloatUint;
				} else if ((_4 === (13)) || (_4 === (14))) {
					$s = -1; return cvtFloat;
				}
				$s = 8; continue;
			/* } else if ((_1 === (15)) || (_1 === (16))) { */ case 5:
				_5 = dst.Kind();
				if ((_5 === (15)) || (_5 === (16))) {
					$s = -1; return cvtComplex;
				}
				$s = 8; continue;
			/* } else if (_1 === (24)) { */ case 6:
				if (!(dst.Kind() === 23)) { _v = false; $s = 11; continue s; }
				_r = dst.Elem().PkgPath(); /* */ $s = 12; case 12: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_v = _r === ""; case 11:
				/* */ if (_v) { $s = 9; continue; }
				/* */ $s = 10; continue;
				/* if (_v) { */ case 9:
						_r$1 = dst.Elem().Kind(); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						_6 = _r$1;
						if (_6 === (8)) {
							$s = -1; return cvtStringBytes;
						} else if (_6 === (5)) {
							$s = -1; return cvtStringRunes;
						}
					case 13:
				/* } */ case 10:
				$s = 8; continue;
			/* } else if (_1 === (23)) { */ case 7:
				if (!(dst.Kind() === 24)) { _v$1 = false; $s = 17; continue s; }
				_r$2 = src.Elem().PkgPath(); /* */ $s = 18; case 18: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_v$1 = _r$2 === ""; case 17:
				/* */ if (_v$1) { $s = 15; continue; }
				/* */ $s = 16; continue;
				/* if (_v$1) { */ case 15:
						_r$3 = src.Elem().Kind(); /* */ $s = 20; case 20: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						_7 = _r$3;
						if (_7 === (8)) {
							$s = -1; return cvtBytesString;
						} else if (_7 === (5)) {
							$s = -1; return cvtRunesString;
						}
					case 19:
				/* } */ case 16:
			/* } */ case 8:
		case 1:
		_r$4 = haveIdenticalUnderlyingType(dst, src, false); /* */ $s = 23; case 23: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		/* */ if (_r$4) { $s = 21; continue; }
		/* */ $s = 22; continue;
		/* if (_r$4) { */ case 21:
			$s = -1; return cvtDirect;
		/* } */ case 22:
		if (!((dst.Kind() === 22) && dst.Name() === "" && (src.Kind() === 22) && src.Name() === "")) { _v$2 = false; $s = 26; continue s; }
		_r$5 = dst.Elem().common(); /* */ $s = 27; case 27: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_arg = _r$5;
		_r$6 = src.Elem().common(); /* */ $s = 28; case 28: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_arg$1 = _r$6;
		_r$7 = haveIdenticalUnderlyingType(_arg, _arg$1, false); /* */ $s = 29; case 29: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_v$2 = _r$7; case 26:
		/* */ if (_v$2) { $s = 24; continue; }
		/* */ $s = 25; continue;
		/* if (_v$2) { */ case 24:
			$s = -1; return cvtDirect;
		/* } */ case 25:
		if (implements$1(dst, src)) {
			if (src.Kind() === 20) {
				$s = -1; return cvtI2I;
			}
			$s = -1; return cvtT2I;
		}
		$s = -1; return $throwNilPointerError;
		/* */ } return; } if ($f === undefined) { $f = { $blk: convertOp }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._6 = _6; $f._7 = _7; $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f.dst = dst; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeFloat = function(f, v, t) {
		var _1, _r, f, ptr, t, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; f = $f.f; ptr = $f.ptr; t = $f.t; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		typ = _r;
		ptr = unsafe_New(typ);
		_1 = typ.size;
		if (_1 === (4)) {
			(ptr).$set(($fround(v)));
		} else if (_1 === (8)) {
			(ptr).$set(v);
		}
		$s = -1; return new Value.ptr(typ, ptr, (((f | 128) >>> 0) | ((typ.Kind() >>> 0))) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeFloat }; } $f._1 = _1; $f._r = _r; $f.f = f; $f.ptr = ptr; $f.t = t; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeComplex = function(f, v, t) {
		var _1, _r, f, ptr, t, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; f = $f.f; ptr = $f.ptr; t = $f.t; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		typ = _r;
		ptr = unsafe_New(typ);
		_1 = typ.size;
		if (_1 === (8)) {
			(ptr).$set((new $Complex64(v.$real, v.$imag)));
		} else if (_1 === (16)) {
			(ptr).$set(v);
		}
		$s = -1; return new Value.ptr(typ, ptr, (((f | 128) >>> 0) | ((typ.Kind() >>> 0))) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeComplex }; } $f._1 = _1; $f._r = _r; $f.f = f; $f.ptr = ptr; $f.t = t; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeString = function(f, v, t) {
		var _r, _r$1, f, ret, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; f = $f.f; ret = $f.ret; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = New(t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = $clone(_r, Value).Elem(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		ret = _r$1;
		$clone(ret, Value).SetString(v);
		ret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeString }; } $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.ret = ret; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeBytes = function(f, v, t) {
		var _r, _r$1, f, ret, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; f = $f.f; ret = $f.ret; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = New(t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = $clone(_r, Value).Elem(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		ret = _r$1;
		$r = $clone(ret, Value).SetBytes(v); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		ret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeBytes }; } $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.ret = ret; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeRunes = function(f, v, t) {
		var _r, _r$1, f, ret, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; f = $f.f; ret = $f.ret; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = New(t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = $clone(_r, Value).Elem(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		ret = _r$1;
		$r = $clone(ret, Value).setRunes(v); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		ret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeRunes }; } $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.ret = ret; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtInt = function(v, t) {
		var _r, t, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeInt((v.flag & 96) >>> 0, ((x = $clone(v, Value).Int(), new $Uint64(x.$high, x.$low))), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtInt }; } $f._r = _r; $f.t = t; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtUint = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeInt((v.flag & 96) >>> 0, $clone(v, Value).Uint(), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtUint }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtFloatInt = function(v, t) {
		var _r, t, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeInt((v.flag & 96) >>> 0, ((x = (new $Int64(0, $clone(v, Value).Float())), new $Uint64(x.$high, x.$low))), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtFloatInt }; } $f._r = _r; $f.t = t; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtFloatUint = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeInt((v.flag & 96) >>> 0, (new $Uint64(0, $clone(v, Value).Float())), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtFloatUint }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtIntFloat = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeFloat((v.flag & 96) >>> 0, ($flatten64($clone(v, Value).Int())), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtIntFloat }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtUintFloat = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeFloat((v.flag & 96) >>> 0, ($flatten64($clone(v, Value).Uint())), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtUintFloat }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtFloat = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeFloat((v.flag & 96) >>> 0, $clone(v, Value).Float(), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtFloat }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtComplex = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeComplex((v.flag & 96) >>> 0, $clone(v, Value).Complex(), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtComplex }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtIntString = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeString((v.flag & 96) >>> 0, ($encodeRune($clone(v, Value).Int().$low)), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtIntString }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtUintString = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeString((v.flag & 96) >>> 0, ($encodeRune($clone(v, Value).Uint().$low)), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtUintString }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtBytesString = function(v, t) {
		var _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_arg = (v.flag & 96) >>> 0;
		_r = $clone(v, Value).Bytes(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg$1 = ($bytesToString(_r));
		_arg$2 = t;
		_r$1 = makeString(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtBytesString }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtStringBytes = function(v, t) {
		var _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_arg = (v.flag & 96) >>> 0;
		_r = $clone(v, Value).String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg$1 = (new sliceType$15($stringToBytes(_r)));
		_arg$2 = t;
		_r$1 = makeBytes(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtStringBytes }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtRunesString = function(v, t) {
		var _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_arg = (v.flag & 96) >>> 0;
		_r = $clone(v, Value).runes(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg$1 = ($runesToString(_r));
		_arg$2 = t;
		_r$1 = makeString(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtRunesString }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtStringRunes = function(v, t) {
		var _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_arg = (v.flag & 96) >>> 0;
		_r = $clone(v, Value).String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg$1 = (new sliceType$17($stringToRunes(_r)));
		_arg$2 = t;
		_r$1 = makeRunes(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtStringRunes }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtT2I = function(v, typ) {
		var _r, _r$1, _r$2, _r$3, _r$4, target, typ, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; target = $f.target; typ = $f.typ; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = typ.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = unsafe_New(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		target = _r$1;
		_r$2 = valueInterface($clone(v, Value), false); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		x = _r$2;
		_r$3 = typ.NumMethod(); /* */ $s = 7; case 7: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		/* */ if (_r$3 === 0) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (_r$3 === 0) { */ case 4:
			(target).$set(x);
			$s = 6; continue;
		/* } else { */ case 5:
			ifaceE2I($assertType(typ, ptrType$1), x, target);
		/* } */ case 6:
		_r$4 = typ.common(); /* */ $s = 8; case 8: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		$s = -1; return new Value.ptr(_r$4, target, (((((v.flag & 96) >>> 0) | 128) >>> 0) | 20) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtT2I }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.target = target; $f.typ = typ; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtI2I = function(v, typ) {
		var _r, _r$1, _r$2, ret, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; ret = $f.ret; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ if ($clone(v, Value).IsNil()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($clone(v, Value).IsNil()) { */ case 1:
			_r = Zero(typ); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			ret = _r;
			ret.flag = (ret.flag | (((v.flag & 96) >>> 0))) >>> 0;
			$s = -1; return ret;
		/* } */ case 2:
		_r$1 = $clone(v, Value).Elem(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = cvtT2I($clone(_r$1, Value), typ); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtI2I }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.ret = ret; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	ptrType$5.methods = [{prop: "methods", name: "methods", pkg: "reflect", typ: $funcType([], [sliceType$5], false)}];
	ptrType$16.methods = [{prop: "in$", name: "in", pkg: "reflect", typ: $funcType([], [sliceType$2], false)}, {prop: "out", name: "out", pkg: "reflect", typ: $funcType([], [sliceType$2], false)}];
	name.methods = [{prop: "name", name: "name", pkg: "reflect", typ: $funcType([], [$String], false)}, {prop: "tag", name: "tag", pkg: "reflect", typ: $funcType([], [$String], false)}, {prop: "pkgPath", name: "pkgPath", pkg: "reflect", typ: $funcType([], [$String], false)}, {prop: "isExported", name: "isExported", pkg: "reflect", typ: $funcType([], [$Bool], false)}, {prop: "data", name: "data", pkg: "reflect", typ: $funcType([$Int], [ptrType$4], false)}, {prop: "nameLen", name: "nameLen", pkg: "reflect", typ: $funcType([], [$Int], false)}, {prop: "tagLen", name: "tagLen", pkg: "reflect", typ: $funcType([], [$Int], false)}];
	Kind.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$1.methods = [{prop: "uncommon", name: "uncommon", pkg: "reflect", typ: $funcType([], [ptrType$5], false)}, {prop: "nameOff", name: "nameOff", pkg: "reflect", typ: $funcType([nameOff], [name], false)}, {prop: "typeOff", name: "typeOff", pkg: "reflect", typ: $funcType([typeOff], [ptrType$1], false)}, {prop: "ptrTo", name: "ptrTo", pkg: "reflect", typ: $funcType([], [ptrType$1], false)}, {prop: "pointers", name: "pointers", pkg: "reflect", typ: $funcType([], [$Bool], false)}, {prop: "Comparable", name: "Comparable", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Method", name: "Method", pkg: "", typ: $funcType([$Int], [Method], false)}, {prop: "textOff", name: "textOff", pkg: "reflect", typ: $funcType([textOff], [$UnsafePointer], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Uintptr], false)}, {prop: "Bits", name: "Bits", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Align", name: "Align", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "FieldAlign", name: "FieldAlign", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Kind", name: "Kind", pkg: "", typ: $funcType([], [Kind], false)}, {prop: "common", name: "common", pkg: "reflect", typ: $funcType([], [ptrType$1], false)}, {prop: "exportedMethods", name: "exportedMethods", pkg: "reflect", typ: $funcType([], [sliceType$5], false)}, {prop: "NumMethod", name: "NumMethod", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "MethodByName", name: "MethodByName", pkg: "", typ: $funcType([$String], [Method, $Bool], false)}, {prop: "PkgPath", name: "PkgPath", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Name", name: "Name", pkg: "", typ: $funcType([], [$String], false)}, {prop: "ChanDir", name: "ChanDir", pkg: "", typ: $funcType([], [ChanDir], false)}, {prop: "IsVariadic", name: "IsVariadic", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Elem", name: "Elem", pkg: "", typ: $funcType([], [Type], false)}, {prop: "Field", name: "Field", pkg: "", typ: $funcType([$Int], [StructField], false)}, {prop: "FieldByIndex", name: "FieldByIndex", pkg: "", typ: $funcType([sliceType$13], [StructField], false)}, {prop: "FieldByName", name: "FieldByName", pkg: "", typ: $funcType([$String], [StructField, $Bool], false)}, {prop: "FieldByNameFunc", name: "FieldByNameFunc", pkg: "", typ: $funcType([funcType$3], [StructField, $Bool], false)}, {prop: "In", name: "In", pkg: "", typ: $funcType([$Int], [Type], false)}, {prop: "Key", name: "Key", pkg: "", typ: $funcType([], [Type], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumField", name: "NumField", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumIn", name: "NumIn", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumOut", name: "NumOut", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Out", name: "Out", pkg: "", typ: $funcType([$Int], [Type], false)}, {prop: "Implements", name: "Implements", pkg: "", typ: $funcType([Type], [$Bool], false)}, {prop: "AssignableTo", name: "AssignableTo", pkg: "", typ: $funcType([Type], [$Bool], false)}, {prop: "ConvertibleTo", name: "ConvertibleTo", pkg: "", typ: $funcType([Type], [$Bool], false)}];
	ChanDir.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$7.methods = [{prop: "Method", name: "Method", pkg: "", typ: $funcType([$Int], [Method], false)}, {prop: "NumMethod", name: "NumMethod", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "MethodByName", name: "MethodByName", pkg: "", typ: $funcType([$String], [Method, $Bool], false)}];
	ptrType$17.methods = [{prop: "offset", name: "offset", pkg: "reflect", typ: $funcType([], [$Uintptr], false)}, {prop: "anon", name: "anon", pkg: "reflect", typ: $funcType([], [$Bool], false)}];
	ptrType$9.methods = [{prop: "Field", name: "Field", pkg: "", typ: $funcType([$Int], [StructField], false)}, {prop: "FieldByIndex", name: "FieldByIndex", pkg: "", typ: $funcType([sliceType$13], [StructField], false)}, {prop: "FieldByNameFunc", name: "FieldByNameFunc", pkg: "", typ: $funcType([funcType$3], [StructField, $Bool], false)}, {prop: "FieldByName", name: "FieldByName", pkg: "", typ: $funcType([$String], [StructField, $Bool], false)}];
	StructTag.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "Lookup", name: "Lookup", pkg: "", typ: $funcType([$String], [$String, $Bool], false)}];
	Value.methods = [{prop: "object", name: "object", pkg: "reflect", typ: $funcType([], [ptrType$2], false)}, {prop: "call", name: "call", pkg: "reflect", typ: $funcType([$String, sliceType$9], [sliceType$9], false)}, {prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Elem", name: "Elem", pkg: "", typ: $funcType([], [Value], false)}, {prop: "Field", name: "Field", pkg: "", typ: $funcType([$Int], [Value], false)}, {prop: "Index", name: "Index", pkg: "", typ: $funcType([$Int], [Value], false)}, {prop: "InterfaceData", name: "InterfaceData", pkg: "", typ: $funcType([], [arrayType$12], false)}, {prop: "IsNil", name: "IsNil", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Pointer", name: "Pointer", pkg: "", typ: $funcType([], [$Uintptr], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([Value], [], false)}, {prop: "SetBytes", name: "SetBytes", pkg: "", typ: $funcType([sliceType$15], [], false)}, {prop: "SetCap", name: "SetCap", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "SetLen", name: "SetLen", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Slice", name: "Slice", pkg: "", typ: $funcType([$Int, $Int], [Value], false)}, {prop: "Slice3", name: "Slice3", pkg: "", typ: $funcType([$Int, $Int, $Int], [Value], false)}, {prop: "Close", name: "Close", pkg: "", typ: $funcType([], [], false)}, {prop: "pointer", name: "pointer", pkg: "reflect", typ: $funcType([], [$UnsafePointer], false)}, {prop: "Addr", name: "Addr", pkg: "", typ: $funcType([], [Value], false)}, {prop: "Bool", name: "Bool", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Bytes", name: "Bytes", pkg: "", typ: $funcType([], [sliceType$15], false)}, {prop: "runes", name: "runes", pkg: "reflect", typ: $funcType([], [sliceType$17], false)}, {prop: "CanAddr", name: "CanAddr", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "CanSet", name: "CanSet", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Call", name: "Call", pkg: "", typ: $funcType([sliceType$9], [sliceType$9], false)}, {prop: "CallSlice", name: "CallSlice", pkg: "", typ: $funcType([sliceType$9], [sliceType$9], false)}, {prop: "Complex", name: "Complex", pkg: "", typ: $funcType([], [$Complex128], false)}, {prop: "FieldByIndex", name: "FieldByIndex", pkg: "", typ: $funcType([sliceType$13], [Value], false)}, {prop: "FieldByName", name: "FieldByName", pkg: "", typ: $funcType([$String], [Value], false)}, {prop: "FieldByNameFunc", name: "FieldByNameFunc", pkg: "", typ: $funcType([funcType$3], [Value], false)}, {prop: "Float", name: "Float", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Int", name: "Int", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "CanInterface", name: "CanInterface", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Interface", name: "Interface", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "IsValid", name: "IsValid", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Kind", name: "Kind", pkg: "", typ: $funcType([], [Kind], false)}, {prop: "MapIndex", name: "MapIndex", pkg: "", typ: $funcType([Value], [Value], false)}, {prop: "MapKeys", name: "MapKeys", pkg: "", typ: $funcType([], [sliceType$9], false)}, {prop: "Method", name: "Method", pkg: "", typ: $funcType([$Int], [Value], false)}, {prop: "NumMethod", name: "NumMethod", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "MethodByName", name: "MethodByName", pkg: "", typ: $funcType([$String], [Value], false)}, {prop: "NumField", name: "NumField", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "OverflowComplex", name: "OverflowComplex", pkg: "", typ: $funcType([$Complex128], [$Bool], false)}, {prop: "OverflowFloat", name: "OverflowFloat", pkg: "", typ: $funcType([$Float64], [$Bool], false)}, {prop: "OverflowInt", name: "OverflowInt", pkg: "", typ: $funcType([$Int64], [$Bool], false)}, {prop: "OverflowUint", name: "OverflowUint", pkg: "", typ: $funcType([$Uint64], [$Bool], false)}, {prop: "Recv", name: "Recv", pkg: "", typ: $funcType([], [Value, $Bool], false)}, {prop: "recv", name: "recv", pkg: "reflect", typ: $funcType([$Bool], [Value, $Bool], false)}, {prop: "Send", name: "Send", pkg: "", typ: $funcType([Value], [], false)}, {prop: "send", name: "send", pkg: "reflect", typ: $funcType([Value, $Bool], [$Bool], false)}, {prop: "SetBool", name: "SetBool", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "setRunes", name: "setRunes", pkg: "reflect", typ: $funcType([sliceType$17], [], false)}, {prop: "SetComplex", name: "SetComplex", pkg: "", typ: $funcType([$Complex128], [], false)}, {prop: "SetFloat", name: "SetFloat", pkg: "", typ: $funcType([$Float64], [], false)}, {prop: "SetInt", name: "SetInt", pkg: "", typ: $funcType([$Int64], [], false)}, {prop: "SetMapIndex", name: "SetMapIndex", pkg: "", typ: $funcType([Value, Value], [], false)}, {prop: "SetUint", name: "SetUint", pkg: "", typ: $funcType([$Uint64], [], false)}, {prop: "SetPointer", name: "SetPointer", pkg: "", typ: $funcType([$UnsafePointer], [], false)}, {prop: "SetString", name: "SetString", pkg: "", typ: $funcType([$String], [], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "TryRecv", name: "TryRecv", pkg: "", typ: $funcType([], [Value, $Bool], false)}, {prop: "TrySend", name: "TrySend", pkg: "", typ: $funcType([Value], [$Bool], false)}, {prop: "Type", name: "Type", pkg: "", typ: $funcType([], [Type], false)}, {prop: "Uint", name: "Uint", pkg: "", typ: $funcType([], [$Uint64], false)}, {prop: "UnsafeAddr", name: "UnsafeAddr", pkg: "", typ: $funcType([], [$Uintptr], false)}, {prop: "assignTo", name: "assignTo", pkg: "reflect", typ: $funcType([$String, ptrType$1, $UnsafePointer], [Value], false)}, {prop: "Convert", name: "Convert", pkg: "", typ: $funcType([Type], [Value], false)}];
	flag.methods = [{prop: "kind", name: "kind", pkg: "reflect", typ: $funcType([], [Kind], false)}, {prop: "mustBe", name: "mustBe", pkg: "reflect", typ: $funcType([Kind], [], false)}, {prop: "mustBeExported", name: "mustBeExported", pkg: "reflect", typ: $funcType([], [], false)}, {prop: "mustBeAssignable", name: "mustBeAssignable", pkg: "reflect", typ: $funcType([], [], false)}];
	ptrType$18.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	uncommonType.init("reflect", [{prop: "pkgPath", name: "pkgPath", anonymous: false, exported: false, typ: nameOff, tag: ""}, {prop: "mcount", name: "mcount", anonymous: false, exported: false, typ: $Uint16, tag: ""}, {prop: "_$2", name: "_", anonymous: false, exported: false, typ: $Uint16, tag: ""}, {prop: "moff", name: "moff", anonymous: false, exported: false, typ: $Uint32, tag: ""}, {prop: "_$4", name: "_", anonymous: false, exported: false, typ: $Uint32, tag: ""}, {prop: "_methods", name: "_methods", anonymous: false, exported: false, typ: sliceType$5, tag: ""}]);
	funcType.init("reflect", [{prop: "rtype", name: "rtype", anonymous: true, exported: false, typ: rtype, tag: "reflect:\"func\""}, {prop: "inCount", name: "inCount", anonymous: false, exported: false, typ: $Uint16, tag: ""}, {prop: "outCount", name: "outCount", anonymous: false, exported: false, typ: $Uint16, tag: ""}, {prop: "_in", name: "_in", anonymous: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "_out", name: "_out", anonymous: false, exported: false, typ: sliceType$2, tag: ""}]);
	name.init("reflect", [{prop: "bytes", name: "bytes", anonymous: false, exported: false, typ: ptrType$4, tag: ""}]);
	nameData.init("reflect", [{prop: "name", name: "name", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "tag", name: "tag", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "pkgPath", name: "pkgPath", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "exported", name: "exported", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	mapIter.init("reflect", [{prop: "t", name: "t", anonymous: false, exported: false, typ: Type, tag: ""}, {prop: "m", name: "m", anonymous: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "keys", name: "keys", anonymous: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "i", name: "i", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	Type.init([{prop: "Align", name: "Align", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "AssignableTo", name: "AssignableTo", pkg: "", typ: $funcType([Type], [$Bool], false)}, {prop: "Bits", name: "Bits", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "ChanDir", name: "ChanDir", pkg: "", typ: $funcType([], [ChanDir], false)}, {prop: "Comparable", name: "Comparable", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "ConvertibleTo", name: "ConvertibleTo", pkg: "", typ: $funcType([Type], [$Bool], false)}, {prop: "Elem", name: "Elem", pkg: "", typ: $funcType([], [Type], false)}, {prop: "Field", name: "Field", pkg: "", typ: $funcType([$Int], [StructField], false)}, {prop: "FieldAlign", name: "FieldAlign", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "FieldByIndex", name: "FieldByIndex", pkg: "", typ: $funcType([sliceType$13], [StructField], false)}, {prop: "FieldByName", name: "FieldByName", pkg: "", typ: $funcType([$String], [StructField, $Bool], false)}, {prop: "FieldByNameFunc", name: "FieldByNameFunc", pkg: "", typ: $funcType([funcType$3], [StructField, $Bool], false)}, {prop: "Implements", name: "Implements", pkg: "", typ: $funcType([Type], [$Bool], false)}, {prop: "In", name: "In", pkg: "", typ: $funcType([$Int], [Type], false)}, {prop: "IsVariadic", name: "IsVariadic", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Key", name: "Key", pkg: "", typ: $funcType([], [Type], false)}, {prop: "Kind", name: "Kind", pkg: "", typ: $funcType([], [Kind], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Method", name: "Method", pkg: "", typ: $funcType([$Int], [Method], false)}, {prop: "MethodByName", name: "MethodByName", pkg: "", typ: $funcType([$String], [Method, $Bool], false)}, {prop: "Name", name: "Name", pkg: "", typ: $funcType([], [$String], false)}, {prop: "NumField", name: "NumField", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumIn", name: "NumIn", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumMethod", name: "NumMethod", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumOut", name: "NumOut", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Out", name: "Out", pkg: "", typ: $funcType([$Int], [Type], false)}, {prop: "PkgPath", name: "PkgPath", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Uintptr], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "common", name: "common", pkg: "reflect", typ: $funcType([], [ptrType$1], false)}, {prop: "uncommon", name: "uncommon", pkg: "reflect", typ: $funcType([], [ptrType$5], false)}]);
	rtype.init("reflect", [{prop: "size", name: "size", anonymous: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "ptrdata", name: "ptrdata", anonymous: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "hash", name: "hash", anonymous: false, exported: false, typ: $Uint32, tag: ""}, {prop: "tflag", name: "tflag", anonymous: false, exported: false, typ: tflag, tag: ""}, {prop: "align", name: "align", anonymous: false, exported: false, typ: $Uint8, tag: ""}, {prop: "fieldAlign", name: "fieldAlign", anonymous: false, exported: false, typ: $Uint8, tag: ""}, {prop: "kind", name: "kind", anonymous: false, exported: false, typ: $Uint8, tag: ""}, {prop: "alg", name: "alg", anonymous: false, exported: false, typ: ptrType$3, tag: ""}, {prop: "gcdata", name: "gcdata", anonymous: false, exported: false, typ: ptrType$4, tag: ""}, {prop: "str", name: "str", anonymous: false, exported: false, typ: nameOff, tag: ""}, {prop: "ptrToThis", name: "ptrToThis", anonymous: false, exported: false, typ: typeOff, tag: ""}]);
	typeAlg.init("reflect", [{prop: "hash", name: "hash", anonymous: false, exported: false, typ: funcType$4, tag: ""}, {prop: "equal", name: "equal", anonymous: false, exported: false, typ: funcType$5, tag: ""}]);
	method.init("reflect", [{prop: "name", name: "name", anonymous: false, exported: false, typ: nameOff, tag: ""}, {prop: "mtyp", name: "mtyp", anonymous: false, exported: false, typ: typeOff, tag: ""}, {prop: "ifn", name: "ifn", anonymous: false, exported: false, typ: textOff, tag: ""}, {prop: "tfn", name: "tfn", anonymous: false, exported: false, typ: textOff, tag: ""}]);
	arrayType.init("reflect", [{prop: "rtype", name: "rtype", anonymous: true, exported: false, typ: rtype, tag: "reflect:\"array\""}, {prop: "elem", name: "elem", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "slice", name: "slice", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "len", name: "len", anonymous: false, exported: false, typ: $Uintptr, tag: ""}]);
	chanType.init("reflect", [{prop: "rtype", name: "rtype", anonymous: true, exported: false, typ: rtype, tag: "reflect:\"chan\""}, {prop: "elem", name: "elem", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "dir", name: "dir", anonymous: false, exported: false, typ: $Uintptr, tag: ""}]);
	imethod.init("reflect", [{prop: "name", name: "name", anonymous: false, exported: false, typ: nameOff, tag: ""}, {prop: "typ", name: "typ", anonymous: false, exported: false, typ: typeOff, tag: ""}]);
	interfaceType.init("reflect", [{prop: "rtype", name: "rtype", anonymous: true, exported: false, typ: rtype, tag: "reflect:\"interface\""}, {prop: "pkgPath", name: "pkgPath", anonymous: false, exported: false, typ: name, tag: ""}, {prop: "methods", name: "methods", anonymous: false, exported: false, typ: sliceType$6, tag: ""}]);
	mapType.init("reflect", [{prop: "rtype", name: "rtype", anonymous: true, exported: false, typ: rtype, tag: "reflect:\"map\""}, {prop: "key", name: "key", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "elem", name: "elem", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "bucket", name: "bucket", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "hmap", name: "hmap", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "keysize", name: "keysize", anonymous: false, exported: false, typ: $Uint8, tag: ""}, {prop: "indirectkey", name: "indirectkey", anonymous: false, exported: false, typ: $Uint8, tag: ""}, {prop: "valuesize", name: "valuesize", anonymous: false, exported: false, typ: $Uint8, tag: ""}, {prop: "indirectvalue", name: "indirectvalue", anonymous: false, exported: false, typ: $Uint8, tag: ""}, {prop: "bucketsize", name: "bucketsize", anonymous: false, exported: false, typ: $Uint16, tag: ""}, {prop: "reflexivekey", name: "reflexivekey", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "needkeyupdate", name: "needkeyupdate", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	ptrType.init("reflect", [{prop: "rtype", name: "rtype", anonymous: true, exported: false, typ: rtype, tag: "reflect:\"ptr\""}, {prop: "elem", name: "elem", anonymous: false, exported: false, typ: ptrType$1, tag: ""}]);
	sliceType.init("reflect", [{prop: "rtype", name: "rtype", anonymous: true, exported: false, typ: rtype, tag: "reflect:\"slice\""}, {prop: "elem", name: "elem", anonymous: false, exported: false, typ: ptrType$1, tag: ""}]);
	structField.init("reflect", [{prop: "name", name: "name", anonymous: false, exported: false, typ: name, tag: ""}, {prop: "typ", name: "typ", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "offsetAnon", name: "offsetAnon", anonymous: false, exported: false, typ: $Uintptr, tag: ""}]);
	structType.init("reflect", [{prop: "rtype", name: "rtype", anonymous: true, exported: false, typ: rtype, tag: "reflect:\"struct\""}, {prop: "pkgPath", name: "pkgPath", anonymous: false, exported: false, typ: name, tag: ""}, {prop: "fields", name: "fields", anonymous: false, exported: false, typ: sliceType$7, tag: ""}]);
	Method.init("", [{prop: "Name", name: "Name", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "PkgPath", name: "PkgPath", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Type", name: "Type", anonymous: false, exported: true, typ: Type, tag: ""}, {prop: "Func", name: "Func", anonymous: false, exported: true, typ: Value, tag: ""}, {prop: "Index", name: "Index", anonymous: false, exported: true, typ: $Int, tag: ""}]);
	StructField.init("", [{prop: "Name", name: "Name", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "PkgPath", name: "PkgPath", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Type", name: "Type", anonymous: false, exported: true, typ: Type, tag: ""}, {prop: "Tag", name: "Tag", anonymous: false, exported: true, typ: StructTag, tag: ""}, {prop: "Offset", name: "Offset", anonymous: false, exported: true, typ: $Uintptr, tag: ""}, {prop: "Index", name: "Index", anonymous: false, exported: true, typ: sliceType$13, tag: ""}, {prop: "Anonymous", name: "Anonymous", anonymous: false, exported: true, typ: $Bool, tag: ""}]);
	fieldScan.init("reflect", [{prop: "typ", name: "typ", anonymous: false, exported: false, typ: ptrType$9, tag: ""}, {prop: "index", name: "index", anonymous: false, exported: false, typ: sliceType$13, tag: ""}]);
	Value.init("reflect", [{prop: "typ", name: "typ", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "ptr", name: "ptr", anonymous: false, exported: false, typ: $UnsafePointer, tag: ""}, {prop: "flag", name: "flag", anonymous: true, exported: false, typ: flag, tag: ""}]);
	ValueError.init("", [{prop: "Method", name: "Method", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Kind", name: "Kind", anonymous: false, exported: true, typ: Kind, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		nameOffList = sliceType$1.nil;
		typeOffList = sliceType$2.nil;
		methodCache = new sync.Map.ptr(new sync.Mutex.ptr(0, 0), new $packages["sync/atomic"].Value.ptr(new $packages["sync/atomic"].noCopy.ptr(), $ifaceNil), false, 0);
		initialized = false;
		uncommonTypeMap = {};
		nameMap = {};
		callHelper = $assertType($internalize($call, $emptyInterface), funcType$1);
		selectHelper = $assertType($internalize($select, $emptyInterface), funcType$1);
		jsObjectPtr = reflectType($jsObjectPtr);
		kindNames = new sliceType$4(["invalid", "bool", "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "uintptr", "float32", "float64", "complex64", "complex128", "array", "chan", "func", "interface", "map", "ptr", "slice", "string", "struct", "unsafe.Pointer"]);
		uint8Type = $assertType(TypeOf(new $Uint8(0)), ptrType$1);
		$r = init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["fmt"] = (function() {
	var $pkg = {}, $init, errors, io, math, os, reflect, strconv, sync, utf8, fmtFlags, fmt, State, Formatter, Stringer, GoStringer, buffer, pp, ScanState, scanError, ss, ssave, sliceType, ptrType, ptrType$1, arrayType, arrayType$1, sliceType$1, sliceType$2, arrayType$2, ptrType$2, ptrType$5, ptrType$25, funcType, ppFree, space, ssFree, complexError, boolError, newPrinter, Fprintf, Sprintf, Errorf, Fprint, Fprintln, getField, tooLarge, parsenum, intFromArg, parseArgNumber, isSpace, notSpace, indexRune;
	errors = $packages["errors"];
	io = $packages["io"];
	math = $packages["math"];
	os = $packages["os"];
	reflect = $packages["reflect"];
	strconv = $packages["strconv"];
	sync = $packages["sync"];
	utf8 = $packages["unicode/utf8"];
	fmtFlags = $pkg.fmtFlags = $newType(0, $kindStruct, "fmt.fmtFlags", true, "fmt", false, function(widPresent_, precPresent_, minus_, plus_, sharp_, space_, zero_, plusV_, sharpV_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.widPresent = false;
			this.precPresent = false;
			this.minus = false;
			this.plus = false;
			this.sharp = false;
			this.space = false;
			this.zero = false;
			this.plusV = false;
			this.sharpV = false;
			return;
		}
		this.widPresent = widPresent_;
		this.precPresent = precPresent_;
		this.minus = minus_;
		this.plus = plus_;
		this.sharp = sharp_;
		this.space = space_;
		this.zero = zero_;
		this.plusV = plusV_;
		this.sharpV = sharpV_;
	});
	fmt = $pkg.fmt = $newType(0, $kindStruct, "fmt.fmt", true, "fmt", false, function(buf_, fmtFlags_, wid_, prec_, intbuf_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = ptrType$1.nil;
			this.fmtFlags = new fmtFlags.ptr(false, false, false, false, false, false, false, false, false);
			this.wid = 0;
			this.prec = 0;
			this.intbuf = arrayType.zero();
			return;
		}
		this.buf = buf_;
		this.fmtFlags = fmtFlags_;
		this.wid = wid_;
		this.prec = prec_;
		this.intbuf = intbuf_;
	});
	State = $pkg.State = $newType(8, $kindInterface, "fmt.State", true, "fmt", true, null);
	Formatter = $pkg.Formatter = $newType(8, $kindInterface, "fmt.Formatter", true, "fmt", true, null);
	Stringer = $pkg.Stringer = $newType(8, $kindInterface, "fmt.Stringer", true, "fmt", true, null);
	GoStringer = $pkg.GoStringer = $newType(8, $kindInterface, "fmt.GoStringer", true, "fmt", true, null);
	buffer = $pkg.buffer = $newType(12, $kindSlice, "fmt.buffer", true, "fmt", false, null);
	pp = $pkg.pp = $newType(0, $kindStruct, "fmt.pp", true, "fmt", false, function(buf_, arg_, value_, fmt_, reordered_, goodArgNum_, panicking_, erroring_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = buffer.nil;
			this.arg = $ifaceNil;
			this.value = new reflect.Value.ptr(ptrType.nil, 0, 0);
			this.fmt = new fmt.ptr(ptrType$1.nil, new fmtFlags.ptr(false, false, false, false, false, false, false, false, false), 0, 0, arrayType.zero());
			this.reordered = false;
			this.goodArgNum = false;
			this.panicking = false;
			this.erroring = false;
			return;
		}
		this.buf = buf_;
		this.arg = arg_;
		this.value = value_;
		this.fmt = fmt_;
		this.reordered = reordered_;
		this.goodArgNum = goodArgNum_;
		this.panicking = panicking_;
		this.erroring = erroring_;
	});
	ScanState = $pkg.ScanState = $newType(8, $kindInterface, "fmt.ScanState", true, "fmt", true, null);
	scanError = $pkg.scanError = $newType(0, $kindStruct, "fmt.scanError", true, "fmt", false, function(err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.err = $ifaceNil;
			return;
		}
		this.err = err_;
	});
	ss = $pkg.ss = $newType(0, $kindStruct, "fmt.ss", true, "fmt", false, function(rs_, buf_, count_, atEOF_, ssave_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rs = $ifaceNil;
			this.buf = buffer.nil;
			this.count = 0;
			this.atEOF = false;
			this.ssave = new ssave.ptr(false, false, false, 0, 0, 0);
			return;
		}
		this.rs = rs_;
		this.buf = buf_;
		this.count = count_;
		this.atEOF = atEOF_;
		this.ssave = ssave_;
	});
	ssave = $pkg.ssave = $newType(0, $kindStruct, "fmt.ssave", true, "fmt", false, function(validSave_, nlIsEnd_, nlIsSpace_, argLimit_, limit_, maxWid_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.validSave = false;
			this.nlIsEnd = false;
			this.nlIsSpace = false;
			this.argLimit = 0;
			this.limit = 0;
			this.maxWid = 0;
			return;
		}
		this.validSave = validSave_;
		this.nlIsEnd = nlIsEnd_;
		this.nlIsSpace = nlIsSpace_;
		this.argLimit = argLimit_;
		this.limit = limit_;
		this.maxWid = maxWid_;
	});
	sliceType = $sliceType($emptyInterface);
	ptrType = $ptrType(reflect.rtype);
	ptrType$1 = $ptrType(buffer);
	arrayType = $arrayType($Uint8, 68);
	arrayType$1 = $arrayType($Uint16, 2);
	sliceType$1 = $sliceType(arrayType$1);
	sliceType$2 = $sliceType($Uint8);
	arrayType$2 = $arrayType($Uint8, 5);
	ptrType$2 = $ptrType(pp);
	ptrType$5 = $ptrType(ss);
	ptrType$25 = $ptrType(fmt);
	funcType = $funcType([$Int32], [$Bool], false);
	fmt.ptr.prototype.clearflags = function() {
		var f;
		f = this;
		fmtFlags.copy(f.fmtFlags, new fmtFlags.ptr(false, false, false, false, false, false, false, false, false));
	};
	fmt.prototype.clearflags = function() { return this.$val.clearflags(); };
	fmt.ptr.prototype.init = function(buf) {
		var buf, f;
		f = this;
		f.buf = buf;
		f.clearflags();
	};
	fmt.prototype.init = function(buf) { return this.$val.init(buf); };
	fmt.ptr.prototype.writePadding = function(n) {
		var _i, _ref, buf, f, i, n, newLen, oldLen, padByte, padding;
		f = this;
		if (n <= 0) {
			return;
		}
		buf = f.buf.$get();
		oldLen = buf.$length;
		newLen = oldLen + n >> 0;
		if (newLen > buf.$capacity) {
			buf = $makeSlice(buffer, (($imul(buf.$capacity, 2)) + n >> 0));
			$copySlice(buf, f.buf.$get());
		}
		padByte = 32;
		if (f.fmtFlags.zero) {
			padByte = 48;
		}
		padding = $subslice(buf, oldLen, newLen);
		_ref = padding;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			((i < 0 || i >= padding.$length) ? ($throwRuntimeError("index out of range"), undefined) : padding.$array[padding.$offset + i] = padByte);
			_i++;
		}
		f.buf.$set($subslice(buf, 0, newLen));
	};
	fmt.prototype.writePadding = function(n) { return this.$val.writePadding(n); };
	fmt.ptr.prototype.pad = function(b) {
		var b, f, width;
		f = this;
		if (!f.fmtFlags.widPresent || (f.wid === 0)) {
			f.buf.Write(b);
			return;
		}
		width = f.wid - utf8.RuneCount(b) >> 0;
		if (!f.fmtFlags.minus) {
			f.writePadding(width);
			f.buf.Write(b);
		} else {
			f.buf.Write(b);
			f.writePadding(width);
		}
	};
	fmt.prototype.pad = function(b) { return this.$val.pad(b); };
	fmt.ptr.prototype.padString = function(s) {
		var f, s, width;
		f = this;
		if (!f.fmtFlags.widPresent || (f.wid === 0)) {
			f.buf.WriteString(s);
			return;
		}
		width = f.wid - utf8.RuneCountInString(s) >> 0;
		if (!f.fmtFlags.minus) {
			f.writePadding(width);
			f.buf.WriteString(s);
		} else {
			f.buf.WriteString(s);
			f.writePadding(width);
		}
	};
	fmt.prototype.padString = function(s) { return this.$val.padString(s); };
	fmt.ptr.prototype.fmt_boolean = function(v) {
		var f, v;
		f = this;
		if (v) {
			f.padString("true");
		} else {
			f.padString("false");
		}
	};
	fmt.prototype.fmt_boolean = function(v) { return this.$val.fmt_boolean(v); };
	fmt.ptr.prototype.fmt_unicode = function(u) {
		var buf, f, i, oldZero, prec, u, width;
		f = this;
		buf = $subslice(new sliceType$2(f.intbuf), 0);
		prec = 4;
		if (f.fmtFlags.precPresent && f.prec > 4) {
			prec = f.prec;
			width = (((2 + prec >> 0) + 2 >> 0) + 4 >> 0) + 1 >> 0;
			if (width > buf.$length) {
				buf = $makeSlice(sliceType$2, width);
			}
		}
		i = buf.$length;
		if (f.fmtFlags.sharp && (u.$high < 0 || (u.$high === 0 && u.$low <= 1114111)) && strconv.IsPrint(((u.$low >> 0)))) {
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 39);
			i = i - (utf8.RuneLen(((u.$low >> 0)))) >> 0;
			utf8.EncodeRune($subslice(buf, i), ((u.$low >> 0)));
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 39);
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 32);
		}
		while (true) {
			if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 16)))) { break; }
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = "0123456789ABCDEFX".charCodeAt($flatten64(new $Uint64(u.$high & 0, (u.$low & 15) >>> 0))));
			prec = prec - (1) >> 0;
			u = $shiftRightUint64(u, (4));
		}
		i = i - (1) >> 0;
		((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = "0123456789ABCDEFX".charCodeAt($flatten64(u)));
		prec = prec - (1) >> 0;
		while (true) {
			if (!(prec > 0)) { break; }
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 48);
			prec = prec - (1) >> 0;
		}
		i = i - (1) >> 0;
		((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 43);
		i = i - (1) >> 0;
		((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 85);
		oldZero = f.fmtFlags.zero;
		f.fmtFlags.zero = false;
		f.pad($subslice(buf, i));
		f.fmtFlags.zero = oldZero;
	};
	fmt.prototype.fmt_unicode = function(u) { return this.$val.fmt_unicode(u); };
	fmt.ptr.prototype.fmt_integer = function(u, base, isSigned, digits) {
		var _1, _2, base, buf, digits, f, i, isSigned, negative, next, oldZero, oldZero$1, prec, u, width, x, x$1, x$2, x$3, x$4;
		f = this;
		negative = isSigned && (x = (new $Int64(u.$high, u.$low)), (x.$high < 0 || (x.$high === 0 && x.$low < 0)));
		if (negative) {
			u = new $Uint64(-u.$high, -u.$low);
		}
		buf = $subslice(new sliceType$2(f.intbuf), 0);
		if (f.fmtFlags.widPresent || f.fmtFlags.precPresent) {
			width = (3 + f.wid >> 0) + f.prec >> 0;
			if (width > buf.$length) {
				buf = $makeSlice(sliceType$2, width);
			}
		}
		prec = 0;
		if (f.fmtFlags.precPresent) {
			prec = f.prec;
			if ((prec === 0) && (u.$high === 0 && u.$low === 0)) {
				oldZero = f.fmtFlags.zero;
				f.fmtFlags.zero = false;
				f.writePadding(f.wid);
				f.fmtFlags.zero = oldZero;
				return;
			}
		} else if (f.fmtFlags.zero && f.fmtFlags.widPresent) {
			prec = f.wid;
			if (negative || f.fmtFlags.plus || f.fmtFlags.space) {
				prec = prec - (1) >> 0;
			}
		}
		i = buf.$length;
		_1 = base;
		if (_1 === (10)) {
			while (true) {
				if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 10)))) { break; }
				i = i - (1) >> 0;
				next = $div64(u, new $Uint64(0, 10), false);
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = (((x$1 = new $Uint64(0 + u.$high, 48 + u.$low), x$2 = $mul64(next, new $Uint64(0, 10)), new $Uint64(x$1.$high - x$2.$high, x$1.$low - x$2.$low)).$low << 24 >>> 24)));
				u = next;
			}
		} else if (_1 === (16)) {
			while (true) {
				if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 16)))) { break; }
				i = i - (1) >> 0;
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = digits.charCodeAt($flatten64(new $Uint64(u.$high & 0, (u.$low & 15) >>> 0))));
				u = $shiftRightUint64(u, (4));
			}
		} else if (_1 === (8)) {
			while (true) {
				if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 8)))) { break; }
				i = i - (1) >> 0;
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = (((x$3 = new $Uint64(u.$high & 0, (u.$low & 7) >>> 0), new $Uint64(0 + x$3.$high, 48 + x$3.$low)).$low << 24 >>> 24)));
				u = $shiftRightUint64(u, (3));
			}
		} else if (_1 === (2)) {
			while (true) {
				if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 2)))) { break; }
				i = i - (1) >> 0;
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = (((x$4 = new $Uint64(u.$high & 0, (u.$low & 1) >>> 0), new $Uint64(0 + x$4.$high, 48 + x$4.$low)).$low << 24 >>> 24)));
				u = $shiftRightUint64(u, (1));
			}
		} else {
			$panic(new $String("fmt: unknown base; can't happen"));
		}
		i = i - (1) >> 0;
		((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = digits.charCodeAt($flatten64(u)));
		while (true) {
			if (!(i > 0 && prec > (buf.$length - i >> 0))) { break; }
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 48);
		}
		if (f.fmtFlags.sharp) {
			_2 = base;
			if (_2 === (8)) {
				if (!((((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i]) === 48))) {
					i = i - (1) >> 0;
					((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 48);
				}
			} else if (_2 === (16)) {
				i = i - (1) >> 0;
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = digits.charCodeAt(16));
				i = i - (1) >> 0;
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 48);
			}
		}
		if (negative) {
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 45);
		} else if (f.fmtFlags.plus) {
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 43);
		} else if (f.fmtFlags.space) {
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 32);
		}
		oldZero$1 = f.fmtFlags.zero;
		f.fmtFlags.zero = false;
		f.pad($subslice(buf, i));
		f.fmtFlags.zero = oldZero$1;
	};
	fmt.prototype.fmt_integer = function(u, base, isSigned, digits) { return this.$val.fmt_integer(u, base, isSigned, digits); };
	fmt.ptr.prototype.truncate = function(s) {
		var _i, _ref, _rune, f, i, n, s;
		f = this;
		if (f.fmtFlags.precPresent) {
			n = f.prec;
			_ref = s;
			_i = 0;
			while (true) {
				if (!(_i < _ref.length)) { break; }
				_rune = $decodeRune(_ref, _i);
				i = _i;
				n = n - (1) >> 0;
				if (n < 0) {
					return $substring(s, 0, i);
				}
				_i += _rune[1];
			}
		}
		return s;
	};
	fmt.prototype.truncate = function(s) { return this.$val.truncate(s); };
	fmt.ptr.prototype.fmt_s = function(s) {
		var f, s;
		f = this;
		s = f.truncate(s);
		f.padString(s);
	};
	fmt.prototype.fmt_s = function(s) { return this.$val.fmt_s(s); };
	fmt.ptr.prototype.fmt_sbx = function(s, b, digits) {
		var b, buf, c, digits, f, i, length, s, width;
		f = this;
		length = b.$length;
		if (b === sliceType$2.nil) {
			length = s.length;
		}
		if (f.fmtFlags.precPresent && f.prec < length) {
			length = f.prec;
		}
		width = $imul(2, length);
		if (width > 0) {
			if (f.fmtFlags.space) {
				if (f.fmtFlags.sharp) {
					width = $imul(width, (2));
				}
				width = width + ((length - 1 >> 0)) >> 0;
			} else if (f.fmtFlags.sharp) {
				width = width + (2) >> 0;
			}
		} else {
			if (f.fmtFlags.widPresent) {
				f.writePadding(f.wid);
			}
			return;
		}
		if (f.fmtFlags.widPresent && f.wid > width && !f.fmtFlags.minus) {
			f.writePadding(f.wid - width >> 0);
		}
		buf = f.buf.$get();
		if (f.fmtFlags.sharp) {
			buf = $append(buf, 48, digits.charCodeAt(16));
		}
		c = 0;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			if (f.fmtFlags.space && i > 0) {
				buf = $append(buf, 32);
				if (f.fmtFlags.sharp) {
					buf = $append(buf, 48, digits.charCodeAt(16));
				}
			}
			if (!(b === sliceType$2.nil)) {
				c = ((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i]);
			} else {
				c = s.charCodeAt(i);
			}
			buf = $append(buf, digits.charCodeAt((c >>> 4 << 24 >>> 24)), digits.charCodeAt(((c & 15) >>> 0)));
			i = i + (1) >> 0;
		}
		f.buf.$set(buf);
		if (f.fmtFlags.widPresent && f.wid > width && f.fmtFlags.minus) {
			f.writePadding(f.wid - width >> 0);
		}
	};
	fmt.prototype.fmt_sbx = function(s, b, digits) { return this.$val.fmt_sbx(s, b, digits); };
	fmt.ptr.prototype.fmt_sx = function(s, digits) {
		var digits, f, s;
		f = this;
		f.fmt_sbx(s, sliceType$2.nil, digits);
	};
	fmt.prototype.fmt_sx = function(s, digits) { return this.$val.fmt_sx(s, digits); };
	fmt.ptr.prototype.fmt_bx = function(b, digits) {
		var b, digits, f;
		f = this;
		f.fmt_sbx("", b, digits);
	};
	fmt.prototype.fmt_bx = function(b, digits) { return this.$val.fmt_bx(b, digits); };
	fmt.ptr.prototype.fmt_q = function(s) {
		var buf, f, s;
		f = this;
		s = f.truncate(s);
		if (f.fmtFlags.sharp && strconv.CanBackquote(s)) {
			f.padString("`" + s + "`");
			return;
		}
		buf = $subslice(new sliceType$2(f.intbuf), 0, 0);
		if (f.fmtFlags.plus) {
			f.pad(strconv.AppendQuoteToASCII(buf, s));
		} else {
			f.pad(strconv.AppendQuote(buf, s));
		}
	};
	fmt.prototype.fmt_q = function(s) { return this.$val.fmt_q(s); };
	fmt.ptr.prototype.fmt_c = function(c) {
		var buf, c, f, r, w;
		f = this;
		r = ((c.$low >> 0));
		if ((c.$high > 0 || (c.$high === 0 && c.$low > 1114111))) {
			r = 65533;
		}
		buf = $subslice(new sliceType$2(f.intbuf), 0, 0);
		w = utf8.EncodeRune($subslice(buf, 0, 4), r);
		f.pad($subslice(buf, 0, w));
	};
	fmt.prototype.fmt_c = function(c) { return this.$val.fmt_c(c); };
	fmt.ptr.prototype.fmt_qc = function(c) {
		var buf, c, f, r;
		f = this;
		r = ((c.$low >> 0));
		if ((c.$high > 0 || (c.$high === 0 && c.$low > 1114111))) {
			r = 65533;
		}
		buf = $subslice(new sliceType$2(f.intbuf), 0, 0);
		if (f.fmtFlags.plus) {
			f.pad(strconv.AppendQuoteRuneToASCII(buf, r));
		} else {
			f.pad(strconv.AppendQuoteRune(buf, r));
		}
	};
	fmt.prototype.fmt_qc = function(c) { return this.$val.fmt_qc(c); };
	fmt.ptr.prototype.fmt_float = function(v, size, verb, prec) {
		var _1, _2, digits, f, hasDecimalPoint, i, num, oldZero, prec, size, tail, tailBuf, v, verb;
		f = this;
		if (f.fmtFlags.precPresent) {
			prec = f.prec;
		}
		num = strconv.AppendFloat($subslice(new sliceType$2(f.intbuf), 0, 1), v, ((verb << 24 >>> 24)), prec, size);
		if (((1 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 1]) === 45) || ((1 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 1]) === 43)) {
			num = $subslice(num, 1);
		} else {
			(0 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 0] = 43);
		}
		if (f.fmtFlags.space && ((0 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 0]) === 43) && !f.fmtFlags.plus) {
			(0 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 0] = 32);
		}
		if (((1 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 1]) === 73) || ((1 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 1]) === 78)) {
			oldZero = f.fmtFlags.zero;
			f.fmtFlags.zero = false;
			if (((1 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 1]) === 78) && !f.fmtFlags.space && !f.fmtFlags.plus) {
				num = $subslice(num, 1);
			}
			f.pad(num);
			f.fmtFlags.zero = oldZero;
			return;
		}
		if (f.fmtFlags.sharp && !((verb === 98))) {
			digits = 0;
			_1 = verb;
			if ((_1 === (118)) || (_1 === (103)) || (_1 === (71))) {
				digits = prec;
				if (digits === -1) {
					digits = 6;
				}
			}
			tailBuf = arrayType$2.zero();
			tail = $subslice(new sliceType$2(tailBuf), 0, 0);
			hasDecimalPoint = false;
			i = 1;
			while (true) {
				if (!(i < num.$length)) { break; }
				_2 = ((i < 0 || i >= num.$length) ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + i]);
				if (_2 === (46)) {
					hasDecimalPoint = true;
				} else if ((_2 === (101)) || (_2 === (69))) {
					tail = $appendSlice(tail, $subslice(num, i));
					num = $subslice(num, 0, i);
				} else {
					digits = digits - (1) >> 0;
				}
				i = i + (1) >> 0;
			}
			if (!hasDecimalPoint) {
				num = $append(num, 46);
			}
			while (true) {
				if (!(digits > 0)) { break; }
				num = $append(num, 48);
				digits = digits - (1) >> 0;
			}
			num = $appendSlice(num, tail);
		}
		if (f.fmtFlags.plus || !(((0 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 0]) === 43))) {
			if (f.fmtFlags.zero && f.fmtFlags.widPresent && f.wid > num.$length) {
				f.buf.WriteByte((0 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 0]));
				f.writePadding(f.wid - num.$length >> 0);
				f.buf.Write($subslice(num, 1));
				return;
			}
			f.pad(num);
			return;
		}
		f.pad($subslice(num, 1));
	};
	fmt.prototype.fmt_float = function(v, size, verb, prec) { return this.$val.fmt_float(v, size, verb, prec); };
	$ptrType(buffer).prototype.Write = function(p) {
		var b, p;
		b = this;
		b.$set($appendSlice(b.$get(), p));
	};
	$ptrType(buffer).prototype.WriteString = function(s) {
		var b, s;
		b = this;
		b.$set($appendSlice(b.$get(), s));
	};
	$ptrType(buffer).prototype.WriteByte = function(c) {
		var b, c;
		b = this;
		b.$set($append(b.$get(), c));
	};
	$ptrType(buffer).prototype.WriteRune = function(r) {
		var b, bp, n, r, w, x;
		bp = this;
		if (r < 128) {
			bp.$set($append(bp.$get(), ((r << 24 >>> 24))));
			return;
		}
		b = bp.$get();
		n = b.$length;
		while (true) {
			if (!((n + 4 >> 0) > b.$capacity)) { break; }
			b = $append(b, 0);
		}
		w = utf8.EncodeRune((x = $subslice(b, n, (n + 4 >> 0)), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length)), r);
		bp.$set($subslice(b, 0, (n + w >> 0)));
	};
	newPrinter = function() {
		var _r, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = ppFree.Get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = $assertType(_r, ptrType$2);
		p.panicking = false;
		p.erroring = false;
		p.fmt.init((p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))));
		$s = -1; return p;
		/* */ } return; } if ($f === undefined) { $f = { $blk: newPrinter }; } $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.ptr.prototype.free = function() {
		var p;
		p = this;
		p.buf = $subslice(p.buf, 0, 0);
		p.arg = $ifaceNil;
		p.value = new reflect.Value.ptr(ptrType.nil, 0, 0);
		ppFree.Put(p);
	};
	pp.prototype.free = function() { return this.$val.free(); };
	pp.ptr.prototype.Width = function() {
		var _tmp, _tmp$1, ok, p, wid;
		wid = 0;
		ok = false;
		p = this;
		_tmp = p.fmt.wid;
		_tmp$1 = p.fmt.fmtFlags.widPresent;
		wid = _tmp;
		ok = _tmp$1;
		return [wid, ok];
	};
	pp.prototype.Width = function() { return this.$val.Width(); };
	pp.ptr.prototype.Precision = function() {
		var _tmp, _tmp$1, ok, p, prec;
		prec = 0;
		ok = false;
		p = this;
		_tmp = p.fmt.prec;
		_tmp$1 = p.fmt.fmtFlags.precPresent;
		prec = _tmp;
		ok = _tmp$1;
		return [prec, ok];
	};
	pp.prototype.Precision = function() { return this.$val.Precision(); };
	pp.ptr.prototype.Flag = function(b) {
		var _1, b, p;
		p = this;
		_1 = b;
		if (_1 === (45)) {
			return p.fmt.fmtFlags.minus;
		} else if (_1 === (43)) {
			return p.fmt.fmtFlags.plus || p.fmt.fmtFlags.plusV;
		} else if (_1 === (35)) {
			return p.fmt.fmtFlags.sharp || p.fmt.fmtFlags.sharpV;
		} else if (_1 === (32)) {
			return p.fmt.fmtFlags.space;
		} else if (_1 === (48)) {
			return p.fmt.fmtFlags.zero;
		}
		return false;
	};
	pp.prototype.Flag = function(b) { return this.$val.Flag(b); };
	pp.ptr.prototype.Write = function(b) {
		var _tmp, _tmp$1, b, err, p, ret;
		ret = 0;
		err = $ifaceNil;
		p = this;
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).Write(b);
		_tmp = b.$length;
		_tmp$1 = $ifaceNil;
		ret = _tmp;
		err = _tmp$1;
		return [ret, err];
	};
	pp.prototype.Write = function(b) { return this.$val.Write(b); };
	Fprintf = function(w, format, a) {
		var _r, _r$1, _tuple, a, err, format, n, p, w, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; a = $f.a; err = $f.err; format = $f.format; n = $f.n; p = $f.p; w = $f.w; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		_r = newPrinter(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = _r;
		$r = p.doPrintf(format, a); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$1 = w.Write((x = p.buf, $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length))); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		n = _tuple[0];
		err = _tuple[1];
		p.free();
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Fprintf }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.a = a; $f.err = err; $f.format = format; $f.n = n; $f.p = p; $f.w = w; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Fprintf = Fprintf;
	Sprintf = function(format, a) {
		var _r, a, format, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; format = $f.format; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = newPrinter(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = _r;
		$r = p.doPrintf(format, a); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		s = ($bytesToString(p.buf));
		p.free();
		$s = -1; return s;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Sprintf }; } $f._r = _r; $f.a = a; $f.format = format; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Sprintf = Sprintf;
	Errorf = function(format, a) {
		var _r, _r$1, a, format, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; a = $f.a; format = $f.format; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = Sprintf(format, a); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = errors.New(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Errorf }; } $f._r = _r; $f._r$1 = _r$1; $f.a = a; $f.format = format; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Errorf = Errorf;
	Fprint = function(w, a) {
		var _r, _r$1, _tuple, a, err, n, p, w, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; a = $f.a; err = $f.err; n = $f.n; p = $f.p; w = $f.w; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		_r = newPrinter(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = _r;
		$r = p.doPrint(a); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$1 = w.Write((x = p.buf, $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length))); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		n = _tuple[0];
		err = _tuple[1];
		p.free();
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Fprint }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.a = a; $f.err = err; $f.n = n; $f.p = p; $f.w = w; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Fprint = Fprint;
	Fprintln = function(w, a) {
		var _r, _r$1, _tuple, a, err, n, p, w, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; a = $f.a; err = $f.err; n = $f.n; p = $f.p; w = $f.w; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		_r = newPrinter(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = _r;
		$r = p.doPrintln(a); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$1 = w.Write((x = p.buf, $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length))); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		n = _tuple[0];
		err = _tuple[1];
		p.free();
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Fprintln }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.a = a; $f.err = err; $f.n = n; $f.p = p; $f.w = w; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Fprintln = Fprintln;
	getField = function(v, i) {
		var _r, _r$1, i, v, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; i = $f.i; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = $clone(v, reflect.Value).Field(i); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		val = _r;
		/* */ if (($clone(val, reflect.Value).Kind() === 20) && !$clone(val, reflect.Value).IsNil()) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (($clone(val, reflect.Value).Kind() === 20) && !$clone(val, reflect.Value).IsNil()) { */ case 2:
			_r$1 = $clone(val, reflect.Value).Elem(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			val = _r$1;
		/* } */ case 3:
		$s = -1; return val;
		/* */ } return; } if ($f === undefined) { $f = { $blk: getField }; } $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	tooLarge = function(x) {
		var x;
		return x > 1000000 || x < -1000000;
	};
	parsenum = function(s, start, end) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, end, isnum, newi, num, s, start;
		num = 0;
		isnum = false;
		newi = 0;
		if (start >= end) {
			_tmp = 0;
			_tmp$1 = false;
			_tmp$2 = end;
			num = _tmp;
			isnum = _tmp$1;
			newi = _tmp$2;
			return [num, isnum, newi];
		}
		newi = start;
		while (true) {
			if (!(newi < end && 48 <= s.charCodeAt(newi) && s.charCodeAt(newi) <= 57)) { break; }
			if (tooLarge(num)) {
				_tmp$3 = 0;
				_tmp$4 = false;
				_tmp$5 = end;
				num = _tmp$3;
				isnum = _tmp$4;
				newi = _tmp$5;
				return [num, isnum, newi];
			}
			num = ($imul(num, 10)) + (((s.charCodeAt(newi) - 48 << 24 >>> 24) >> 0)) >> 0;
			isnum = true;
			newi = newi + (1) >> 0;
		}
		return [num, isnum, newi];
	};
	pp.ptr.prototype.unknownType = function(v) {
		var _r, p, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!$clone(v, reflect.Value).IsValid()) {
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
			$s = -1; return;
		}
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(63);
		_r = $clone(v, reflect.Value).Type().String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(63);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.unknownType }; } $f._r = _r; $f.p = p; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.unknownType = function(v) { return this.$val.unknownType(v); };
	pp.ptr.prototype.badVerb = function(verb) {
		var _r, _r$1, p, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; p = $f.p; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		p.erroring = true;
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!");
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteRune(verb);
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(40);
			/* */ if (!($interfaceIsEqual(p.arg, $ifaceNil))) { $s = 2; continue; }
			/* */ if ($clone(p.value, reflect.Value).IsValid()) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!($interfaceIsEqual(p.arg, $ifaceNil))) { */ case 2:
				_r = reflect.TypeOf(p.arg).String(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(61);
				$r = p.printArg(p.arg, 118); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 5; continue;
			/* } else if ($clone(p.value, reflect.Value).IsValid()) { */ case 3:
				_r$1 = $clone(p.value, reflect.Value).Type().String(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$1); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(61);
				$r = p.printValue($clone(p.value, reflect.Value), 118, 0); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 5; continue;
			/* } else { */ case 4:
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
			/* } */ case 5:
		case 1:
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(41);
		p.erroring = false;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.badVerb }; } $f._r = _r; $f._r$1 = _r$1; $f.p = p; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.badVerb = function(verb) { return this.$val.badVerb(verb); };
	pp.ptr.prototype.fmtBool = function(v, verb) {
		var _1, p, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if ((_1 === (116)) || (_1 === (118))) { $s = 2; continue; }
			/* */ $s = 3; continue;
			/* if ((_1 === (116)) || (_1 === (118))) { */ case 2:
				p.fmt.fmt_boolean(v);
				$s = 4; continue;
			/* } else { */ case 3:
				$r = p.badVerb(verb); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 4:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtBool }; } $f._1 = _1; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtBool = function(v, verb) { return this.$val.fmtBool(v, verb); };
	pp.ptr.prototype.fmt0x64 = function(v, leading0x) {
		var leading0x, p, sharp, v;
		p = this;
		sharp = p.fmt.fmtFlags.sharp;
		p.fmt.fmtFlags.sharp = leading0x;
		p.fmt.fmt_integer(v, 16, false, "0123456789abcdefx");
		p.fmt.fmtFlags.sharp = sharp;
	};
	pp.prototype.fmt0x64 = function(v, leading0x) { return this.$val.fmt0x64(v, leading0x); };
	pp.ptr.prototype.fmtInteger = function(v, isSigned, verb) {
		var _1, isSigned, p, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; isSigned = $f.isSigned; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if (_1 === (118)) { $s = 2; continue; }
			/* */ if (_1 === (100)) { $s = 3; continue; }
			/* */ if (_1 === (98)) { $s = 4; continue; }
			/* */ if (_1 === (111)) { $s = 5; continue; }
			/* */ if (_1 === (120)) { $s = 6; continue; }
			/* */ if (_1 === (88)) { $s = 7; continue; }
			/* */ if (_1 === (99)) { $s = 8; continue; }
			/* */ if (_1 === (113)) { $s = 9; continue; }
			/* */ if (_1 === (85)) { $s = 10; continue; }
			/* */ $s = 11; continue;
			/* if (_1 === (118)) { */ case 2:
				if (p.fmt.fmtFlags.sharpV && !isSigned) {
					p.fmt0x64(v, true);
				} else {
					p.fmt.fmt_integer(v, 10, isSigned, "0123456789abcdefx");
				}
				$s = 12; continue;
			/* } else if (_1 === (100)) { */ case 3:
				p.fmt.fmt_integer(v, 10, isSigned, "0123456789abcdefx");
				$s = 12; continue;
			/* } else if (_1 === (98)) { */ case 4:
				p.fmt.fmt_integer(v, 2, isSigned, "0123456789abcdefx");
				$s = 12; continue;
			/* } else if (_1 === (111)) { */ case 5:
				p.fmt.fmt_integer(v, 8, isSigned, "0123456789abcdefx");
				$s = 12; continue;
			/* } else if (_1 === (120)) { */ case 6:
				p.fmt.fmt_integer(v, 16, isSigned, "0123456789abcdefx");
				$s = 12; continue;
			/* } else if (_1 === (88)) { */ case 7:
				p.fmt.fmt_integer(v, 16, isSigned, "0123456789ABCDEFX");
				$s = 12; continue;
			/* } else if (_1 === (99)) { */ case 8:
				p.fmt.fmt_c(v);
				$s = 12; continue;
			/* } else if (_1 === (113)) { */ case 9:
				/* */ if ((v.$high < 0 || (v.$high === 0 && v.$low <= 1114111))) { $s = 13; continue; }
				/* */ $s = 14; continue;
				/* if ((v.$high < 0 || (v.$high === 0 && v.$low <= 1114111))) { */ case 13:
					p.fmt.fmt_qc(v);
					$s = 15; continue;
				/* } else { */ case 14:
					$r = p.badVerb(verb); /* */ $s = 16; case 16: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 15:
				$s = 12; continue;
			/* } else if (_1 === (85)) { */ case 10:
				p.fmt.fmt_unicode(v);
				$s = 12; continue;
			/* } else { */ case 11:
				$r = p.badVerb(verb); /* */ $s = 17; case 17: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 12:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtInteger }; } $f._1 = _1; $f.isSigned = isSigned; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtInteger = function(v, isSigned, verb) { return this.$val.fmtInteger(v, isSigned, verb); };
	pp.ptr.prototype.fmtFloat = function(v, size, verb) {
		var _1, p, size, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; p = $f.p; size = $f.size; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if (_1 === (118)) { $s = 2; continue; }
			/* */ if ((_1 === (98)) || (_1 === (103)) || (_1 === (71))) { $s = 3; continue; }
			/* */ if ((_1 === (102)) || (_1 === (101)) || (_1 === (69))) { $s = 4; continue; }
			/* */ if (_1 === (70)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (118)) { */ case 2:
				p.fmt.fmt_float(v, size, 103, -1);
				$s = 7; continue;
			/* } else if ((_1 === (98)) || (_1 === (103)) || (_1 === (71))) { */ case 3:
				p.fmt.fmt_float(v, size, verb, -1);
				$s = 7; continue;
			/* } else if ((_1 === (102)) || (_1 === (101)) || (_1 === (69))) { */ case 4:
				p.fmt.fmt_float(v, size, verb, 6);
				$s = 7; continue;
			/* } else if (_1 === (70)) { */ case 5:
				p.fmt.fmt_float(v, size, 102, 6);
				$s = 7; continue;
			/* } else { */ case 6:
				$r = p.badVerb(verb); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 7:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtFloat }; } $f._1 = _1; $f.p = p; $f.size = size; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtFloat = function(v, size, verb) { return this.$val.fmtFloat(v, size, verb); };
	pp.ptr.prototype.fmtComplex = function(v, size, verb) {
		var _1, _q, _q$1, oldPlus, p, size, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _q = $f._q; _q$1 = $f._q$1; oldPlus = $f.oldPlus; p = $f.p; size = $f.size; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if ((_1 === (118)) || (_1 === (98)) || (_1 === (103)) || (_1 === (71)) || (_1 === (102)) || (_1 === (70)) || (_1 === (101)) || (_1 === (69))) { $s = 2; continue; }
			/* */ $s = 3; continue;
			/* if ((_1 === (118)) || (_1 === (98)) || (_1 === (103)) || (_1 === (71)) || (_1 === (102)) || (_1 === (70)) || (_1 === (101)) || (_1 === (69))) { */ case 2:
				oldPlus = p.fmt.fmtFlags.plus;
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(40);
				$r = p.fmtFloat(v.$real, (_q = size / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")), verb); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				p.fmt.fmtFlags.plus = true;
				$r = p.fmtFloat(v.$imag, (_q$1 = size / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")), verb); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("i)");
				p.fmt.fmtFlags.plus = oldPlus;
				$s = 4; continue;
			/* } else { */ case 3:
				$r = p.badVerb(verb); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 4:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtComplex }; } $f._1 = _1; $f._q = _q; $f._q$1 = _q$1; $f.oldPlus = oldPlus; $f.p = p; $f.size = size; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtComplex = function(v, size, verb) { return this.$val.fmtComplex(v, size, verb); };
	pp.ptr.prototype.fmtString = function(v, verb) {
		var _1, p, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if (_1 === (118)) { $s = 2; continue; }
			/* */ if (_1 === (115)) { $s = 3; continue; }
			/* */ if (_1 === (120)) { $s = 4; continue; }
			/* */ if (_1 === (88)) { $s = 5; continue; }
			/* */ if (_1 === (113)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (118)) { */ case 2:
				if (p.fmt.fmtFlags.sharpV) {
					p.fmt.fmt_q(v);
				} else {
					p.fmt.fmt_s(v);
				}
				$s = 8; continue;
			/* } else if (_1 === (115)) { */ case 3:
				p.fmt.fmt_s(v);
				$s = 8; continue;
			/* } else if (_1 === (120)) { */ case 4:
				p.fmt.fmt_sx(v, "0123456789abcdefx");
				$s = 8; continue;
			/* } else if (_1 === (88)) { */ case 5:
				p.fmt.fmt_sx(v, "0123456789ABCDEFX");
				$s = 8; continue;
			/* } else if (_1 === (113)) { */ case 6:
				p.fmt.fmt_q(v);
				$s = 8; continue;
			/* } else { */ case 7:
				$r = p.badVerb(verb); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 8:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtString }; } $f._1 = _1; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtString = function(v, verb) { return this.$val.fmtString(v, verb); };
	pp.ptr.prototype.fmtBytes = function(v, verb, typeString) {
		var _1, _i, _i$1, _r, _ref, _ref$1, c, c$1, i, i$1, p, typeString, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; c = $f.c; c$1 = $f.c$1; i = $f.i; i$1 = $f.i$1; p = $f.p; typeString = $f.typeString; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if ((_1 === (118)) || (_1 === (100))) { $s = 2; continue; }
			/* */ if (_1 === (115)) { $s = 3; continue; }
			/* */ if (_1 === (120)) { $s = 4; continue; }
			/* */ if (_1 === (88)) { $s = 5; continue; }
			/* */ if (_1 === (113)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if ((_1 === (118)) || (_1 === (100))) { */ case 2:
				if (p.fmt.fmtFlags.sharpV) {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(typeString);
					if (v === sliceType$2.nil) {
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(nil)");
						$s = -1; return;
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);
					_ref = v;
					_i = 0;
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						i = _i;
						c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
						if (i > 0) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(", ");
						}
						p.fmt0x64((new $Uint64(0, c)), true);
						_i++;
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);
				} else {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(91);
					_ref$1 = v;
					_i$1 = 0;
					while (true) {
						if (!(_i$1 < _ref$1.$length)) { break; }
						i$1 = _i$1;
						c$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
						if (i$1 > 0) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
						}
						p.fmt.fmt_integer((new $Uint64(0, c$1)), 10, false, "0123456789abcdefx");
						_i$1++;
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(93);
				}
				$s = 8; continue;
			/* } else if (_1 === (115)) { */ case 3:
				p.fmt.fmt_s(($bytesToString(v)));
				$s = 8; continue;
			/* } else if (_1 === (120)) { */ case 4:
				p.fmt.fmt_bx(v, "0123456789abcdefx");
				$s = 8; continue;
			/* } else if (_1 === (88)) { */ case 5:
				p.fmt.fmt_bx(v, "0123456789ABCDEFX");
				$s = 8; continue;
			/* } else if (_1 === (113)) { */ case 6:
				p.fmt.fmt_q(($bytesToString(v)));
				$s = 8; continue;
			/* } else { */ case 7:
				_r = reflect.ValueOf(v); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$r = p.printValue($clone(_r, reflect.Value), verb, 0); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 8:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtBytes }; } $f._1 = _1; $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.i$1 = i$1; $f.p = p; $f.typeString = typeString; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtBytes = function(v, verb, typeString) { return this.$val.fmtBytes(v, verb, typeString); };
	pp.ptr.prototype.fmtPointer = function(value, verb) {
		var _1, _2, _r, p, u, value, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _r = $f._r; p = $f.p; u = $f.u; value = $f.value; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		u = 0;
			_1 = $clone(value, reflect.Value).Kind();
			/* */ if ((_1 === (18)) || (_1 === (19)) || (_1 === (21)) || (_1 === (22)) || (_1 === (23)) || (_1 === (26))) { $s = 2; continue; }
			/* */ $s = 3; continue;
			/* if ((_1 === (18)) || (_1 === (19)) || (_1 === (21)) || (_1 === (22)) || (_1 === (23)) || (_1 === (26))) { */ case 2:
				u = $clone(value, reflect.Value).Pointer();
				$s = 4; continue;
			/* } else { */ case 3:
				$r = p.badVerb(verb); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return;
			/* } */ case 4:
		case 1:
			_2 = verb;
			/* */ if (_2 === (118)) { $s = 7; continue; }
			/* */ if (_2 === (112)) { $s = 8; continue; }
			/* */ if ((_2 === (98)) || (_2 === (111)) || (_2 === (100)) || (_2 === (120)) || (_2 === (88))) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_2 === (118)) { */ case 7:
				/* */ if (p.fmt.fmtFlags.sharpV) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if (p.fmt.fmtFlags.sharpV) { */ case 12:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(40);
					_r = $clone(value, reflect.Value).Type().String(); /* */ $s = 15; case 15: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r); /* */ $s = 16; case 16: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(")(");
					if (u === 0) {
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("nil");
					} else {
						p.fmt0x64((new $Uint64(0, u.constructor === Number ? u : 1)), true);
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(41);
					$s = 14; continue;
				/* } else { */ case 13:
					if (u === 0) {
						p.fmt.padString("<nil>");
					} else {
						p.fmt0x64((new $Uint64(0, u.constructor === Number ? u : 1)), !p.fmt.fmtFlags.sharp);
					}
				/* } */ case 14:
				$s = 11; continue;
			/* } else if (_2 === (112)) { */ case 8:
				p.fmt0x64((new $Uint64(0, u.constructor === Number ? u : 1)), !p.fmt.fmtFlags.sharp);
				$s = 11; continue;
			/* } else if ((_2 === (98)) || (_2 === (111)) || (_2 === (100)) || (_2 === (120)) || (_2 === (88))) { */ case 9:
				$r = p.fmtInteger((new $Uint64(0, u.constructor === Number ? u : 1)), false, verb); /* */ $s = 17; case 17: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 11; continue;
			/* } else { */ case 10:
				$r = p.badVerb(verb); /* */ $s = 18; case 18: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 11:
		case 6:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtPointer }; } $f._1 = _1; $f._2 = _2; $f._r = _r; $f.p = p; $f.u = u; $f.value = value; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtPointer = function(value, verb) { return this.$val.fmtPointer(value, verb); };
	pp.ptr.prototype.catchPanic = function(arg, verb) {
		var _r, arg, err, oldFlags, p, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; arg = $f.arg; err = $f.err; oldFlags = $f.oldFlags; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		err = $recover();
		/* */ if (!($interfaceIsEqual(err, $ifaceNil))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
			_r = reflect.ValueOf(arg); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			v = _r;
			if (($clone(v, reflect.Value).Kind() === 22) && $clone(v, reflect.Value).IsNil()) {
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
				$s = -1; return;
			}
			if (p.panicking) {
				$panic(err);
			}
			oldFlags = $clone(p.fmt.fmtFlags, fmtFlags);
			p.fmt.clearflags();
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!");
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteRune(verb);
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(PANIC=");
			p.panicking = true;
			$r = p.printArg(err, 118); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			p.panicking = false;
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(41);
			fmtFlags.copy(p.fmt.fmtFlags, oldFlags);
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.catchPanic }; } $f._r = _r; $f.arg = arg; $f.err = err; $f.oldFlags = oldFlags; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.catchPanic = function(arg, verb) { return this.$val.catchPanic(arg, verb); };
	pp.ptr.prototype.handleMethods = function(verb) {
		var _1, _r, _r$1, _r$2, _ref, _tuple, _tuple$1, formatter, handled, ok, ok$1, p, stringer, v, v$1, verb, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; formatter = $f.formatter; handled = $f.handled; ok = $f.ok; ok$1 = $f.ok$1; p = $f.p; stringer = $f.stringer; v = $f.v; v$1 = $f.v$1; verb = $f.verb; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		handled = false;
		p = this;
		if (p.erroring) {
			$s = -1; return handled;
		}
		_tuple = $assertType(p.arg, Formatter, true);
		formatter = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (ok) { */ case 1:
			handled = true;
			$deferred.push([$methodVal(p, "catchPanic"), [p.arg, verb]]);
			$r = formatter.Format(p, verb); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return handled;
		/* } */ case 2:
		/* */ if (p.fmt.fmtFlags.sharpV) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (p.fmt.fmtFlags.sharpV) { */ case 4:
			_tuple$1 = $assertType(p.arg, GoStringer, true);
			stringer = _tuple$1[0];
			ok$1 = _tuple$1[1];
			/* */ if (ok$1) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (ok$1) { */ case 7:
				handled = true;
				$deferred.push([$methodVal(p, "catchPanic"), [p.arg, verb]]);
				_r = stringer.GoString(); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$r = p.fmt.fmt_s(_r); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return handled;
			/* } */ case 8:
			$s = 6; continue;
		/* } else { */ case 5:
				_1 = verb;
				/* */ if ((_1 === (118)) || (_1 === (115)) || (_1 === (120)) || (_1 === (88)) || (_1 === (113))) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if ((_1 === (118)) || (_1 === (115)) || (_1 === (120)) || (_1 === (88)) || (_1 === (113))) { */ case 12:
					_ref = p.arg;
					/* */ if ($assertType(_ref, $error, true)[1]) { $s = 14; continue; }
					/* */ if ($assertType(_ref, Stringer, true)[1]) { $s = 15; continue; }
					/* */ $s = 16; continue;
					/* if ($assertType(_ref, $error, true)[1]) { */ case 14:
						v = _ref;
						handled = true;
						$deferred.push([$methodVal(p, "catchPanic"), [p.arg, verb]]);
						_r$1 = v.Error(); /* */ $s = 17; case 17: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$r = p.fmtString(_r$1, verb); /* */ $s = 18; case 18: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return handled;
					/* } else if ($assertType(_ref, Stringer, true)[1]) { */ case 15:
						v$1 = _ref;
						handled = true;
						$deferred.push([$methodVal(p, "catchPanic"), [p.arg, verb]]);
						_r$2 = v$1.String(); /* */ $s = 19; case 19: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$r = p.fmtString(_r$2, verb); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return handled;
					/* } */ case 16:
				/* } */ case 13:
			case 11:
		/* } */ case 6:
		handled = false;
		$s = -1; return handled;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  handled; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: pp.ptr.prototype.handleMethods }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.formatter = formatter; $f.handled = handled; $f.ok = ok; $f.ok$1 = ok$1; $f.p = p; $f.stringer = stringer; $f.v = v; $f.v$1 = v$1; $f.verb = verb; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	pp.prototype.handleMethods = function(verb) { return this.$val.handleMethods(verb); };
	pp.ptr.prototype.printArg = function(arg, verb) {
		var _1, _2, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _ref, arg, f, f$1, f$10, f$11, f$12, f$13, f$14, f$15, f$16, f$17, f$18, f$19, f$2, f$3, f$4, f$5, f$6, f$7, f$8, f$9, p, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _ref = $f._ref; arg = $f.arg; f = $f.f; f$1 = $f.f$1; f$10 = $f.f$10; f$11 = $f.f$11; f$12 = $f.f$12; f$13 = $f.f$13; f$14 = $f.f$14; f$15 = $f.f$15; f$16 = $f.f$16; f$17 = $f.f$17; f$18 = $f.f$18; f$19 = $f.f$19; f$2 = $f.f$2; f$3 = $f.f$3; f$4 = $f.f$4; f$5 = $f.f$5; f$6 = $f.f$6; f$7 = $f.f$7; f$8 = $f.f$8; f$9 = $f.f$9; p = $f.p; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		p.arg = arg;
		p.value = new reflect.Value.ptr(ptrType.nil, 0, 0);
		/* */ if ($interfaceIsEqual(arg, $ifaceNil)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($interfaceIsEqual(arg, $ifaceNil)) { */ case 1:
				_1 = verb;
				/* */ if ((_1 === (84)) || (_1 === (118))) { $s = 4; continue; }
				/* */ $s = 5; continue;
				/* if ((_1 === (84)) || (_1 === (118))) { */ case 4:
					p.fmt.padString("<nil>");
					$s = 6; continue;
				/* } else { */ case 5:
					$r = p.badVerb(verb); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 6:
			case 3:
			$s = -1; return;
		/* } */ case 2:
			_2 = verb;
			/* */ if (_2 === (84)) { $s = 9; continue; }
			/* */ if (_2 === (112)) { $s = 10; continue; }
			/* */ $s = 11; continue;
			/* if (_2 === (84)) { */ case 9:
				_r = reflect.TypeOf(arg).String(); /* */ $s = 12; case 12: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$r = p.fmt.fmt_s(_r); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return;
			/* } else if (_2 === (112)) { */ case 10:
				_r$1 = reflect.ValueOf(arg); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$r = p.fmtPointer($clone(_r$1, reflect.Value), 112); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return;
			/* } */ case 11:
		case 8:
		_ref = arg;
		/* */ if ($assertType(_ref, $Bool, true)[1]) { $s = 16; continue; }
		/* */ if ($assertType(_ref, $Float32, true)[1]) { $s = 17; continue; }
		/* */ if ($assertType(_ref, $Float64, true)[1]) { $s = 18; continue; }
		/* */ if ($assertType(_ref, $Complex64, true)[1]) { $s = 19; continue; }
		/* */ if ($assertType(_ref, $Complex128, true)[1]) { $s = 20; continue; }
		/* */ if ($assertType(_ref, $Int, true)[1]) { $s = 21; continue; }
		/* */ if ($assertType(_ref, $Int8, true)[1]) { $s = 22; continue; }
		/* */ if ($assertType(_ref, $Int16, true)[1]) { $s = 23; continue; }
		/* */ if ($assertType(_ref, $Int32, true)[1]) { $s = 24; continue; }
		/* */ if ($assertType(_ref, $Int64, true)[1]) { $s = 25; continue; }
		/* */ if ($assertType(_ref, $Uint, true)[1]) { $s = 26; continue; }
		/* */ if ($assertType(_ref, $Uint8, true)[1]) { $s = 27; continue; }
		/* */ if ($assertType(_ref, $Uint16, true)[1]) { $s = 28; continue; }
		/* */ if ($assertType(_ref, $Uint32, true)[1]) { $s = 29; continue; }
		/* */ if ($assertType(_ref, $Uint64, true)[1]) { $s = 30; continue; }
		/* */ if ($assertType(_ref, $Uintptr, true)[1]) { $s = 31; continue; }
		/* */ if ($assertType(_ref, $String, true)[1]) { $s = 32; continue; }
		/* */ if ($assertType(_ref, sliceType$2, true)[1]) { $s = 33; continue; }
		/* */ if ($assertType(_ref, reflect.Value, true)[1]) { $s = 34; continue; }
		/* */ $s = 35; continue;
		/* if ($assertType(_ref, $Bool, true)[1]) { */ case 16:
			f = _ref.$val;
			$r = p.fmtBool(f, verb); /* */ $s = 37; case 37: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Float32, true)[1]) { */ case 17:
			f$1 = _ref.$val;
			$r = p.fmtFloat((f$1), 32, verb); /* */ $s = 38; case 38: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Float64, true)[1]) { */ case 18:
			f$2 = _ref.$val;
			$r = p.fmtFloat(f$2, 64, verb); /* */ $s = 39; case 39: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Complex64, true)[1]) { */ case 19:
			f$3 = _ref.$val;
			$r = p.fmtComplex((new $Complex128(f$3.$real, f$3.$imag)), 64, verb); /* */ $s = 40; case 40: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Complex128, true)[1]) { */ case 20:
			f$4 = _ref.$val;
			$r = p.fmtComplex(f$4, 128, verb); /* */ $s = 41; case 41: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Int, true)[1]) { */ case 21:
			f$5 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$5)), true, verb); /* */ $s = 42; case 42: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Int8, true)[1]) { */ case 22:
			f$6 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$6)), true, verb); /* */ $s = 43; case 43: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Int16, true)[1]) { */ case 23:
			f$7 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$7)), true, verb); /* */ $s = 44; case 44: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Int32, true)[1]) { */ case 24:
			f$8 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$8)), true, verb); /* */ $s = 45; case 45: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Int64, true)[1]) { */ case 25:
			f$9 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(f$9.$high, f$9.$low)), true, verb); /* */ $s = 46; case 46: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uint, true)[1]) { */ case 26:
			f$10 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$10)), false, verb); /* */ $s = 47; case 47: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uint8, true)[1]) { */ case 27:
			f$11 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$11)), false, verb); /* */ $s = 48; case 48: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uint16, true)[1]) { */ case 28:
			f$12 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$12)), false, verb); /* */ $s = 49; case 49: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uint32, true)[1]) { */ case 29:
			f$13 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$13)), false, verb); /* */ $s = 50; case 50: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uint64, true)[1]) { */ case 30:
			f$14 = _ref.$val;
			$r = p.fmtInteger(f$14, false, verb); /* */ $s = 51; case 51: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uintptr, true)[1]) { */ case 31:
			f$15 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$15.constructor === Number ? f$15 : 1)), false, verb); /* */ $s = 52; case 52: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $String, true)[1]) { */ case 32:
			f$16 = _ref.$val;
			$r = p.fmtString(f$16, verb); /* */ $s = 53; case 53: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, sliceType$2, true)[1]) { */ case 33:
			f$17 = _ref.$val;
			$r = p.fmtBytes(f$17, verb, "[]byte"); /* */ $s = 54; case 54: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, reflect.Value, true)[1]) { */ case 34:
			f$18 = _ref.$val;
			/* */ if ($clone(f$18, reflect.Value).IsValid() && $clone(f$18, reflect.Value).CanInterface()) { $s = 55; continue; }
			/* */ $s = 56; continue;
			/* if ($clone(f$18, reflect.Value).IsValid() && $clone(f$18, reflect.Value).CanInterface()) { */ case 55:
				_r$2 = $clone(f$18, reflect.Value).Interface(); /* */ $s = 57; case 57: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				p.arg = _r$2;
				_r$3 = p.handleMethods(verb); /* */ $s = 60; case 60: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				/* */ if (_r$3) { $s = 58; continue; }
				/* */ $s = 59; continue;
				/* if (_r$3) { */ case 58:
					$s = -1; return;
				/* } */ case 59:
			/* } */ case 56:
			$r = p.printValue($clone(f$18, reflect.Value), verb, 0); /* */ $s = 61; case 61: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else { */ case 35:
			f$19 = _ref;
			_r$4 = p.handleMethods(verb); /* */ $s = 64; case 64: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			/* */ if (!_r$4) { $s = 62; continue; }
			/* */ $s = 63; continue;
			/* if (!_r$4) { */ case 62:
				_r$5 = reflect.ValueOf(f$19); /* */ $s = 65; case 65: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				$r = p.printValue($clone(_r$5, reflect.Value), verb, 0); /* */ $s = 66; case 66: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 63:
		/* } */ case 36:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.printArg }; } $f._1 = _1; $f._2 = _2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._ref = _ref; $f.arg = arg; $f.f = f; $f.f$1 = f$1; $f.f$10 = f$10; $f.f$11 = f$11; $f.f$12 = f$12; $f.f$13 = f$13; $f.f$14 = f$14; $f.f$15 = f$15; $f.f$16 = f$16; $f.f$17 = f$17; $f.f$18 = f$18; $f.f$19 = f$19; $f.f$2 = f$2; $f.f$3 = f$3; $f.f$4 = f$4; $f.f$5 = f$5; $f.f$6 = f$6; $f.f$7 = f$7; $f.f$8 = f$8; $f.f$9 = f$9; $f.p = p; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.printArg = function(arg, verb) { return this.$val.printArg(arg, verb); };
	pp.ptr.prototype.printValue = function(value, verb, depth) {
		var _1, _2, _3, _4, _arg, _arg$1, _arg$2, _i, _i$1, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$2, _r$20, _r$21, _r$22, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, a, bytes, depth, f, i, i$1, i$2, i$3, i$4, key, keys, name, p, t, value, value$1, verb, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$2 = $f._r$2; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; a = $f.a; bytes = $f.bytes; depth = $f.depth; f = $f.f; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; i$4 = $f.i$4; key = $f.key; keys = $f.keys; name = $f.name; p = $f.p; t = $f.t; value = $f.value; value$1 = $f.value$1; verb = $f.verb; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (depth > 0 && $clone(value, reflect.Value).IsValid() && $clone(value, reflect.Value).CanInterface()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (depth > 0 && $clone(value, reflect.Value).IsValid() && $clone(value, reflect.Value).CanInterface()) { */ case 1:
			_r = $clone(value, reflect.Value).Interface(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			p.arg = _r;
			_r$1 = p.handleMethods(verb); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (_r$1) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_r$1) { */ case 4:
				$s = -1; return;
			/* } */ case 5:
		/* } */ case 2:
		p.arg = $ifaceNil;
		p.value = value;
			f = value;
			_1 = $clone(value, reflect.Value).Kind();
			/* */ if (_1 === (0)) { $s = 8; continue; }
			/* */ if (_1 === (1)) { $s = 9; continue; }
			/* */ if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { $s = 10; continue; }
			/* */ if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { $s = 11; continue; }
			/* */ if (_1 === (13)) { $s = 12; continue; }
			/* */ if (_1 === (14)) { $s = 13; continue; }
			/* */ if (_1 === (15)) { $s = 14; continue; }
			/* */ if (_1 === (16)) { $s = 15; continue; }
			/* */ if (_1 === (24)) { $s = 16; continue; }
			/* */ if (_1 === (21)) { $s = 17; continue; }
			/* */ if (_1 === (25)) { $s = 18; continue; }
			/* */ if (_1 === (20)) { $s = 19; continue; }
			/* */ if ((_1 === (17)) || (_1 === (23))) { $s = 20; continue; }
			/* */ if (_1 === (22)) { $s = 21; continue; }
			/* */ if ((_1 === (18)) || (_1 === (19)) || (_1 === (26))) { $s = 22; continue; }
			/* */ $s = 23; continue;
			/* if (_1 === (0)) { */ case 8:
				/* */ if (depth === 0) { $s = 25; continue; }
				/* */ $s = 26; continue;
				/* if (depth === 0) { */ case 25:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<invalid reflect.Value>");
					$s = 27; continue;
				/* } else { */ case 26:
						_2 = verb;
						/* */ if (_2 === (118)) { $s = 29; continue; }
						/* */ $s = 30; continue;
						/* if (_2 === (118)) { */ case 29:
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
							$s = 31; continue;
						/* } else { */ case 30:
							$r = p.badVerb(verb); /* */ $s = 32; case 32: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						/* } */ case 31:
					case 28:
				/* } */ case 27:
				$s = 24; continue;
			/* } else if (_1 === (1)) { */ case 9:
				$r = p.fmtBool($clone(f, reflect.Value).Bool(), verb); /* */ $s = 33; case 33: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 10:
				$r = p.fmtInteger(((x = $clone(f, reflect.Value).Int(), new $Uint64(x.$high, x.$low))), true, verb); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 11:
				$r = p.fmtInteger($clone(f, reflect.Value).Uint(), false, verb); /* */ $s = 35; case 35: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (13)) { */ case 12:
				$r = p.fmtFloat($clone(f, reflect.Value).Float(), 32, verb); /* */ $s = 36; case 36: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (14)) { */ case 13:
				$r = p.fmtFloat($clone(f, reflect.Value).Float(), 64, verb); /* */ $s = 37; case 37: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (15)) { */ case 14:
				$r = p.fmtComplex($clone(f, reflect.Value).Complex(), 64, verb); /* */ $s = 38; case 38: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (16)) { */ case 15:
				$r = p.fmtComplex($clone(f, reflect.Value).Complex(), 128, verb); /* */ $s = 39; case 39: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (24)) { */ case 16:
				_r$2 = $clone(f, reflect.Value).String(); /* */ $s = 40; case 40: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				$r = p.fmtString(_r$2, verb); /* */ $s = 41; case 41: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (21)) { */ case 17:
				/* */ if (p.fmt.fmtFlags.sharpV) { $s = 42; continue; }
				/* */ $s = 43; continue;
				/* if (p.fmt.fmtFlags.sharpV) { */ case 42:
					_r$3 = $clone(f, reflect.Value).Type().String(); /* */ $s = 45; case 45: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$3); /* */ $s = 46; case 46: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					if ($clone(f, reflect.Value).IsNil()) {
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(nil)");
						$s = -1; return;
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);
					$s = 44; continue;
				/* } else { */ case 43:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("map[");
				/* } */ case 44:
				_r$4 = $clone(f, reflect.Value).MapKeys(); /* */ $s = 47; case 47: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				keys = _r$4;
				_ref = keys;
				_i = 0;
				/* while (true) { */ case 48:
					/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 49; continue; }
					i = _i;
					key = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
					if (i > 0) {
						if (p.fmt.fmtFlags.sharpV) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(", ");
						} else {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
						}
					}
					$r = p.printValue($clone(key, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 50; case 50: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(58);
					_r$5 = $clone(f, reflect.Value).MapIndex($clone(key, reflect.Value)); /* */ $s = 51; case 51: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
					$r = p.printValue($clone(_r$5, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 52; case 52: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_i++;
				/* } */ $s = 48; continue; case 49:
				if (p.fmt.fmtFlags.sharpV) {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);
				} else {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(93);
				}
				$s = 24; continue;
			/* } else if (_1 === (25)) { */ case 18:
				/* */ if (p.fmt.fmtFlags.sharpV) { $s = 53; continue; }
				/* */ $s = 54; continue;
				/* if (p.fmt.fmtFlags.sharpV) { */ case 53:
					_r$6 = $clone(f, reflect.Value).Type().String(); /* */ $s = 55; case 55: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
					$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$6); /* */ $s = 56; case 56: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 54:
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);
				i$1 = 0;
				/* while (true) { */ case 57:
					/* if (!(i$1 < $clone(f, reflect.Value).NumField())) { break; } */ if(!(i$1 < $clone(f, reflect.Value).NumField())) { $s = 58; continue; }
					if (i$1 > 0) {
						if (p.fmt.fmtFlags.sharpV) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(", ");
						} else {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
						}
					}
					/* */ if (p.fmt.fmtFlags.plusV || p.fmt.fmtFlags.sharpV) { $s = 59; continue; }
					/* */ $s = 60; continue;
					/* if (p.fmt.fmtFlags.plusV || p.fmt.fmtFlags.sharpV) { */ case 59:
						_r$7 = $clone(f, reflect.Value).Type().Field(i$1); /* */ $s = 61; case 61: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
						name = _r$7.Name;
						if (!(name === "")) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(name);
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(58);
						}
					/* } */ case 60:
					_r$8 = getField($clone(f, reflect.Value), i$1); /* */ $s = 62; case 62: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
					$r = p.printValue($clone(_r$8, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 63; case 63: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					i$1 = i$1 + (1) >> 0;
				/* } */ $s = 57; continue; case 58:
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);
				$s = 24; continue;
			/* } else if (_1 === (20)) { */ case 19:
				_r$9 = $clone(f, reflect.Value).Elem(); /* */ $s = 64; case 64: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				value$1 = _r$9;
				/* */ if (!$clone(value$1, reflect.Value).IsValid()) { $s = 65; continue; }
				/* */ $s = 66; continue;
				/* if (!$clone(value$1, reflect.Value).IsValid()) { */ case 65:
					/* */ if (p.fmt.fmtFlags.sharpV) { $s = 68; continue; }
					/* */ $s = 69; continue;
					/* if (p.fmt.fmtFlags.sharpV) { */ case 68:
						_r$10 = $clone(f, reflect.Value).Type().String(); /* */ $s = 71; case 71: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
						$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$10); /* */ $s = 72; case 72: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(nil)");
						$s = 70; continue;
					/* } else { */ case 69:
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
					/* } */ case 70:
					$s = 67; continue;
				/* } else { */ case 66:
					$r = p.printValue($clone(value$1, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 73; case 73: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 67:
				$s = 24; continue;
			/* } else if ((_1 === (17)) || (_1 === (23))) { */ case 20:
					_3 = verb;
					/* */ if ((_3 === (115)) || (_3 === (113)) || (_3 === (120)) || (_3 === (88))) { $s = 75; continue; }
					/* */ $s = 76; continue;
					/* if ((_3 === (115)) || (_3 === (113)) || (_3 === (120)) || (_3 === (88))) { */ case 75:
						t = $clone(f, reflect.Value).Type();
						_r$11 = t.Elem(); /* */ $s = 79; case 79: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
						_r$12 = _r$11.Kind(); /* */ $s = 80; case 80: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
						/* */ if (_r$12 === 8) { $s = 77; continue; }
						/* */ $s = 78; continue;
						/* if (_r$12 === 8) { */ case 77:
							bytes = sliceType$2.nil;
							/* */ if ($clone(f, reflect.Value).Kind() === 23) { $s = 81; continue; }
							/* */ if ($clone(f, reflect.Value).CanAddr()) { $s = 82; continue; }
							/* */ $s = 83; continue;
							/* if ($clone(f, reflect.Value).Kind() === 23) { */ case 81:
								_r$13 = $clone(f, reflect.Value).Bytes(); /* */ $s = 85; case 85: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
								bytes = _r$13;
								$s = 84; continue;
							/* } else if ($clone(f, reflect.Value).CanAddr()) { */ case 82:
								_r$14 = $clone(f, reflect.Value).Slice(0, $clone(f, reflect.Value).Len()); /* */ $s = 86; case 86: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
								_r$15 = $clone(_r$14, reflect.Value).Bytes(); /* */ $s = 87; case 87: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
								bytes = _r$15;
								$s = 84; continue;
							/* } else { */ case 83:
								bytes = $makeSlice(sliceType$2, $clone(f, reflect.Value).Len());
								_ref$1 = bytes;
								_i$1 = 0;
								/* while (true) { */ case 88:
									/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 89; continue; }
									i$2 = _i$1;
									_r$16 = $clone(f, reflect.Value).Index(i$2); /* */ $s = 90; case 90: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
									_r$17 = $clone(_r$16, reflect.Value).Uint(); /* */ $s = 91; case 91: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
									((i$2 < 0 || i$2 >= bytes.$length) ? ($throwRuntimeError("index out of range"), undefined) : bytes.$array[bytes.$offset + i$2] = ((_r$17.$low << 24 >>> 24)));
									_i$1++;
								/* } */ $s = 88; continue; case 89:
							/* } */ case 84:
							_arg = bytes;
							_arg$1 = verb;
							_r$18 = t.String(); /* */ $s = 92; case 92: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
							_arg$2 = _r$18;
							$r = p.fmtBytes(_arg, _arg$1, _arg$2); /* */ $s = 93; case 93: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = -1; return;
						/* } */ case 78:
					/* } */ case 76:
				case 74:
				/* */ if (p.fmt.fmtFlags.sharpV) { $s = 94; continue; }
				/* */ $s = 95; continue;
				/* if (p.fmt.fmtFlags.sharpV) { */ case 94:
					_r$19 = $clone(f, reflect.Value).Type().String(); /* */ $s = 97; case 97: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
					$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$19); /* */ $s = 98; case 98: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					if (($clone(f, reflect.Value).Kind() === 23) && $clone(f, reflect.Value).IsNil()) {
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(nil)");
						$s = -1; return;
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);
					i$3 = 0;
					/* while (true) { */ case 99:
						/* if (!(i$3 < $clone(f, reflect.Value).Len())) { break; } */ if(!(i$3 < $clone(f, reflect.Value).Len())) { $s = 100; continue; }
						if (i$3 > 0) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(", ");
						}
						_r$20 = $clone(f, reflect.Value).Index(i$3); /* */ $s = 101; case 101: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
						$r = p.printValue($clone(_r$20, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 102; case 102: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						i$3 = i$3 + (1) >> 0;
					/* } */ $s = 99; continue; case 100:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);
					$s = 96; continue;
				/* } else { */ case 95:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(91);
					i$4 = 0;
					/* while (true) { */ case 103:
						/* if (!(i$4 < $clone(f, reflect.Value).Len())) { break; } */ if(!(i$4 < $clone(f, reflect.Value).Len())) { $s = 104; continue; }
						if (i$4 > 0) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
						}
						_r$21 = $clone(f, reflect.Value).Index(i$4); /* */ $s = 105; case 105: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
						$r = p.printValue($clone(_r$21, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 106; case 106: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						i$4 = i$4 + (1) >> 0;
					/* } */ $s = 103; continue; case 104:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(93);
				/* } */ case 96:
				$s = 24; continue;
			/* } else if (_1 === (22)) { */ case 21:
				/* */ if ((depth === 0) && !(($clone(f, reflect.Value).Pointer() === 0))) { $s = 107; continue; }
				/* */ $s = 108; continue;
				/* if ((depth === 0) && !(($clone(f, reflect.Value).Pointer() === 0))) { */ case 107:
						_r$22 = $clone(f, reflect.Value).Elem(); /* */ $s = 110; case 110: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }
						a = _r$22;
						_4 = $clone(a, reflect.Value).Kind();
						/* */ if ((_4 === (17)) || (_4 === (23)) || (_4 === (25)) || (_4 === (21))) { $s = 111; continue; }
						/* */ $s = 112; continue;
						/* if ((_4 === (17)) || (_4 === (23)) || (_4 === (25)) || (_4 === (21))) { */ case 111:
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(38);
							$r = p.printValue($clone(a, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 113; case 113: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = -1; return;
						/* } */ case 112:
					case 109:
				/* } */ case 108:
				$r = p.fmtPointer($clone(f, reflect.Value), verb); /* */ $s = 114; case 114: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if ((_1 === (18)) || (_1 === (19)) || (_1 === (26))) { */ case 22:
				$r = p.fmtPointer($clone(f, reflect.Value), verb); /* */ $s = 115; case 115: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else { */ case 23:
				$r = p.unknownType($clone(f, reflect.Value)); /* */ $s = 116; case 116: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 24:
		case 7:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.printValue }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$2 = _r$2; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f.a = a; $f.bytes = bytes; $f.depth = depth; $f.f = f; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.i$4 = i$4; $f.key = key; $f.keys = keys; $f.name = name; $f.p = p; $f.t = t; $f.value = value; $f.value$1 = value$1; $f.verb = verb; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.printValue = function(value, verb, depth) { return this.$val.printValue(value, verb, depth); };
	intFromArg = function(a, argNum) {
		var _1, _r, _tuple, a, argNum, isInt, n, n$1, newArgNum, num, v, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _tuple = $f._tuple; a = $f.a; argNum = $f.argNum; isInt = $f.isInt; n = $f.n; n$1 = $f.n$1; newArgNum = $f.newArgNum; num = $f.num; v = $f.v; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		num = 0;
		isInt = false;
		newArgNum = 0;
		newArgNum = argNum;
		/* */ if (argNum < a.$length) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (argNum < a.$length) { */ case 1:
			_tuple = $assertType(((argNum < 0 || argNum >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + argNum]), $Int, true);
			num = _tuple[0];
			isInt = _tuple[1];
			/* */ if (!isInt) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!isInt) { */ case 3:
					_r = reflect.ValueOf(((argNum < 0 || argNum >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + argNum])); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					v = _r;
					_1 = $clone(v, reflect.Value).Kind();
					if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) {
						n = $clone(v, reflect.Value).Int();
						if ((x = (new $Int64(0, (((n.$low + ((n.$high >> 31) * 4294967296)) >> 0)))), (x.$high === n.$high && x.$low === n.$low))) {
							num = (((n.$low + ((n.$high >> 31) * 4294967296)) >> 0));
							isInt = true;
						}
					} else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) {
						n$1 = $clone(v, reflect.Value).Uint();
						if ((x$1 = (new $Int64(n$1.$high, n$1.$low)), (x$1.$high > 0 || (x$1.$high === 0 && x$1.$low >= 0))) && (x$2 = (new $Uint64(0, ((n$1.$low >> 0)))), (x$2.$high === n$1.$high && x$2.$low === n$1.$low))) {
							num = ((n$1.$low >> 0));
							isInt = true;
						}
					}
				case 5:
			/* } */ case 4:
			newArgNum = argNum + 1 >> 0;
			if (tooLarge(num)) {
				num = 0;
				isInt = false;
			}
		/* } */ case 2:
		$s = -1; return [num, isInt, newArgNum];
		/* */ } return; } if ($f === undefined) { $f = { $blk: intFromArg }; } $f._1 = _1; $f._r = _r; $f._tuple = _tuple; $f.a = a; $f.argNum = argNum; $f.isInt = isInt; $f.n = n; $f.n$1 = n$1; $f.newArgNum = newArgNum; $f.num = num; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	parseArgNumber = function(format) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, format, i, index, newi, ok, ok$1, wid, width;
		index = 0;
		wid = 0;
		ok = false;
		if (format.length < 3) {
			_tmp = 0;
			_tmp$1 = 1;
			_tmp$2 = false;
			index = _tmp;
			wid = _tmp$1;
			ok = _tmp$2;
			return [index, wid, ok];
		}
		i = 1;
		while (true) {
			if (!(i < format.length)) { break; }
			if (format.charCodeAt(i) === 93) {
				_tuple = parsenum(format, 1, i);
				width = _tuple[0];
				ok$1 = _tuple[1];
				newi = _tuple[2];
				if (!ok$1 || !((newi === i))) {
					_tmp$3 = 0;
					_tmp$4 = i + 1 >> 0;
					_tmp$5 = false;
					index = _tmp$3;
					wid = _tmp$4;
					ok = _tmp$5;
					return [index, wid, ok];
				}
				_tmp$6 = width - 1 >> 0;
				_tmp$7 = i + 1 >> 0;
				_tmp$8 = true;
				index = _tmp$6;
				wid = _tmp$7;
				ok = _tmp$8;
				return [index, wid, ok];
			}
			i = i + (1) >> 0;
		}
		_tmp$9 = 0;
		_tmp$10 = 1;
		_tmp$11 = false;
		index = _tmp$9;
		wid = _tmp$10;
		ok = _tmp$11;
		return [index, wid, ok];
	};
	pp.ptr.prototype.argNumber = function(argNum, format, i, numArgs) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tuple, argNum, format, found, i, index, newArgNum, newi, numArgs, ok, p, wid;
		newArgNum = 0;
		newi = 0;
		found = false;
		p = this;
		if (format.length <= i || !((format.charCodeAt(i) === 91))) {
			_tmp = argNum;
			_tmp$1 = i;
			_tmp$2 = false;
			newArgNum = _tmp;
			newi = _tmp$1;
			found = _tmp$2;
			return [newArgNum, newi, found];
		}
		p.reordered = true;
		_tuple = parseArgNumber($substring(format, i));
		index = _tuple[0];
		wid = _tuple[1];
		ok = _tuple[2];
		if (ok && 0 <= index && index < numArgs) {
			_tmp$3 = index;
			_tmp$4 = i + wid >> 0;
			_tmp$5 = true;
			newArgNum = _tmp$3;
			newi = _tmp$4;
			found = _tmp$5;
			return [newArgNum, newi, found];
		}
		p.goodArgNum = false;
		_tmp$6 = argNum;
		_tmp$7 = i + wid >> 0;
		_tmp$8 = ok;
		newArgNum = _tmp$6;
		newi = _tmp$7;
		found = _tmp$8;
		return [newArgNum, newi, found];
	};
	pp.prototype.argNumber = function(argNum, format, i, numArgs) { return this.$val.argNumber(argNum, format, i, numArgs); };
	pp.ptr.prototype.badArgNum = function(verb) {
		var p, verb;
		p = this;
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!");
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteRune(verb);
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(BADINDEX)");
	};
	pp.prototype.badArgNum = function(verb) { return this.$val.badArgNum(verb); };
	pp.ptr.prototype.missingArg = function(verb) {
		var p, verb;
		p = this;
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!");
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteRune(verb);
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(MISSING)");
	};
	pp.prototype.missingArg = function(verb) { return this.$val.missingArg(verb); };
	pp.ptr.prototype.doPrintf = function(format, a) {
		var _1, _i, _r, _r$1, _r$2, _ref, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, a, afterIndex, arg, argNum, c, end, format, i, i$1, lasti, p, verb, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; a = $f.a; afterIndex = $f.afterIndex; arg = $f.arg; argNum = $f.argNum; c = $f.c; end = $f.end; format = $f.format; i = $f.i; i$1 = $f.i$1; lasti = $f.lasti; p = $f.p; verb = $f.verb; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		end = format.length;
		argNum = 0;
		afterIndex = false;
		p.reordered = false;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < end)) { break; } */ if(!(i < end)) { $s = 2; continue; }
			p.goodArgNum = true;
			lasti = i;
			while (true) {
				if (!(i < end && !((format.charCodeAt(i) === 37)))) { break; }
				i = i + (1) >> 0;
			}
			if (i > lasti) {
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString($substring(format, lasti, i));
			}
			if (i >= end) {
				/* break; */ $s = 2; continue;
			}
			i = i + (1) >> 0;
			p.fmt.clearflags();
			/* while (true) { */ case 3:
				/* if (!(i < end)) { break; } */ if(!(i < end)) { $s = 4; continue; }
				c = format.charCodeAt(i);
					_1 = c;
					/* */ if (_1 === (35)) { $s = 6; continue; }
					/* */ if (_1 === (48)) { $s = 7; continue; }
					/* */ if (_1 === (43)) { $s = 8; continue; }
					/* */ if (_1 === (45)) { $s = 9; continue; }
					/* */ if (_1 === (32)) { $s = 10; continue; }
					/* */ $s = 11; continue;
					/* if (_1 === (35)) { */ case 6:
						p.fmt.fmtFlags.sharp = true;
						$s = 12; continue;
					/* } else if (_1 === (48)) { */ case 7:
						p.fmt.fmtFlags.zero = !p.fmt.fmtFlags.minus;
						$s = 12; continue;
					/* } else if (_1 === (43)) { */ case 8:
						p.fmt.fmtFlags.plus = true;
						$s = 12; continue;
					/* } else if (_1 === (45)) { */ case 9:
						p.fmt.fmtFlags.minus = true;
						p.fmt.fmtFlags.zero = false;
						$s = 12; continue;
					/* } else if (_1 === (32)) { */ case 10:
						p.fmt.fmtFlags.space = true;
						$s = 12; continue;
					/* } else { */ case 11:
						/* */ if (97 <= c && c <= 122 && argNum < a.$length) { $s = 13; continue; }
						/* */ $s = 14; continue;
						/* if (97 <= c && c <= 122 && argNum < a.$length) { */ case 13:
							if (c === 118) {
								p.fmt.fmtFlags.sharpV = p.fmt.fmtFlags.sharp;
								p.fmt.fmtFlags.sharp = false;
								p.fmt.fmtFlags.plusV = p.fmt.fmtFlags.plus;
								p.fmt.fmtFlags.plus = false;
							}
							$r = p.printArg(((argNum < 0 || argNum >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + argNum]), ((c >> 0))); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							argNum = argNum + (1) >> 0;
							i = i + (1) >> 0;
							/* continue formatLoop; */ $s = 1; continue s;
						/* } */ case 14:
						/* break simpleFormat; */ $s = 4; continue s;
					/* } */ case 12:
				case 5:
				i = i + (1) >> 0;
			/* } */ $s = 3; continue; case 4:
			_tuple = p.argNumber(argNum, format, i, a.$length);
			argNum = _tuple[0];
			i = _tuple[1];
			afterIndex = _tuple[2];
			/* */ if (i < end && (format.charCodeAt(i) === 42)) { $s = 16; continue; }
			/* */ $s = 17; continue;
			/* if (i < end && (format.charCodeAt(i) === 42)) { */ case 16:
				i = i + (1) >> 0;
				_r = intFromArg(a, argNum); /* */ $s = 19; case 19: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple$1 = _r;
				p.fmt.wid = _tuple$1[0];
				p.fmt.fmtFlags.widPresent = _tuple$1[1];
				argNum = _tuple$1[2];
				if (!p.fmt.fmtFlags.widPresent) {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!(BADWIDTH)");
				}
				if (p.fmt.wid < 0) {
					p.fmt.wid = -p.fmt.wid;
					p.fmt.fmtFlags.minus = true;
					p.fmt.fmtFlags.zero = false;
				}
				afterIndex = false;
				$s = 18; continue;
			/* } else { */ case 17:
				_tuple$2 = parsenum(format, i, end);
				p.fmt.wid = _tuple$2[0];
				p.fmt.fmtFlags.widPresent = _tuple$2[1];
				i = _tuple$2[2];
				if (afterIndex && p.fmt.fmtFlags.widPresent) {
					p.goodArgNum = false;
				}
			/* } */ case 18:
			/* */ if ((i + 1 >> 0) < end && (format.charCodeAt(i) === 46)) { $s = 20; continue; }
			/* */ $s = 21; continue;
			/* if ((i + 1 >> 0) < end && (format.charCodeAt(i) === 46)) { */ case 20:
				i = i + (1) >> 0;
				if (afterIndex) {
					p.goodArgNum = false;
				}
				_tuple$3 = p.argNumber(argNum, format, i, a.$length);
				argNum = _tuple$3[0];
				i = _tuple$3[1];
				afterIndex = _tuple$3[2];
				/* */ if (i < end && (format.charCodeAt(i) === 42)) { $s = 22; continue; }
				/* */ $s = 23; continue;
				/* if (i < end && (format.charCodeAt(i) === 42)) { */ case 22:
					i = i + (1) >> 0;
					_r$1 = intFromArg(a, argNum); /* */ $s = 25; case 25: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_tuple$4 = _r$1;
					p.fmt.prec = _tuple$4[0];
					p.fmt.fmtFlags.precPresent = _tuple$4[1];
					argNum = _tuple$4[2];
					if (p.fmt.prec < 0) {
						p.fmt.prec = 0;
						p.fmt.fmtFlags.precPresent = false;
					}
					if (!p.fmt.fmtFlags.precPresent) {
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!(BADPREC)");
					}
					afterIndex = false;
					$s = 24; continue;
				/* } else { */ case 23:
					_tuple$5 = parsenum(format, i, end);
					p.fmt.prec = _tuple$5[0];
					p.fmt.fmtFlags.precPresent = _tuple$5[1];
					i = _tuple$5[2];
					if (!p.fmt.fmtFlags.precPresent) {
						p.fmt.prec = 0;
						p.fmt.fmtFlags.precPresent = true;
					}
				/* } */ case 24:
			/* } */ case 21:
			if (!afterIndex) {
				_tuple$6 = p.argNumber(argNum, format, i, a.$length);
				argNum = _tuple$6[0];
				i = _tuple$6[1];
				afterIndex = _tuple$6[2];
			}
			if (i >= end) {
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!(NOVERB)");
				/* break; */ $s = 2; continue;
			}
			_tuple$7 = utf8.DecodeRuneInString($substring(format, i));
			verb = _tuple$7[0];
			w = _tuple$7[1];
			i = i + (w) >> 0;
				/* */ if ((verb === 37)) { $s = 27; continue; }
				/* */ if (!p.goodArgNum) { $s = 28; continue; }
				/* */ if (argNum >= a.$length) { $s = 29; continue; }
				/* */ if ((verb === 118)) { $s = 30; continue; }
				/* */ $s = 31; continue;
				/* if ((verb === 37)) { */ case 27:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(37);
					$s = 32; continue;
				/* } else if (!p.goodArgNum) { */ case 28:
					p.badArgNum(verb);
					$s = 32; continue;
				/* } else if (argNum >= a.$length) { */ case 29:
					p.missingArg(verb);
					$s = 32; continue;
				/* } else if ((verb === 118)) { */ case 30:
					p.fmt.fmtFlags.sharpV = p.fmt.fmtFlags.sharp;
					p.fmt.fmtFlags.sharp = false;
					p.fmt.fmtFlags.plusV = p.fmt.fmtFlags.plus;
					p.fmt.fmtFlags.plus = false;
					$r = p.printArg(((argNum < 0 || argNum >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + argNum]), verb); /* */ $s = 33; case 33: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					argNum = argNum + (1) >> 0;
					$s = 32; continue;
				/* } else { */ case 31:
					$r = p.printArg(((argNum < 0 || argNum >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + argNum]), verb); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					argNum = argNum + (1) >> 0;
				/* } */ case 32:
			case 26:
		/* } */ $s = 1; continue; case 2:
		/* */ if (!p.reordered && argNum < a.$length) { $s = 35; continue; }
		/* */ $s = 36; continue;
		/* if (!p.reordered && argNum < a.$length) { */ case 35:
			p.fmt.clearflags();
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!(EXTRA ");
			_ref = $subslice(a, argNum);
			_i = 0;
			/* while (true) { */ case 37:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 38; continue; }
				i$1 = _i;
				arg = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (i$1 > 0) {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(", ");
				}
				/* */ if ($interfaceIsEqual(arg, $ifaceNil)) { $s = 39; continue; }
				/* */ $s = 40; continue;
				/* if ($interfaceIsEqual(arg, $ifaceNil)) { */ case 39:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
					$s = 41; continue;
				/* } else { */ case 40:
					_r$2 = reflect.TypeOf(arg).String(); /* */ $s = 42; case 42: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$2); /* */ $s = 43; case 43: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(61);
					$r = p.printArg(arg, 118); /* */ $s = 44; case 44: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 41:
				_i++;
			/* } */ $s = 37; continue; case 38:
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(41);
		/* } */ case 36:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.doPrintf }; } $f._1 = _1; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f.a = a; $f.afterIndex = afterIndex; $f.arg = arg; $f.argNum = argNum; $f.c = c; $f.end = end; $f.format = format; $f.i = i; $f.i$1 = i$1; $f.lasti = lasti; $f.p = p; $f.verb = verb; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.doPrintf = function(format, a) { return this.$val.doPrintf(format, a); };
	pp.ptr.prototype.doPrint = function(a) {
		var _i, _r, _ref, _v, a, arg, argNum, isString, p, prevString, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _v = $f._v; a = $f.a; arg = $f.arg; argNum = $f.argNum; isString = $f.isString; p = $f.p; prevString = $f.prevString; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		prevString = false;
		_ref = a;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			argNum = _i;
			arg = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!(!($interfaceIsEqual(arg, $ifaceNil)))) { _v = false; $s = 3; continue s; }
			_r = reflect.TypeOf(arg).Kind(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_v = _r === 24; case 3:
			isString = _v;
			if (argNum > 0 && !isString && !prevString) {
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
			}
			$r = p.printArg(arg, 118); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			prevString = isString;
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.doPrint }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._v = _v; $f.a = a; $f.arg = arg; $f.argNum = argNum; $f.isString = isString; $f.p = p; $f.prevString = prevString; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.doPrint = function(a) { return this.$val.doPrint(a); };
	pp.ptr.prototype.doPrintln = function(a) {
		var _i, _ref, a, arg, argNum, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _ref = $f._ref; a = $f.a; arg = $f.arg; argNum = $f.argNum; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_ref = a;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			argNum = _i;
			arg = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (argNum > 0) {
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
			}
			$r = p.printArg(arg, 118); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 1; continue; case 2:
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(10);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.doPrintln }; } $f._i = _i; $f._ref = _ref; $f.a = a; $f.arg = arg; $f.argNum = argNum; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.doPrintln = function(a) { return this.$val.doPrintln(a); };
	ss.ptr.prototype.Read = function(buf) {
		var _tmp, _tmp$1, buf, err, n, s;
		n = 0;
		err = $ifaceNil;
		s = this;
		_tmp = 0;
		_tmp$1 = errors.New("ScanState's Read should not be called. Use ReadRune");
		n = _tmp;
		err = _tmp$1;
		return [n, err];
	};
	ss.prototype.Read = function(buf) { return this.$val.Read(buf); };
	ss.ptr.prototype.ReadRune = function() {
		var _r, _tuple, err, r, s, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; r = $f.r; s = $f.s; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = 0;
		size = 0;
		err = $ifaceNil;
		s = this;
		if (s.atEOF || s.count >= s.ssave.argLimit) {
			err = io.EOF;
			$s = -1; return [r, size, err];
		}
		_r = s.rs.ReadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		size = _tuple[1];
		err = _tuple[2];
		if ($interfaceIsEqual(err, $ifaceNil)) {
			s.count = s.count + (1) >> 0;
			if (s.ssave.nlIsEnd && (r === 10)) {
				s.atEOF = true;
			}
		} else if ($interfaceIsEqual(err, io.EOF)) {
			s.atEOF = true;
		}
		$s = -1; return [r, size, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.ReadRune }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.r = r; $f.s = s; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	ss.ptr.prototype.Width = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, ok, s, wid;
		wid = 0;
		ok = false;
		s = this;
		if (s.ssave.maxWid === 1073741824) {
			_tmp = 0;
			_tmp$1 = false;
			wid = _tmp;
			ok = _tmp$1;
			return [wid, ok];
		}
		_tmp$2 = s.ssave.maxWid;
		_tmp$3 = true;
		wid = _tmp$2;
		ok = _tmp$3;
		return [wid, ok];
	};
	ss.prototype.Width = function() { return this.$val.Width(); };
	ss.ptr.prototype.getRune = function() {
		var _r, _tuple, err, r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; r = $f.r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = 0;
		s = this;
		_r = s.ReadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			if ($interfaceIsEqual(err, io.EOF)) {
				r = -1;
				$s = -1; return r;
			}
			s.error(err);
		}
		$s = -1; return r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.getRune }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.r = r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.getRune = function() { return this.$val.getRune(); };
	ss.ptr.prototype.UnreadRune = function() {
		var _r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		_r = s.rs.UnreadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		s.atEOF = false;
		s.count = s.count - (1) >> 0;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.UnreadRune }; } $f._r = _r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	ss.ptr.prototype.error = function(err) {
		var err, s, x;
		s = this;
		$panic((x = new scanError.ptr(err), new x.constructor.elem(x)));
	};
	ss.prototype.error = function(err) { return this.$val.error(err); };
	ss.ptr.prototype.errorString = function(err) {
		var err, s, x;
		s = this;
		$panic((x = new scanError.ptr(errors.New(err)), new x.constructor.elem(x)));
	};
	ss.prototype.errorString = function(err) { return this.$val.errorString(err); };
	ss.ptr.prototype.Token = function(skipSpace, f) {
		var _r, err, f, s, skipSpace, tok, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; f = $f.f; s = $f.s; skipSpace = $f.skipSpace; tok = $f.tok; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		err = [err];
		tok = sliceType$2.nil;
		err[0] = $ifaceNil;
		s = this;
		$deferred.push([(function(err) { return function() {
			var _tuple, e, ok, se;
			e = $recover();
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				_tuple = $assertType(e, scanError, true);
				se = $clone(_tuple[0], scanError);
				ok = _tuple[1];
				if (ok) {
					err[0] = se.err;
				} else {
					$panic(e);
				}
			}
		}; })(err), []]);
		if (f === $throwNilPointerError) {
			f = notSpace;
		}
		s.buf = $subslice(s.buf, 0, 0);
		_r = s.token(skipSpace, f); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		tok = _r;
		$s = -1; return [tok, err[0]];
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  [tok, err[0]]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: ss.ptr.prototype.Token }; } $f._r = _r; $f.err = err; $f.f = f; $f.s = s; $f.skipSpace = skipSpace; $f.tok = tok; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	ss.prototype.Token = function(skipSpace, f) { return this.$val.Token(skipSpace, f); };
	isSpace = function(r) {
		var _i, _ref, r, rng, rx;
		if (r >= 65536) {
			return false;
		}
		rx = ((r << 16 >>> 16));
		_ref = space;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			rng = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), arrayType$1);
			if (rx < rng[0]) {
				return false;
			}
			if (rx <= rng[1]) {
				return true;
			}
			_i++;
		}
		return false;
	};
	notSpace = function(r) {
		var r;
		return !isSpace(r);
	};
	ss.ptr.prototype.SkipSpace = function() {
		var s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		$r = s.skipSpace(false); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.SkipSpace }; } $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.SkipSpace = function() { return this.$val.SkipSpace(); };
	ss.ptr.prototype.free = function(old) {
		var old, s;
		s = this;
		if (old.validSave) {
			ssave.copy(s.ssave, old);
			return;
		}
		if (s.buf.$capacity > 1024) {
			return;
		}
		s.buf = $subslice(s.buf, 0, 0);
		s.rs = $ifaceNil;
		ssFree.Put(s);
	};
	ss.prototype.free = function(old) { return this.$val.free(old); };
	ss.ptr.prototype.skipSpace = function(stopAtNewline) {
		var _r, _r$1, _r$2, _v, r, s, stopAtNewline, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _v = $f._v; r = $f.r; s = $f.s; stopAtNewline = $f.stopAtNewline; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		/* while (true) { */ case 1:
			_r = s.getRune(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			r = _r;
			if (r === -1) {
				$s = -1; return;
			}
			if (!(r === 13)) { _v = false; $s = 6; continue s; }
			_r$1 = s.peek("\n"); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_v = _r$1; case 6:
			/* */ if (_v) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_v) { */ case 4:
				/* continue; */ $s = 1; continue;
			/* } */ case 5:
			/* */ if (r === 10) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (r === 10) { */ case 8:
				if (stopAtNewline) {
					/* break; */ $s = 2; continue;
				}
				if (s.ssave.nlIsSpace) {
					/* continue; */ $s = 1; continue;
				}
				s.errorString("unexpected newline");
				$s = -1; return;
			/* } */ case 9:
			/* */ if (!isSpace(r)) { $s = 10; continue; }
			/* */ $s = 11; continue;
			/* if (!isSpace(r)) { */ case 10:
				_r$2 = s.UnreadRune(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$2;
				/* break; */ $s = 2; continue;
			/* } */ case 11:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.skipSpace }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._v = _v; $f.r = r; $f.s = s; $f.stopAtNewline = stopAtNewline; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.skipSpace = function(stopAtNewline) { return this.$val.skipSpace(stopAtNewline); };
	ss.ptr.prototype.token = function(skipSpace, f) {
		var _r, _r$1, _r$2, f, r, s, skipSpace, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; f = $f.f; r = $f.r; s = $f.s; skipSpace = $f.skipSpace; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		/* */ if (skipSpace) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (skipSpace) { */ case 1:
			$r = s.skipSpace(false); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		/* while (true) { */ case 4:
			_r = s.getRune(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			r = _r;
			if (r === -1) {
				/* break; */ $s = 5; continue;
			}
			_r$1 = f(r); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (!_r$1) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!_r$1) { */ case 7:
				_r$2 = s.UnreadRune(); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$2;
				/* break; */ $s = 5; continue;
			/* } */ case 8:
			(s.$ptr_buf || (s.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, s))).WriteRune(r);
		/* } */ $s = 4; continue; case 5:
		$s = -1; return (x = s.buf, $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length));
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.token }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.f = f; $f.r = r; $f.s = s; $f.skipSpace = skipSpace; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.token = function(skipSpace, f) { return this.$val.token(skipSpace, f); };
	indexRune = function(s, r) {
		var _i, _ref, _rune, c, i, r, s;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			i = _i;
			c = _rune[0];
			if (c === r) {
				return i;
			}
			_i += _rune[1];
		}
		return -1;
	};
	ss.ptr.prototype.peek = function(ok) {
		var _r, _r$1, ok, r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; ok = $f.ok; r = $f.r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		_r = s.getRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		r = _r;
		/* */ if (!((r === -1))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((r === -1))) { */ case 2:
			_r$1 = s.UnreadRune(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$1;
		/* } */ case 3:
		$s = -1; return indexRune(ok, r) >= 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.peek }; } $f._r = _r; $f._r$1 = _r$1; $f.ok = ok; $f.r = r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.peek = function(ok) { return this.$val.peek(ok); };
	ptrType$25.methods = [{prop: "clearflags", name: "clearflags", pkg: "fmt", typ: $funcType([], [], false)}, {prop: "init", name: "init", pkg: "fmt", typ: $funcType([ptrType$1], [], false)}, {prop: "writePadding", name: "writePadding", pkg: "fmt", typ: $funcType([$Int], [], false)}, {prop: "pad", name: "pad", pkg: "fmt", typ: $funcType([sliceType$2], [], false)}, {prop: "padString", name: "padString", pkg: "fmt", typ: $funcType([$String], [], false)}, {prop: "fmt_boolean", name: "fmt_boolean", pkg: "fmt", typ: $funcType([$Bool], [], false)}, {prop: "fmt_unicode", name: "fmt_unicode", pkg: "fmt", typ: $funcType([$Uint64], [], false)}, {prop: "fmt_integer", name: "fmt_integer", pkg: "fmt", typ: $funcType([$Uint64, $Int, $Bool, $String], [], false)}, {prop: "truncate", name: "truncate", pkg: "fmt", typ: $funcType([$String], [$String], false)}, {prop: "fmt_s", name: "fmt_s", pkg: "fmt", typ: $funcType([$String], [], false)}, {prop: "fmt_sbx", name: "fmt_sbx", pkg: "fmt", typ: $funcType([$String, sliceType$2, $String], [], false)}, {prop: "fmt_sx", name: "fmt_sx", pkg: "fmt", typ: $funcType([$String, $String], [], false)}, {prop: "fmt_bx", name: "fmt_bx", pkg: "fmt", typ: $funcType([sliceType$2, $String], [], false)}, {prop: "fmt_q", name: "fmt_q", pkg: "fmt", typ: $funcType([$String], [], false)}, {prop: "fmt_c", name: "fmt_c", pkg: "fmt", typ: $funcType([$Uint64], [], false)}, {prop: "fmt_qc", name: "fmt_qc", pkg: "fmt", typ: $funcType([$Uint64], [], false)}, {prop: "fmt_float", name: "fmt_float", pkg: "fmt", typ: $funcType([$Float64, $Int, $Int32, $Int], [], false)}];
	ptrType$1.methods = [{prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$2], [], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [], false)}, {prop: "WriteRune", name: "WriteRune", pkg: "", typ: $funcType([$Int32], [], false)}];
	ptrType$2.methods = [{prop: "free", name: "free", pkg: "fmt", typ: $funcType([], [], false)}, {prop: "Width", name: "Width", pkg: "", typ: $funcType([], [$Int, $Bool], false)}, {prop: "Precision", name: "Precision", pkg: "", typ: $funcType([], [$Int, $Bool], false)}, {prop: "Flag", name: "Flag", pkg: "", typ: $funcType([$Int], [$Bool], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "unknownType", name: "unknownType", pkg: "fmt", typ: $funcType([reflect.Value], [], false)}, {prop: "badVerb", name: "badVerb", pkg: "fmt", typ: $funcType([$Int32], [], false)}, {prop: "fmtBool", name: "fmtBool", pkg: "fmt", typ: $funcType([$Bool, $Int32], [], false)}, {prop: "fmt0x64", name: "fmt0x64", pkg: "fmt", typ: $funcType([$Uint64, $Bool], [], false)}, {prop: "fmtInteger", name: "fmtInteger", pkg: "fmt", typ: $funcType([$Uint64, $Bool, $Int32], [], false)}, {prop: "fmtFloat", name: "fmtFloat", pkg: "fmt", typ: $funcType([$Float64, $Int, $Int32], [], false)}, {prop: "fmtComplex", name: "fmtComplex", pkg: "fmt", typ: $funcType([$Complex128, $Int, $Int32], [], false)}, {prop: "fmtString", name: "fmtString", pkg: "fmt", typ: $funcType([$String, $Int32], [], false)}, {prop: "fmtBytes", name: "fmtBytes", pkg: "fmt", typ: $funcType([sliceType$2, $Int32, $String], [], false)}, {prop: "fmtPointer", name: "fmtPointer", pkg: "fmt", typ: $funcType([reflect.Value, $Int32], [], false)}, {prop: "catchPanic", name: "catchPanic", pkg: "fmt", typ: $funcType([$emptyInterface, $Int32], [], false)}, {prop: "handleMethods", name: "handleMethods", pkg: "fmt", typ: $funcType([$Int32], [$Bool], false)}, {prop: "printArg", name: "printArg", pkg: "fmt", typ: $funcType([$emptyInterface, $Int32], [], false)}, {prop: "printValue", name: "printValue", pkg: "fmt", typ: $funcType([reflect.Value, $Int32, $Int], [], false)}, {prop: "argNumber", name: "argNumber", pkg: "fmt", typ: $funcType([$Int, $String, $Int, $Int], [$Int, $Int, $Bool], false)}, {prop: "badArgNum", name: "badArgNum", pkg: "fmt", typ: $funcType([$Int32], [], false)}, {prop: "missingArg", name: "missingArg", pkg: "fmt", typ: $funcType([$Int32], [], false)}, {prop: "doPrintf", name: "doPrintf", pkg: "fmt", typ: $funcType([$String, sliceType], [], false)}, {prop: "doPrint", name: "doPrint", pkg: "fmt", typ: $funcType([sliceType], [], false)}, {prop: "doPrintln", name: "doPrintln", pkg: "fmt", typ: $funcType([sliceType], [], false)}];
	ptrType$5.methods = [{prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "Width", name: "Width", pkg: "", typ: $funcType([], [$Int, $Bool], false)}, {prop: "getRune", name: "getRune", pkg: "fmt", typ: $funcType([], [$Int32], false)}, {prop: "mustReadRune", name: "mustReadRune", pkg: "fmt", typ: $funcType([], [$Int32], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "error", name: "error", pkg: "fmt", typ: $funcType([$error], [], false)}, {prop: "errorString", name: "errorString", pkg: "fmt", typ: $funcType([$String], [], false)}, {prop: "Token", name: "Token", pkg: "", typ: $funcType([$Bool, funcType], [sliceType$2, $error], false)}, {prop: "SkipSpace", name: "SkipSpace", pkg: "", typ: $funcType([], [], false)}, {prop: "free", name: "free", pkg: "fmt", typ: $funcType([ssave], [], false)}, {prop: "skipSpace", name: "skipSpace", pkg: "fmt", typ: $funcType([$Bool], [], false)}, {prop: "token", name: "token", pkg: "fmt", typ: $funcType([$Bool, funcType], [sliceType$2], false)}, {prop: "consume", name: "consume", pkg: "fmt", typ: $funcType([$String, $Bool], [$Bool], false)}, {prop: "peek", name: "peek", pkg: "fmt", typ: $funcType([$String], [$Bool], false)}, {prop: "notEOF", name: "notEOF", pkg: "fmt", typ: $funcType([], [], false)}, {prop: "accept", name: "accept", pkg: "fmt", typ: $funcType([$String], [$Bool], false)}, {prop: "okVerb", name: "okVerb", pkg: "fmt", typ: $funcType([$Int32, $String, $String], [$Bool], false)}, {prop: "scanBool", name: "scanBool", pkg: "fmt", typ: $funcType([$Int32], [$Bool], false)}, {prop: "getBase", name: "getBase", pkg: "fmt", typ: $funcType([$Int32], [$Int, $String], false)}, {prop: "scanNumber", name: "scanNumber", pkg: "fmt", typ: $funcType([$String, $Bool], [$String], false)}, {prop: "scanRune", name: "scanRune", pkg: "fmt", typ: $funcType([$Int], [$Int64], false)}, {prop: "scanBasePrefix", name: "scanBasePrefix", pkg: "fmt", typ: $funcType([], [$Int, $String, $Bool], false)}, {prop: "scanInt", name: "scanInt", pkg: "fmt", typ: $funcType([$Int32, $Int], [$Int64], false)}, {prop: "scanUint", name: "scanUint", pkg: "fmt", typ: $funcType([$Int32, $Int], [$Uint64], false)}, {prop: "floatToken", name: "floatToken", pkg: "fmt", typ: $funcType([], [$String], false)}, {prop: "complexTokens", name: "complexTokens", pkg: "fmt", typ: $funcType([], [$String, $String], false)}, {prop: "convertFloat", name: "convertFloat", pkg: "fmt", typ: $funcType([$String, $Int], [$Float64], false)}, {prop: "scanComplex", name: "scanComplex", pkg: "fmt", typ: $funcType([$Int32, $Int], [$Complex128], false)}, {prop: "convertString", name: "convertString", pkg: "fmt", typ: $funcType([$Int32], [$String], false)}, {prop: "quotedString", name: "quotedString", pkg: "fmt", typ: $funcType([], [$String], false)}, {prop: "hexByte", name: "hexByte", pkg: "fmt", typ: $funcType([], [$Uint8, $Bool], false)}, {prop: "hexString", name: "hexString", pkg: "fmt", typ: $funcType([], [$String], false)}, {prop: "scanOne", name: "scanOne", pkg: "fmt", typ: $funcType([$Int32, $emptyInterface], [], false)}, {prop: "doScan", name: "doScan", pkg: "fmt", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "advance", name: "advance", pkg: "fmt", typ: $funcType([$String], [$Int], false)}, {prop: "doScanf", name: "doScanf", pkg: "fmt", typ: $funcType([$String, sliceType], [$Int, $error], false)}];
	fmtFlags.init("fmt", [{prop: "widPresent", name: "widPresent", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "precPresent", name: "precPresent", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "minus", name: "minus", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "plus", name: "plus", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "sharp", name: "sharp", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "space", name: "space", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "zero", name: "zero", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "plusV", name: "plusV", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "sharpV", name: "sharpV", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	fmt.init("fmt", [{prop: "buf", name: "buf", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "fmtFlags", name: "fmtFlags", anonymous: true, exported: false, typ: fmtFlags, tag: ""}, {prop: "wid", name: "wid", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "prec", name: "prec", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "intbuf", name: "intbuf", anonymous: false, exported: false, typ: arrayType, tag: ""}]);
	State.init([{prop: "Flag", name: "Flag", pkg: "", typ: $funcType([$Int], [$Bool], false)}, {prop: "Precision", name: "Precision", pkg: "", typ: $funcType([], [$Int, $Bool], false)}, {prop: "Width", name: "Width", pkg: "", typ: $funcType([], [$Int, $Bool], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$2], [$Int, $error], false)}]);
	Formatter.init([{prop: "Format", name: "Format", pkg: "", typ: $funcType([State, $Int32], [], false)}]);
	Stringer.init([{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}]);
	GoStringer.init([{prop: "GoString", name: "GoString", pkg: "", typ: $funcType([], [$String], false)}]);
	buffer.init($Uint8);
	pp.init("fmt", [{prop: "buf", name: "buf", anonymous: false, exported: false, typ: buffer, tag: ""}, {prop: "arg", name: "arg", anonymous: false, exported: false, typ: $emptyInterface, tag: ""}, {prop: "value", name: "value", anonymous: false, exported: false, typ: reflect.Value, tag: ""}, {prop: "fmt", name: "fmt", anonymous: false, exported: false, typ: fmt, tag: ""}, {prop: "reordered", name: "reordered", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "goodArgNum", name: "goodArgNum", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "panicking", name: "panicking", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "erroring", name: "erroring", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	ScanState.init([{prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "SkipSpace", name: "SkipSpace", pkg: "", typ: $funcType([], [], false)}, {prop: "Token", name: "Token", pkg: "", typ: $funcType([$Bool, funcType], [sliceType$2, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Width", name: "Width", pkg: "", typ: $funcType([], [$Int, $Bool], false)}]);
	scanError.init("fmt", [{prop: "err", name: "err", anonymous: false, exported: false, typ: $error, tag: ""}]);
	ss.init("fmt", [{prop: "rs", name: "rs", anonymous: false, exported: false, typ: io.RuneScanner, tag: ""}, {prop: "buf", name: "buf", anonymous: false, exported: false, typ: buffer, tag: ""}, {prop: "count", name: "count", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "atEOF", name: "atEOF", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "ssave", name: "ssave", anonymous: true, exported: false, typ: ssave, tag: ""}]);
	ssave.init("fmt", [{prop: "validSave", name: "validSave", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "nlIsEnd", name: "nlIsEnd", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "nlIsSpace", name: "nlIsSpace", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "argLimit", name: "argLimit", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "limit", name: "limit", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "maxWid", name: "maxWid", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = os.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = reflect.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		ppFree = new sync.Pool.ptr(0, 0, sliceType.nil, (function() {
			return new pp.ptr(buffer.nil, $ifaceNil, new reflect.Value.ptr(ptrType.nil, 0, 0), new fmt.ptr(ptrType$1.nil, new fmtFlags.ptr(false, false, false, false, false, false, false, false, false), 0, 0, arrayType.zero()), false, false, false, false);
		}));
		space = new sliceType$1([$toNativeArray($kindUint16, [9, 13]), $toNativeArray($kindUint16, [32, 32]), $toNativeArray($kindUint16, [133, 133]), $toNativeArray($kindUint16, [160, 160]), $toNativeArray($kindUint16, [5760, 5760]), $toNativeArray($kindUint16, [8192, 8202]), $toNativeArray($kindUint16, [8232, 8233]), $toNativeArray($kindUint16, [8239, 8239]), $toNativeArray($kindUint16, [8287, 8287]), $toNativeArray($kindUint16, [12288, 12288])]);
		ssFree = new sync.Pool.ptr(0, 0, sliceType.nil, (function() {
			return new ss.ptr($ifaceNil, buffer.nil, 0, false, new ssave.ptr(false, false, false, 0, 0, 0));
		}));
		complexError = errors.New("syntax error scanning complex number");
		boolError = errors.New("syntax error scanning boolean");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["strings"] = (function() {
	var $pkg = {}, $init, errors, js, io, unicode, utf8, Reader, asciiSet, sliceType, sliceType$3, ptrType$5, arrayType$3, ptrType$6, IndexByte, Index, LastIndex, Count, NewReader, explode, Contains, ContainsAny, ContainsRune, IndexRune, IndexAny, genSplit, Split, Join, HasPrefix, Map, ToUpper, ToLower, TrimLeftFunc, TrimRightFunc, TrimFunc, indexFunc, lastIndexFunc, makeASCIISet, makeCutsetFunc, TrimRight, TrimSpace, EqualFold;
	errors = $packages["errors"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	io = $packages["io"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	Reader = $pkg.Reader = $newType(0, $kindStruct, "strings.Reader", true, "strings", true, function(s_, i_, prevRune_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.s = "";
			this.i = new $Int64(0, 0);
			this.prevRune = 0;
			return;
		}
		this.s = s_;
		this.i = i_;
		this.prevRune = prevRune_;
	});
	asciiSet = $pkg.asciiSet = $newType(32, $kindArray, "strings.asciiSet", true, "strings", false, null);
	sliceType = $sliceType($Uint8);
	sliceType$3 = $sliceType($String);
	ptrType$5 = $ptrType(asciiSet);
	arrayType$3 = $arrayType($Uint32, 8);
	ptrType$6 = $ptrType(Reader);
	IndexByte = function(s, c) {
		var c, s;
		return $parseInt(s.indexOf($global.String.fromCharCode(c))) >> 0;
	};
	$pkg.IndexByte = IndexByte;
	Index = function(s, sep) {
		var s, sep;
		return $parseInt(s.indexOf(sep)) >> 0;
	};
	$pkg.Index = Index;
	LastIndex = function(s, sep) {
		var s, sep;
		return $parseInt(s.lastIndexOf(sep)) >> 0;
	};
	$pkg.LastIndex = LastIndex;
	Count = function(s, sep) {
		var n, pos, s, sep;
		n = 0;
		if ((sep.length === 0)) {
			return utf8.RuneCountInString(s) + 1 >> 0;
		} else if (sep.length > s.length) {
			return 0;
		} else if ((sep.length === s.length)) {
			if (sep === s) {
				return 1;
			}
			return 0;
		}
		while (true) {
			pos = Index(s, sep);
			if (pos === -1) {
				break;
			}
			n = n + (1) >> 0;
			s = $substring(s, (pos + sep.length >> 0));
		}
		return n;
	};
	$pkg.Count = Count;
	Reader.ptr.prototype.Len = function() {
		var r, x, x$1, x$2, x$3, x$4;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			return 0;
		}
		return (((x$2 = (x$3 = (new $Int64(0, r.s.length)), x$4 = r.i, new $Int64(x$3.$high - x$4.$high, x$3.$low - x$4.$low)), x$2.$low + ((x$2.$high >> 31) * 4294967296)) >> 0));
	};
	Reader.prototype.Len = function() { return this.$val.Len(); };
	Reader.ptr.prototype.Size = function() {
		var r;
		r = this;
		return (new $Int64(0, r.s.length));
	};
	Reader.prototype.Size = function() { return this.$val.Size(); };
	Reader.ptr.prototype.Read = function(b) {
		var _tmp, _tmp$1, b, err, n, r, x, x$1, x$2, x$3;
		n = 0;
		err = $ifaceNil;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			_tmp = 0;
			_tmp$1 = io.EOF;
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		r.prevRune = -1;
		n = $copyString(b, $substring(r.s, $flatten64(r.i)));
		r.i = (x$2 = r.i, x$3 = (new $Int64(0, n)), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		return [n, err];
	};
	Reader.prototype.Read = function(b) { return this.$val.Read(b); };
	Reader.ptr.prototype.ReadAt = function(b, off) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, b, err, n, off, r, x;
		n = 0;
		err = $ifaceNil;
		r = this;
		if ((off.$high < 0 || (off.$high === 0 && off.$low < 0))) {
			_tmp = 0;
			_tmp$1 = errors.New("strings.Reader.ReadAt: negative offset");
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		if ((x = (new $Int64(0, r.s.length)), (off.$high > x.$high || (off.$high === x.$high && off.$low >= x.$low)))) {
			_tmp$2 = 0;
			_tmp$3 = io.EOF;
			n = _tmp$2;
			err = _tmp$3;
			return [n, err];
		}
		n = $copyString(b, $substring(r.s, $flatten64(off)));
		if (n < b.$length) {
			err = io.EOF;
		}
		return [n, err];
	};
	Reader.prototype.ReadAt = function(b, off) { return this.$val.ReadAt(b, off); };
	Reader.ptr.prototype.ReadByte = function() {
		var b, r, x, x$1, x$2, x$3;
		r = this;
		r.prevRune = -1;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			return [0, io.EOF];
		}
		b = r.s.charCodeAt($flatten64(r.i));
		r.i = (x$2 = r.i, x$3 = new $Int64(0, 1), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		return [b, $ifaceNil];
	};
	Reader.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	Reader.ptr.prototype.UnreadByte = function() {
		var r, x, x$1, x$2;
		r = this;
		r.prevRune = -1;
		if ((x = r.i, (x.$high < 0 || (x.$high === 0 && x.$low <= 0)))) {
			return errors.New("strings.Reader.UnreadByte: at beginning of string");
		}
		r.i = (x$1 = r.i, x$2 = new $Int64(0, 1), new $Int64(x$1.$high - x$2.$high, x$1.$low - x$2.$low));
		return $ifaceNil;
	};
	Reader.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Reader.ptr.prototype.ReadRune = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, c, ch, err, r, size, x, x$1, x$2, x$3, x$4, x$5, x$6;
		ch = 0;
		size = 0;
		err = $ifaceNil;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			r.prevRune = -1;
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = io.EOF;
			ch = _tmp;
			size = _tmp$1;
			err = _tmp$2;
			return [ch, size, err];
		}
		r.prevRune = (((x$2 = r.i, x$2.$low + ((x$2.$high >> 31) * 4294967296)) >> 0));
		c = r.s.charCodeAt($flatten64(r.i));
		if (c < 128) {
			r.i = (x$3 = r.i, x$4 = new $Int64(0, 1), new $Int64(x$3.$high + x$4.$high, x$3.$low + x$4.$low));
			_tmp$3 = ((c >> 0));
			_tmp$4 = 1;
			_tmp$5 = $ifaceNil;
			ch = _tmp$3;
			size = _tmp$4;
			err = _tmp$5;
			return [ch, size, err];
		}
		_tuple = utf8.DecodeRuneInString($substring(r.s, $flatten64(r.i)));
		ch = _tuple[0];
		size = _tuple[1];
		r.i = (x$5 = r.i, x$6 = (new $Int64(0, size)), new $Int64(x$5.$high + x$6.$high, x$5.$low + x$6.$low));
		return [ch, size, err];
	};
	Reader.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	Reader.ptr.prototype.UnreadRune = function() {
		var r;
		r = this;
		if (r.prevRune < 0) {
			return errors.New("strings.Reader.UnreadRune: previous operation was not ReadRune");
		}
		r.i = (new $Int64(0, r.prevRune));
		r.prevRune = -1;
		return $ifaceNil;
	};
	Reader.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	Reader.ptr.prototype.Seek = function(offset, whence) {
		var _1, abs, offset, r, whence, x, x$1;
		r = this;
		r.prevRune = -1;
		abs = new $Int64(0, 0);
		_1 = whence;
		if (_1 === (0)) {
			abs = offset;
		} else if (_1 === (1)) {
			abs = (x = r.i, new $Int64(x.$high + offset.$high, x.$low + offset.$low));
		} else if (_1 === (2)) {
			abs = (x$1 = (new $Int64(0, r.s.length)), new $Int64(x$1.$high + offset.$high, x$1.$low + offset.$low));
		} else {
			return [new $Int64(0, 0), errors.New("strings.Reader.Seek: invalid whence")];
		}
		if ((abs.$high < 0 || (abs.$high === 0 && abs.$low < 0))) {
			return [new $Int64(0, 0), errors.New("strings.Reader.Seek: negative position")];
		}
		r.i = abs;
		return [abs, $ifaceNil];
	};
	Reader.prototype.Seek = function(offset, whence) { return this.$val.Seek(offset, whence); };
	Reader.ptr.prototype.WriteTo = function(w) {
		var _r, _tmp, _tmp$1, _tuple, err, m, n, r, s, w, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; err = $f.err; m = $f.m; n = $f.n; r = $f.r; s = $f.s; w = $f.w; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		r = this;
		r.prevRune = -1;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			_tmp = new $Int64(0, 0);
			_tmp$1 = $ifaceNil;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		s = $substring(r.s, $flatten64(r.i));
		_r = io.WriteString(w, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		m = _tuple[0];
		err = _tuple[1];
		if (m > s.length) {
			$panic(new $String("strings.Reader.WriteTo: invalid WriteString count"));
		}
		r.i = (x$2 = r.i, x$3 = (new $Int64(0, m)), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		n = (new $Int64(0, m));
		if (!((m === s.length)) && $interfaceIsEqual(err, $ifaceNil)) {
			err = io.ErrShortWrite;
		}
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.WriteTo }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.err = err; $f.m = m; $f.n = n; $f.r = r; $f.s = s; $f.w = w; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.WriteTo = function(w) { return this.$val.WriteTo(w); };
	Reader.ptr.prototype.Reset = function(s) {
		var r, s;
		r = this;
		Reader.copy(r, new Reader.ptr(s, new $Int64(0, 0), -1));
	};
	Reader.prototype.Reset = function(s) { return this.$val.Reset(s); };
	NewReader = function(s) {
		var s;
		return new Reader.ptr(s, new $Int64(0, 0), -1);
	};
	$pkg.NewReader = NewReader;
	explode = function(s, n) {
		var _tuple, a, ch, i, l, n, s, size, x;
		l = utf8.RuneCountInString(s);
		if (n < 0 || n > l) {
			n = l;
		}
		a = $makeSlice(sliceType$3, n);
		i = 0;
		while (true) {
			if (!(i < (n - 1 >> 0))) { break; }
			_tuple = utf8.DecodeRuneInString(s);
			ch = _tuple[0];
			size = _tuple[1];
			((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = $substring(s, 0, size));
			s = $substring(s, size);
			if (ch === 65533) {
				((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = "\xEF\xBF\xBD");
			}
			i = i + (1) >> 0;
		}
		if (n > 0) {
			(x = n - 1 >> 0, ((x < 0 || x >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x] = s));
		}
		return a;
	};
	Contains = function(s, substr) {
		var s, substr;
		return Index(s, substr) >= 0;
	};
	$pkg.Contains = Contains;
	ContainsAny = function(s, chars) {
		var chars, s;
		return IndexAny(s, chars) >= 0;
	};
	$pkg.ContainsAny = ContainsAny;
	ContainsRune = function(s, r) {
		var r, s;
		return IndexRune(s, r) >= 0;
	};
	$pkg.ContainsRune = ContainsRune;
	IndexRune = function(s, r) {
		var _i, _ref, _rune, i, r, r$1, s;
		if (0 <= r && r < 128) {
			return IndexByte(s, ((r << 24 >>> 24)));
		} else if ((r === 65533)) {
			_ref = s;
			_i = 0;
			while (true) {
				if (!(_i < _ref.length)) { break; }
				_rune = $decodeRune(_ref, _i);
				i = _i;
				r$1 = _rune[0];
				if (r$1 === 65533) {
					return i;
				}
				_i += _rune[1];
			}
			return -1;
		} else if (!utf8.ValidRune(r)) {
			return -1;
		} else {
			return Index(s, ($encodeRune(r)));
		}
	};
	$pkg.IndexRune = IndexRune;
	IndexAny = function(s, chars) {
		var _i, _i$1, _ref, _ref$1, _rune, _rune$1, _tuple, as, c, chars, i, i$1, isASCII, m, s;
		if (chars.length > 0) {
			if (s.length > 8) {
				_tuple = makeASCIISet(chars);
				as = $clone(_tuple[0], asciiSet);
				isASCII = _tuple[1];
				if (isASCII) {
					i = 0;
					while (true) {
						if (!(i < s.length)) { break; }
						if (new ptrType$5(as).contains(s.charCodeAt(i))) {
							return i;
						}
						i = i + (1) >> 0;
					}
					return -1;
				}
			}
			_ref = s;
			_i = 0;
			while (true) {
				if (!(_i < _ref.length)) { break; }
				_rune = $decodeRune(_ref, _i);
				i$1 = _i;
				c = _rune[0];
				_ref$1 = chars;
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.length)) { break; }
					_rune$1 = $decodeRune(_ref$1, _i$1);
					m = _rune$1[0];
					if (c === m) {
						return i$1;
					}
					_i$1 += _rune$1[1];
				}
				_i += _rune[1];
			}
		}
		return -1;
	};
	$pkg.IndexAny = IndexAny;
	genSplit = function(s, sep, sepSave, n) {
		var a, i, m, n, s, sep, sepSave;
		if (n === 0) {
			return sliceType$3.nil;
		}
		if (sep === "") {
			return explode(s, n);
		}
		if (n < 0) {
			n = Count(s, sep) + 1 >> 0;
		}
		a = $makeSlice(sliceType$3, n);
		n = n - (1) >> 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			m = Index(s, sep);
			if (m < 0) {
				break;
			}
			((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = $substring(s, 0, (m + sepSave >> 0)));
			s = $substring(s, (m + sep.length >> 0));
			i = i + (1) >> 0;
		}
		((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = s);
		return $subslice(a, 0, (i + 1 >> 0));
	};
	Split = function(s, sep) {
		var s, sep;
		return genSplit(s, sep, 0, -1);
	};
	$pkg.Split = Split;
	Join = function(a, sep) {
		var _1, _i, _ref, a, b, bp, i, n, s, sep;
		_1 = a.$length;
		if (_1 === (0)) {
			return "";
		} else if (_1 === (1)) {
			return (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]);
		} else if (_1 === (2)) {
			return (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]) + sep + (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]);
		} else if (_1 === (3)) {
			return (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]) + sep + (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]) + sep + (2 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 2]);
		}
		n = $imul(sep.length, ((a.$length - 1 >> 0)));
		i = 0;
		while (true) {
			if (!(i < a.$length)) { break; }
			n = n + (((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i]).length) >> 0;
			i = i + (1) >> 0;
		}
		b = $makeSlice(sliceType, n);
		bp = $copyString(b, (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]));
		_ref = $subslice(a, 1);
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			s = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			bp = bp + ($copyString($subslice(b, bp), sep)) >> 0;
			bp = bp + ($copyString($subslice(b, bp), s)) >> 0;
			_i++;
		}
		return ($bytesToString(b));
	};
	$pkg.Join = Join;
	HasPrefix = function(s, prefix) {
		var prefix, s;
		return s.length >= prefix.length && $substring(s, 0, prefix.length) === prefix;
	};
	$pkg.HasPrefix = HasPrefix;
	Map = function(mapping, s) {
		var _i, _i$1, _r, _r$1, _ref, _ref$1, _rune, _rune$1, _tuple, b, c, c$1, i, mapping, nb, nbytes, r, r$1, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; _rune = $f._rune; _rune$1 = $f._rune$1; _tuple = $f._tuple; b = $f.b; c = $f.c; c$1 = $f.c$1; i = $f.i; mapping = $f.mapping; nb = $f.nb; nbytes = $f.nbytes; r = $f.r; r$1 = $f.r$1; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = sliceType.nil;
		nbytes = 0;
		_ref = s;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.length)) { break; } */ if(!(_i < _ref.length)) { $s = 2; continue; }
			_rune = $decodeRune(_ref, _i);
			i = _i;
			c = _rune[0];
			_r = mapping(c); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			r = _r;
			if (r === c) {
				_i += _rune[1];
				/* continue; */ $s = 1; continue;
			}
			b = $makeSlice(sliceType, (s.length + 4 >> 0));
			nbytes = $copyString(b, $substring(s, 0, i));
			if (r >= 0) {
				if (r <= 128) {
					((nbytes < 0 || nbytes >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + nbytes] = ((r << 24 >>> 24)));
					nbytes = nbytes + (1) >> 0;
				} else {
					nbytes = nbytes + (utf8.EncodeRune($subslice(b, nbytes), r)) >> 0;
				}
			}
			if (c === 65533) {
				_tuple = utf8.DecodeRuneInString($substring(s, i));
				w = _tuple[1];
				i = i + (w) >> 0;
			} else {
				i = i + (utf8.RuneLen(c)) >> 0;
			}
			s = $substring(s, i);
			/* break; */ $s = 2; continue;
		/* } */ $s = 1; continue; case 2:
		if (b === sliceType.nil) {
			$s = -1; return s;
		}
		_ref$1 = s;
		_i$1 = 0;
		/* while (true) { */ case 4:
			/* if (!(_i$1 < _ref$1.length)) { break; } */ if(!(_i$1 < _ref$1.length)) { $s = 5; continue; }
			_rune$1 = $decodeRune(_ref$1, _i$1);
			c$1 = _rune$1[0];
			_r$1 = mapping(c$1); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			r$1 = _r$1;
			if ((0 <= r$1 && r$1 <= 128) && nbytes < b.$length) {
				((nbytes < 0 || nbytes >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + nbytes] = ((r$1 << 24 >>> 24)));
				nbytes = nbytes + (1) >> 0;
				_i$1 += _rune$1[1];
				/* continue; */ $s = 4; continue;
			}
			if (r$1 >= 0) {
				if ((nbytes + 4 >> 0) >= b.$length) {
					nb = $makeSlice(sliceType, ($imul(2, b.$length)));
					$copySlice(nb, $subslice(b, 0, nbytes));
					b = nb;
				}
				nbytes = nbytes + (utf8.EncodeRune($subslice(b, nbytes), r$1)) >> 0;
			}
			_i$1 += _rune$1[1];
		/* } */ $s = 4; continue; case 5:
		$s = -1; return ($bytesToString($subslice(b, 0, nbytes)));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Map }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._rune = _rune; $f._rune$1 = _rune$1; $f._tuple = _tuple; $f.b = b; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.mapping = mapping; $f.nb = nb; $f.nbytes = nbytes; $f.r = r; $f.r$1 = r$1; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Map = Map;
	ToUpper = function(s) {
		var _r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = Map(unicode.ToUpper, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ToUpper }; } $f._r = _r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ToUpper = ToUpper;
	ToLower = function(s) {
		var _r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = Map(unicode.ToLower, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ToLower }; } $f._r = _r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ToLower = ToLower;
	TrimLeftFunc = function(s, f) {
		var _r, f, i, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; i = $f.i; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = indexFunc(s, f, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		if (i === -1) {
			$s = -1; return "";
		}
		$s = -1; return $substring(s, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimLeftFunc }; } $f._r = _r; $f.f = f; $f.i = i; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimLeftFunc = TrimLeftFunc;
	TrimRightFunc = function(s, f) {
		var _r, _tuple, f, i, s, wid, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; f = $f.f; i = $f.i; s = $f.s; wid = $f.wid; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = lastIndexFunc(s, f, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		if (i >= 0 && s.charCodeAt(i) >= 128) {
			_tuple = utf8.DecodeRuneInString($substring(s, i));
			wid = _tuple[1];
			i = i + (wid) >> 0;
		} else {
			i = i + (1) >> 0;
		}
		$s = -1; return $substring(s, 0, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimRightFunc }; } $f._r = _r; $f._tuple = _tuple; $f.f = f; $f.i = i; $f.s = s; $f.wid = wid; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimRightFunc = TrimRightFunc;
	TrimFunc = function(s, f) {
		var _r, _r$1, f, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; f = $f.f; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimLeftFunc(s, f); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = TrimRightFunc(_r, f); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimFunc }; } $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimFunc = TrimFunc;
	indexFunc = function(s, f, truth) {
		var _i, _r, _ref, _rune, f, i, r, s, truth, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _rune = $f._rune; f = $f.f; i = $f.i; r = $f.r; s = $f.s; truth = $f.truth; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_ref = s;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.length)) { break; } */ if(!(_i < _ref.length)) { $s = 2; continue; }
			_rune = $decodeRune(_ref, _i);
			i = _i;
			r = _rune[0];
			_r = f(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r === truth) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r === truth) { */ case 3:
				$s = -1; return i;
			/* } */ case 4:
			_i += _rune[1];
		/* } */ $s = 1; continue; case 2:
		$s = -1; return -1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: indexFunc }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._rune = _rune; $f.f = f; $f.i = i; $f.r = r; $f.s = s; $f.truth = truth; $f.$s = $s; $f.$r = $r; return $f;
	};
	lastIndexFunc = function(s, f, truth) {
		var _r, _tuple, f, i, r, s, size, truth, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; f = $f.f; i = $f.i; r = $f.r; s = $f.s; size = $f.size; truth = $f.truth; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = s.length;
		/* while (true) { */ case 1:
			/* if (!(i > 0)) { break; } */ if(!(i > 0)) { $s = 2; continue; }
			_tuple = utf8.DecodeLastRuneInString($substring(s, 0, i));
			r = _tuple[0];
			size = _tuple[1];
			i = i - (size) >> 0;
			_r = f(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r === truth) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r === truth) { */ case 3:
				$s = -1; return i;
			/* } */ case 4:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return -1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lastIndexFunc }; } $f._r = _r; $f._tuple = _tuple; $f.f = f; $f.i = i; $f.r = r; $f.s = s; $f.size = size; $f.truth = truth; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeASCIISet = function(chars) {
		var _index, _tmp, _tmp$1, _tmp$2, _tmp$3, as, c, chars, i, ok, y;
		as = arrayType$3.zero();
		ok = false;
		i = 0;
		while (true) {
			if (!(i < chars.length)) { break; }
			c = chars.charCodeAt(i);
			if (c >= 128) {
				_tmp = $clone(as, asciiSet);
				_tmp$1 = false;
				asciiSet.copy(as, _tmp);
				ok = _tmp$1;
				return [as, ok];
			}
			_index = c >>> 5 << 24 >>> 24;
			((_index < 0 || _index >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[_index] = ((((_index < 0 || _index >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[_index]) | (((y = ((((c & 31) >>> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0));
			i = i + (1) >> 0;
		}
		_tmp$2 = $clone(as, asciiSet);
		_tmp$3 = true;
		asciiSet.copy(as, _tmp$2);
		ok = _tmp$3;
		return [as, ok];
	};
	asciiSet.prototype.contains = function(c) {
		var as, c, x, y;
		as = this.$val;
		return !((((((x = c >>> 5 << 24 >>> 24, (as.nilCheck, ((x < 0 || x >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[x]))) & (((y = ((((c & 31) >>> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0)) === 0));
	};
	$ptrType(asciiSet).prototype.contains = function(c) { return (new asciiSet(this.$get())).contains(c); };
	makeCutsetFunc = function(cutset) {
		var _tuple, as, cutset, isASCII;
		if ((cutset.length === 1) && cutset.charCodeAt(0) < 128) {
			return (function(r) {
				var r;
				return r === ((cutset.charCodeAt(0) >> 0));
			});
		}
		_tuple = makeASCIISet(cutset);
		as = $clone(_tuple[0], asciiSet);
		isASCII = _tuple[1];
		if (isASCII) {
			return (function(r) {
				var r;
				return r < 128 && new ptrType$5(as).contains(((r << 24 >>> 24)));
			});
		}
		return (function(r) {
			var r;
			return IndexRune(cutset, r) >= 0;
		});
	};
	TrimRight = function(s, cutset) {
		var _r, cutset, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; cutset = $f.cutset; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (s === "" || cutset === "") {
			$s = -1; return s;
		}
		_r = TrimRightFunc(s, makeCutsetFunc(cutset)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimRight }; } $f._r = _r; $f.cutset = cutset; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimRight = TrimRight;
	TrimSpace = function(s) {
		var _r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimFunc(s, unicode.IsSpace); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimSpace }; } $f._r = _r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimSpace = TrimSpace;
	EqualFold = function(s, t) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, r, r$1, r$2, s, size, size$1, sr, t, tr;
		while (true) {
			if (!(!(s === "") && !(t === ""))) { break; }
			_tmp = 0;
			_tmp$1 = 0;
			sr = _tmp;
			tr = _tmp$1;
			if (s.charCodeAt(0) < 128) {
				_tmp$2 = ((s.charCodeAt(0) >> 0));
				_tmp$3 = $substring(s, 1);
				sr = _tmp$2;
				s = _tmp$3;
			} else {
				_tuple = utf8.DecodeRuneInString(s);
				r = _tuple[0];
				size = _tuple[1];
				_tmp$4 = r;
				_tmp$5 = $substring(s, size);
				sr = _tmp$4;
				s = _tmp$5;
			}
			if (t.charCodeAt(0) < 128) {
				_tmp$6 = ((t.charCodeAt(0) >> 0));
				_tmp$7 = $substring(t, 1);
				tr = _tmp$6;
				t = _tmp$7;
			} else {
				_tuple$1 = utf8.DecodeRuneInString(t);
				r$1 = _tuple$1[0];
				size$1 = _tuple$1[1];
				_tmp$8 = r$1;
				_tmp$9 = $substring(t, size$1);
				tr = _tmp$8;
				t = _tmp$9;
			}
			if (tr === sr) {
				continue;
			}
			if (tr < sr) {
				_tmp$10 = sr;
				_tmp$11 = tr;
				tr = _tmp$10;
				sr = _tmp$11;
			}
			if (tr < 128 && 65 <= sr && sr <= 90) {
				if (tr === ((sr + 97 >> 0) - 65 >> 0)) {
					continue;
				}
				return false;
			}
			r$2 = unicode.SimpleFold(sr);
			while (true) {
				if (!(!((r$2 === sr)) && r$2 < tr)) { break; }
				r$2 = unicode.SimpleFold(r$2);
			}
			if (r$2 === tr) {
				continue;
			}
			return false;
		}
		return s === t;
	};
	$pkg.EqualFold = EqualFold;
	ptrType$6.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "ReadAt", name: "ReadAt", pkg: "", typ: $funcType([sliceType, $Int64], [$Int, $error], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Seek", name: "Seek", pkg: "", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([io.Writer], [$Int64, $error], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([$String], [], false)}];
	ptrType$5.methods = [{prop: "contains", name: "contains", pkg: "strings", typ: $funcType([$Uint8], [$Bool], false)}];
	Reader.init("strings", [{prop: "s", name: "s", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "i", name: "i", anonymous: false, exported: false, typ: $Int64, tag: ""}, {prop: "prevRune", name: "prevRune", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	asciiSet.init($Uint32, 8);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["encoding/csv"] = (function() {
	var $pkg = {}, $init, bufio, bytes, errors, fmt, io, strings, unicode, utf8, Writer, sliceType$1, sliceType$3, sliceType$4, ptrType$1, ptrType$4, NewWriter;
	bufio = $packages["bufio"];
	bytes = $packages["bytes"];
	errors = $packages["errors"];
	fmt = $packages["fmt"];
	io = $packages["io"];
	strings = $packages["strings"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	Writer = $pkg.Writer = $newType(0, $kindStruct, "csv.Writer", true, "encoding/csv", true, function(Comma_, UseCRLF_, w_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Comma = 0;
			this.UseCRLF = false;
			this.w = ptrType$1.nil;
			return;
		}
		this.Comma = Comma_;
		this.UseCRLF = UseCRLF_;
		this.w = w_;
	});
	sliceType$1 = $sliceType($Uint8);
	sliceType$3 = $sliceType($String);
	sliceType$4 = $sliceType(sliceType$3);
	ptrType$1 = $ptrType(bufio.Writer);
	ptrType$4 = $ptrType(Writer);
	NewWriter = function(w) {
		var w;
		return new Writer.ptr(44, false, bufio.NewWriter(w));
	};
	$pkg.NewWriter = NewWriter;
	Writer.ptr.prototype.Write = function(record) {
		var _1, _i, _i$1, _r, _r$1, _r$10, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, _rune, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, err, err$1, err$2, err$3, err$4, err$5, field, n, r1, record, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; _rune = $f._rune; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; err$4 = $f.err$4; err$5 = $f.err$5; field = $f.field; n = $f.n; r1 = $f.r1; record = $f.record; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		w = this;
		_ref = record;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			n = _i;
			field = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			/* */ if (n > 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (n > 0) { */ case 3:
				_r = w.w.WriteRune(w.Comma); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				err = _tuple[1];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					$s = -1; return err;
				}
			/* } */ case 4:
			/* */ if (!w.fieldNeedsQuotes(field)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (!w.fieldNeedsQuotes(field)) { */ case 6:
				_r$1 = w.w.WriteString(field); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tuple$1 = _r$1;
				err$1 = _tuple$1[1];
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					$s = -1; return err$1;
				}
				_i++;
				/* continue; */ $s = 1; continue;
			/* } */ case 7:
			_r$2 = w.w.WriteByte(34); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			err$2 = _r$2;
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return err$2;
			}
			_ref$1 = field;
			_i$1 = 0;
			/* while (true) { */ case 10:
				/* if (!(_i$1 < _ref$1.length)) { break; } */ if(!(_i$1 < _ref$1.length)) { $s = 11; continue; }
				_rune = $decodeRune(_ref$1, _i$1);
				r1 = _rune[0];
				err$3 = $ifaceNil;
					_1 = r1;
					/* */ if (_1 === (34)) { $s = 13; continue; }
					/* */ if (_1 === (13)) { $s = 14; continue; }
					/* */ if (_1 === (10)) { $s = 15; continue; }
					/* */ $s = 16; continue;
					/* if (_1 === (34)) { */ case 13:
						_r$3 = w.w.WriteString("\"\""); /* */ $s = 18; case 18: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						_tuple$2 = _r$3;
						err$3 = _tuple$2[1];
						$s = 17; continue;
					/* } else if (_1 === (13)) { */ case 14:
						/* */ if (!w.UseCRLF) { $s = 19; continue; }
						/* */ $s = 20; continue;
						/* if (!w.UseCRLF) { */ case 19:
							_r$4 = w.w.WriteByte(13); /* */ $s = 21; case 21: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
							err$3 = _r$4;
						/* } */ case 20:
						$s = 17; continue;
					/* } else if (_1 === (10)) { */ case 15:
						/* */ if (w.UseCRLF) { $s = 22; continue; }
						/* */ $s = 23; continue;
						/* if (w.UseCRLF) { */ case 22:
							_r$5 = w.w.WriteString("\r\n"); /* */ $s = 25; case 25: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
							_tuple$3 = _r$5;
							err$3 = _tuple$3[1];
							$s = 24; continue;
						/* } else { */ case 23:
							_r$6 = w.w.WriteByte(10); /* */ $s = 26; case 26: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
							err$3 = _r$6;
						/* } */ case 24:
						$s = 17; continue;
					/* } else { */ case 16:
						_r$7 = w.w.WriteRune(r1); /* */ $s = 27; case 27: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
						_tuple$4 = _r$7;
						err$3 = _tuple$4[1];
					/* } */ case 17:
				case 12:
				if (!($interfaceIsEqual(err$3, $ifaceNil))) {
					$s = -1; return err$3;
				}
				_i$1 += _rune[1];
			/* } */ $s = 10; continue; case 11:
			_r$8 = w.w.WriteByte(34); /* */ $s = 28; case 28: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			err$4 = _r$8;
			if (!($interfaceIsEqual(err$4, $ifaceNil))) {
				$s = -1; return err$4;
			}
			_i++;
		/* } */ $s = 1; continue; case 2:
		err$5 = $ifaceNil;
		/* */ if (w.UseCRLF) { $s = 29; continue; }
		/* */ $s = 30; continue;
		/* if (w.UseCRLF) { */ case 29:
			_r$9 = w.w.WriteString("\r\n"); /* */ $s = 32; case 32: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
			_tuple$5 = _r$9;
			err$5 = _tuple$5[1];
			$s = 31; continue;
		/* } else { */ case 30:
			_r$10 = w.w.WriteByte(10); /* */ $s = 33; case 33: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			err$5 = _r$10;
		/* } */ case 31:
		$s = -1; return err$5;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.Write }; } $f._1 = _1; $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f._rune = _rune; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.err$4 = err$4; $f.err$5 = err$5; $f.field = field; $f.n = n; $f.r1 = r1; $f.record = record; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.Write = function(record) { return this.$val.Write(record); };
	Writer.ptr.prototype.Flush = function() {
		var _r, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		w = this;
		_r = w.w.Flush(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.Flush }; } $f._r = _r; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.Flush = function() { return this.$val.Flush(); };
	Writer.ptr.prototype.Error = function() {
		var _r, _tuple, err, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		w = this;
		_r = w.w.Write(sliceType$1.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		err = _tuple[1];
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.Error }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.Error = function() { return this.$val.Error(); };
	Writer.ptr.prototype.WriteAll = function(records) {
		var _i, _r, _r$1, _ref, err, record, records, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; err = $f.err; record = $f.record; records = $f.records; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		w = this;
		_ref = records;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			record = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r = w.Write(record); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			err = _r;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			_i++;
		/* } */ $s = 1; continue; case 2:
		_r$1 = w.w.Flush(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.WriteAll }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f.err = err; $f.record = record; $f.records = records; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.WriteAll = function(records) { return this.$val.WriteAll(records); };
	Writer.ptr.prototype.fieldNeedsQuotes = function(field) {
		var _tuple, field, r1, w;
		w = this;
		if (field === "") {
			return false;
		}
		if (field === "\\." || strings.ContainsRune(field, w.Comma) || strings.ContainsAny(field, "\"\r\n")) {
			return true;
		}
		_tuple = utf8.DecodeRuneInString(field);
		r1 = _tuple[0];
		return unicode.IsSpace(r1);
	};
	Writer.prototype.fieldNeedsQuotes = function(field) { return this.$val.fieldNeedsQuotes(field); };
	ptrType$4.methods = [{prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$3], [$error], false)}, {prop: "Flush", name: "Flush", pkg: "", typ: $funcType([], [], false)}, {prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$error], false)}, {prop: "WriteAll", name: "WriteAll", pkg: "", typ: $funcType([sliceType$4], [$error], false)}, {prop: "fieldNeedsQuotes", name: "fieldNeedsQuotes", pkg: "encoding/csv", typ: $funcType([$String], [$Bool], false)}];
	Writer.init("encoding/csv", [{prop: "Comma", name: "Comma", anonymous: false, exported: true, typ: $Int32, tag: ""}, {prop: "UseCRLF", name: "UseCRLF", anonymous: false, exported: true, typ: $Bool, tag: ""}, {prop: "w", name: "w", anonymous: false, exported: false, typ: ptrType$1, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bufio.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytes.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmt.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrTrailingComma = errors.New("extra delimiter at end of line");
		$pkg.ErrBareQuote = errors.New("bare \" in non-quoted-field");
		$pkg.ErrQuote = errors.New("extraneous \" in field");
		$pkg.ErrFieldCount = errors.New("wrong number of fields in line");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["encoding"] = (function() {
	var $pkg = {}, $init, TextMarshaler, TextUnmarshaler, sliceType;
	TextMarshaler = $pkg.TextMarshaler = $newType(8, $kindInterface, "encoding.TextMarshaler", true, "encoding", true, null);
	TextUnmarshaler = $pkg.TextUnmarshaler = $newType(8, $kindInterface, "encoding.TextUnmarshaler", true, "encoding", true, null);
	sliceType = $sliceType($Uint8);
	TextMarshaler.init([{prop: "MarshalText", name: "MarshalText", pkg: "", typ: $funcType([], [sliceType, $error], false)}]);
	TextUnmarshaler.init([{prop: "UnmarshalText", name: "UnmarshalText", pkg: "", typ: $funcType([sliceType], [$error], false)}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["encoding/base64"] = (function() {
	var $pkg = {}, $init, io, strconv, Encoding, encoder, CorruptInputError, arrayType, arrayType$1, sliceType, ptrType, arrayType$2, arrayType$3, arrayType$4, ptrType$1, NewEncoding, NewEncoder;
	io = $packages["io"];
	strconv = $packages["strconv"];
	Encoding = $pkg.Encoding = $newType(0, $kindStruct, "base64.Encoding", true, "encoding/base64", true, function(encode_, decodeMap_, padChar_, strict_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.encode = arrayType.zero();
			this.decodeMap = arrayType$1.zero();
			this.padChar = 0;
			this.strict = false;
			return;
		}
		this.encode = encode_;
		this.decodeMap = decodeMap_;
		this.padChar = padChar_;
		this.strict = strict_;
	});
	encoder = $pkg.encoder = $newType(0, $kindStruct, "base64.encoder", true, "encoding/base64", false, function(err_, enc_, w_, buf_, nbuf_, out_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.err = $ifaceNil;
			this.enc = ptrType.nil;
			this.w = $ifaceNil;
			this.buf = arrayType$2.zero();
			this.nbuf = 0;
			this.out = arrayType$3.zero();
			return;
		}
		this.err = err_;
		this.enc = enc_;
		this.w = w_;
		this.buf = buf_;
		this.nbuf = nbuf_;
		this.out = out_;
	});
	CorruptInputError = $pkg.CorruptInputError = $newType(8, $kindInt64, "base64.CorruptInputError", true, "encoding/base64", true, null);
	arrayType = $arrayType($Uint8, 64);
	arrayType$1 = $arrayType($Uint8, 256);
	sliceType = $sliceType($Uint8);
	ptrType = $ptrType(Encoding);
	arrayType$2 = $arrayType($Uint8, 3);
	arrayType$3 = $arrayType($Uint8, 1024);
	arrayType$4 = $arrayType($Uint8, 4);
	ptrType$1 = $ptrType(encoder);
	NewEncoding = function(encoder$1) {
		var e, encoder$1, i, i$1, i$2, x, x$1, x$2;
		if (!((encoder$1.length === 64))) {
			$panic(new $String("encoding alphabet is not 64-bytes long"));
		}
		i = 0;
		while (true) {
			if (!(i < encoder$1.length)) { break; }
			if ((encoder$1.charCodeAt(i) === 10) || (encoder$1.charCodeAt(i) === 13)) {
				$panic(new $String("encoding alphabet contains newline character"));
			}
			i = i + (1) >> 0;
		}
		e = new Encoding.ptr(arrayType.zero(), arrayType$1.zero(), 0, false);
		e.padChar = 61;
		$copyString(new sliceType(e.encode), encoder$1);
		i$1 = 0;
		while (true) {
			if (!(i$1 < 256)) { break; }
			(x = e.decodeMap, ((i$1 < 0 || i$1 >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i$1] = 255));
			i$1 = i$1 + (1) >> 0;
		}
		i$2 = 0;
		while (true) {
			if (!(i$2 < encoder$1.length)) { break; }
			(x$1 = e.decodeMap, x$2 = encoder$1.charCodeAt(i$2), ((x$2 < 0 || x$2 >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[x$2] = ((i$2 << 24 >>> 24))));
			i$2 = i$2 + (1) >> 0;
		}
		return e;
	};
	$pkg.NewEncoding = NewEncoding;
	Encoding.ptr.prototype.WithPadding = function(padding) {
		var enc, i, padding, x;
		enc = this;
		if ((padding === 13) || (padding === 10) || padding > 255) {
			$panic(new $String("invalid padding"));
		}
		i = 0;
		while (true) {
			if (!(i < 64)) { break; }
			if ((((x = enc.encode, ((i < 0 || i >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i])) >> 0)) === padding) {
				$panic(new $String("padding contained in alphabet"));
			}
			i = i + (1) >> 0;
		}
		enc.padChar = padding;
		return enc;
	};
	Encoding.prototype.WithPadding = function(padding) { return this.$val.WithPadding(padding); };
	Encoding.ptr.prototype.Strict = function() {
		var enc;
		enc = this;
		enc.strict = true;
		return enc;
	};
	Encoding.prototype.Strict = function() { return this.$val.Strict(); };
	Encoding.ptr.prototype.Encode = function(dst, src) {
		var _1, _q, _tmp, _tmp$1, di, dst, enc, n, remain, si, src, val, val$1, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$22, x$23, x$24, x$25, x$26, x$27, x$28, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		enc = this;
		if (src.$length === 0) {
			return;
		}
		_tmp = 0;
		_tmp$1 = 0;
		di = _tmp;
		si = _tmp$1;
		n = $imul(((_q = src.$length / 3, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"))), 3);
		while (true) {
			if (!(si < n)) { break; }
			val = (((((((x = si + 0 >> 0, ((x < 0 || x >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + x])) >>> 0)) << 16 >>> 0) | ((((x$1 = si + 1 >> 0, ((x$1 < 0 || x$1 >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + x$1])) >>> 0)) << 8 >>> 0)) >>> 0) | (((x$2 = si + 2 >> 0, ((x$2 < 0 || x$2 >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + x$2])) >>> 0))) >>> 0;
			(x$5 = di + 0 >> 0, ((x$5 < 0 || x$5 >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + x$5] = (x$3 = enc.encode, x$4 = ((val >>> 18 >>> 0) & 63) >>> 0, ((x$4 < 0 || x$4 >= x$3.length) ? ($throwRuntimeError("index out of range"), undefined) : x$3[x$4]))));
			(x$8 = di + 1 >> 0, ((x$8 < 0 || x$8 >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + x$8] = (x$6 = enc.encode, x$7 = ((val >>> 12 >>> 0) & 63) >>> 0, ((x$7 < 0 || x$7 >= x$6.length) ? ($throwRuntimeError("index out of range"), undefined) : x$6[x$7]))));
			(x$11 = di + 2 >> 0, ((x$11 < 0 || x$11 >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + x$11] = (x$9 = enc.encode, x$10 = ((val >>> 6 >>> 0) & 63) >>> 0, ((x$10 < 0 || x$10 >= x$9.length) ? ($throwRuntimeError("index out of range"), undefined) : x$9[x$10]))));
			(x$14 = di + 3 >> 0, ((x$14 < 0 || x$14 >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + x$14] = (x$12 = enc.encode, x$13 = (val & 63) >>> 0, ((x$13 < 0 || x$13 >= x$12.length) ? ($throwRuntimeError("index out of range"), undefined) : x$12[x$13]))));
			si = si + (3) >> 0;
			di = di + (4) >> 0;
		}
		remain = src.$length - si >> 0;
		if (remain === 0) {
			return;
		}
		val$1 = (((x$15 = si + 0 >> 0, ((x$15 < 0 || x$15 >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + x$15])) >>> 0)) << 16 >>> 0;
		if (remain === 2) {
			val$1 = (val$1 | (((((x$16 = si + 1 >> 0, ((x$16 < 0 || x$16 >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + x$16])) >>> 0)) << 8 >>> 0))) >>> 0;
		}
		(x$19 = di + 0 >> 0, ((x$19 < 0 || x$19 >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + x$19] = (x$17 = enc.encode, x$18 = ((val$1 >>> 18 >>> 0) & 63) >>> 0, ((x$18 < 0 || x$18 >= x$17.length) ? ($throwRuntimeError("index out of range"), undefined) : x$17[x$18]))));
		(x$22 = di + 1 >> 0, ((x$22 < 0 || x$22 >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + x$22] = (x$20 = enc.encode, x$21 = ((val$1 >>> 12 >>> 0) & 63) >>> 0, ((x$21 < 0 || x$21 >= x$20.length) ? ($throwRuntimeError("index out of range"), undefined) : x$20[x$21]))));
		_1 = remain;
		if (_1 === (2)) {
			(x$25 = di + 2 >> 0, ((x$25 < 0 || x$25 >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + x$25] = (x$23 = enc.encode, x$24 = ((val$1 >>> 6 >>> 0) & 63) >>> 0, ((x$24 < 0 || x$24 >= x$23.length) ? ($throwRuntimeError("index out of range"), undefined) : x$23[x$24]))));
			if (!((enc.padChar === -1))) {
				(x$26 = di + 3 >> 0, ((x$26 < 0 || x$26 >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + x$26] = ((enc.padChar << 24 >>> 24))));
			}
		} else if (_1 === (1)) {
			if (!((enc.padChar === -1))) {
				(x$27 = di + 2 >> 0, ((x$27 < 0 || x$27 >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + x$27] = ((enc.padChar << 24 >>> 24))));
				(x$28 = di + 3 >> 0, ((x$28 < 0 || x$28 >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + x$28] = ((enc.padChar << 24 >>> 24))));
			}
		}
	};
	Encoding.prototype.Encode = function(dst, src) { return this.$val.Encode(dst, src); };
	Encoding.ptr.prototype.EncodeToString = function(src) {
		var buf, enc, src;
		enc = this;
		buf = $makeSlice(sliceType, enc.EncodedLen(src.$length));
		enc.Encode(buf, src);
		return ($bytesToString(buf));
	};
	Encoding.prototype.EncodeToString = function(src) { return this.$val.EncodeToString(src); };
	encoder.ptr.prototype.Write = function(p) {
		var _q, _r, _r$1, _r$2, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, e, err, i, i$1, n, nn, p, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; e = $f.e; err = $f.err; i = $f.i; i$1 = $f.i$1; n = $f.n; nn = $f.nn; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		e = this;
		if (!($interfaceIsEqual(e.err, $ifaceNil))) {
			_tmp = 0;
			_tmp$1 = e.err;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		/* */ if (e.nbuf > 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (e.nbuf > 0) { */ case 1:
			i = 0;
			i = 0;
			while (true) {
				if (!(i < p.$length && e.nbuf < 3)) { break; }
				(x = e.buf, x$1 = e.nbuf, ((x$1 < 0 || x$1 >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[x$1] = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i])));
				e.nbuf = e.nbuf + (1) >> 0;
				i = i + (1) >> 0;
			}
			n = n + (i) >> 0;
			p = $subslice(p, i);
			if (e.nbuf < 3) {
				$s = -1; return [n, err];
			}
			e.enc.Encode(new sliceType(e.out), new sliceType(e.buf));
			_r = e.w.Write($subslice(new sliceType(e.out), 0, 4)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			e.err = _tuple[1];
			if (!($interfaceIsEqual(e.err, $ifaceNil))) {
				_tmp$2 = n;
				_tmp$3 = e.err;
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
			e.nbuf = 0;
		/* } */ case 2:
		/* while (true) { */ case 4:
			/* if (!(p.$length >= 3)) { break; } */ if(!(p.$length >= 3)) { $s = 5; continue; }
			nn = 768;
			if (nn > p.$length) {
				nn = p.$length;
				nn = nn - ((_r$1 = nn % 3, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"))) >> 0;
			}
			e.enc.Encode(new sliceType(e.out), $subslice(p, 0, nn));
			_r$2 = e.w.Write($subslice(new sliceType(e.out), 0, ($imul((_q = nn / 3, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")), 4)))); /* */ $s = 6; case 6: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_tuple$1 = _r$2;
			e.err = _tuple$1[1];
			if (!($interfaceIsEqual(e.err, $ifaceNil))) {
				_tmp$4 = n;
				_tmp$5 = e.err;
				n = _tmp$4;
				err = _tmp$5;
				$s = -1; return [n, err];
			}
			n = n + (nn) >> 0;
			p = $subslice(p, nn);
		/* } */ $s = 4; continue; case 5:
		i$1 = 0;
		while (true) {
			if (!(i$1 < p.$length)) { break; }
			(x$2 = e.buf, ((i$1 < 0 || i$1 >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[i$1] = ((i$1 < 0 || i$1 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i$1])));
			i$1 = i$1 + (1) >> 0;
		}
		e.nbuf = p.$length;
		n = n + (p.$length) >> 0;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: encoder.ptr.prototype.Write }; } $f._q = _q; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.e = e; $f.err = err; $f.i = i; $f.i$1 = i$1; $f.n = n; $f.nn = nn; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	encoder.prototype.Write = function(p) { return this.$val.Write(p); };
	encoder.ptr.prototype.Close = function() {
		var _r, _tuple, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		/* */ if ($interfaceIsEqual(e.err, $ifaceNil) && e.nbuf > 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($interfaceIsEqual(e.err, $ifaceNil) && e.nbuf > 0) { */ case 1:
			e.enc.Encode(new sliceType(e.out), $subslice(new sliceType(e.buf), 0, e.nbuf));
			_r = e.w.Write($subslice(new sliceType(e.out), 0, e.enc.EncodedLen(e.nbuf))); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			e.err = _tuple[1];
			e.nbuf = 0;
		/* } */ case 2:
		$s = -1; return e.err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: encoder.ptr.prototype.Close }; } $f._r = _r; $f._tuple = _tuple; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	encoder.prototype.Close = function() { return this.$val.Close(); };
	NewEncoder = function(enc, w) {
		var enc, w;
		return new encoder.ptr($ifaceNil, enc, w, arrayType$2.zero(), 0, arrayType$3.zero());
	};
	$pkg.NewEncoder = NewEncoder;
	Encoding.ptr.prototype.EncodedLen = function(n) {
		var _q, _q$1, enc, n;
		enc = this;
		if (enc.padChar === -1) {
			return (_q = ((($imul(n, 8)) + 5 >> 0)) / 6, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		}
		return $imul((_q$1 = ((n + 2 >> 0)) / 3, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")), 4);
	};
	Encoding.prototype.EncodedLen = function(n) { return this.$val.EncodedLen(n); };
	CorruptInputError.prototype.Error = function() {
		var e;
		e = this;
		return "illegal base64 data at input byte " + strconv.FormatInt((new $Int64(e.$high, e.$low)), 10);
	};
	$ptrType(CorruptInputError).prototype.Error = function() { return this.$get().Error(); };
	Encoding.ptr.prototype.decode = function(dst, src) {
		var _1, _2, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, _tmp$27, _tmp$28, _tmp$29, _tmp$3, _tmp$30, _tmp$31, _tmp$32, _tmp$33, _tmp$34, _tmp$35, _tmp$36, _tmp$37, _tmp$38, _tmp$39, _tmp$4, _tmp$40, _tmp$41, _tmp$42, _tmp$43, _tmp$44, _tmp$45, _tmp$46, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, dbuf, dinc, dlen, dst, enc, end, err, in$1, j, n, out, si, src, val, x;
		n = 0;
		end = false;
		err = $ifaceNil;
		enc = this;
		si = 0;
		while (true) {
			if (!(si < src.$length && !end)) { break; }
			dbuf = arrayType$4.zero();
			_tmp = 3;
			_tmp$1 = 4;
			dinc = _tmp;
			dlen = _tmp$1;
			j = 0;
			while (true) {
				if (!(j < 4)) { break; }
				if (src.$length === si) {
					if ((j === 0)) {
						_tmp$2 = n;
						_tmp$3 = false;
						_tmp$4 = $ifaceNil;
						n = _tmp$2;
						end = _tmp$3;
						err = _tmp$4;
						return [n, end, err];
					} else if (((j === 1)) || (!((enc.padChar === -1)))) {
						_tmp$5 = n;
						_tmp$6 = false;
						_tmp$7 = (new CorruptInputError(0, (si - j >> 0)));
						n = _tmp$5;
						end = _tmp$6;
						err = _tmp$7;
						return [n, end, err];
					}
					_tmp$8 = j - 1 >> 0;
					_tmp$9 = j;
					_tmp$10 = true;
					dinc = _tmp$8;
					dlen = _tmp$9;
					end = _tmp$10;
					break;
				}
				in$1 = ((si < 0 || si >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + si]);
				si = si + (1) >> 0;
				out = (x = enc.decodeMap, ((in$1 < 0 || in$1 >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[in$1]));
				if (!((out === 255))) {
					((j < 0 || j >= dbuf.length) ? ($throwRuntimeError("index out of range"), undefined) : dbuf[j] = out);
					j = j + (1) >> 0;
					continue;
				}
				if ((in$1 === 10) || (in$1 === 13)) {
					j = j - (1) >> 0;
					j = j + (1) >> 0;
					continue;
				}
				if (((in$1 >> 0)) === enc.padChar) {
					_1 = j;
					if ((_1 === (0)) || (_1 === (1))) {
						_tmp$11 = n;
						_tmp$12 = false;
						_tmp$13 = (new CorruptInputError(0, (si - 1 >> 0)));
						n = _tmp$11;
						end = _tmp$12;
						err = _tmp$13;
						return [n, end, err];
					} else if (_1 === (2)) {
						while (true) {
							if (!(si < src.$length && ((((si < 0 || si >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + si]) === 10) || (((si < 0 || si >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + si]) === 13)))) { break; }
							si = si + (1) >> 0;
						}
						if (si === src.$length) {
							_tmp$14 = n;
							_tmp$15 = false;
							_tmp$16 = (new CorruptInputError(0, src.$length));
							n = _tmp$14;
							end = _tmp$15;
							err = _tmp$16;
							return [n, end, err];
						}
						if (!((((((si < 0 || si >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + si]) >> 0)) === enc.padChar))) {
							_tmp$17 = n;
							_tmp$18 = false;
							_tmp$19 = (new CorruptInputError(0, (si - 1 >> 0)));
							n = _tmp$17;
							end = _tmp$18;
							err = _tmp$19;
							return [n, end, err];
						}
						si = si + (1) >> 0;
					}
					while (true) {
						if (!(si < src.$length && ((((si < 0 || si >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + si]) === 10) || (((si < 0 || si >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + si]) === 13)))) { break; }
						si = si + (1) >> 0;
					}
					if (si < src.$length) {
						err = (new CorruptInputError(0, si));
					}
					_tmp$20 = 3;
					_tmp$21 = j;
					_tmp$22 = true;
					dinc = _tmp$20;
					dlen = _tmp$21;
					end = _tmp$22;
					break;
				}
				_tmp$23 = n;
				_tmp$24 = false;
				_tmp$25 = (new CorruptInputError(0, (si - 1 >> 0)));
				n = _tmp$23;
				end = _tmp$24;
				err = _tmp$25;
				return [n, end, err];
			}
			val = ((((((((dbuf[0] >>> 0)) << 18 >>> 0) | (((dbuf[1] >>> 0)) << 12 >>> 0)) >>> 0) | (((dbuf[2] >>> 0)) << 6 >>> 0)) >>> 0) | ((dbuf[3] >>> 0))) >>> 0;
			_tmp$26 = (((val >>> 0 >>> 0) << 24 >>> 24));
			_tmp$27 = (((val >>> 8 >>> 0) << 24 >>> 24));
			_tmp$28 = (((val >>> 16 >>> 0) << 24 >>> 24));
			dbuf[2] = _tmp$26;
			dbuf[1] = _tmp$27;
			dbuf[0] = _tmp$28;
			_2 = dlen;
			if (_2 === (4)) {
				(2 >= dst.$length ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + 2] = dbuf[2]);
				dbuf[2] = 0;
				(1 >= dst.$length ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + 1] = dbuf[1]);
				if (enc.strict && !((dbuf[2] === 0))) {
					_tmp$29 = n;
					_tmp$30 = end;
					_tmp$31 = (new CorruptInputError(0, (si - 1 >> 0)));
					n = _tmp$29;
					end = _tmp$30;
					err = _tmp$31;
					return [n, end, err];
				}
				dbuf[1] = 0;
				(0 >= dst.$length ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + 0] = dbuf[0]);
				if (enc.strict && (!((dbuf[1] === 0)) || !((dbuf[2] === 0)))) {
					_tmp$32 = n;
					_tmp$33 = end;
					_tmp$34 = (new CorruptInputError(0, (si - 2 >> 0)));
					n = _tmp$32;
					end = _tmp$33;
					err = _tmp$34;
					return [n, end, err];
				}
			} else if (_2 === (3)) {
				(1 >= dst.$length ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + 1] = dbuf[1]);
				if (enc.strict && !((dbuf[2] === 0))) {
					_tmp$35 = n;
					_tmp$36 = end;
					_tmp$37 = (new CorruptInputError(0, (si - 1 >> 0)));
					n = _tmp$35;
					end = _tmp$36;
					err = _tmp$37;
					return [n, end, err];
				}
				dbuf[1] = 0;
				(0 >= dst.$length ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + 0] = dbuf[0]);
				if (enc.strict && (!((dbuf[1] === 0)) || !((dbuf[2] === 0)))) {
					_tmp$38 = n;
					_tmp$39 = end;
					_tmp$40 = (new CorruptInputError(0, (si - 2 >> 0)));
					n = _tmp$38;
					end = _tmp$39;
					err = _tmp$40;
					return [n, end, err];
				}
			} else if (_2 === (2)) {
				(0 >= dst.$length ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + 0] = dbuf[0]);
				if (enc.strict && (!((dbuf[1] === 0)) || !((dbuf[2] === 0)))) {
					_tmp$41 = n;
					_tmp$42 = end;
					_tmp$43 = (new CorruptInputError(0, (si - 2 >> 0)));
					n = _tmp$41;
					end = _tmp$42;
					err = _tmp$43;
					return [n, end, err];
				}
			}
			dst = $subslice(dst, dinc);
			n = n + ((dlen - 1 >> 0)) >> 0;
		}
		_tmp$44 = n;
		_tmp$45 = end;
		_tmp$46 = err;
		n = _tmp$44;
		end = _tmp$45;
		err = _tmp$46;
		return [n, end, err];
	};
	Encoding.prototype.decode = function(dst, src) { return this.$val.decode(dst, src); };
	Encoding.ptr.prototype.Decode = function(dst, src) {
		var _tuple, dst, enc, err, n, src;
		n = 0;
		err = $ifaceNil;
		enc = this;
		_tuple = enc.decode(dst, src);
		n = _tuple[0];
		err = _tuple[2];
		return [n, err];
	};
	Encoding.prototype.Decode = function(dst, src) { return this.$val.Decode(dst, src); };
	Encoding.ptr.prototype.DecodeString = function(s) {
		var _tuple, dbuf, enc, err, n, s;
		enc = this;
		dbuf = $makeSlice(sliceType, enc.DecodedLen(s.length));
		_tuple = enc.decode(dbuf, (new sliceType($stringToBytes(s))));
		n = _tuple[0];
		err = _tuple[2];
		return [$subslice(dbuf, 0, n), err];
	};
	Encoding.prototype.DecodeString = function(s) { return this.$val.DecodeString(s); };
	Encoding.ptr.prototype.DecodedLen = function(n) {
		var _q, _q$1, enc, n;
		enc = this;
		if (enc.padChar === -1) {
			return (_q = ($imul(n, 6)) / 8, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		}
		return $imul((_q$1 = n / 4, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")), 3);
	};
	Encoding.prototype.DecodedLen = function(n) { return this.$val.DecodedLen(n); };
	Encoding.methods = [{prop: "WithPadding", name: "WithPadding", pkg: "", typ: $funcType([$Int32], [ptrType], false)}, {prop: "Strict", name: "Strict", pkg: "", typ: $funcType([], [ptrType], false)}];
	ptrType.methods = [{prop: "Encode", name: "Encode", pkg: "", typ: $funcType([sliceType, sliceType], [], false)}, {prop: "EncodeToString", name: "EncodeToString", pkg: "", typ: $funcType([sliceType], [$String], false)}, {prop: "EncodedLen", name: "EncodedLen", pkg: "", typ: $funcType([$Int], [$Int], false)}, {prop: "decode", name: "decode", pkg: "encoding/base64", typ: $funcType([sliceType, sliceType], [$Int, $Bool, $error], false)}, {prop: "Decode", name: "Decode", pkg: "", typ: $funcType([sliceType, sliceType], [$Int, $error], false)}, {prop: "DecodeString", name: "DecodeString", pkg: "", typ: $funcType([$String], [sliceType, $error], false)}, {prop: "DecodedLen", name: "DecodedLen", pkg: "", typ: $funcType([$Int], [$Int], false)}];
	ptrType$1.methods = [{prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "Close", name: "Close", pkg: "", typ: $funcType([], [$error], false)}];
	CorruptInputError.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	Encoding.init("encoding/base64", [{prop: "encode", name: "encode", anonymous: false, exported: false, typ: arrayType, tag: ""}, {prop: "decodeMap", name: "decodeMap", anonymous: false, exported: false, typ: arrayType$1, tag: ""}, {prop: "padChar", name: "padChar", anonymous: false, exported: false, typ: $Int32, tag: ""}, {prop: "strict", name: "strict", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	encoder.init("encoding/base64", [{prop: "err", name: "err", anonymous: false, exported: false, typ: $error, tag: ""}, {prop: "enc", name: "enc", anonymous: false, exported: false, typ: ptrType, tag: ""}, {prop: "w", name: "w", anonymous: false, exported: false, typ: io.Writer, tag: ""}, {prop: "buf", name: "buf", anonymous: false, exported: false, typ: arrayType$2, tag: ""}, {prop: "nbuf", name: "nbuf", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "out", name: "out", anonymous: false, exported: false, typ: arrayType$3, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = io.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.StdEncoding = NewEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
		$pkg.URLEncoding = NewEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_");
		$pkg.RawStdEncoding = $clone($pkg.StdEncoding, Encoding).WithPadding(-1);
		$pkg.RawURLEncoding = $clone($pkg.URLEncoding, Encoding).WithPadding(-1);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["sort"] = (function() {
	var $pkg = {}, $init, reflect, lessSwap, funcType, funcType$1, insertionSort, siftDown, heapSort, medianOfThree, doPivot, quickSort, Sort, maxDepth, Slice, insertionSort_func, siftDown_func, heapSort_func, medianOfThree_func, doPivot_func, quickSort_func;
	reflect = $packages["reflect"];
	lessSwap = $pkg.lessSwap = $newType(0, $kindStruct, "sort.lessSwap", true, "sort", false, function(Less_, Swap_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Less = $throwNilPointerError;
			this.Swap = $throwNilPointerError;
			return;
		}
		this.Less = Less_;
		this.Swap = Swap_;
	});
	funcType = $funcType([$Int, $Int], [$Bool], false);
	funcType$1 = $funcType([$Int, $Int], [], false);
	insertionSort = function(data, a, b) {
		var _r, _v, a, b, data, i, j, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _v = $f._v; a = $f.a; b = $f.b; data = $f.data; i = $f.i; j = $f.j; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = a + 1 >> 0;
		/* while (true) { */ case 1:
			/* if (!(i < b)) { break; } */ if(!(i < b)) { $s = 2; continue; }
			j = i;
			/* while (true) { */ case 3:
				if (!(j > a)) { _v = false; $s = 5; continue s; }
				_r = data.Less(j, j - 1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_v = _r; case 5:
				/* if (!(_v)) { break; } */ if(!(_v)) { $s = 4; continue; }
				$r = data.Swap(j, j - 1 >> 0); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				j = j - (1) >> 0;
			/* } */ $s = 3; continue; case 4:
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: insertionSort }; } $f._r = _r; $f._v = _v; $f.a = a; $f.b = b; $f.data = data; $f.i = i; $f.j = j; $f.$s = $s; $f.$r = $r; return $f;
	};
	siftDown = function(data, lo, hi, first) {
		var _r, _r$1, _v, child, data, first, hi, lo, root, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _v = $f._v; child = $f.child; data = $f.data; first = $f.first; hi = $f.hi; lo = $f.lo; root = $f.root; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		root = lo;
		/* while (true) { */ case 1:
			child = ($imul(2, root)) + 1 >> 0;
			if (child >= hi) {
				/* break; */ $s = 2; continue;
			}
			if (!((child + 1 >> 0) < hi)) { _v = false; $s = 5; continue s; }
			_r = data.Less(first + child >> 0, (first + child >> 0) + 1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_v = _r; case 5:
			/* */ if (_v) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_v) { */ case 3:
				child = child + (1) >> 0;
			/* } */ case 4:
			_r$1 = data.Less(first + root >> 0, first + child >> 0); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (!_r$1) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!_r$1) { */ case 7:
				$s = -1; return;
			/* } */ case 8:
			$r = data.Swap(first + root >> 0, first + child >> 0); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			root = child;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: siftDown }; } $f._r = _r; $f._r$1 = _r$1; $f._v = _v; $f.child = child; $f.data = data; $f.first = first; $f.hi = hi; $f.lo = lo; $f.root = root; $f.$s = $s; $f.$r = $r; return $f;
	};
	heapSort = function(data, a, b) {
		var _q, a, b, data, first, hi, i, i$1, lo, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; a = $f.a; b = $f.b; data = $f.data; first = $f.first; hi = $f.hi; i = $f.i; i$1 = $f.i$1; lo = $f.lo; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		first = a;
		lo = 0;
		hi = b - a >> 0;
		i = (_q = ((hi - 1 >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		/* while (true) { */ case 1:
			/* if (!(i >= 0)) { break; } */ if(!(i >= 0)) { $s = 2; continue; }
			$r = siftDown(data, i, hi, first); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i = i - (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		i$1 = hi - 1 >> 0;
		/* while (true) { */ case 4:
			/* if (!(i$1 >= 0)) { break; } */ if(!(i$1 >= 0)) { $s = 5; continue; }
			$r = data.Swap(first, first + i$1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = siftDown(data, lo, i$1, first); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i$1 = i$1 - (1) >> 0;
		/* } */ $s = 4; continue; case 5:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: heapSort }; } $f._q = _q; $f.a = a; $f.b = b; $f.data = data; $f.first = first; $f.hi = hi; $f.i = i; $f.i$1 = i$1; $f.lo = lo; $f.$s = $s; $f.$r = $r; return $f;
	};
	medianOfThree = function(data, m1, m0, m2) {
		var _r, _r$1, _r$2, data, m0, m1, m2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; data = $f.data; m0 = $f.m0; m1 = $f.m1; m2 = $f.m2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = data.Less(m1, m0); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r) { */ case 1:
			$r = data.Swap(m1, m0); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		_r$1 = data.Less(m2, m1); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (_r$1) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (_r$1) { */ case 5:
			$r = data.Swap(m2, m1); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$2 = data.Less(m1, m0); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			/* */ if (_r$2) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_r$2) { */ case 9:
				$r = data.Swap(m1, m0); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 10:
		/* } */ case 6:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: medianOfThree }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.data = data; $f.m0 = m0; $f.m1 = m1; $f.m2 = m2; $f.$s = $s; $f.$r = $r; return $f;
	};
	doPivot = function(data, lo, hi) {
		var _q, _q$1, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _tmp, _tmp$1, _tmp$2, _tmp$3, _v, _v$1, _v$2, _v$3, _v$4, a, b, c, data, dups, hi, lo, m, midhi, midlo, pivot, protect, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _q$1 = $f._q$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; _v$3 = $f._v$3; _v$4 = $f._v$4; a = $f.a; b = $f.b; c = $f.c; data = $f.data; dups = $f.dups; hi = $f.hi; lo = $f.lo; m = $f.m; midhi = $f.midhi; midlo = $f.midlo; pivot = $f.pivot; protect = $f.protect; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		midlo = 0;
		midhi = 0;
		m = ((((((lo + hi >> 0) >>> 0)) >>> 1 >>> 0) >> 0));
		/* */ if ((hi - lo >> 0) > 40) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((hi - lo >> 0) > 40) { */ case 1:
			s = (_q = ((hi - lo >> 0)) / 8, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
			$r = medianOfThree(data, lo, lo + s >> 0, lo + ($imul(2, s)) >> 0); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = medianOfThree(data, m, m - s >> 0, m + s >> 0); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = medianOfThree(data, hi - 1 >> 0, (hi - 1 >> 0) - s >> 0, (hi - 1 >> 0) - ($imul(2, s)) >> 0); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		$r = medianOfThree(data, lo, m, hi - 1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		pivot = lo;
		_tmp = lo + 1 >> 0;
		_tmp$1 = hi - 1 >> 0;
		a = _tmp;
		c = _tmp$1;
		/* while (true) { */ case 7:
			if (!(a < c)) { _v = false; $s = 9; continue s; }
			_r = data.Less(a, pivot); /* */ $s = 10; case 10: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_v = _r; case 9:
			/* if (!(_v)) { break; } */ if(!(_v)) { $s = 8; continue; }
			a = a + (1) >> 0;
		/* } */ $s = 7; continue; case 8:
		b = a;
		/* while (true) { */ case 11:
			/* while (true) { */ case 13:
				if (!(b < c)) { _v$1 = false; $s = 15; continue s; }
				_r$1 = data.Less(pivot, b); /* */ $s = 16; case 16: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_v$1 = !_r$1; case 15:
				/* if (!(_v$1)) { break; } */ if(!(_v$1)) { $s = 14; continue; }
				b = b + (1) >> 0;
			/* } */ $s = 13; continue; case 14:
			/* while (true) { */ case 17:
				if (!(b < c)) { _v$2 = false; $s = 19; continue s; }
				_r$2 = data.Less(pivot, c - 1 >> 0); /* */ $s = 20; case 20: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_v$2 = _r$2; case 19:
				/* if (!(_v$2)) { break; } */ if(!(_v$2)) { $s = 18; continue; }
				c = c - (1) >> 0;
			/* } */ $s = 17; continue; case 18:
			if (b >= c) {
				/* break; */ $s = 12; continue;
			}
			$r = data.Swap(b, c - 1 >> 0); /* */ $s = 21; case 21: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			b = b + (1) >> 0;
			c = c - (1) >> 0;
		/* } */ $s = 11; continue; case 12:
		protect = (hi - c >> 0) < 5;
		/* */ if (!protect && (hi - c >> 0) < (_q$1 = ((hi - lo >> 0)) / 4, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"))) { $s = 22; continue; }
		/* */ $s = 23; continue;
		/* if (!protect && (hi - c >> 0) < (_q$1 = ((hi - lo >> 0)) / 4, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"))) { */ case 22:
			dups = 0;
			_r$3 = data.Less(pivot, hi - 1 >> 0); /* */ $s = 26; case 26: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			/* */ if (!_r$3) { $s = 24; continue; }
			/* */ $s = 25; continue;
			/* if (!_r$3) { */ case 24:
				$r = data.Swap(c, hi - 1 >> 0); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				c = c + (1) >> 0;
				dups = dups + (1) >> 0;
			/* } */ case 25:
			_r$4 = data.Less(b - 1 >> 0, pivot); /* */ $s = 30; case 30: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			/* */ if (!_r$4) { $s = 28; continue; }
			/* */ $s = 29; continue;
			/* if (!_r$4) { */ case 28:
				b = b - (1) >> 0;
				dups = dups + (1) >> 0;
			/* } */ case 29:
			_r$5 = data.Less(m, pivot); /* */ $s = 33; case 33: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			/* */ if (!_r$5) { $s = 31; continue; }
			/* */ $s = 32; continue;
			/* if (!_r$5) { */ case 31:
				$r = data.Swap(m, b - 1 >> 0); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				b = b - (1) >> 0;
				dups = dups + (1) >> 0;
			/* } */ case 32:
			protect = dups > 1;
		/* } */ case 23:
		/* */ if (protect) { $s = 35; continue; }
		/* */ $s = 36; continue;
		/* if (protect) { */ case 35:
			/* while (true) { */ case 37:
				/* while (true) { */ case 39:
					if (!(a < b)) { _v$3 = false; $s = 41; continue s; }
					_r$6 = data.Less(b - 1 >> 0, pivot); /* */ $s = 42; case 42: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
					_v$3 = !_r$6; case 41:
					/* if (!(_v$3)) { break; } */ if(!(_v$3)) { $s = 40; continue; }
					b = b - (1) >> 0;
				/* } */ $s = 39; continue; case 40:
				/* while (true) { */ case 43:
					if (!(a < b)) { _v$4 = false; $s = 45; continue s; }
					_r$7 = data.Less(a, pivot); /* */ $s = 46; case 46: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
					_v$4 = _r$7; case 45:
					/* if (!(_v$4)) { break; } */ if(!(_v$4)) { $s = 44; continue; }
					a = a + (1) >> 0;
				/* } */ $s = 43; continue; case 44:
				if (a >= b) {
					/* break; */ $s = 38; continue;
				}
				$r = data.Swap(a, b - 1 >> 0); /* */ $s = 47; case 47: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				a = a + (1) >> 0;
				b = b - (1) >> 0;
			/* } */ $s = 37; continue; case 38:
		/* } */ case 36:
		$r = data.Swap(pivot, b - 1 >> 0); /* */ $s = 48; case 48: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_tmp$2 = b - 1 >> 0;
		_tmp$3 = c;
		midlo = _tmp$2;
		midhi = _tmp$3;
		$s = -1; return [midlo, midhi];
		/* */ } return; } if ($f === undefined) { $f = { $blk: doPivot }; } $f._q = _q; $f._q$1 = _q$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f._v$3 = _v$3; $f._v$4 = _v$4; $f.a = a; $f.b = b; $f.c = c; $f.data = data; $f.dups = dups; $f.hi = hi; $f.lo = lo; $f.m = m; $f.midhi = midhi; $f.midlo = midlo; $f.pivot = pivot; $f.protect = protect; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	quickSort = function(data, a, b, maxDepth$1) {
		var _r, _r$1, _tuple, a, b, data, i, maxDepth$1, mhi, mlo, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; a = $f.a; b = $f.b; data = $f.data; i = $f.i; maxDepth$1 = $f.maxDepth$1; mhi = $f.mhi; mlo = $f.mlo; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* while (true) { */ case 1:
			/* if (!((b - a >> 0) > 12)) { break; } */ if(!((b - a >> 0) > 12)) { $s = 2; continue; }
			/* */ if (maxDepth$1 === 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (maxDepth$1 === 0) { */ case 3:
				$r = heapSort(data, a, b); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return;
			/* } */ case 4:
			maxDepth$1 = maxDepth$1 - (1) >> 0;
			_r = doPivot(data, a, b); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			mlo = _tuple[0];
			mhi = _tuple[1];
			/* */ if ((mlo - a >> 0) < (b - mhi >> 0)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if ((mlo - a >> 0) < (b - mhi >> 0)) { */ case 7:
				$r = quickSort(data, a, mlo, maxDepth$1); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				a = mhi;
				$s = 9; continue;
			/* } else { */ case 8:
				$r = quickSort(data, mhi, b, maxDepth$1); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				b = mlo;
			/* } */ case 9:
		/* } */ $s = 1; continue; case 2:
		/* */ if ((b - a >> 0) > 1) { $s = 12; continue; }
		/* */ $s = 13; continue;
		/* if ((b - a >> 0) > 1) { */ case 12:
			i = a + 6 >> 0;
			/* while (true) { */ case 14:
				/* if (!(i < b)) { break; } */ if(!(i < b)) { $s = 15; continue; }
				_r$1 = data.Less(i, i - 6 >> 0); /* */ $s = 18; case 18: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				/* */ if (_r$1) { $s = 16; continue; }
				/* */ $s = 17; continue;
				/* if (_r$1) { */ case 16:
					$r = data.Swap(i, i - 6 >> 0); /* */ $s = 19; case 19: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 17:
				i = i + (1) >> 0;
			/* } */ $s = 14; continue; case 15:
			$r = insertionSort(data, a, b); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 13:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: quickSort }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.a = a; $f.b = b; $f.data = data; $f.i = i; $f.maxDepth$1 = maxDepth$1; $f.mhi = mhi; $f.mlo = mlo; $f.$s = $s; $f.$r = $r; return $f;
	};
	Sort = function(data) {
		var _r, data, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; data = $f.data; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = data.Len(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		n = _r;
		$r = quickSort(data, 0, n, maxDepth(n)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Sort }; } $f._r = _r; $f.data = data; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Sort = Sort;
	maxDepth = function(n) {
		var depth, i, n;
		depth = 0;
		i = n;
		while (true) {
			if (!(i > 0)) { break; }
			depth = depth + (1) >> 0;
			i = (i >> $min((1), 31)) >> 0;
		}
		return $imul(depth, 2);
	};
	Slice = function(slice, less) {
		var _r, _r$1, length, less, rv, slice, swap, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; length = $f.length; less = $f.less; rv = $f.rv; slice = $f.slice; swap = $f.swap; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = reflect.ValueOf(slice); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		rv = _r;
		_r$1 = reflect.Swapper(slice); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		swap = _r$1;
		length = $clone(rv, reflect.Value).Len();
		$r = quickSort_func(new lessSwap.ptr(less, swap), 0, length, maxDepth(length)); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Slice }; } $f._r = _r; $f._r$1 = _r$1; $f.length = length; $f.less = less; $f.rv = rv; $f.slice = slice; $f.swap = swap; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Slice = Slice;
	insertionSort_func = function(data, a, b) {
		var _r, _v, a, b, data, i, j, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _v = $f._v; a = $f.a; b = $f.b; data = $f.data; i = $f.i; j = $f.j; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = a + 1 >> 0;
		/* while (true) { */ case 1:
			/* if (!(i < b)) { break; } */ if(!(i < b)) { $s = 2; continue; }
			j = i;
			/* while (true) { */ case 3:
				if (!(j > a)) { _v = false; $s = 5; continue s; }
				_r = data.Less(j, j - 1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_v = _r; case 5:
				/* if (!(_v)) { break; } */ if(!(_v)) { $s = 4; continue; }
				$r = data.Swap(j, j - 1 >> 0); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				j = j - (1) >> 0;
			/* } */ $s = 3; continue; case 4:
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: insertionSort_func }; } $f._r = _r; $f._v = _v; $f.a = a; $f.b = b; $f.data = data; $f.i = i; $f.j = j; $f.$s = $s; $f.$r = $r; return $f;
	};
	siftDown_func = function(data, lo, hi, first) {
		var _r, _r$1, _v, child, data, first, hi, lo, root, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _v = $f._v; child = $f.child; data = $f.data; first = $f.first; hi = $f.hi; lo = $f.lo; root = $f.root; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		root = lo;
		/* while (true) { */ case 1:
			child = ($imul(2, root)) + 1 >> 0;
			if (child >= hi) {
				/* break; */ $s = 2; continue;
			}
			if (!((child + 1 >> 0) < hi)) { _v = false; $s = 5; continue s; }
			_r = data.Less(first + child >> 0, (first + child >> 0) + 1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_v = _r; case 5:
			/* */ if (_v) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_v) { */ case 3:
				child = child + (1) >> 0;
			/* } */ case 4:
			_r$1 = data.Less(first + root >> 0, first + child >> 0); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (!_r$1) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!_r$1) { */ case 7:
				$s = -1; return;
			/* } */ case 8:
			$r = data.Swap(first + root >> 0, first + child >> 0); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			root = child;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: siftDown_func }; } $f._r = _r; $f._r$1 = _r$1; $f._v = _v; $f.child = child; $f.data = data; $f.first = first; $f.hi = hi; $f.lo = lo; $f.root = root; $f.$s = $s; $f.$r = $r; return $f;
	};
	heapSort_func = function(data, a, b) {
		var _q, a, b, data, first, hi, i, i$1, lo, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; a = $f.a; b = $f.b; data = $f.data; first = $f.first; hi = $f.hi; i = $f.i; i$1 = $f.i$1; lo = $f.lo; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		first = a;
		lo = 0;
		hi = b - a >> 0;
		i = (_q = ((hi - 1 >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		/* while (true) { */ case 1:
			/* if (!(i >= 0)) { break; } */ if(!(i >= 0)) { $s = 2; continue; }
			$r = siftDown_func($clone(data, lessSwap), i, hi, first); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i = i - (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		i$1 = hi - 1 >> 0;
		/* while (true) { */ case 4:
			/* if (!(i$1 >= 0)) { break; } */ if(!(i$1 >= 0)) { $s = 5; continue; }
			$r = data.Swap(first, first + i$1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = siftDown_func($clone(data, lessSwap), lo, i$1, first); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i$1 = i$1 - (1) >> 0;
		/* } */ $s = 4; continue; case 5:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: heapSort_func }; } $f._q = _q; $f.a = a; $f.b = b; $f.data = data; $f.first = first; $f.hi = hi; $f.i = i; $f.i$1 = i$1; $f.lo = lo; $f.$s = $s; $f.$r = $r; return $f;
	};
	medianOfThree_func = function(data, m1, m0, m2) {
		var _r, _r$1, _r$2, data, m0, m1, m2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; data = $f.data; m0 = $f.m0; m1 = $f.m1; m2 = $f.m2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = data.Less(m1, m0); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r) { */ case 1:
			$r = data.Swap(m1, m0); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		_r$1 = data.Less(m2, m1); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (_r$1) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (_r$1) { */ case 5:
			$r = data.Swap(m2, m1); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$2 = data.Less(m1, m0); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			/* */ if (_r$2) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_r$2) { */ case 9:
				$r = data.Swap(m1, m0); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 10:
		/* } */ case 6:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: medianOfThree_func }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.data = data; $f.m0 = m0; $f.m1 = m1; $f.m2 = m2; $f.$s = $s; $f.$r = $r; return $f;
	};
	doPivot_func = function(data, lo, hi) {
		var _q, _q$1, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _tmp, _tmp$1, _tmp$2, _tmp$3, _v, _v$1, _v$2, _v$3, _v$4, a, b, c, data, dups, hi, lo, m, midhi, midlo, pivot, protect, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _q$1 = $f._q$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; _v$3 = $f._v$3; _v$4 = $f._v$4; a = $f.a; b = $f.b; c = $f.c; data = $f.data; dups = $f.dups; hi = $f.hi; lo = $f.lo; m = $f.m; midhi = $f.midhi; midlo = $f.midlo; pivot = $f.pivot; protect = $f.protect; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		midlo = 0;
		midhi = 0;
		m = ((((((lo + hi >> 0) >>> 0)) >>> 1 >>> 0) >> 0));
		/* */ if ((hi - lo >> 0) > 40) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((hi - lo >> 0) > 40) { */ case 1:
			s = (_q = ((hi - lo >> 0)) / 8, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
			$r = medianOfThree_func($clone(data, lessSwap), lo, lo + s >> 0, lo + ($imul(2, s)) >> 0); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = medianOfThree_func($clone(data, lessSwap), m, m - s >> 0, m + s >> 0); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = medianOfThree_func($clone(data, lessSwap), hi - 1 >> 0, (hi - 1 >> 0) - s >> 0, (hi - 1 >> 0) - ($imul(2, s)) >> 0); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		$r = medianOfThree_func($clone(data, lessSwap), lo, m, hi - 1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		pivot = lo;
		_tmp = lo + 1 >> 0;
		_tmp$1 = hi - 1 >> 0;
		a = _tmp;
		c = _tmp$1;
		/* while (true) { */ case 7:
			if (!(a < c)) { _v = false; $s = 9; continue s; }
			_r = data.Less(a, pivot); /* */ $s = 10; case 10: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_v = _r; case 9:
			/* if (!(_v)) { break; } */ if(!(_v)) { $s = 8; continue; }
			a = a + (1) >> 0;
		/* } */ $s = 7; continue; case 8:
		b = a;
		/* while (true) { */ case 11:
			/* while (true) { */ case 13:
				if (!(b < c)) { _v$1 = false; $s = 15; continue s; }
				_r$1 = data.Less(pivot, b); /* */ $s = 16; case 16: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_v$1 = !_r$1; case 15:
				/* if (!(_v$1)) { break; } */ if(!(_v$1)) { $s = 14; continue; }
				b = b + (1) >> 0;
			/* } */ $s = 13; continue; case 14:
			/* while (true) { */ case 17:
				if (!(b < c)) { _v$2 = false; $s = 19; continue s; }
				_r$2 = data.Less(pivot, c - 1 >> 0); /* */ $s = 20; case 20: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_v$2 = _r$2; case 19:
				/* if (!(_v$2)) { break; } */ if(!(_v$2)) { $s = 18; continue; }
				c = c - (1) >> 0;
			/* } */ $s = 17; continue; case 18:
			if (b >= c) {
				/* break; */ $s = 12; continue;
			}
			$r = data.Swap(b, c - 1 >> 0); /* */ $s = 21; case 21: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			b = b + (1) >> 0;
			c = c - (1) >> 0;
		/* } */ $s = 11; continue; case 12:
		protect = (hi - c >> 0) < 5;
		/* */ if (!protect && (hi - c >> 0) < (_q$1 = ((hi - lo >> 0)) / 4, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"))) { $s = 22; continue; }
		/* */ $s = 23; continue;
		/* if (!protect && (hi - c >> 0) < (_q$1 = ((hi - lo >> 0)) / 4, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"))) { */ case 22:
			dups = 0;
			_r$3 = data.Less(pivot, hi - 1 >> 0); /* */ $s = 26; case 26: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			/* */ if (!_r$3) { $s = 24; continue; }
			/* */ $s = 25; continue;
			/* if (!_r$3) { */ case 24:
				$r = data.Swap(c, hi - 1 >> 0); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				c = c + (1) >> 0;
				dups = dups + (1) >> 0;
			/* } */ case 25:
			_r$4 = data.Less(b - 1 >> 0, pivot); /* */ $s = 30; case 30: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			/* */ if (!_r$4) { $s = 28; continue; }
			/* */ $s = 29; continue;
			/* if (!_r$4) { */ case 28:
				b = b - (1) >> 0;
				dups = dups + (1) >> 0;
			/* } */ case 29:
			_r$5 = data.Less(m, pivot); /* */ $s = 33; case 33: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			/* */ if (!_r$5) { $s = 31; continue; }
			/* */ $s = 32; continue;
			/* if (!_r$5) { */ case 31:
				$r = data.Swap(m, b - 1 >> 0); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				b = b - (1) >> 0;
				dups = dups + (1) >> 0;
			/* } */ case 32:
			protect = dups > 1;
		/* } */ case 23:
		/* */ if (protect) { $s = 35; continue; }
		/* */ $s = 36; continue;
		/* if (protect) { */ case 35:
			/* while (true) { */ case 37:
				/* while (true) { */ case 39:
					if (!(a < b)) { _v$3 = false; $s = 41; continue s; }
					_r$6 = data.Less(b - 1 >> 0, pivot); /* */ $s = 42; case 42: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
					_v$3 = !_r$6; case 41:
					/* if (!(_v$3)) { break; } */ if(!(_v$3)) { $s = 40; continue; }
					b = b - (1) >> 0;
				/* } */ $s = 39; continue; case 40:
				/* while (true) { */ case 43:
					if (!(a < b)) { _v$4 = false; $s = 45; continue s; }
					_r$7 = data.Less(a, pivot); /* */ $s = 46; case 46: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
					_v$4 = _r$7; case 45:
					/* if (!(_v$4)) { break; } */ if(!(_v$4)) { $s = 44; continue; }
					a = a + (1) >> 0;
				/* } */ $s = 43; continue; case 44:
				if (a >= b) {
					/* break; */ $s = 38; continue;
				}
				$r = data.Swap(a, b - 1 >> 0); /* */ $s = 47; case 47: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				a = a + (1) >> 0;
				b = b - (1) >> 0;
			/* } */ $s = 37; continue; case 38:
		/* } */ case 36:
		$r = data.Swap(pivot, b - 1 >> 0); /* */ $s = 48; case 48: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_tmp$2 = b - 1 >> 0;
		_tmp$3 = c;
		midlo = _tmp$2;
		midhi = _tmp$3;
		$s = -1; return [midlo, midhi];
		/* */ } return; } if ($f === undefined) { $f = { $blk: doPivot_func }; } $f._q = _q; $f._q$1 = _q$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f._v$3 = _v$3; $f._v$4 = _v$4; $f.a = a; $f.b = b; $f.c = c; $f.data = data; $f.dups = dups; $f.hi = hi; $f.lo = lo; $f.m = m; $f.midhi = midhi; $f.midlo = midlo; $f.pivot = pivot; $f.protect = protect; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	quickSort_func = function(data, a, b, maxDepth$1) {
		var _r, _r$1, _tuple, a, b, data, i, maxDepth$1, mhi, mlo, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; a = $f.a; b = $f.b; data = $f.data; i = $f.i; maxDepth$1 = $f.maxDepth$1; mhi = $f.mhi; mlo = $f.mlo; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* while (true) { */ case 1:
			/* if (!((b - a >> 0) > 12)) { break; } */ if(!((b - a >> 0) > 12)) { $s = 2; continue; }
			/* */ if (maxDepth$1 === 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (maxDepth$1 === 0) { */ case 3:
				$r = heapSort_func($clone(data, lessSwap), a, b); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return;
			/* } */ case 4:
			maxDepth$1 = maxDepth$1 - (1) >> 0;
			_r = doPivot_func($clone(data, lessSwap), a, b); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			mlo = _tuple[0];
			mhi = _tuple[1];
			/* */ if ((mlo - a >> 0) < (b - mhi >> 0)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if ((mlo - a >> 0) < (b - mhi >> 0)) { */ case 7:
				$r = quickSort_func($clone(data, lessSwap), a, mlo, maxDepth$1); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				a = mhi;
				$s = 9; continue;
			/* } else { */ case 8:
				$r = quickSort_func($clone(data, lessSwap), mhi, b, maxDepth$1); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				b = mlo;
			/* } */ case 9:
		/* } */ $s = 1; continue; case 2:
		/* */ if ((b - a >> 0) > 1) { $s = 12; continue; }
		/* */ $s = 13; continue;
		/* if ((b - a >> 0) > 1) { */ case 12:
			i = a + 6 >> 0;
			/* while (true) { */ case 14:
				/* if (!(i < b)) { break; } */ if(!(i < b)) { $s = 15; continue; }
				_r$1 = data.Less(i, i - 6 >> 0); /* */ $s = 18; case 18: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				/* */ if (_r$1) { $s = 16; continue; }
				/* */ $s = 17; continue;
				/* if (_r$1) { */ case 16:
					$r = data.Swap(i, i - 6 >> 0); /* */ $s = 19; case 19: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 17:
				i = i + (1) >> 0;
			/* } */ $s = 14; continue; case 15:
			$r = insertionSort_func($clone(data, lessSwap), a, b); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 13:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: quickSort_func }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.a = a; $f.b = b; $f.data = data; $f.i = i; $f.maxDepth$1 = maxDepth$1; $f.mhi = mhi; $f.mlo = mlo; $f.$s = $s; $f.$r = $r; return $f;
	};
	lessSwap.init("", [{prop: "Less", name: "Less", anonymous: false, exported: true, typ: funcType, tag: ""}, {prop: "Swap", name: "Swap", anonymous: false, exported: true, typ: funcType$1, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = reflect.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["unicode/utf16"] = (function() {
	var $pkg = {}, $init;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["encoding/json"] = (function() {
	var $pkg = {}, $init, bytes, encoding, base64, errors, fmt, nosync, io, math, reflect, runtime, sort, strconv, strings, atomic, unicode, utf16, utf8, Number, Marshaler, UnsupportedTypeError, UnsupportedValueError, MarshalerError, encodeState, encOpts, encoderFunc, floatEncoder, structEncoder, mapEncoder, sliceEncoder, arrayEncoder, ptrEncoder, condAddrEncoder, reflectWithString, field, byIndex, SyntaxError, scanner, tagOptions, sliceType, structType, sliceType$1, ptrType, ptrType$1, ptrType$2, sliceType$2, ptrType$5, arrayType, ptrType$7, sliceType$3, sliceType$4, sliceType$5, mapType$1, ptrType$11, ptrType$15, ptrType$16, ptrType$18, ptrType$19, ptrType$20, ptrType$21, ptrType$22, ptrType$23, ptrType$24, ptrType$25, funcType, ptrType$26, funcType$1, errPhase, textUnmarshalerType, numberType, hex, encoderCache, marshalerType, textMarshalerType, float32Encoder, float64Encoder, fieldCache, safeSet, htmlSafeSet, _r, _r$1, _r$2, isValidNumber, Marshal, MarshalIndent, isEmptyValue, valueEncoder, typeEncoder, newTypeEncoder, invalidValueEncoder, marshalerEncoder, addrMarshalerEncoder, textMarshalerEncoder, addrTextMarshalerEncoder, boolEncoder, intEncoder, uintEncoder, stringEncoder, interfaceEncoder, unsupportedTypeEncoder, newStructEncoder, newMapEncoder, encodeByteSlice, newSliceEncoder, newArrayEncoder, newPtrEncoder, newCondAddrEncoder, isValidTag, fieldByIndex, typeByIndex, fillField, typeFields, isExported, dominantField, cachedTypeFields, foldFunc, equalFoldRight, asciiEqualFold, simpleLetterEqualFold, compact, newline, Indent, isSpace, stateBeginValueOrEmpty, stateBeginValue, stateBeginStringOrEmpty, stateBeginString, stateEndValue, stateEndTop, stateInString, stateInStringEsc, stateInStringEscU, stateInStringEscU1, stateInStringEscU12, stateInStringEscU123, stateNeg, state1, state0, stateDot, stateDot0, stateE, stateESign, stateE0, stateT, stateTr, stateTru, stateF, stateFa, stateFal, stateFals, stateN, stateNu, stateNul, stateError, quoteChar, parseTag;
	bytes = $packages["bytes"];
	encoding = $packages["encoding"];
	base64 = $packages["encoding/base64"];
	errors = $packages["errors"];
	fmt = $packages["fmt"];
	nosync = $packages["github.com/gopherjs/gopherjs/nosync"];
	io = $packages["io"];
	math = $packages["math"];
	reflect = $packages["reflect"];
	runtime = $packages["runtime"];
	sort = $packages["sort"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	atomic = $packages["sync/atomic"];
	unicode = $packages["unicode"];
	utf16 = $packages["unicode/utf16"];
	utf8 = $packages["unicode/utf8"];
	Number = $pkg.Number = $newType(8, $kindString, "json.Number", true, "encoding/json", true, null);
	Marshaler = $pkg.Marshaler = $newType(8, $kindInterface, "json.Marshaler", true, "encoding/json", true, null);
	UnsupportedTypeError = $pkg.UnsupportedTypeError = $newType(0, $kindStruct, "json.UnsupportedTypeError", true, "encoding/json", true, function(Type_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Type = $ifaceNil;
			return;
		}
		this.Type = Type_;
	});
	UnsupportedValueError = $pkg.UnsupportedValueError = $newType(0, $kindStruct, "json.UnsupportedValueError", true, "encoding/json", true, function(Value_, Str_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Value = new reflect.Value.ptr(ptrType$5.nil, 0, 0);
			this.Str = "";
			return;
		}
		this.Value = Value_;
		this.Str = Str_;
	});
	MarshalerError = $pkg.MarshalerError = $newType(0, $kindStruct, "json.MarshalerError", true, "encoding/json", true, function(Type_, Err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Type = $ifaceNil;
			this.Err = $ifaceNil;
			return;
		}
		this.Type = Type_;
		this.Err = Err_;
	});
	encodeState = $pkg.encodeState = $newType(0, $kindStruct, "json.encodeState", true, "encoding/json", false, function(Buffer_, scratch_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Buffer = new bytes.Buffer.ptr(sliceType$1.nil, 0, 0, arrayType.zero());
			this.scratch = arrayType.zero();
			return;
		}
		this.Buffer = Buffer_;
		this.scratch = scratch_;
	});
	encOpts = $pkg.encOpts = $newType(0, $kindStruct, "json.encOpts", true, "encoding/json", false, function(quoted_, escapeHTML_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.quoted = false;
			this.escapeHTML = false;
			return;
		}
		this.quoted = quoted_;
		this.escapeHTML = escapeHTML_;
	});
	encoderFunc = $pkg.encoderFunc = $newType(4, $kindFunc, "json.encoderFunc", true, "encoding/json", false, null);
	floatEncoder = $pkg.floatEncoder = $newType(4, $kindInt, "json.floatEncoder", true, "encoding/json", false, null);
	structEncoder = $pkg.structEncoder = $newType(0, $kindStruct, "json.structEncoder", true, "encoding/json", false, function(fields_, fieldEncs_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.fields = sliceType$3.nil;
			this.fieldEncs = sliceType$4.nil;
			return;
		}
		this.fields = fields_;
		this.fieldEncs = fieldEncs_;
	});
	mapEncoder = $pkg.mapEncoder = $newType(0, $kindStruct, "json.mapEncoder", true, "encoding/json", false, function(elemEnc_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.elemEnc = $throwNilPointerError;
			return;
		}
		this.elemEnc = elemEnc_;
	});
	sliceEncoder = $pkg.sliceEncoder = $newType(0, $kindStruct, "json.sliceEncoder", true, "encoding/json", false, function(arrayEnc_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.arrayEnc = $throwNilPointerError;
			return;
		}
		this.arrayEnc = arrayEnc_;
	});
	arrayEncoder = $pkg.arrayEncoder = $newType(0, $kindStruct, "json.arrayEncoder", true, "encoding/json", false, function(elemEnc_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.elemEnc = $throwNilPointerError;
			return;
		}
		this.elemEnc = elemEnc_;
	});
	ptrEncoder = $pkg.ptrEncoder = $newType(0, $kindStruct, "json.ptrEncoder", true, "encoding/json", false, function(elemEnc_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.elemEnc = $throwNilPointerError;
			return;
		}
		this.elemEnc = elemEnc_;
	});
	condAddrEncoder = $pkg.condAddrEncoder = $newType(0, $kindStruct, "json.condAddrEncoder", true, "encoding/json", false, function(canAddrEnc_, elseEnc_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.canAddrEnc = $throwNilPointerError;
			this.elseEnc = $throwNilPointerError;
			return;
		}
		this.canAddrEnc = canAddrEnc_;
		this.elseEnc = elseEnc_;
	});
	reflectWithString = $pkg.reflectWithString = $newType(0, $kindStruct, "json.reflectWithString", true, "encoding/json", false, function(v_, s_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.v = new reflect.Value.ptr(ptrType$5.nil, 0, 0);
			this.s = "";
			return;
		}
		this.v = v_;
		this.s = s_;
	});
	field = $pkg.field = $newType(0, $kindStruct, "json.field", true, "encoding/json", false, function(name_, nameBytes_, equalFold_, tag_, index_, typ_, omitEmpty_, quoted_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = "";
			this.nameBytes = sliceType$1.nil;
			this.equalFold = $throwNilPointerError;
			this.tag = false;
			this.index = sliceType$2.nil;
			this.typ = $ifaceNil;
			this.omitEmpty = false;
			this.quoted = false;
			return;
		}
		this.name = name_;
		this.nameBytes = nameBytes_;
		this.equalFold = equalFold_;
		this.tag = tag_;
		this.index = index_;
		this.typ = typ_;
		this.omitEmpty = omitEmpty_;
		this.quoted = quoted_;
	});
	byIndex = $pkg.byIndex = $newType(12, $kindSlice, "json.byIndex", true, "encoding/json", false, null);
	SyntaxError = $pkg.SyntaxError = $newType(0, $kindStruct, "json.SyntaxError", true, "encoding/json", true, function(msg_, Offset_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.msg = "";
			this.Offset = new $Int64(0, 0);
			return;
		}
		this.msg = msg_;
		this.Offset = Offset_;
	});
	scanner = $pkg.scanner = $newType(0, $kindStruct, "json.scanner", true, "encoding/json", false, function(step_, endTop_, parseState_, err_, redo_, redoCode_, redoState_, bytes_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.step = $throwNilPointerError;
			this.endTop = false;
			this.parseState = sliceType$2.nil;
			this.err = $ifaceNil;
			this.redo = false;
			this.redoCode = 0;
			this.redoState = $throwNilPointerError;
			this.bytes = new $Int64(0, 0);
			return;
		}
		this.step = step_;
		this.endTop = endTop_;
		this.parseState = parseState_;
		this.err = err_;
		this.redo = redo_;
		this.redoCode = redoCode_;
		this.redoState = redoState_;
		this.bytes = bytes_;
	});
	tagOptions = $pkg.tagOptions = $newType(8, $kindString, "json.tagOptions", true, "encoding/json", false, null);
	sliceType = $sliceType($emptyInterface);
	structType = $structType("encoding/json", [{prop: "value", name: "value", anonymous: false, exported: false, typ: atomic.Value, tag: ""}, {prop: "mu", name: "mu", anonymous: false, exported: false, typ: nosync.Mutex, tag: ""}]);
	sliceType$1 = $sliceType($Uint8);
	ptrType = $ptrType(encoding.TextUnmarshaler);
	ptrType$1 = $ptrType(Marshaler);
	ptrType$2 = $ptrType(encoding.TextMarshaler);
	sliceType$2 = $sliceType($Int);
	ptrType$5 = $ptrType(reflect.rtype);
	arrayType = $arrayType($Uint8, 64);
	ptrType$7 = $ptrType(encodeState);
	sliceType$3 = $sliceType(field);
	sliceType$4 = $sliceType(encoderFunc);
	sliceType$5 = $sliceType(reflectWithString);
	mapType$1 = $mapType(reflect.Type, sliceType$3);
	ptrType$11 = $ptrType(SyntaxError);
	ptrType$15 = $ptrType(UnsupportedTypeError);
	ptrType$16 = $ptrType(UnsupportedValueError);
	ptrType$18 = $ptrType(MarshalerError);
	ptrType$19 = $ptrType(structEncoder);
	ptrType$20 = $ptrType(mapEncoder);
	ptrType$21 = $ptrType(sliceEncoder);
	ptrType$22 = $ptrType(arrayEncoder);
	ptrType$23 = $ptrType(ptrEncoder);
	ptrType$24 = $ptrType(condAddrEncoder);
	ptrType$25 = $ptrType(reflectWithString);
	funcType = $funcType([sliceType$1, sliceType$1], [$Bool], false);
	ptrType$26 = $ptrType(scanner);
	funcType$1 = $funcType([ptrType$26, $Uint8], [$Int], false);
	Number.prototype.String = function() {
		var n;
		n = this.$val;
		return (n);
	};
	$ptrType(Number).prototype.String = function() { return new Number(this.$get()).String(); };
	Number.prototype.Float64 = function() {
		var n;
		n = this.$val;
		return strconv.ParseFloat((n), 64);
	};
	$ptrType(Number).prototype.Float64 = function() { return new Number(this.$get()).Float64(); };
	Number.prototype.Int64 = function() {
		var n;
		n = this.$val;
		return strconv.ParseInt((n), 10, 64);
	};
	$ptrType(Number).prototype.Int64 = function() { return new Number(this.$get()).Int64(); };
	isValidNumber = function(s) {
		var s;
		if (s === "") {
			return false;
		}
		if (s.charCodeAt(0) === 45) {
			s = $substring(s, 1);
			if (s === "") {
				return false;
			}
		}
		if ((s.charCodeAt(0) === 48)) {
			s = $substring(s, 1);
		} else if (49 <= s.charCodeAt(0) && s.charCodeAt(0) <= 57) {
			s = $substring(s, 1);
			while (true) {
				if (!(s.length > 0 && 48 <= s.charCodeAt(0) && s.charCodeAt(0) <= 57)) { break; }
				s = $substring(s, 1);
			}
		} else {
			return false;
		}
		if (s.length >= 2 && (s.charCodeAt(0) === 46) && 48 <= s.charCodeAt(1) && s.charCodeAt(1) <= 57) {
			s = $substring(s, 2);
			while (true) {
				if (!(s.length > 0 && 48 <= s.charCodeAt(0) && s.charCodeAt(0) <= 57)) { break; }
				s = $substring(s, 1);
			}
		}
		if (s.length >= 2 && ((s.charCodeAt(0) === 101) || (s.charCodeAt(0) === 69))) {
			s = $substring(s, 1);
			if ((s.charCodeAt(0) === 43) || (s.charCodeAt(0) === 45)) {
				s = $substring(s, 1);
				if (s === "") {
					return false;
				}
			}
			while (true) {
				if (!(s.length > 0 && 48 <= s.charCodeAt(0) && s.charCodeAt(0) <= 57)) { break; }
				s = $substring(s, 1);
			}
		}
		return s === "";
	};
	Marshal = function(v) {
		var _r$3, e, err, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; e = $f.e; err = $f.err; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = new encodeState.ptr(new bytes.Buffer.ptr(sliceType$1.nil, 0, 0, arrayType.zero()), arrayType.zero());
		_r$3 = e.marshal(v, new encOpts.ptr(false, true)); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		err = _r$3;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [sliceType$1.nil, err];
		}
		$s = -1; return [e.Buffer.Bytes(), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Marshal }; } $f._r$3 = _r$3; $f.e = e; $f.err = err; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Marshal = Marshal;
	MarshalIndent = function(v, prefix, indent) {
		var _r$3, _r$4, _tuple, b, buf, err, indent, prefix, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _r$4 = $f._r$4; _tuple = $f._tuple; b = $f.b; buf = $f.buf; err = $f.err; indent = $f.indent; prefix = $f.prefix; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		buf = [buf];
		_r$3 = Marshal(v); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_tuple = _r$3;
		b = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [sliceType$1.nil, err];
		}
		buf[0] = new bytes.Buffer.ptr(sliceType$1.nil, 0, 0, arrayType.zero());
		_r$4 = Indent(buf[0], b, prefix, indent); /* */ $s = 2; case 2: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		err = _r$4;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [sliceType$1.nil, err];
		}
		$s = -1; return [buf[0].Bytes(), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: MarshalIndent }; } $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tuple = _tuple; $f.b = b; $f.buf = buf; $f.err = err; $f.indent = indent; $f.prefix = prefix; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MarshalIndent = MarshalIndent;
	UnsupportedTypeError.ptr.prototype.Error = function() {
		var _r$3, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r$3 = e.Type.String(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		$s = -1; return "json: unsupported type: " + _r$3;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UnsupportedTypeError.ptr.prototype.Error }; } $f._r$3 = _r$3; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	UnsupportedTypeError.prototype.Error = function() { return this.$val.Error(); };
	UnsupportedValueError.ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: unsupported value: " + e.Str;
	};
	UnsupportedValueError.prototype.Error = function() { return this.$val.Error(); };
	MarshalerError.ptr.prototype.Error = function() {
		var _r$3, _r$4, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _r$4 = $f._r$4; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r$3 = e.Type.String(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$4 = e.Err.Error(); /* */ $s = 2; case 2: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		$s = -1; return "json: error calling MarshalJSON for type " + _r$3 + ": " + _r$4;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MarshalerError.ptr.prototype.Error }; } $f._r$3 = _r$3; $f._r$4 = _r$4; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	MarshalerError.prototype.Error = function() { return this.$val.Error(); };
	encodeState.ptr.prototype.marshal = function(v, opts) {
		var _r$3, e, err, opts, v, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; e = $f.e; err = $f.err; opts = $f.opts; v = $f.v; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		err = [err];
		err[0] = $ifaceNil;
		e = this;
		$deferred.push([(function(err) { return function() {
			var _tuple, _tuple$1, ok, ok$1, r, s;
			r = $recover();
			if (!($interfaceIsEqual(r, $ifaceNil))) {
				_tuple = $assertType(r, runtime.Error, true);
				ok = _tuple[1];
				if (ok) {
					$panic(r);
				}
				_tuple$1 = $assertType(r, $String, true);
				s = _tuple$1[0];
				ok$1 = _tuple$1[1];
				if (ok$1) {
					$panic(new $String(s));
				}
				err[0] = $assertType(r, $error);
			}
		}; })(err), []]);
		_r$3 = reflect.ValueOf(v); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		$r = e.reflectValue($clone(_r$3, reflect.Value), $clone(opts, encOpts)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		err[0] = $ifaceNil;
		$s = -1; return err[0];
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  err[0]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: encodeState.ptr.prototype.marshal }; } $f._r$3 = _r$3; $f.e = e; $f.err = err; $f.opts = opts; $f.v = v; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	encodeState.prototype.marshal = function(v, opts) { return this.$val.marshal(v, opts); };
	encodeState.ptr.prototype.error = function(err) {
		var e, err;
		e = this;
		$panic(err);
	};
	encodeState.prototype.error = function(err) { return this.$val.error(err); };
	isEmptyValue = function(v) {
		var _1, v, x, x$1;
		_1 = $clone(v, reflect.Value).Kind();
		if ((_1 === (17)) || (_1 === (21)) || (_1 === (23)) || (_1 === (24))) {
			return $clone(v, reflect.Value).Len() === 0;
		} else if (_1 === (1)) {
			return !$clone(v, reflect.Value).Bool();
		} else if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) {
			return (x = $clone(v, reflect.Value).Int(), (x.$high === 0 && x.$low === 0));
		} else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) {
			return (x$1 = $clone(v, reflect.Value).Uint(), (x$1.$high === 0 && x$1.$low === 0));
		} else if ((_1 === (13)) || (_1 === (14))) {
			return $clone(v, reflect.Value).Float() === 0;
		} else if ((_1 === (20)) || (_1 === (22))) {
			return $clone(v, reflect.Value).IsNil();
		}
		return false;
	};
	encodeState.ptr.prototype.reflectValue = function(v, opts) {
		var _r$3, e, opts, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; e = $f.e; opts = $f.opts; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r$3 = valueEncoder($clone(v, reflect.Value)); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		$r = _r$3(e, $clone(v, reflect.Value), $clone(opts, encOpts)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: encodeState.ptr.prototype.reflectValue }; } $f._r$3 = _r$3; $f.e = e; $f.opts = opts; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	encodeState.prototype.reflectValue = function(v, opts) { return this.$val.reflectValue(v, opts); };
	valueEncoder = function(v) {
		var _r$3, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (!$clone(v, reflect.Value).IsValid()) {
			$s = -1; return invalidValueEncoder;
		}
		_r$3 = typeEncoder($clone(v, reflect.Value).Type()); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		$s = -1; return _r$3;
		/* */ } return; } if ($f === undefined) { $f = { $blk: valueEncoder }; } $f._r$3 = _r$3; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	typeEncoder = function(t) {
		var _r$3, _tuple, _tuple$1, f, fi, fi$1, loaded, ok, t, wg, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; f = $f.f; fi = $f.fi; fi$1 = $f.fi$1; loaded = $f.loaded; ok = $f.ok; t = $f.t; wg = $f.wg; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = [f];
		wg = [wg];
		_tuple = encoderCache.Load(t);
		fi = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			$s = -1; return $assertType(fi, encoderFunc);
		}
		wg[0] = new nosync.WaitGroup.ptr(0);
		f[0] = $throwNilPointerError;
		wg[0].Add(1);
		_tuple$1 = encoderCache.LoadOrStore(t, new encoderFunc(((function(f, wg) { return function $b(e, v, opts) {
			var e, opts, v, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; e = $f.e; opts = $f.opts; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			wg[0].Wait();
			$r = f[0](e, $clone(v, reflect.Value), $clone(opts, encOpts)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f.e = e; $f.opts = opts; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
		}; })(f, wg))));
		fi$1 = _tuple$1[0];
		loaded = _tuple$1[1];
		if (loaded) {
			$s = -1; return $assertType(fi$1, encoderFunc);
		}
		_r$3 = newTypeEncoder(t, true); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		f[0] = _r$3;
		wg[0].Done();
		encoderCache.Store(t, new encoderFunc(f[0]));
		$s = -1; return f[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: typeEncoder }; } $f._r$3 = _r$3; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.f = f; $f.fi = fi; $f.fi$1 = fi$1; $f.loaded = loaded; $f.ok = ok; $f.t = t; $f.wg = wg; $f.$s = $s; $f.$r = $r; return $f;
	};
	newTypeEncoder = function(t, allowAddr) {
		var _1, _arg, _arg$1, _arg$2, _arg$3, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, allowAddr, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _arg$3 = $f._arg$3; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; allowAddr = $f.allowAddr; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r$3 = t.Implements(marshalerType); /* */ $s = 3; case 3: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		/* */ if (_r$3) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r$3) { */ case 1:
			$s = -1; return marshalerEncoder;
		/* } */ case 2:
		_r$4 = t.Kind(); /* */ $s = 6; case 6: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		/* */ if (!((_r$4 === 22)) && allowAddr) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!((_r$4 === 22)) && allowAddr) { */ case 4:
			_r$5 = reflect.PtrTo(t).Implements(marshalerType); /* */ $s = 9; case 9: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			/* */ if (_r$5) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_r$5) { */ case 7:
				_arg = addrMarshalerEncoder;
				_r$6 = newTypeEncoder(t, false); /* */ $s = 10; case 10: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_arg$1 = _r$6;
				_r$7 = newCondAddrEncoder(_arg, _arg$1); /* */ $s = 11; case 11: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				$s = -1; return _r$7;
			/* } */ case 8:
		/* } */ case 5:
		_r$8 = t.Implements(textMarshalerType); /* */ $s = 14; case 14: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		/* */ if (_r$8) { $s = 12; continue; }
		/* */ $s = 13; continue;
		/* if (_r$8) { */ case 12:
			$s = -1; return textMarshalerEncoder;
		/* } */ case 13:
		_r$9 = t.Kind(); /* */ $s = 17; case 17: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
		/* */ if (!((_r$9 === 22)) && allowAddr) { $s = 15; continue; }
		/* */ $s = 16; continue;
		/* if (!((_r$9 === 22)) && allowAddr) { */ case 15:
			_r$10 = reflect.PtrTo(t).Implements(textMarshalerType); /* */ $s = 20; case 20: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			/* */ if (_r$10) { $s = 18; continue; }
			/* */ $s = 19; continue;
			/* if (_r$10) { */ case 18:
				_arg$2 = addrTextMarshalerEncoder;
				_r$11 = newTypeEncoder(t, false); /* */ $s = 21; case 21: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
				_arg$3 = _r$11;
				_r$12 = newCondAddrEncoder(_arg$2, _arg$3); /* */ $s = 22; case 22: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
				$s = -1; return _r$12;
			/* } */ case 19:
		/* } */ case 16:
			_r$13 = t.Kind(); /* */ $s = 24; case 24: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
			_1 = _r$13;
			/* */ if (_1 === (1)) { $s = 25; continue; }
			/* */ if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { $s = 26; continue; }
			/* */ if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { $s = 27; continue; }
			/* */ if (_1 === (13)) { $s = 28; continue; }
			/* */ if (_1 === (14)) { $s = 29; continue; }
			/* */ if (_1 === (24)) { $s = 30; continue; }
			/* */ if (_1 === (20)) { $s = 31; continue; }
			/* */ if (_1 === (25)) { $s = 32; continue; }
			/* */ if (_1 === (21)) { $s = 33; continue; }
			/* */ if (_1 === (23)) { $s = 34; continue; }
			/* */ if (_1 === (17)) { $s = 35; continue; }
			/* */ if (_1 === (22)) { $s = 36; continue; }
			/* */ $s = 37; continue;
			/* if (_1 === (1)) { */ case 25:
				$s = -1; return boolEncoder;
			/* } else if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 26:
				$s = -1; return intEncoder;
			/* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 27:
				$s = -1; return uintEncoder;
			/* } else if (_1 === (13)) { */ case 28:
				$s = -1; return float32Encoder;
			/* } else if (_1 === (14)) { */ case 29:
				$s = -1; return float64Encoder;
			/* } else if (_1 === (24)) { */ case 30:
				$s = -1; return stringEncoder;
			/* } else if (_1 === (20)) { */ case 31:
				$s = -1; return interfaceEncoder;
			/* } else if (_1 === (25)) { */ case 32:
				_r$14 = newStructEncoder(t); /* */ $s = 39; case 39: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
				$s = -1; return _r$14;
			/* } else if (_1 === (21)) { */ case 33:
				_r$15 = newMapEncoder(t); /* */ $s = 40; case 40: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
				$s = -1; return _r$15;
			/* } else if (_1 === (23)) { */ case 34:
				_r$16 = newSliceEncoder(t); /* */ $s = 41; case 41: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
				$s = -1; return _r$16;
			/* } else if (_1 === (17)) { */ case 35:
				_r$17 = newArrayEncoder(t); /* */ $s = 42; case 42: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
				$s = -1; return _r$17;
			/* } else if (_1 === (22)) { */ case 36:
				_r$18 = newPtrEncoder(t); /* */ $s = 43; case 43: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
				$s = -1; return _r$18;
			/* } else { */ case 37:
				$s = -1; return unsupportedTypeEncoder;
			/* } */ case 38:
		case 23:
		$s = -1; return $throwNilPointerError;
		/* */ } return; } if ($f === undefined) { $f = { $blk: newTypeEncoder }; } $f._1 = _1; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._arg$3 = _arg$3; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f.allowAddr = allowAddr; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	invalidValueEncoder = function(e, v, param) {
		var e, param, v;
		e.Buffer.WriteString("null");
	};
	marshalerEncoder = function(e, v, opts) {
		var _r$3, _r$4, _r$5, _tuple, _tuple$1, b, e, err, m, ok, opts, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; b = $f.b; e = $f.e; err = $f.err; m = $f.m; ok = $f.ok; opts = $f.opts; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (($clone(v, reflect.Value).Kind() === 22) && $clone(v, reflect.Value).IsNil()) {
			e.Buffer.WriteString("null");
			$s = -1; return;
		}
		_r$3 = $clone(v, reflect.Value).Interface(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_tuple = $assertType(_r$3, Marshaler, true);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			e.Buffer.WriteString("null");
			$s = -1; return;
		}
		_r$4 = m.MarshalJSON(); /* */ $s = 2; case 2: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_tuple$1 = _r$4;
		b = _tuple$1[0];
		err = _tuple$1[1];
		/* */ if ($interfaceIsEqual(err, $ifaceNil)) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if ($interfaceIsEqual(err, $ifaceNil)) { */ case 3:
			_r$5 = compact(e.Buffer, b, opts.escapeHTML); /* */ $s = 5; case 5: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			err = _r$5;
		/* } */ case 4:
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			e.error(new MarshalerError.ptr($clone(v, reflect.Value).Type(), err));
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: marshalerEncoder }; } $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.b = b; $f.e = e; $f.err = err; $f.m = m; $f.ok = ok; $f.opts = opts; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	addrMarshalerEncoder = function(e, v, param) {
		var _r$3, _r$4, _r$5, _tuple, b, e, err, m, param, v, va, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; m = $f.m; param = $f.param; v = $f.v; va = $f.va; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		va = $clone(v, reflect.Value).Addr();
		if ($clone(va, reflect.Value).IsNil()) {
			e.Buffer.WriteString("null");
			$s = -1; return;
		}
		_r$3 = $clone(va, reflect.Value).Interface(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		m = $assertType(_r$3, Marshaler);
		_r$4 = m.MarshalJSON(); /* */ $s = 2; case 2: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_tuple = _r$4;
		b = _tuple[0];
		err = _tuple[1];
		/* */ if ($interfaceIsEqual(err, $ifaceNil)) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if ($interfaceIsEqual(err, $ifaceNil)) { */ case 3:
			_r$5 = compact(e.Buffer, b, true); /* */ $s = 5; case 5: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			err = _r$5;
		/* } */ case 4:
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			e.error(new MarshalerError.ptr($clone(v, reflect.Value).Type(), err));
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: addrMarshalerEncoder }; } $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.m = m; $f.param = param; $f.v = v; $f.va = va; $f.$s = $s; $f.$r = $r; return $f;
	};
	textMarshalerEncoder = function(e, v, opts) {
		var _r$3, _r$4, _tuple, b, e, err, m, opts, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _r$4 = $f._r$4; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; m = $f.m; opts = $f.opts; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (($clone(v, reflect.Value).Kind() === 22) && $clone(v, reflect.Value).IsNil()) {
			e.Buffer.WriteString("null");
			$s = -1; return;
		}
		_r$3 = $clone(v, reflect.Value).Interface(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		m = $assertType(_r$3, encoding.TextMarshaler);
		_r$4 = m.MarshalText(); /* */ $s = 2; case 2: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_tuple = _r$4;
		b = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			e.error(new MarshalerError.ptr($clone(v, reflect.Value).Type(), err));
		}
		e.stringBytes(b, opts.escapeHTML);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: textMarshalerEncoder }; } $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.m = m; $f.opts = opts; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	addrTextMarshalerEncoder = function(e, v, opts) {
		var _r$3, _r$4, _tuple, b, e, err, m, opts, v, va, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _r$4 = $f._r$4; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; m = $f.m; opts = $f.opts; v = $f.v; va = $f.va; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		va = $clone(v, reflect.Value).Addr();
		if ($clone(va, reflect.Value).IsNil()) {
			e.Buffer.WriteString("null");
			$s = -1; return;
		}
		_r$3 = $clone(va, reflect.Value).Interface(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		m = $assertType(_r$3, encoding.TextMarshaler);
		_r$4 = m.MarshalText(); /* */ $s = 2; case 2: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_tuple = _r$4;
		b = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			e.error(new MarshalerError.ptr($clone(v, reflect.Value).Type(), err));
		}
		e.stringBytes(b, opts.escapeHTML);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: addrTextMarshalerEncoder }; } $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.m = m; $f.opts = opts; $f.v = v; $f.va = va; $f.$s = $s; $f.$r = $r; return $f;
	};
	boolEncoder = function(e, v, opts) {
		var e, opts, v;
		if (opts.quoted) {
			e.Buffer.WriteByte(34);
		}
		if ($clone(v, reflect.Value).Bool()) {
			e.Buffer.WriteString("true");
		} else {
			e.Buffer.WriteString("false");
		}
		if (opts.quoted) {
			e.Buffer.WriteByte(34);
		}
	};
	intEncoder = function(e, v, opts) {
		var b, e, opts, v;
		b = strconv.AppendInt($subslice(new sliceType$1(e.scratch), 0, 0), $clone(v, reflect.Value).Int(), 10);
		if (opts.quoted) {
			e.Buffer.WriteByte(34);
		}
		e.Buffer.Write(b);
		if (opts.quoted) {
			e.Buffer.WriteByte(34);
		}
	};
	uintEncoder = function(e, v, opts) {
		var b, e, opts, v;
		b = strconv.AppendUint($subslice(new sliceType$1(e.scratch), 0, 0), $clone(v, reflect.Value).Uint(), 10);
		if (opts.quoted) {
			e.Buffer.WriteByte(34);
		}
		e.Buffer.Write(b);
		if (opts.quoted) {
			e.Buffer.WriteByte(34);
		}
	};
	floatEncoder.prototype.encode = function(e, v, opts) {
		var abs, b, bits, e, f, fmt$1, n, opts, v, x, x$1, x$2, x$3, x$4;
		bits = this.$val;
		f = $clone(v, reflect.Value).Float();
		if (math.IsInf(f, 0) || math.IsNaN(f)) {
			e.error(new UnsupportedValueError.ptr($clone(v, reflect.Value), strconv.FormatFloat(f, 103, -1, ((bits >> 0)))));
		}
		b = $subslice(new sliceType$1(e.scratch), 0, 0);
		abs = math.Abs(f);
		fmt$1 = 102;
		if (!((abs === 0))) {
			if ((bits === 64) && (abs < 1e-06 || abs >= 1e+21) || (bits === 32) && (($fround(abs)) < 9.999999974752427e-07 || ($fround(abs)) >= 1.0000000200408773e+21)) {
				fmt$1 = 101;
			}
		}
		b = strconv.AppendFloat(b, f, fmt$1, -1, ((bits >> 0)));
		if (fmt$1 === 101) {
			n = b.$length;
			if (n >= 4 && ((x = n - 4 >> 0, ((x < 0 || x >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + x])) === 101) && ((x$1 = n - 3 >> 0, ((x$1 < 0 || x$1 >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + x$1])) === 45) && ((x$2 = n - 2 >> 0, ((x$2 < 0 || x$2 >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + x$2])) === 48)) {
				(x$4 = n - 2 >> 0, ((x$4 < 0 || x$4 >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + x$4] = (x$3 = n - 1 >> 0, ((x$3 < 0 || x$3 >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + x$3]))));
				b = $subslice(b, 0, (n - 1 >> 0));
			}
		}
		if (opts.quoted) {
			e.Buffer.WriteByte(34);
		}
		e.Buffer.Write(b);
		if (opts.quoted) {
			e.Buffer.WriteByte(34);
		}
	};
	$ptrType(floatEncoder).prototype.encode = function(e, v, opts) { return new floatEncoder(this.$get()).encode(e, v, opts); };
	stringEncoder = function(e, v, opts) {
		var _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _tuple, e, err, numStr, opts, sb, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _tuple = $f._tuple; e = $f.e; err = $f.err; numStr = $f.numStr; opts = $f.opts; sb = $f.sb; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ if ($interfaceIsEqual($clone(v, reflect.Value).Type(), numberType)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($interfaceIsEqual($clone(v, reflect.Value).Type(), numberType)) { */ case 1:
			_r$3 = $clone(v, reflect.Value).String(); /* */ $s = 3; case 3: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			numStr = _r$3;
			if (numStr === "") {
				numStr = "0";
			}
			/* */ if (!isValidNumber(numStr)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (!isValidNumber(numStr)) { */ case 4:
				_r$4 = fmt.Errorf("json: invalid number literal %q", new sliceType([new $String(numStr)])); /* */ $s = 6; case 6: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				$r = e.error(_r$4); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 5:
			e.Buffer.WriteString(numStr);
			$s = -1; return;
		/* } */ case 2:
		/* */ if (opts.quoted) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if (opts.quoted) { */ case 8:
			_r$5 = $clone(v, reflect.Value).String(); /* */ $s = 11; case 11: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			_r$6 = Marshal(new $String(_r$5)); /* */ $s = 12; case 12: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_tuple = _r$6;
			sb = _tuple[0];
			err = _tuple[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				e.error(err);
			}
			e.string(($bytesToString(sb)), opts.escapeHTML);
			$s = 10; continue;
		/* } else { */ case 9:
			_r$7 = $clone(v, reflect.Value).String(); /* */ $s = 13; case 13: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_r$8 = e.string(_r$7, opts.escapeHTML); /* */ $s = 14; case 14: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			_r$8;
		/* } */ case 10:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: stringEncoder }; } $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._tuple = _tuple; $f.e = e; $f.err = err; $f.numStr = numStr; $f.opts = opts; $f.sb = sb; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	interfaceEncoder = function(e, v, opts) {
		var _r$3, e, opts, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; e = $f.e; opts = $f.opts; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if ($clone(v, reflect.Value).IsNil()) {
			e.Buffer.WriteString("null");
			$s = -1; return;
		}
		_r$3 = $clone(v, reflect.Value).Elem(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		$r = e.reflectValue($clone(_r$3, reflect.Value), $clone(opts, encOpts)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: interfaceEncoder }; } $f._r$3 = _r$3; $f.e = e; $f.opts = opts; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	unsupportedTypeEncoder = function(e, v, param) {
		var e, param, v;
		e.error(new UnsupportedTypeError.ptr($clone(v, reflect.Value).Type()));
	};
	structEncoder.ptr.prototype.encode = function(e, v, opts) {
		var _i, _r$3, _ref, e, f, first, fv, i, opts, se, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r$3 = $f._r$3; _ref = $f._ref; e = $f.e; f = $f.f; first = $f.first; fv = $f.fv; i = $f.i; opts = $f.opts; se = $f.se; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		se = this;
		e.Buffer.WriteByte(123);
		first = true;
		_ref = se.fields;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			f = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), field);
			_r$3 = fieldByIndex($clone(v, reflect.Value), f.index); /* */ $s = 3; case 3: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			fv = _r$3;
			/* */ if (!$clone(fv, reflect.Value).IsValid() || f.omitEmpty && isEmptyValue($clone(fv, reflect.Value))) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (!$clone(fv, reflect.Value).IsValid() || f.omitEmpty && isEmptyValue($clone(fv, reflect.Value))) { */ case 4:
				_i++;
				/* continue; */ $s = 1; continue;
			/* } */ case 5:
			if (first) {
				first = false;
			} else {
				e.Buffer.WriteByte(44);
			}
			e.string(f.name, opts.escapeHTML);
			e.Buffer.WriteByte(58);
			opts.quoted = f.quoted;
			$r = (x = se.fieldEncs, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]))(e, $clone(fv, reflect.Value), $clone(opts, encOpts)); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 1; continue; case 2:
		e.Buffer.WriteByte(125);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: structEncoder.ptr.prototype.encode }; } $f._i = _i; $f._r$3 = _r$3; $f._ref = _ref; $f.e = e; $f.f = f; $f.first = first; $f.fv = fv; $f.i = i; $f.opts = opts; $f.se = se; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	structEncoder.prototype.encode = function(e, v, opts) { return this.$val.encode(e, v, opts); };
	newStructEncoder = function(t) {
		var _i, _r$3, _r$4, _r$5, _ref, f, fields, i, se, t, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _ref = $f._ref; f = $f.f; fields = $f.fields; i = $f.i; se = $f.se; t = $f.t; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r$3 = cachedTypeFields(t); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		fields = _r$3;
		se = new structEncoder.ptr(fields, $makeSlice(sliceType$4, fields.$length));
		_ref = fields;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			i = _i;
			f = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), field);
			_r$4 = typeByIndex(t, f.index); /* */ $s = 4; case 4: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			_r$5 = typeEncoder(_r$4); /* */ $s = 5; case 5: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			(x = se.fieldEncs, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i] = _r$5));
			_i++;
		/* } */ $s = 2; continue; case 3:
		$s = -1; return $methodVal(se, "encode");
		/* */ } return; } if ($f === undefined) { $f = { $blk: newStructEncoder }; } $f._i = _i; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._ref = _ref; $f.f = f; $f.fields = fields; $f.i = i; $f.se = se; $f.t = t; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	mapEncoder.ptr.prototype.encode = function(e, v, opts) {
		var _arg, _arg$1, _arg$2, _i, _i$1, _r$3, _r$4, _r$5, _ref, _ref$1, e, err, i, i$1, keys, kv, me, opts, sv, v, v$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _i = $f._i; _i$1 = $f._i$1; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _ref = $f._ref; _ref$1 = $f._ref$1; e = $f.e; err = $f.err; i = $f.i; i$1 = $f.i$1; keys = $f.keys; kv = $f.kv; me = $f.me; opts = $f.opts; sv = $f.sv; v = $f.v; v$1 = $f.v$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		sv = [sv];
		me = this;
		if ($clone(v, reflect.Value).IsNil()) {
			e.Buffer.WriteString("null");
			$s = -1; return;
		}
		e.Buffer.WriteByte(123);
		_r$3 = $clone(v, reflect.Value).MapKeys(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		keys = _r$3;
		sv[0] = $makeSlice(sliceType$5, keys.$length);
		_ref = keys;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			i = _i;
			v$1 = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			((i < 0 || i >= sv[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : sv[0].$array[sv[0].$offset + i]).v = v$1;
			_r$4 = ((i < 0 || i >= sv[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : sv[0].$array[sv[0].$offset + i]).resolve(); /* */ $s = 4; case 4: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			err = _r$4;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				e.error(new MarshalerError.ptr($clone(v$1, reflect.Value).Type(), err));
			}
			_i++;
		/* } */ $s = 2; continue; case 3:
		$r = sort.Slice(sv[0], (function(sv) { return function(i$1, j) {
			var i$1, j;
			return ((i$1 < 0 || i$1 >= sv[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : sv[0].$array[sv[0].$offset + i$1]).s < ((j < 0 || j >= sv[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : sv[0].$array[sv[0].$offset + j]).s;
		}; })(sv)); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_ref$1 = sv[0];
		_i$1 = 0;
		/* while (true) { */ case 6:
			/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 7; continue; }
			i$1 = _i$1;
			kv = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), reflectWithString);
			if (i$1 > 0) {
				e.Buffer.WriteByte(44);
			}
			e.string(kv.s, opts.escapeHTML);
			e.Buffer.WriteByte(58);
			_arg = e;
			_r$5 = $clone(v, reflect.Value).MapIndex($clone(kv.v, reflect.Value)); /* */ $s = 8; case 8: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			_arg$1 = $clone(_r$5, reflect.Value);
			_arg$2 = $clone(opts, encOpts);
			$r = me.elemEnc(_arg, _arg$1, _arg$2); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i$1++;
		/* } */ $s = 6; continue; case 7:
		e.Buffer.WriteByte(125);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: mapEncoder.ptr.prototype.encode }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._i = _i; $f._i$1 = _i$1; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._ref = _ref; $f._ref$1 = _ref$1; $f.e = e; $f.err = err; $f.i = i; $f.i$1 = i$1; $f.keys = keys; $f.kv = kv; $f.me = me; $f.opts = opts; $f.sv = sv; $f.v = v; $f.v$1 = v$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	mapEncoder.prototype.encode = function(e, v, opts) { return this.$val.encode(e, v, opts); };
	newMapEncoder = function(t) {
		var _1, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, me, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; me = $f.me; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r$3 = t.Key(); /* */ $s = 2; case 2: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			_r$4 = _r$3.Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			_1 = _r$4;
			/* */ if ((_1 === (24)) || (_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6)) || (_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { $s = 4; continue; }
			_r$5 = t.Key(); /* */ $s = 7; case 7: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			_r$6 = _r$5.Implements(textMarshalerType); /* */ $s = 8; case 8: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			/* */ if (!_r$6) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if ((_1 === (24)) || (_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6)) || (_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 4:
				$s = 6; continue;
			/* } else if (!_r$6) { */ case 5:
				$s = -1; return unsupportedTypeEncoder;
			/* } */ case 6:
		case 1:
		_r$7 = t.Elem(); /* */ $s = 9; case 9: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_r$8 = typeEncoder(_r$7); /* */ $s = 10; case 10: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		me = new mapEncoder.ptr(_r$8);
		$s = -1; return $methodVal(me, "encode");
		/* */ } return; } if ($f === undefined) { $f = { $blk: newMapEncoder }; } $f._1 = _1; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f.me = me; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	encodeByteSlice = function(e, v, param) {
		var _r$3, _r$4, _r$5, dst, e, enc, param, s, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; dst = $f.dst; e = $f.e; enc = $f.enc; param = $f.param; s = $f.s; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if ($clone(v, reflect.Value).IsNil()) {
			e.Buffer.WriteString("null");
			$s = -1; return;
		}
		_r$3 = $clone(v, reflect.Value).Bytes(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		s = _r$3;
		e.Buffer.WriteByte(34);
		/* */ if (s.$length < 1024) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (s.$length < 1024) { */ case 2:
			dst = $makeSlice(sliceType$1, base64.StdEncoding.EncodedLen(s.$length));
			base64.StdEncoding.Encode(dst, s);
			e.Buffer.Write(dst);
			$s = 4; continue;
		/* } else { */ case 3:
			enc = base64.NewEncoder(base64.StdEncoding, e);
			_r$4 = enc.Write(s); /* */ $s = 5; case 5: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			_r$4;
			_r$5 = enc.Close(); /* */ $s = 6; case 6: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			_r$5;
		/* } */ case 4:
		e.Buffer.WriteByte(34);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: encodeByteSlice }; } $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f.dst = dst; $f.e = e; $f.enc = enc; $f.param = param; $f.s = s; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	sliceEncoder.ptr.prototype.encode = function(e, v, opts) {
		var e, opts, se, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; e = $f.e; opts = $f.opts; se = $f.se; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		se = this;
		if ($clone(v, reflect.Value).IsNil()) {
			e.Buffer.WriteString("null");
			$s = -1; return;
		}
		$r = se.arrayEnc(e, $clone(v, reflect.Value), $clone(opts, encOpts)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: sliceEncoder.ptr.prototype.encode }; } $f.e = e; $f.opts = opts; $f.se = se; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	sliceEncoder.prototype.encode = function(e, v, opts) { return this.$val.encode(e, v, opts); };
	newSliceEncoder = function(t) {
		var _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _v, enc, p, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _v = $f._v; enc = $f.enc; p = $f.p; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r$3 = t.Elem(); /* */ $s = 3; case 3: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$4 = _r$3.Kind(); /* */ $s = 4; case 4: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		/* */ if (_r$4 === 8) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r$4 === 8) { */ case 1:
			_r$5 = t.Elem(); /* */ $s = 5; case 5: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			_r$6 = reflect.PtrTo(_r$5); /* */ $s = 6; case 6: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			p = _r$6;
			_r$7 = p.Implements(marshalerType); /* */ $s = 10; case 10: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			if (!(!_r$7)) { _v = false; $s = 9; continue s; }
			_r$8 = p.Implements(textMarshalerType); /* */ $s = 11; case 11: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			_v = !_r$8; case 9:
			/* */ if (_v) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_v) { */ case 7:
				$s = -1; return encodeByteSlice;
			/* } */ case 8:
		/* } */ case 2:
		_r$9 = newArrayEncoder(t); /* */ $s = 12; case 12: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
		enc = new sliceEncoder.ptr(_r$9);
		$s = -1; return $methodVal(enc, "encode");
		/* */ } return; } if ($f === undefined) { $f = { $blk: newSliceEncoder }; } $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._v = _v; $f.enc = enc; $f.p = p; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	arrayEncoder.ptr.prototype.encode = function(e, v, opts) {
		var _arg, _arg$1, _arg$2, _r$3, ae, e, i, n, opts, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r$3 = $f._r$3; ae = $f.ae; e = $f.e; i = $f.i; n = $f.n; opts = $f.opts; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ae = this;
		e.Buffer.WriteByte(91);
		n = $clone(v, reflect.Value).Len();
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < n)) { break; } */ if(!(i < n)) { $s = 2; continue; }
			if (i > 0) {
				e.Buffer.WriteByte(44);
			}
			_arg = e;
			_r$3 = $clone(v, reflect.Value).Index(i); /* */ $s = 3; case 3: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			_arg$1 = $clone(_r$3, reflect.Value);
			_arg$2 = $clone(opts, encOpts);
			$r = ae.elemEnc(_arg, _arg$1, _arg$2); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		e.Buffer.WriteByte(93);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: arrayEncoder.ptr.prototype.encode }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r$3 = _r$3; $f.ae = ae; $f.e = e; $f.i = i; $f.n = n; $f.opts = opts; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	arrayEncoder.prototype.encode = function(e, v, opts) { return this.$val.encode(e, v, opts); };
	newArrayEncoder = function(t) {
		var _r$3, _r$4, enc, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _r$4 = $f._r$4; enc = $f.enc; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r$3 = t.Elem(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$4 = typeEncoder(_r$3); /* */ $s = 2; case 2: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		enc = new arrayEncoder.ptr(_r$4);
		$s = -1; return $methodVal(enc, "encode");
		/* */ } return; } if ($f === undefined) { $f = { $blk: newArrayEncoder }; } $f._r$3 = _r$3; $f._r$4 = _r$4; $f.enc = enc; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	ptrEncoder.ptr.prototype.encode = function(e, v, opts) {
		var _arg, _arg$1, _arg$2, _r$3, e, opts, pe, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r$3 = $f._r$3; e = $f.e; opts = $f.opts; pe = $f.pe; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		pe = this;
		if ($clone(v, reflect.Value).IsNil()) {
			e.Buffer.WriteString("null");
			$s = -1; return;
		}
		_arg = e;
		_r$3 = $clone(v, reflect.Value).Elem(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_arg$1 = $clone(_r$3, reflect.Value);
		_arg$2 = $clone(opts, encOpts);
		$r = pe.elemEnc(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ptrEncoder.ptr.prototype.encode }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r$3 = _r$3; $f.e = e; $f.opts = opts; $f.pe = pe; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	ptrEncoder.prototype.encode = function(e, v, opts) { return this.$val.encode(e, v, opts); };
	newPtrEncoder = function(t) {
		var _r$3, _r$4, enc, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; _r$4 = $f._r$4; enc = $f.enc; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r$3 = t.Elem(); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$4 = typeEncoder(_r$3); /* */ $s = 2; case 2: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		enc = new ptrEncoder.ptr(_r$4);
		$s = -1; return $methodVal(enc, "encode");
		/* */ } return; } if ($f === undefined) { $f = { $blk: newPtrEncoder }; } $f._r$3 = _r$3; $f._r$4 = _r$4; $f.enc = enc; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	condAddrEncoder.ptr.prototype.encode = function(e, v, opts) {
		var ce, e, opts, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; ce = $f.ce; e = $f.e; opts = $f.opts; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ce = this;
		/* */ if ($clone(v, reflect.Value).CanAddr()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($clone(v, reflect.Value).CanAddr()) { */ case 1:
			$r = ce.canAddrEnc(e, $clone(v, reflect.Value), $clone(opts, encOpts)); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 3; continue;
		/* } else { */ case 2:
			$r = ce.elseEnc(e, $clone(v, reflect.Value), $clone(opts, encOpts)); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: condAddrEncoder.ptr.prototype.encode }; } $f.ce = ce; $f.e = e; $f.opts = opts; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	condAddrEncoder.prototype.encode = function(e, v, opts) { return this.$val.encode(e, v, opts); };
	newCondAddrEncoder = function(canAddrEnc, elseEnc) {
		var canAddrEnc, elseEnc, enc;
		enc = new condAddrEncoder.ptr(canAddrEnc, elseEnc);
		return $methodVal(enc, "encode");
	};
	isValidTag = function(s) {
		var _i, _ref, _rune, c, s;
		if (s === "") {
			return false;
		}
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			c = _rune[0];
			if (strings.ContainsRune("!#$%&()*+-./:<=>?@[]^_{|}~ ", c)) {
			} else if (!unicode.IsLetter(c) && !unicode.IsDigit(c)) {
				return false;
			}
			_i += _rune[1];
		}
		return true;
	};
	fieldByIndex = function(v, index) {
		var _i, _r$3, _r$4, _ref, i, index, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; i = $f.i; index = $f.index; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_ref = index;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			/* */ if ($clone(v, reflect.Value).Kind() === 22) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if ($clone(v, reflect.Value).Kind() === 22) { */ case 3:
				if ($clone(v, reflect.Value).IsNil()) {
					$s = -1; return new reflect.Value.ptr(ptrType$5.nil, 0, 0);
				}
				_r$3 = $clone(v, reflect.Value).Elem(); /* */ $s = 5; case 5: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				v = _r$3;
			/* } */ case 4:
			_r$4 = $clone(v, reflect.Value).Field(i); /* */ $s = 6; case 6: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			v = _r$4;
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return v;
		/* */ } return; } if ($f === undefined) { $f = { $blk: fieldByIndex }; } $f._i = _i; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f.i = i; $f.index = index; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	typeByIndex = function(t, index) {
		var _i, _r$3, _r$4, _r$5, _ref, i, index, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _ref = $f._ref; i = $f.i; index = $f.index; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_ref = index;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r$3 = t.Kind(); /* */ $s = 5; case 5: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			/* */ if (_r$3 === 22) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r$3 === 22) { */ case 3:
				_r$4 = t.Elem(); /* */ $s = 6; case 6: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				t = _r$4;
			/* } */ case 4:
			_r$5 = t.Field(i); /* */ $s = 7; case 7: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			t = _r$5.Type;
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return t;
		/* */ } return; } if ($f === undefined) { $f = { $blk: typeByIndex }; } $f._i = _i; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._ref = _ref; $f.i = i; $f.index = index; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	reflectWithString.ptr.prototype.resolve = function() {
		var _1, _r$3, _r$4, _r$5, _tuple, _tuple$1, buf, err, ok, tm, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; buf = $f.buf; err = $f.err; ok = $f.ok; tm = $f.tm; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		w = this;
		/* */ if ($clone(w.v, reflect.Value).Kind() === 24) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($clone(w.v, reflect.Value).Kind() === 24) { */ case 1:
			_r$3 = $clone(w.v, reflect.Value).String(); /* */ $s = 3; case 3: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			w.s = _r$3;
			$s = -1; return $ifaceNil;
		/* } */ case 2:
		_r$4 = $clone(w.v, reflect.Value).Interface(); /* */ $s = 4; case 4: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_tuple = $assertType(_r$4, encoding.TextMarshaler, true);
		tm = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (ok) { */ case 5:
			_r$5 = tm.MarshalText(); /* */ $s = 7; case 7: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			_tuple$1 = _r$5;
			buf = _tuple$1[0];
			err = _tuple$1[1];
			w.s = ($bytesToString(buf));
			$s = -1; return err;
		/* } */ case 6:
		_1 = $clone(w.v, reflect.Value).Kind();
		if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) {
			w.s = strconv.FormatInt($clone(w.v, reflect.Value).Int(), 10);
			$s = -1; return $ifaceNil;
		} else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) {
			w.s = strconv.FormatUint($clone(w.v, reflect.Value).Uint(), 10);
			$s = -1; return $ifaceNil;
		}
		$panic(new $String("unexpected map key type"));
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: reflectWithString.ptr.prototype.resolve }; } $f._1 = _1; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.buf = buf; $f.err = err; $f.ok = ok; $f.tm = tm; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	reflectWithString.prototype.resolve = function() { return this.$val.resolve(); };
	encodeState.ptr.prototype.string = function(s, escapeHTML) {
		var _1, _tuple, b, c, e, escapeHTML, i, len0, s, size, start;
		e = this;
		len0 = e.Buffer.Len();
		e.Buffer.WriteByte(34);
		start = 0;
		i = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			b = s.charCodeAt(i);
			if (b < 128) {
				if (((b < 0 || b >= htmlSafeSet.length) ? ($throwRuntimeError("index out of range"), undefined) : htmlSafeSet[b]) || (!escapeHTML && ((b < 0 || b >= safeSet.length) ? ($throwRuntimeError("index out of range"), undefined) : safeSet[b]))) {
					i = i + (1) >> 0;
					continue;
				}
				if (start < i) {
					e.Buffer.WriteString($substring(s, start, i));
				}
				_1 = b;
				if ((_1 === (92)) || (_1 === (34))) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(b);
				} else if (_1 === (10)) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(110);
				} else if (_1 === (13)) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(114);
				} else if (_1 === (9)) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(116);
				} else {
					e.Buffer.WriteString("\\u00");
					e.Buffer.WriteByte(hex.charCodeAt((b >>> 4 << 24 >>> 24)));
					e.Buffer.WriteByte(hex.charCodeAt(((b & 15) >>> 0)));
				}
				i = i + (1) >> 0;
				start = i;
				continue;
			}
			_tuple = utf8.DecodeRuneInString($substring(s, i));
			c = _tuple[0];
			size = _tuple[1];
			if ((c === 65533) && (size === 1)) {
				if (start < i) {
					e.Buffer.WriteString($substring(s, start, i));
				}
				e.Buffer.WriteString("\\ufffd");
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			if ((c === 8232) || (c === 8233)) {
				if (start < i) {
					e.Buffer.WriteString($substring(s, start, i));
				}
				e.Buffer.WriteString("\\u202");
				e.Buffer.WriteByte(hex.charCodeAt((c & 15)));
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			i = i + (size) >> 0;
		}
		if (start < s.length) {
			e.Buffer.WriteString($substring(s, start));
		}
		e.Buffer.WriteByte(34);
		return e.Buffer.Len() - len0 >> 0;
	};
	encodeState.prototype.string = function(s, escapeHTML) { return this.$val.string(s, escapeHTML); };
	encodeState.ptr.prototype.stringBytes = function(s, escapeHTML) {
		var _1, _tuple, b, c, e, escapeHTML, i, len0, s, size, start;
		e = this;
		len0 = e.Buffer.Len();
		e.Buffer.WriteByte(34);
		start = 0;
		i = 0;
		while (true) {
			if (!(i < s.$length)) { break; }
			b = ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]);
			if (b < 128) {
				if (((b < 0 || b >= htmlSafeSet.length) ? ($throwRuntimeError("index out of range"), undefined) : htmlSafeSet[b]) || (!escapeHTML && ((b < 0 || b >= safeSet.length) ? ($throwRuntimeError("index out of range"), undefined) : safeSet[b]))) {
					i = i + (1) >> 0;
					continue;
				}
				if (start < i) {
					e.Buffer.Write($subslice(s, start, i));
				}
				_1 = b;
				if ((_1 === (92)) || (_1 === (34))) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(b);
				} else if (_1 === (10)) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(110);
				} else if (_1 === (13)) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(114);
				} else if (_1 === (9)) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(116);
				} else {
					e.Buffer.WriteString("\\u00");
					e.Buffer.WriteByte(hex.charCodeAt((b >>> 4 << 24 >>> 24)));
					e.Buffer.WriteByte(hex.charCodeAt(((b & 15) >>> 0)));
				}
				i = i + (1) >> 0;
				start = i;
				continue;
			}
			_tuple = utf8.DecodeRune($subslice(s, i));
			c = _tuple[0];
			size = _tuple[1];
			if ((c === 65533) && (size === 1)) {
				if (start < i) {
					e.Buffer.Write($subslice(s, start, i));
				}
				e.Buffer.WriteString("\\ufffd");
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			if ((c === 8232) || (c === 8233)) {
				if (start < i) {
					e.Buffer.Write($subslice(s, start, i));
				}
				e.Buffer.WriteString("\\u202");
				e.Buffer.WriteByte(hex.charCodeAt((c & 15)));
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			i = i + (size) >> 0;
		}
		if (start < s.$length) {
			e.Buffer.Write($subslice(s, start));
		}
		e.Buffer.WriteByte(34);
		return e.Buffer.Len() - len0 >> 0;
	};
	encodeState.prototype.stringBytes = function(s, escapeHTML) { return this.$val.stringBytes(s, escapeHTML); };
	fillField = function(f) {
		var f;
		f.nameBytes = (new sliceType$1($stringToBytes(f.name)));
		f.equalFold = foldFunc(f.nameBytes);
		return f;
	};
	byIndex.prototype.Len = function() {
		var x;
		x = this;
		return x.$length;
	};
	$ptrType(byIndex).prototype.Len = function() { return this.$get().Len(); };
	byIndex.prototype.Swap = function(i, j) {
		var _tmp, _tmp$1, i, j, x;
		x = this;
		_tmp = $clone(((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]), field);
		_tmp$1 = $clone(((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), field);
		field.copy(((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), _tmp);
		field.copy(((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]), _tmp$1);
	};
	$ptrType(byIndex).prototype.Swap = function(i, j) { return this.$get().Swap(i, j); };
	byIndex.prototype.Less = function(i, j) {
		var _i, _ref, i, j, k, x, x$1, x$2, xik;
		x = this;
		_ref = ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]).index;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			k = _i;
			xik = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (k >= ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]).index.$length) {
				return false;
			}
			if (!((xik === (x$1 = ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]).index, ((k < 0 || k >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + k]))))) {
				return xik < (x$2 = ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]).index, ((k < 0 || k >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + k]));
			}
			_i++;
		}
		return ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]).index.$length < ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]).index.$length;
	};
	$ptrType(byIndex).prototype.Less = function(i, j) { return this.$get().Less(i, j); };
	typeFields = function(t) {
		var _1, _entry, _entry$1, _entry$2, _entry$3, _i, _key, _key$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, _v, _v$1, _v$2, advance, count, current, dominant, f, fi, fields, fj, ft, i, i$1, index, name, name$1, next, nextCount, ok, opts, out, quoted, sf, t, t$1, tag, tagged, visited, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _i = $f._i; _key = $f._key; _key$1 = $f._key$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; advance = $f.advance; count = $f.count; current = $f.current; dominant = $f.dominant; f = $f.f; fi = $f.fi; fields = $f.fields; fj = $f.fj; ft = $f.ft; i = $f.i; i$1 = $f.i$1; index = $f.index; name = $f.name; name$1 = $f.name$1; next = $f.next; nextCount = $f.nextCount; ok = $f.ok; opts = $f.opts; out = $f.out; quoted = $f.quoted; sf = $f.sf; t = $f.t; t$1 = $f.t$1; tag = $f.tag; tagged = $f.tagged; visited = $f.visited; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fields = [fields];
		current = new sliceType$3([]);
		next = new sliceType$3([new field.ptr("", sliceType$1.nil, $throwNilPointerError, false, sliceType$2.nil, t, false, false)]);
		count = $makeMap(reflect.Type.keyFor, []);
		nextCount = $makeMap(reflect.Type.keyFor, []);
		visited = $makeMap(reflect.Type.keyFor, []);
		fields[0] = sliceType$3.nil;
		/* while (true) { */ case 1:
			/* if (!(next.$length > 0)) { break; } */ if(!(next.$length > 0)) { $s = 2; continue; }
			_tmp = next;
			_tmp$1 = $subslice(current, 0, 0);
			current = _tmp;
			next = _tmp$1;
			_tmp$2 = nextCount;
			_tmp$3 = $makeMap(reflect.Type.keyFor, []);
			count = _tmp$2;
			nextCount = _tmp$3;
			_ref = current;
			_i = 0;
			/* while (true) { */ case 3:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 4; continue; }
				f = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), field);
				/* */ if ((_entry = visited[reflect.Type.keyFor(f.typ)], _entry !== undefined ? _entry.v : false)) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if ((_entry = visited[reflect.Type.keyFor(f.typ)], _entry !== undefined ? _entry.v : false)) { */ case 5:
					_i++;
					/* continue; */ $s = 3; continue;
				/* } */ case 6:
				_key = f.typ; (visited || $throwRuntimeError("assignment to entry in nil map"))[reflect.Type.keyFor(_key)] = { k: _key, v: true };
				i = 0;
				/* while (true) { */ case 7:
					_r$3 = f.typ.NumField(); /* */ $s = 9; case 9: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					/* if (!(i < _r$3)) { break; } */ if(!(i < _r$3)) { $s = 8; continue; }
					_r$4 = f.typ.Field(i); /* */ $s = 10; case 10: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					sf = $clone(_r$4, reflect.StructField);
					/* */ if (sf.Anonymous) { $s = 11; continue; }
					/* */ if (!(sf.PkgPath === "")) { $s = 12; continue; }
					/* */ $s = 13; continue;
					/* if (sf.Anonymous) { */ case 11:
						t$1 = sf.Type;
						_r$5 = t$1.Kind(); /* */ $s = 16; case 16: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
						/* */ if (_r$5 === 22) { $s = 14; continue; }
						/* */ $s = 15; continue;
						/* if (_r$5 === 22) { */ case 14:
							_r$6 = t$1.Elem(); /* */ $s = 17; case 17: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
							t$1 = _r$6;
						/* } */ case 15:
						_r$7 = t$1.Name(); /* */ $s = 21; case 21: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
						_r$8 = isExported(_r$7); /* */ $s = 22; case 22: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
						if (!(!_r$8)) { _v = false; $s = 20; continue s; }
						_r$9 = t$1.Kind(); /* */ $s = 23; case 23: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
						_v = !((_r$9 === 25)); case 20:
						/* */ if (_v) { $s = 18; continue; }
						/* */ $s = 19; continue;
						/* if (_v) { */ case 18:
							i = i + (1) >> 0;
							/* continue; */ $s = 7; continue;
						/* } */ case 19:
						$s = 13; continue;
					/* } else if (!(sf.PkgPath === "")) { */ case 12:
						i = i + (1) >> 0;
						/* continue; */ $s = 7; continue;
					/* } */ case 13:
					tag = new reflect.StructTag(sf.Tag).Get("json");
					/* */ if (tag === "-") { $s = 24; continue; }
					/* */ $s = 25; continue;
					/* if (tag === "-") { */ case 24:
						i = i + (1) >> 0;
						/* continue; */ $s = 7; continue;
					/* } */ case 25:
					_tuple = parseTag(tag);
					name = _tuple[0];
					opts = _tuple[1];
					if (!isValidTag(name)) {
						name = "";
					}
					index = $makeSlice(sliceType$2, (f.index.$length + 1 >> 0));
					$copySlice(index, f.index);
					(x = f.index.$length, ((x < 0 || x >= index.$length) ? ($throwRuntimeError("index out of range"), undefined) : index.$array[index.$offset + x] = i));
					ft = sf.Type;
					_r$10 = ft.Name(); /* */ $s = 29; case 29: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
					if (!(_r$10 === "")) { _v$1 = false; $s = 28; continue s; }
					_r$11 = ft.Kind(); /* */ $s = 30; case 30: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
					_v$1 = _r$11 === 22; case 28:
					/* */ if (_v$1) { $s = 26; continue; }
					/* */ $s = 27; continue;
					/* if (_v$1) { */ case 26:
						_r$12 = ft.Elem(); /* */ $s = 31; case 31: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
						ft = _r$12;
					/* } */ case 27:
					quoted = false;
					/* */ if (new tagOptions(opts).Contains("string")) { $s = 32; continue; }
					/* */ $s = 33; continue;
					/* if (new tagOptions(opts).Contains("string")) { */ case 32:
							_r$13 = ft.Kind(); /* */ $s = 35; case 35: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
							_1 = _r$13;
							if ((_1 === (1)) || (_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6)) || (_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (13)) || (_1 === (14)) || (_1 === (24))) {
								quoted = true;
							}
						case 34:
					/* } */ case 33:
					if (!(name === "") || !sf.Anonymous) { _v$2 = true; $s = 38; continue s; }
					_r$14 = ft.Kind(); /* */ $s = 39; case 39: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
					_v$2 = !((_r$14 === 25)); case 38:
					/* */ if (_v$2) { $s = 36; continue; }
					/* */ $s = 37; continue;
					/* if (_v$2) { */ case 36:
						tagged = !(name === "");
						if (name === "") {
							name = sf.Name;
						}
						fields[0] = $append(fields[0], fillField(new field.ptr(name, sliceType$1.nil, $throwNilPointerError, tagged, index, ft, new tagOptions(opts).Contains("omitempty"), quoted)));
						if ((_entry$1 = count[reflect.Type.keyFor(f.typ)], _entry$1 !== undefined ? _entry$1.v : 0) > 1) {
							fields[0] = $append(fields[0], (x$1 = fields[0].$length - 1 >> 0, ((x$1 < 0 || x$1 >= fields[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : fields[0].$array[fields[0].$offset + x$1])));
						}
						i = i + (1) >> 0;
						/* continue; */ $s = 7; continue;
					/* } */ case 37:
					_key$1 = ft; (nextCount || $throwRuntimeError("assignment to entry in nil map"))[reflect.Type.keyFor(_key$1)] = { k: _key$1, v: (_entry$2 = nextCount[reflect.Type.keyFor(ft)], _entry$2 !== undefined ? _entry$2.v : 0) + (1) >> 0 };
					/* */ if ((_entry$3 = nextCount[reflect.Type.keyFor(ft)], _entry$3 !== undefined ? _entry$3.v : 0) === 1) { $s = 40; continue; }
					/* */ $s = 41; continue;
					/* if ((_entry$3 = nextCount[reflect.Type.keyFor(ft)], _entry$3 !== undefined ? _entry$3.v : 0) === 1) { */ case 40:
						_r$15 = ft.Name(); /* */ $s = 42; case 42: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
						_r$16 = fillField(new field.ptr(_r$15, sliceType$1.nil, $throwNilPointerError, false, index, ft, false, false)); /* */ $s = 43; case 43: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
						next = $append(next, _r$16);
					/* } */ case 41:
					i = i + (1) >> 0;
				/* } */ $s = 7; continue; case 8:
				_i++;
			/* } */ $s = 3; continue; case 4:
		/* } */ $s = 1; continue; case 2:
		$r = sort.Slice(fields[0], (function(fields) { return function(i$1, j) {
			var i$1, j, x$2;
			x$2 = fields[0];
			if (!(((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1]).name === ((j < 0 || j >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + j]).name)) {
				return ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1]).name < ((j < 0 || j >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + j]).name;
			}
			if (!((((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1]).index.$length === ((j < 0 || j >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + j]).index.$length))) {
				return ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1]).index.$length < ((j < 0 || j >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + j]).index.$length;
			}
			if (!(((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1]).tag === ((j < 0 || j >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + j]).tag)) {
				return ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1]).tag;
			}
			return ($subslice(new byIndex(x$2.$array), x$2.$offset, x$2.$offset + x$2.$length)).Less(i$1, j);
		}; })(fields)); /* */ $s = 44; case 44: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		out = $subslice(fields[0], 0, 0);
		_tmp$4 = 0;
		_tmp$5 = 0;
		advance = _tmp$4;
		i$1 = _tmp$5;
		/* while (true) { */ case 45:
			/* if (!(i$1 < fields[0].$length)) { break; } */ if(!(i$1 < fields[0].$length)) { $s = 46; continue; }
			fi = $clone(((i$1 < 0 || i$1 >= fields[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : fields[0].$array[fields[0].$offset + i$1]), field);
			name$1 = fi.name;
			advance = 1;
			while (true) {
				if (!((i$1 + advance >> 0) < fields[0].$length)) { break; }
				fj = $clone((x$2 = i$1 + advance >> 0, ((x$2 < 0 || x$2 >= fields[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : fields[0].$array[fields[0].$offset + x$2])), field);
				if (!(fj.name === name$1)) {
					break;
				}
				advance = advance + (1) >> 0;
			}
			if (advance === 1) {
				out = $append(out, fi);
				i$1 = i$1 + (advance) >> 0;
				/* continue; */ $s = 45; continue;
			}
			_tuple$1 = dominantField($subslice(fields[0], i$1, (i$1 + advance >> 0)));
			dominant = $clone(_tuple$1[0], field);
			ok = _tuple$1[1];
			if (ok) {
				out = $append(out, dominant);
			}
			i$1 = i$1 + (advance) >> 0;
		/* } */ $s = 45; continue; case 46:
		fields[0] = out;
		$r = sort.Sort(($subslice(new byIndex(fields[0].$array), fields[0].$offset, fields[0].$offset + fields[0].$length))); /* */ $s = 47; case 47: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return fields[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: typeFields }; } $f._1 = _1; $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._i = _i; $f._key = _key; $f._key$1 = _key$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f.advance = advance; $f.count = count; $f.current = current; $f.dominant = dominant; $f.f = f; $f.fi = fi; $f.fields = fields; $f.fj = fj; $f.ft = ft; $f.i = i; $f.i$1 = i$1; $f.index = index; $f.name = name; $f.name$1 = name$1; $f.next = next; $f.nextCount = nextCount; $f.ok = ok; $f.opts = opts; $f.out = out; $f.quoted = quoted; $f.sf = sf; $f.t = t; $f.t$1 = t$1; $f.tag = tag; $f.tagged = tagged; $f.visited = visited; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	isExported = function(id) {
		var _tuple, id, r;
		_tuple = utf8.DecodeRuneInString(id);
		r = _tuple[0];
		return unicode.IsUpper(r);
	};
	dominantField = function(fields) {
		var _i, _ref, f, fields, i, length, tagged;
		length = (0 >= fields.$length ? ($throwRuntimeError("index out of range"), undefined) : fields.$array[fields.$offset + 0]).index.$length;
		tagged = -1;
		_ref = fields;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			f = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), field);
			if (f.index.$length > length) {
				fields = $subslice(fields, 0, i);
				break;
			}
			if (f.tag) {
				if (tagged >= 0) {
					return [new field.ptr("", sliceType$1.nil, $throwNilPointerError, false, sliceType$2.nil, $ifaceNil, false, false), false];
				}
				tagged = i;
			}
			_i++;
		}
		if (tagged >= 0) {
			return [((tagged < 0 || tagged >= fields.$length) ? ($throwRuntimeError("index out of range"), undefined) : fields.$array[fields.$offset + tagged]), true];
		}
		if (fields.$length > 1) {
			return [new field.ptr("", sliceType$1.nil, $throwNilPointerError, false, sliceType$2.nil, $ifaceNil, false, false), false];
		}
		return [(0 >= fields.$length ? ($throwRuntimeError("index out of range"), undefined) : fields.$array[fields.$offset + 0]), true];
	};
	cachedTypeFields = function(t) {
		var _entry, _entry$1, _i, _key, _key$1, _keys, _r$3, _ref, _tuple, _tuple$1, f, k, m, newM, t, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _i = $f._i; _key = $f._key; _key$1 = $f._key$1; _keys = $f._keys; _r$3 = $f._r$3; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; f = $f.f; k = $f.k; m = $f.m; newM = $f.newM; t = $f.t; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(fieldCache.value.Load(), mapType$1, true);
		m = _tuple[0];
		f = (_entry = m[reflect.Type.keyFor(t)], _entry !== undefined ? _entry.v : sliceType$3.nil);
		if (!(f === sliceType$3.nil)) {
			$s = -1; return f;
		}
		_r$3 = typeFields(t); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		f = _r$3;
		if (f === sliceType$3.nil) {
			f = new sliceType$3([]);
		}
		fieldCache.mu.Lock();
		_tuple$1 = $assertType(fieldCache.value.Load(), mapType$1, true);
		m = _tuple$1[0];
		newM = (x = $keys(m).length + 1 >> 0, ((x < 0 || x > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		_ref = m;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry$1 = _ref[_keys[_i]];
			if (_entry$1 === undefined) {
				_i++;
				continue;
			}
			k = _entry$1.k;
			v = _entry$1.v;
			_key = k; (newM || $throwRuntimeError("assignment to entry in nil map"))[reflect.Type.keyFor(_key)] = { k: _key, v: v };
			_i++;
		}
		_key$1 = t; (newM || $throwRuntimeError("assignment to entry in nil map"))[reflect.Type.keyFor(_key$1)] = { k: _key$1, v: f };
		fieldCache.value.Store(new mapType$1(newM));
		fieldCache.mu.Unlock();
		$s = -1; return f;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cachedTypeFields }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._i = _i; $f._key = _key; $f._key$1 = _key$1; $f._keys = _keys; $f._r$3 = _r$3; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.f = f; $f.k = k; $f.m = m; $f.newM = newM; $f.t = t; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	foldFunc = function(s) {
		var _i, _ref, b, nonLetter, s, special, upper;
		nonLetter = false;
		special = false;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (b >= 128) {
				return bytes.EqualFold;
			}
			upper = (b & 223) >>> 0;
			if (upper < 65 || upper > 90) {
				nonLetter = true;
			} else if ((upper === 75) || (upper === 83)) {
				special = true;
			}
			_i++;
		}
		if (special) {
			return equalFoldRight;
		}
		if (nonLetter) {
			return asciiEqualFold;
		}
		return simpleLetterEqualFold;
	};
	equalFoldRight = function(s, t) {
		var _1, _i, _ref, _tuple, s, sb, sbUpper, size, t, tb, tr;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			sb = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (t.$length === 0) {
				return false;
			}
			tb = (0 >= t.$length ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + 0]);
			if (tb < 128) {
				if (!((sb === tb))) {
					sbUpper = (sb & 223) >>> 0;
					if (65 <= sbUpper && sbUpper <= 90) {
						if (!((sbUpper === ((tb & 223) >>> 0)))) {
							return false;
						}
					} else {
						return false;
					}
				}
				t = $subslice(t, 1);
				_i++;
				continue;
			}
			_tuple = utf8.DecodeRune(t);
			tr = _tuple[0];
			size = _tuple[1];
			_1 = sb;
			if ((_1 === (115)) || (_1 === (83))) {
				if (!((tr === 383))) {
					return false;
				}
			} else if ((_1 === (107)) || (_1 === (75))) {
				if (!((tr === 8490))) {
					return false;
				}
			} else {
				return false;
			}
			t = $subslice(t, size);
			_i++;
		}
		if (t.$length > 0) {
			return false;
		}
		return true;
	};
	asciiEqualFold = function(s, t) {
		var _i, _ref, i, s, sb, t, tb;
		if (!((s.$length === t.$length))) {
			return false;
		}
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			sb = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			tb = ((i < 0 || i >= t.$length) ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + i]);
			if (sb === tb) {
				_i++;
				continue;
			}
			if ((97 <= sb && sb <= 122) || (65 <= sb && sb <= 90)) {
				if (!((((sb & 223) >>> 0) === ((tb & 223) >>> 0)))) {
					return false;
				}
			} else {
				return false;
			}
			_i++;
		}
		return true;
	};
	simpleLetterEqualFold = function(s, t) {
		var _i, _ref, b, i, s, t;
		if (!((s.$length === t.$length))) {
			return false;
		}
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((((b & 223) >>> 0) === ((((i < 0 || i >= t.$length) ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + i]) & 223) >>> 0)))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	compact = function(dst, src, escape) {
		var _i, _r$3, _r$4, _ref, c, dst, escape, i, origLen, scan, src, start, v, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; c = $f.c; dst = $f.dst; escape = $f.escape; i = $f.i; origLen = $f.origLen; scan = $f.scan; src = $f.src; start = $f.start; v = $f.v; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		scan = [scan];
		origLen = dst.Len();
		scan[0] = new scanner.ptr($throwNilPointerError, false, sliceType$2.nil, $ifaceNil, false, 0, $throwNilPointerError, new $Int64(0, 0));
		scan[0].reset();
		start = 0;
		_ref = src;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (escape && ((c === 60) || (c === 62) || (c === 38))) {
				if (start < i) {
					dst.Write($subslice(src, start, i));
				}
				dst.WriteString("\\u00");
				dst.WriteByte(hex.charCodeAt((c >>> 4 << 24 >>> 24)));
				dst.WriteByte(hex.charCodeAt(((c & 15) >>> 0)));
				start = i + 1 >> 0;
			}
			if ((c === 226) && (i + 2 >> 0) < src.$length && ((x = i + 1 >> 0, ((x < 0 || x >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + x])) === 128) && ((((x$1 = i + 2 >> 0, ((x$1 < 0 || x$1 >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + x$1])) & ~1) << 24 >>> 24) === 168)) {
				if (start < i) {
					dst.Write($subslice(src, start, i));
				}
				dst.WriteString("\\u202");
				dst.WriteByte(hex.charCodeAt((((x$2 = i + 2 >> 0, ((x$2 < 0 || x$2 >= src.$length) ? ($throwRuntimeError("index out of range"), undefined) : src.$array[src.$offset + x$2])) & 15) >>> 0)));
				start = i + 3 >> 0;
			}
			_r$3 = scan[0].step(scan[0], c); /* */ $s = 3; case 3: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			v = _r$3;
			if (v >= 9) {
				if (v === 11) {
					/* break; */ $s = 2; continue;
				}
				if (start < i) {
					dst.Write($subslice(src, start, i));
				}
				start = i + 1 >> 0;
			}
			_i++;
		/* } */ $s = 1; continue; case 2:
		_r$4 = scan[0].eof(); /* */ $s = 6; case 6: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		/* */ if (_r$4 === 11) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (_r$4 === 11) { */ case 4:
			dst.Truncate(origLen);
			$s = -1; return scan[0].err;
		/* } */ case 5:
		if (start < src.$length) {
			dst.Write($subslice(src, start));
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: compact }; } $f._i = _i; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f.c = c; $f.dst = dst; $f.escape = escape; $f.i = i; $f.origLen = origLen; $f.scan = scan; $f.src = src; $f.start = start; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	newline = function(dst, prefix, indent, depth) {
		var depth, dst, i, indent, prefix;
		dst.WriteByte(10);
		dst.WriteString(prefix);
		i = 0;
		while (true) {
			if (!(i < depth)) { break; }
			dst.WriteString(indent);
			i = i + (1) >> 0;
		}
	};
	Indent = function(dst, src, prefix, indent) {
		var _1, _i, _r$3, _r$4, _ref, c, depth, dst, indent, needIndent, origLen, prefix, scan, src, v, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; c = $f.c; depth = $f.depth; dst = $f.dst; indent = $f.indent; needIndent = $f.needIndent; origLen = $f.origLen; prefix = $f.prefix; scan = $f.scan; src = $f.src; v = $f.v; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		scan = [scan];
		origLen = dst.Len();
		scan[0] = new scanner.ptr($throwNilPointerError, false, sliceType$2.nil, $ifaceNil, false, 0, $throwNilPointerError, new $Int64(0, 0));
		scan[0].reset();
		needIndent = false;
		depth = 0;
		_ref = src;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			scan[0].bytes = (x = scan[0].bytes, x$1 = new $Int64(0, 1), new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));
			_r$3 = scan[0].step(scan[0], c); /* */ $s = 3; case 3: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			v = _r$3;
			if (v === 9) {
				_i++;
				/* continue; */ $s = 1; continue;
			}
			if (v === 11) {
				/* break; */ $s = 2; continue;
			}
			if (needIndent && !((v === 5)) && !((v === 8))) {
				needIndent = false;
				depth = depth + (1) >> 0;
				newline(dst, prefix, indent, depth);
			}
			if (v === 0) {
				dst.WriteByte(c);
				_i++;
				/* continue; */ $s = 1; continue;
			}
			_1 = c;
			if ((_1 === (123)) || (_1 === (91))) {
				needIndent = true;
				dst.WriteByte(c);
			} else if (_1 === (44)) {
				dst.WriteByte(c);
				newline(dst, prefix, indent, depth);
			} else if (_1 === (58)) {
				dst.WriteByte(c);
				dst.WriteByte(32);
			} else if ((_1 === (125)) || (_1 === (93))) {
				if (needIndent) {
					needIndent = false;
				} else {
					depth = depth - (1) >> 0;
					newline(dst, prefix, indent, depth);
				}
				dst.WriteByte(c);
			} else {
				dst.WriteByte(c);
			}
			_i++;
		/* } */ $s = 1; continue; case 2:
		_r$4 = scan[0].eof(); /* */ $s = 6; case 6: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		/* */ if (_r$4 === 11) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (_r$4 === 11) { */ case 4:
			dst.Truncate(origLen);
			$s = -1; return scan[0].err;
		/* } */ case 5:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Indent }; } $f._1 = _1; $f._i = _i; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f.c = c; $f.depth = depth; $f.dst = dst; $f.indent = indent; $f.needIndent = needIndent; $f.origLen = origLen; $f.prefix = prefix; $f.scan = scan; $f.src = src; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Indent = Indent;
	SyntaxError.ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.msg;
	};
	SyntaxError.prototype.Error = function() { return this.$val.Error(); };
	scanner.ptr.prototype.reset = function() {
		var s;
		s = this;
		s.step = stateBeginValue;
		s.parseState = $subslice(s.parseState, 0, 0);
		s.err = $ifaceNil;
		s.redo = false;
		s.endTop = false;
	};
	scanner.prototype.reset = function() { return this.$val.reset(); };
	scanner.ptr.prototype.eof = function() {
		var _r$3, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		if (!($interfaceIsEqual(s.err, $ifaceNil))) {
			$s = -1; return 11;
		}
		if (s.endTop) {
			$s = -1; return 10;
		}
		_r$3 = s.step(s, 32); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$3;
		if (s.endTop) {
			$s = -1; return 10;
		}
		if ($interfaceIsEqual(s.err, $ifaceNil)) {
			s.err = new SyntaxError.ptr("unexpected end of JSON input", s.bytes);
		}
		$s = -1; return 11;
		/* */ } return; } if ($f === undefined) { $f = { $blk: scanner.ptr.prototype.eof }; } $f._r$3 = _r$3; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	scanner.prototype.eof = function() { return this.$val.eof(); };
	scanner.ptr.prototype.pushParseState = function(p) {
		var p, s;
		s = this;
		s.parseState = $append(s.parseState, p);
	};
	scanner.prototype.pushParseState = function(p) { return this.$val.pushParseState(p); };
	scanner.ptr.prototype.popParseState = function() {
		var n, s;
		s = this;
		n = s.parseState.$length - 1 >> 0;
		s.parseState = $subslice(s.parseState, 0, n);
		s.redo = false;
		if (n === 0) {
			s.step = stateEndTop;
			s.endTop = true;
		} else {
			s.step = stateEndValue;
		}
	};
	scanner.prototype.popParseState = function() { return this.$val.popParseState(); };
	isSpace = function(c) {
		var c;
		return (c === 32) || (c === 9) || (c === 13) || (c === 10);
	};
	stateBeginValueOrEmpty = function(s, c) {
		var c, s;
		if (c <= 32 && isSpace(c)) {
			return 9;
		}
		if (c === 93) {
			return stateEndValue(s, c);
		}
		return stateBeginValue(s, c);
	};
	stateBeginValue = function(s, c) {
		var _1, c, s;
		if (c <= 32 && isSpace(c)) {
			return 9;
		}
		_1 = c;
		if (_1 === (123)) {
			s.step = stateBeginStringOrEmpty;
			s.pushParseState(0);
			return 2;
		} else if (_1 === (91)) {
			s.step = stateBeginValueOrEmpty;
			s.pushParseState(2);
			return 6;
		} else if (_1 === (34)) {
			s.step = stateInString;
			return 1;
		} else if (_1 === (45)) {
			s.step = stateNeg;
			return 1;
		} else if (_1 === (48)) {
			s.step = state0;
			return 1;
		} else if (_1 === (116)) {
			s.step = stateT;
			return 1;
		} else if (_1 === (102)) {
			s.step = stateF;
			return 1;
		} else if (_1 === (110)) {
			s.step = stateN;
			return 1;
		}
		if (49 <= c && c <= 57) {
			s.step = state1;
			return 1;
		}
		return s.error(c, "looking for beginning of value");
	};
	stateBeginStringOrEmpty = function(s, c) {
		var c, n, s, x, x$1;
		if (c <= 32 && isSpace(c)) {
			return 9;
		}
		if (c === 125) {
			n = s.parseState.$length;
			(x = s.parseState, x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1] = 1));
			return stateEndValue(s, c);
		}
		return stateBeginString(s, c);
	};
	stateBeginString = function(s, c) {
		var c, s;
		if (c <= 32 && isSpace(c)) {
			return 9;
		}
		if (c === 34) {
			s.step = stateInString;
			return 1;
		}
		return s.error(c, "looking for beginning of object key string");
	};
	stateEndValue = function(s, c) {
		var _1, c, n, ps, s, x, x$1, x$2, x$3, x$4, x$5;
		n = s.parseState.$length;
		if (n === 0) {
			s.step = stateEndTop;
			s.endTop = true;
			return stateEndTop(s, c);
		}
		if (c <= 32 && isSpace(c)) {
			s.step = stateEndValue;
			return 9;
		}
		ps = (x = s.parseState, x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		_1 = ps;
		if (_1 === (0)) {
			if (c === 58) {
				(x$2 = s.parseState, x$3 = n - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3] = 1));
				s.step = stateBeginValue;
				return 3;
			}
			return s.error(c, "after object key");
		} else if (_1 === (1)) {
			if (c === 44) {
				(x$4 = s.parseState, x$5 = n - 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5] = 0));
				s.step = stateBeginString;
				return 4;
			}
			if (c === 125) {
				s.popParseState();
				return 5;
			}
			return s.error(c, "after object key:value pair");
		} else if (_1 === (2)) {
			if (c === 44) {
				s.step = stateBeginValue;
				return 7;
			}
			if (c === 93) {
				s.popParseState();
				return 8;
			}
			return s.error(c, "after array element");
		}
		return s.error(c, "");
	};
	stateEndTop = function(s, c) {
		var c, s;
		if (!((c === 32)) && !((c === 9)) && !((c === 13)) && !((c === 10))) {
			s.error(c, "after top-level value");
		}
		return 10;
	};
	stateInString = function(s, c) {
		var c, s;
		if (c === 34) {
			s.step = stateEndValue;
			return 0;
		}
		if (c === 92) {
			s.step = stateInStringEsc;
			return 0;
		}
		if (c < 32) {
			return s.error(c, "in string literal");
		}
		return 0;
	};
	stateInStringEsc = function(s, c) {
		var _1, c, s;
		_1 = c;
		if ((_1 === (98)) || (_1 === (102)) || (_1 === (110)) || (_1 === (114)) || (_1 === (116)) || (_1 === (92)) || (_1 === (47)) || (_1 === (34))) {
			s.step = stateInString;
			return 0;
		} else if (_1 === (117)) {
			s.step = stateInStringEscU;
			return 0;
		}
		return s.error(c, "in string escape code");
	};
	stateInStringEscU = function(s, c) {
		var c, s;
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInStringEscU1;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
	stateInStringEscU1 = function(s, c) {
		var c, s;
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInStringEscU12;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
	stateInStringEscU12 = function(s, c) {
		var c, s;
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInStringEscU123;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
	stateInStringEscU123 = function(s, c) {
		var c, s;
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInString;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
	stateNeg = function(s, c) {
		var c, s;
		if (c === 48) {
			s.step = state0;
			return 0;
		}
		if (49 <= c && c <= 57) {
			s.step = state1;
			return 0;
		}
		return s.error(c, "in numeric literal");
	};
	state1 = function(s, c) {
		var c, s;
		if (48 <= c && c <= 57) {
			s.step = state1;
			return 0;
		}
		return state0(s, c);
	};
	state0 = function(s, c) {
		var c, s;
		if (c === 46) {
			s.step = stateDot;
			return 0;
		}
		if ((c === 101) || (c === 69)) {
			s.step = stateE;
			return 0;
		}
		return stateEndValue(s, c);
	};
	stateDot = function(s, c) {
		var c, s;
		if (48 <= c && c <= 57) {
			s.step = stateDot0;
			return 0;
		}
		return s.error(c, "after decimal point in numeric literal");
	};
	stateDot0 = function(s, c) {
		var c, s;
		if (48 <= c && c <= 57) {
			return 0;
		}
		if ((c === 101) || (c === 69)) {
			s.step = stateE;
			return 0;
		}
		return stateEndValue(s, c);
	};
	stateE = function(s, c) {
		var c, s;
		if ((c === 43) || (c === 45)) {
			s.step = stateESign;
			return 0;
		}
		return stateESign(s, c);
	};
	stateESign = function(s, c) {
		var c, s;
		if (48 <= c && c <= 57) {
			s.step = stateE0;
			return 0;
		}
		return s.error(c, "in exponent of numeric literal");
	};
	stateE0 = function(s, c) {
		var c, s;
		if (48 <= c && c <= 57) {
			return 0;
		}
		return stateEndValue(s, c);
	};
	stateT = function(s, c) {
		var c, s;
		if (c === 114) {
			s.step = stateTr;
			return 0;
		}
		return s.error(c, "in literal true (expecting 'r')");
	};
	stateTr = function(s, c) {
		var c, s;
		if (c === 117) {
			s.step = stateTru;
			return 0;
		}
		return s.error(c, "in literal true (expecting 'u')");
	};
	stateTru = function(s, c) {
		var c, s;
		if (c === 101) {
			s.step = stateEndValue;
			return 0;
		}
		return s.error(c, "in literal true (expecting 'e')");
	};
	stateF = function(s, c) {
		var c, s;
		if (c === 97) {
			s.step = stateFa;
			return 0;
		}
		return s.error(c, "in literal false (expecting 'a')");
	};
	stateFa = function(s, c) {
		var c, s;
		if (c === 108) {
			s.step = stateFal;
			return 0;
		}
		return s.error(c, "in literal false (expecting 'l')");
	};
	stateFal = function(s, c) {
		var c, s;
		if (c === 115) {
			s.step = stateFals;
			return 0;
		}
		return s.error(c, "in literal false (expecting 's')");
	};
	stateFals = function(s, c) {
		var c, s;
		if (c === 101) {
			s.step = stateEndValue;
			return 0;
		}
		return s.error(c, "in literal false (expecting 'e')");
	};
	stateN = function(s, c) {
		var c, s;
		if (c === 117) {
			s.step = stateNu;
			return 0;
		}
		return s.error(c, "in literal null (expecting 'u')");
	};
	stateNu = function(s, c) {
		var c, s;
		if (c === 108) {
			s.step = stateNul;
			return 0;
		}
		return s.error(c, "in literal null (expecting 'l')");
	};
	stateNul = function(s, c) {
		var c, s;
		if (c === 108) {
			s.step = stateEndValue;
			return 0;
		}
		return s.error(c, "in literal null (expecting 'l')");
	};
	stateError = function(s, c) {
		var c, s;
		return 11;
	};
	scanner.ptr.prototype.error = function(c, context) {
		var c, context, s;
		s = this;
		s.step = stateError;
		s.err = new SyntaxError.ptr("invalid character " + quoteChar(c) + " " + context, s.bytes);
		return 11;
	};
	scanner.prototype.error = function(c, context) { return this.$val.error(c, context); };
	quoteChar = function(c) {
		var c, s;
		if (c === 39) {
			return "'\\''";
		}
		if (c === 34) {
			return "'\"'";
		}
		s = strconv.Quote(($encodeRune(c)));
		return "'" + $substring(s, 1, (s.length - 1 >> 0)) + "'";
	};
	parseTag = function(tag) {
		var idx, tag;
		idx = strings.Index(tag, ",");
		if (!((idx === -1))) {
			return [$substring(tag, 0, idx), ($substring(tag, (idx + 1 >> 0)))];
		}
		return [tag, ""];
	};
	tagOptions.prototype.Contains = function(optionName) {
		var _tmp, _tmp$1, i, next, o, optionName, s;
		o = this.$val;
		if (o.length === 0) {
			return false;
		}
		s = (o);
		while (true) {
			if (!(!(s === ""))) { break; }
			next = "";
			i = strings.Index(s, ",");
			if (i >= 0) {
				_tmp = $substring(s, 0, i);
				_tmp$1 = $substring(s, (i + 1 >> 0));
				s = _tmp;
				next = _tmp$1;
			}
			if (s === optionName) {
				return true;
			}
			s = next;
		}
		return false;
	};
	$ptrType(tagOptions).prototype.Contains = function(optionName) { return new tagOptions(this.$get()).Contains(optionName); };
	Number.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Float64", name: "Float64", pkg: "", typ: $funcType([], [$Float64, $error], false)}, {prop: "Int64", name: "Int64", pkg: "", typ: $funcType([], [$Int64, $error], false)}];
	ptrType$15.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$16.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$18.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$7.methods = [{prop: "marshal", name: "marshal", pkg: "encoding/json", typ: $funcType([$emptyInterface, encOpts], [$error], false)}, {prop: "error", name: "error", pkg: "encoding/json", typ: $funcType([$error], [], false)}, {prop: "reflectValue", name: "reflectValue", pkg: "encoding/json", typ: $funcType([reflect.Value, encOpts], [], false)}, {prop: "string", name: "string", pkg: "encoding/json", typ: $funcType([$String, $Bool], [$Int], false)}, {prop: "stringBytes", name: "stringBytes", pkg: "encoding/json", typ: $funcType([sliceType$1, $Bool], [$Int], false)}];
	floatEncoder.methods = [{prop: "encode", name: "encode", pkg: "encoding/json", typ: $funcType([ptrType$7, reflect.Value, encOpts], [], false)}];
	ptrType$19.methods = [{prop: "encode", name: "encode", pkg: "encoding/json", typ: $funcType([ptrType$7, reflect.Value, encOpts], [], false)}];
	ptrType$20.methods = [{prop: "encode", name: "encode", pkg: "encoding/json", typ: $funcType([ptrType$7, reflect.Value, encOpts], [], false)}];
	ptrType$21.methods = [{prop: "encode", name: "encode", pkg: "encoding/json", typ: $funcType([ptrType$7, reflect.Value, encOpts], [], false)}];
	ptrType$22.methods = [{prop: "encode", name: "encode", pkg: "encoding/json", typ: $funcType([ptrType$7, reflect.Value, encOpts], [], false)}];
	ptrType$23.methods = [{prop: "encode", name: "encode", pkg: "encoding/json", typ: $funcType([ptrType$7, reflect.Value, encOpts], [], false)}];
	ptrType$24.methods = [{prop: "encode", name: "encode", pkg: "encoding/json", typ: $funcType([ptrType$7, reflect.Value, encOpts], [], false)}];
	ptrType$25.methods = [{prop: "resolve", name: "resolve", pkg: "encoding/json", typ: $funcType([], [$error], false)}];
	byIndex.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Swap", name: "Swap", pkg: "", typ: $funcType([$Int, $Int], [], false)}, {prop: "Less", name: "Less", pkg: "", typ: $funcType([$Int, $Int], [$Bool], false)}];
	ptrType$11.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$26.methods = [{prop: "reset", name: "reset", pkg: "encoding/json", typ: $funcType([], [], false)}, {prop: "eof", name: "eof", pkg: "encoding/json", typ: $funcType([], [$Int], false)}, {prop: "pushParseState", name: "pushParseState", pkg: "encoding/json", typ: $funcType([$Int], [], false)}, {prop: "popParseState", name: "popParseState", pkg: "encoding/json", typ: $funcType([], [], false)}, {prop: "error", name: "error", pkg: "encoding/json", typ: $funcType([$Uint8, $String], [$Int], false)}, {prop: "undo", name: "undo", pkg: "encoding/json", typ: $funcType([$Int], [], false)}];
	tagOptions.methods = [{prop: "Contains", name: "Contains", pkg: "", typ: $funcType([$String], [$Bool], false)}];
	Marshaler.init([{prop: "MarshalJSON", name: "MarshalJSON", pkg: "", typ: $funcType([], [sliceType$1, $error], false)}]);
	UnsupportedTypeError.init("", [{prop: "Type", name: "Type", anonymous: false, exported: true, typ: reflect.Type, tag: ""}]);
	UnsupportedValueError.init("", [{prop: "Value", name: "Value", anonymous: false, exported: true, typ: reflect.Value, tag: ""}, {prop: "Str", name: "Str", anonymous: false, exported: true, typ: $String, tag: ""}]);
	MarshalerError.init("", [{prop: "Type", name: "Type", anonymous: false, exported: true, typ: reflect.Type, tag: ""}, {prop: "Err", name: "Err", anonymous: false, exported: true, typ: $error, tag: ""}]);
	encodeState.init("encoding/json", [{prop: "Buffer", name: "Buffer", anonymous: true, exported: true, typ: bytes.Buffer, tag: ""}, {prop: "scratch", name: "scratch", anonymous: false, exported: false, typ: arrayType, tag: ""}]);
	encOpts.init("encoding/json", [{prop: "quoted", name: "quoted", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "escapeHTML", name: "escapeHTML", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	encoderFunc.init([ptrType$7, reflect.Value, encOpts], [], false);
	structEncoder.init("encoding/json", [{prop: "fields", name: "fields", anonymous: false, exported: false, typ: sliceType$3, tag: ""}, {prop: "fieldEncs", name: "fieldEncs", anonymous: false, exported: false, typ: sliceType$4, tag: ""}]);
	mapEncoder.init("encoding/json", [{prop: "elemEnc", name: "elemEnc", anonymous: false, exported: false, typ: encoderFunc, tag: ""}]);
	sliceEncoder.init("encoding/json", [{prop: "arrayEnc", name: "arrayEnc", anonymous: false, exported: false, typ: encoderFunc, tag: ""}]);
	arrayEncoder.init("encoding/json", [{prop: "elemEnc", name: "elemEnc", anonymous: false, exported: false, typ: encoderFunc, tag: ""}]);
	ptrEncoder.init("encoding/json", [{prop: "elemEnc", name: "elemEnc", anonymous: false, exported: false, typ: encoderFunc, tag: ""}]);
	condAddrEncoder.init("encoding/json", [{prop: "canAddrEnc", name: "canAddrEnc", anonymous: false, exported: false, typ: encoderFunc, tag: ""}, {prop: "elseEnc", name: "elseEnc", anonymous: false, exported: false, typ: encoderFunc, tag: ""}]);
	reflectWithString.init("encoding/json", [{prop: "v", name: "v", anonymous: false, exported: false, typ: reflect.Value, tag: ""}, {prop: "s", name: "s", anonymous: false, exported: false, typ: $String, tag: ""}]);
	field.init("encoding/json", [{prop: "name", name: "name", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "nameBytes", name: "nameBytes", anonymous: false, exported: false, typ: sliceType$1, tag: ""}, {prop: "equalFold", name: "equalFold", anonymous: false, exported: false, typ: funcType, tag: ""}, {prop: "tag", name: "tag", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "index", name: "index", anonymous: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "typ", name: "typ", anonymous: false, exported: false, typ: reflect.Type, tag: ""}, {prop: "omitEmpty", name: "omitEmpty", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "quoted", name: "quoted", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	byIndex.init(field);
	SyntaxError.init("encoding/json", [{prop: "msg", name: "msg", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "Offset", name: "Offset", anonymous: false, exported: true, typ: $Int64, tag: ""}]);
	scanner.init("encoding/json", [{prop: "step", name: "step", anonymous: false, exported: false, typ: funcType$1, tag: ""}, {prop: "endTop", name: "endTop", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "parseState", name: "parseState", anonymous: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "err", name: "err", anonymous: false, exported: false, typ: $error, tag: ""}, {prop: "redo", name: "redo", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "redoCode", name: "redoCode", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "redoState", name: "redoState", anonymous: false, exported: false, typ: funcType$1, tag: ""}, {prop: "bytes", name: "bytes", anonymous: false, exported: false, typ: $Int64, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = encoding.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = base64.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmt.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = nosync.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = reflect.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sort.$init(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 14; case 14: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf16.$init(); /* */ $s = 16; case 16: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 17; case 17: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		encoderCache = new nosync.Map.ptr(false);
		fieldCache = new structType.ptr(new atomic.Value.ptr(new atomic.noCopy.ptr(), $ifaceNil), new nosync.Mutex.ptr(false));
		errPhase = errors.New("JSON decoder out of sync - data changing underfoot?");
		_r = reflect.TypeOf($newDataPointer($ifaceNil, ptrType)).Elem(); /* */ $s = 18; case 18: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		textUnmarshalerType = _r;
		numberType = reflect.TypeOf(new Number(""));
		hex = "0123456789abcdef";
		_r$1 = reflect.TypeOf($newDataPointer($ifaceNil, ptrType$1)).Elem(); /* */ $s = 19; case 19: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		marshalerType = _r$1;
		_r$2 = reflect.TypeOf($newDataPointer($ifaceNil, ptrType$2)).Elem(); /* */ $s = 20; case 20: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		textMarshalerType = _r$2;
		float32Encoder = $methodVal(new floatEncoder(32), "encode");
		float64Encoder = $methodVal(new floatEncoder(64), "encode");
		safeSet = $toNativeArray($kindBool, [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true]);
		htmlSafeSet = $toNativeArray($kindBool, [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["encoding/xml"] = (function() {
	var $pkg = {}, $init, bufio, bytes, encoding, errors, fmt, io, reflect, strconv, strings, sync, unicode, utf8, Marshaler, MarshalerAttr, Encoder, printer, parentStack, UnsupportedTypeError, UnmarshalError, Unmarshaler, UnmarshalerAttr, typeInfo, fieldInfo, fieldFlags, TagPathError, SyntaxError, Name, Attr, Token, StartElement, EndElement, CharData, Comment, ProcInst, Directive, Decoder, stack, sliceType, ptrType, ptrType$1, ptrType$2, ptrType$3, ptrType$4, ptrType$5, sliceType$1, sliceType$2, sliceType$3, arrayType, ptrType$6, ptrType$7, sliceType$4, ptrType$8, ptrType$9, sliceType$5, sliceType$6, ptrType$10, sliceType$7, ptrType$11, ptrType$12, ptrType$13, sliceType$8, sliceType$9, ptrType$14, mapType, ptrType$15, ptrType$16, ptrType$17, ptrType$18, ptrType$19, ptrType$20, ptrType$21, funcType, begComment, endComment, endProcInst, marshalerType, marshalerAttrType, textMarshalerType, ddBytes, attrType, unmarshalerType, unmarshalerAttrType, textUnmarshalerType, tinfoMap, nameType, errRawToken, entity, first, second, esc_quot, esc_apos, esc_amp, esc_lt, esc_gt, esc_tab, esc_nl, esc_cr, esc_fffd, cdataStart, cdataEnd, cdataEscape, _r, _r$1, _r$2, x, _r$3, _r$4, _r$5, x$1, MarshalIndent, NewEncoder, isValidDirective, defaultStart, indirect, isEmptyValue, receiverType, copyValue, getTypeInfo, structFieldInfo, lookupXMLName, min, addFieldInfo, makeCopy, isInCharacterRange, isNameByte, isName, isNameString, EscapeText, escapeText, emitCDATA, procInst;
	bufio = $packages["bufio"];
	bytes = $packages["bytes"];
	encoding = $packages["encoding"];
	errors = $packages["errors"];
	fmt = $packages["fmt"];
	io = $packages["io"];
	reflect = $packages["reflect"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	sync = $packages["sync"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	Marshaler = $pkg.Marshaler = $newType(8, $kindInterface, "xml.Marshaler", true, "encoding/xml", true, null);
	MarshalerAttr = $pkg.MarshalerAttr = $newType(8, $kindInterface, "xml.MarshalerAttr", true, "encoding/xml", true, null);
	Encoder = $pkg.Encoder = $newType(0, $kindStruct, "xml.Encoder", true, "encoding/xml", true, function(p_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.p = new printer.ptr(ptrType$6.nil, ptrType$7.nil, 0, "", "", 0, false, false, false, false, sliceType$3.nil, sliceType$4.nil);
			return;
		}
		this.p = p_;
	});
	printer = $pkg.printer = $newType(0, $kindStruct, "xml.printer", true, "encoding/xml", false, function(Writer_, encoder_, seq_, indent_, prefix_, depth_, indentedIn_, putNewline_, attrNS_, attrPrefix_, prefixes_, tags_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Writer = ptrType$6.nil;
			this.encoder = ptrType$7.nil;
			this.seq = 0;
			this.indent = "";
			this.prefix = "";
			this.depth = 0;
			this.indentedIn = false;
			this.putNewline = false;
			this.attrNS = false;
			this.attrPrefix = false;
			this.prefixes = sliceType$3.nil;
			this.tags = sliceType$4.nil;
			return;
		}
		this.Writer = Writer_;
		this.encoder = encoder_;
		this.seq = seq_;
		this.indent = indent_;
		this.prefix = prefix_;
		this.depth = depth_;
		this.indentedIn = indentedIn_;
		this.putNewline = putNewline_;
		this.attrNS = attrNS_;
		this.attrPrefix = attrPrefix_;
		this.prefixes = prefixes_;
		this.tags = tags_;
	});
	parentStack = $pkg.parentStack = $newType(0, $kindStruct, "xml.parentStack", true, "encoding/xml", false, function(p_, stack_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.p = ptrType$10.nil;
			this.stack = sliceType$3.nil;
			return;
		}
		this.p = p_;
		this.stack = stack_;
	});
	UnsupportedTypeError = $pkg.UnsupportedTypeError = $newType(0, $kindStruct, "xml.UnsupportedTypeError", true, "encoding/xml", true, function(Type_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Type = $ifaceNil;
			return;
		}
		this.Type = Type_;
	});
	UnmarshalError = $pkg.UnmarshalError = $newType(8, $kindString, "xml.UnmarshalError", true, "encoding/xml", true, null);
	Unmarshaler = $pkg.Unmarshaler = $newType(8, $kindInterface, "xml.Unmarshaler", true, "encoding/xml", true, null);
	UnmarshalerAttr = $pkg.UnmarshalerAttr = $newType(8, $kindInterface, "xml.UnmarshalerAttr", true, "encoding/xml", true, null);
	typeInfo = $pkg.typeInfo = $newType(0, $kindStruct, "xml.typeInfo", true, "encoding/xml", false, function(xmlname_, fields_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.xmlname = ptrType$8.nil;
			this.fields = sliceType$8.nil;
			return;
		}
		this.xmlname = xmlname_;
		this.fields = fields_;
	});
	fieldInfo = $pkg.fieldInfo = $newType(0, $kindStruct, "xml.fieldInfo", true, "encoding/xml", false, function(idx_, name_, xmlns_, flags_, parents_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.idx = sliceType$9.nil;
			this.name = "";
			this.xmlns = "";
			this.flags = 0;
			this.parents = sliceType$3.nil;
			return;
		}
		this.idx = idx_;
		this.name = name_;
		this.xmlns = xmlns_;
		this.flags = flags_;
		this.parents = parents_;
	});
	fieldFlags = $pkg.fieldFlags = $newType(4, $kindInt, "xml.fieldFlags", true, "encoding/xml", false, null);
	TagPathError = $pkg.TagPathError = $newType(0, $kindStruct, "xml.TagPathError", true, "encoding/xml", true, function(Struct_, Field1_, Tag1_, Field2_, Tag2_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Struct = $ifaceNil;
			this.Field1 = "";
			this.Tag1 = "";
			this.Field2 = "";
			this.Tag2 = "";
			return;
		}
		this.Struct = Struct_;
		this.Field1 = Field1_;
		this.Tag1 = Tag1_;
		this.Field2 = Field2_;
		this.Tag2 = Tag2_;
	});
	SyntaxError = $pkg.SyntaxError = $newType(0, $kindStruct, "xml.SyntaxError", true, "encoding/xml", true, function(Msg_, Line_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Msg = "";
			this.Line = 0;
			return;
		}
		this.Msg = Msg_;
		this.Line = Line_;
	});
	Name = $pkg.Name = $newType(0, $kindStruct, "xml.Name", true, "encoding/xml", true, function(Space_, Local_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Space = "";
			this.Local = "";
			return;
		}
		this.Space = Space_;
		this.Local = Local_;
	});
	Attr = $pkg.Attr = $newType(0, $kindStruct, "xml.Attr", true, "encoding/xml", true, function(Name_, Value_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = new Name.ptr("", "");
			this.Value = "";
			return;
		}
		this.Name = Name_;
		this.Value = Value_;
	});
	Token = $pkg.Token = $newType(8, $kindInterface, "xml.Token", true, "encoding/xml", true, null);
	StartElement = $pkg.StartElement = $newType(0, $kindStruct, "xml.StartElement", true, "encoding/xml", true, function(Name_, Attr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = new Name.ptr("", "");
			this.Attr = sliceType$6.nil;
			return;
		}
		this.Name = Name_;
		this.Attr = Attr_;
	});
	EndElement = $pkg.EndElement = $newType(0, $kindStruct, "xml.EndElement", true, "encoding/xml", true, function(Name_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = new Name.ptr("", "");
			return;
		}
		this.Name = Name_;
	});
	CharData = $pkg.CharData = $newType(12, $kindSlice, "xml.CharData", true, "encoding/xml", true, null);
	Comment = $pkg.Comment = $newType(12, $kindSlice, "xml.Comment", true, "encoding/xml", true, null);
	ProcInst = $pkg.ProcInst = $newType(0, $kindStruct, "xml.ProcInst", true, "encoding/xml", true, function(Target_, Inst_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Target = "";
			this.Inst = sliceType.nil;
			return;
		}
		this.Target = Target_;
		this.Inst = Inst_;
	});
	Directive = $pkg.Directive = $newType(12, $kindSlice, "xml.Directive", true, "encoding/xml", true, null);
	Decoder = $pkg.Decoder = $newType(0, $kindStruct, "xml.Decoder", true, "encoding/xml", true, function(Strict_, AutoClose_, Entity_, CharsetReader_, DefaultSpace_, r_, buf_, saved_, stk_, free_, needClose_, toClose_, nextToken_, nextByte_, ns_, err_, line_, offset_, unmarshalDepth_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Strict = false;
			this.AutoClose = sliceType$3.nil;
			this.Entity = false;
			this.CharsetReader = $throwNilPointerError;
			this.DefaultSpace = "";
			this.r = $ifaceNil;
			this.buf = new bytes.Buffer.ptr(sliceType.nil, 0, 0, arrayType.zero());
			this.saved = ptrType$13.nil;
			this.stk = ptrType$14.nil;
			this.free = ptrType$14.nil;
			this.needClose = false;
			this.toClose = new Name.ptr("", "");
			this.nextToken = $ifaceNil;
			this.nextByte = 0;
			this.ns = false;
			this.err = $ifaceNil;
			this.line = 0;
			this.offset = new $Int64(0, 0);
			this.unmarshalDepth = 0;
			return;
		}
		this.Strict = Strict_;
		this.AutoClose = AutoClose_;
		this.Entity = Entity_;
		this.CharsetReader = CharsetReader_;
		this.DefaultSpace = DefaultSpace_;
		this.r = r_;
		this.buf = buf_;
		this.saved = saved_;
		this.stk = stk_;
		this.free = free_;
		this.needClose = needClose_;
		this.toClose = toClose_;
		this.nextToken = nextToken_;
		this.nextByte = nextByte_;
		this.ns = ns_;
		this.err = err_;
		this.line = line_;
		this.offset = offset_;
		this.unmarshalDepth = unmarshalDepth_;
	});
	stack = $pkg.stack = $newType(0, $kindStruct, "xml.stack", true, "encoding/xml", false, function(next_, kind_, name_, ok_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.next = ptrType$14.nil;
			this.kind = 0;
			this.name = new Name.ptr("", "");
			this.ok = false;
			return;
		}
		this.next = next_;
		this.kind = kind_;
		this.name = name_;
		this.ok = ok_;
	});
	sliceType = $sliceType($Uint8);
	ptrType = $ptrType(Marshaler);
	ptrType$1 = $ptrType(MarshalerAttr);
	ptrType$2 = $ptrType(encoding.TextMarshaler);
	ptrType$3 = $ptrType(Unmarshaler);
	ptrType$4 = $ptrType(UnmarshalerAttr);
	ptrType$5 = $ptrType(encoding.TextUnmarshaler);
	sliceType$1 = $sliceType(unicode.Range16);
	sliceType$2 = $sliceType(unicode.Range32);
	sliceType$3 = $sliceType($String);
	arrayType = $arrayType($Uint8, 64);
	ptrType$6 = $ptrType(bufio.Writer);
	ptrType$7 = $ptrType(Encoder);
	sliceType$4 = $sliceType(Name);
	ptrType$8 = $ptrType(fieldInfo);
	ptrType$9 = $ptrType(StartElement);
	sliceType$5 = $sliceType($emptyInterface);
	sliceType$6 = $sliceType(Attr);
	ptrType$10 = $ptrType(printer);
	sliceType$7 = $sliceType(reflect.Value);
	ptrType$11 = $ptrType(reflect.rtype);
	ptrType$12 = $ptrType(typeInfo);
	ptrType$13 = $ptrType(bytes.Buffer);
	sliceType$8 = $sliceType(fieldInfo);
	sliceType$9 = $sliceType($Int);
	ptrType$14 = $ptrType(stack);
	mapType = $mapType($String, $String);
	ptrType$15 = $ptrType(parentStack);
	ptrType$16 = $ptrType(UnsupportedTypeError);
	ptrType$17 = $ptrType(Decoder);
	ptrType$18 = $ptrType(TagPathError);
	ptrType$19 = $ptrType(SyntaxError);
	ptrType$20 = $ptrType(Name);
	ptrType$21 = $ptrType(EndElement);
	funcType = $funcType([$String, io.Reader], [io.Reader, $error], false);
	MarshalIndent = function(v, prefix, indent) {
		var _r$6, b, enc, err, indent, prefix, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; b = $f.b; enc = $f.enc; err = $f.err; indent = $f.indent; prefix = $f.prefix; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = [b];
		b[0] = new bytes.Buffer.ptr(sliceType.nil, 0, 0, arrayType.zero());
		enc = NewEncoder(b[0]);
		enc.Indent(prefix, indent);
		_r$6 = enc.Encode(v); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		err = _r$6;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [sliceType.nil, err];
		}
		$s = -1; return [b[0].Bytes(), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: MarshalIndent }; } $f._r$6 = _r$6; $f.b = b; $f.enc = enc; $f.err = err; $f.indent = indent; $f.prefix = prefix; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MarshalIndent = MarshalIndent;
	NewEncoder = function(w) {
		var e, w;
		e = new Encoder.ptr(new printer.ptr(bufio.NewWriter(w), ptrType$7.nil, 0, "", "", 0, false, false, false, false, sliceType$3.nil, sliceType$4.nil));
		e.p.encoder = e;
		return e;
	};
	$pkg.NewEncoder = NewEncoder;
	Encoder.ptr.prototype.Indent = function(prefix, indent) {
		var enc, indent, prefix;
		enc = this;
		enc.p.prefix = prefix;
		enc.p.indent = indent;
	};
	Encoder.prototype.Indent = function(prefix, indent) { return this.$val.Indent(prefix, indent); };
	Encoder.ptr.prototype.Encode = function(v) {
		var _r$6, _r$7, _r$8, enc, err, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; enc = $f.enc; err = $f.err; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		enc = this;
		_r$6 = reflect.ValueOf(v); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_r$7 = enc.p.marshalValue($clone(_r$6, reflect.Value), ptrType$8.nil, ptrType$9.nil); /* */ $s = 2; case 2: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		err = _r$7;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r$8 = enc.p.Writer.Flush(); /* */ $s = 3; case 3: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		$s = -1; return _r$8;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Encoder.ptr.prototype.Encode }; } $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f.enc = enc; $f.err = err; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Encoder.prototype.Encode = function(v) { return this.$val.Encode(v); };
	Encoder.ptr.prototype.EncodeElement = function(v, start) {
		var _r$6, _r$7, _r$8, enc, err, start, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; enc = $f.enc; err = $f.err; start = $f.start; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		start = [start];
		enc = this;
		_r$6 = reflect.ValueOf(v); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_r$7 = enc.p.marshalValue($clone(_r$6, reflect.Value), ptrType$8.nil, start[0]); /* */ $s = 2; case 2: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		err = _r$7;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r$8 = enc.p.Writer.Flush(); /* */ $s = 3; case 3: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		$s = -1; return _r$8;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Encoder.ptr.prototype.EncodeElement }; } $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f.enc = enc; $f.err = err; $f.start = start; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Encoder.prototype.EncodeElement = function(v, start) { return this.$val.EncodeElement(v, start); };
	Encoder.ptr.prototype.EncodeToken = function(t) {
		var _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$20, _r$21, _r$22, _r$23, _r$24, _r$25, _r$26, _r$27, _r$6, _r$7, _r$8, _r$9, _ref, enc, err, err$1, p, t, t$1, t$2, t$3, t$4, t$5, t$6, t$7, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$23 = $f._r$23; _r$24 = $f._r$24; _r$25 = $f._r$25; _r$26 = $f._r$26; _r$27 = $f._r$27; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; enc = $f.enc; err = $f.err; err$1 = $f.err$1; p = $f.p; t = $f.t; t$1 = $f.t$1; t$2 = $f.t$2; t$3 = $f.t$3; t$4 = $f.t$4; t$5 = $f.t$5; t$6 = $f.t$6; t$7 = $f.t$7; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t$1 = [t$1];
		enc = this;
		p = enc.p;
		_ref = t;
		/* */ if ($assertType(_ref, StartElement, true)[1]) { $s = 1; continue; }
		/* */ if ($assertType(_ref, EndElement, true)[1]) { $s = 2; continue; }
		/* */ if ($assertType(_ref, CharData, true)[1]) { $s = 3; continue; }
		/* */ if ($assertType(_ref, Comment, true)[1]) { $s = 4; continue; }
		/* */ if ($assertType(_ref, ProcInst, true)[1]) { $s = 5; continue; }
		/* */ if ($assertType(_ref, Directive, true)[1]) { $s = 6; continue; }
		/* */ $s = 7; continue;
		/* if ($assertType(_ref, StartElement, true)[1]) { */ case 1:
			t$1[0] = $clone(_ref.$val, StartElement);
			_r$6 = p.writeStart(t$1[0]); /* */ $s = 9; case 9: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			err = _r$6;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			$s = 8; continue;
		/* } else if ($assertType(_ref, EndElement, true)[1]) { */ case 2:
			t$2 = $clone(_ref.$val, EndElement);
			_r$7 = p.writeEnd($clone(t$2.Name, Name)); /* */ $s = 10; case 10: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			err$1 = _r$7;
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				$s = -1; return err$1;
			}
			$s = 8; continue;
		/* } else if ($assertType(_ref, CharData, true)[1]) { */ case 3:
			t$3 = _ref.$val;
			_r$8 = escapeText(p, $subslice(new sliceType(t$3.$array), t$3.$offset, t$3.$offset + t$3.$length), false); /* */ $s = 11; case 11: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			_r$8;
			$s = 8; continue;
		/* } else if ($assertType(_ref, Comment, true)[1]) { */ case 4:
			t$4 = _ref.$val;
			/* */ if (bytes.Contains($subslice(new sliceType(t$4.$array), t$4.$offset, t$4.$offset + t$4.$length), endComment)) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if (bytes.Contains($subslice(new sliceType(t$4.$array), t$4.$offset, t$4.$offset + t$4.$length), endComment)) { */ case 12:
				_r$9 = fmt.Errorf("xml: EncodeToken of Comment containing --> marker", new sliceType$5([])); /* */ $s = 14; case 14: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				$s = -1; return _r$9;
			/* } */ case 13:
			_r$10 = p.Writer.WriteString("<!--"); /* */ $s = 15; case 15: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			_r$10;
			_r$11 = p.Writer.Write($subslice(new sliceType(t$4.$array), t$4.$offset, t$4.$offset + t$4.$length)); /* */ $s = 16; case 16: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
			_r$11;
			_r$12 = p.Writer.WriteString("-->"); /* */ $s = 17; case 17: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
			_r$12;
			_r$13 = p.cachedWriteError(); /* */ $s = 18; case 18: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
			$s = -1; return _r$13;
		/* } else if ($assertType(_ref, ProcInst, true)[1]) { */ case 5:
			t$5 = $clone(_ref.$val, ProcInst);
			/* */ if (t$5.Target === "xml" && !((p.Writer.Buffered() === 0))) { $s = 19; continue; }
			/* */ $s = 20; continue;
			/* if (t$5.Target === "xml" && !((p.Writer.Buffered() === 0))) { */ case 19:
				_r$14 = fmt.Errorf("xml: EncodeToken of ProcInst xml target only valid for xml declaration, first token encoded", new sliceType$5([])); /* */ $s = 21; case 21: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
				$s = -1; return _r$14;
			/* } */ case 20:
			/* */ if (!isNameString(t$5.Target)) { $s = 22; continue; }
			/* */ $s = 23; continue;
			/* if (!isNameString(t$5.Target)) { */ case 22:
				_r$15 = fmt.Errorf("xml: EncodeToken of ProcInst with invalid Target", new sliceType$5([])); /* */ $s = 24; case 24: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
				$s = -1; return _r$15;
			/* } */ case 23:
			/* */ if (bytes.Contains(t$5.Inst, endProcInst)) { $s = 25; continue; }
			/* */ $s = 26; continue;
			/* if (bytes.Contains(t$5.Inst, endProcInst)) { */ case 25:
				_r$16 = fmt.Errorf("xml: EncodeToken of ProcInst containing ?> marker", new sliceType$5([])); /* */ $s = 27; case 27: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
				$s = -1; return _r$16;
			/* } */ case 26:
			_r$17 = p.Writer.WriteString("<?"); /* */ $s = 28; case 28: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
			_r$17;
			_r$18 = p.Writer.WriteString(t$5.Target); /* */ $s = 29; case 29: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
			_r$18;
			/* */ if (t$5.Inst.$length > 0) { $s = 30; continue; }
			/* */ $s = 31; continue;
			/* if (t$5.Inst.$length > 0) { */ case 30:
				_r$19 = p.Writer.WriteByte(32); /* */ $s = 32; case 32: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
				_r$19;
				_r$20 = p.Writer.Write(t$5.Inst); /* */ $s = 33; case 33: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
				_r$20;
			/* } */ case 31:
			_r$21 = p.Writer.WriteString("?>"); /* */ $s = 34; case 34: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
			_r$21;
			$s = 8; continue;
		/* } else if ($assertType(_ref, Directive, true)[1]) { */ case 6:
			t$6 = _ref.$val;
			/* */ if (!isValidDirective(t$6)) { $s = 35; continue; }
			/* */ $s = 36; continue;
			/* if (!isValidDirective(t$6)) { */ case 35:
				_r$22 = fmt.Errorf("xml: EncodeToken of Directive containing wrong < or > markers", new sliceType$5([])); /* */ $s = 37; case 37: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }
				$s = -1; return _r$22;
			/* } */ case 36:
			_r$23 = p.Writer.WriteString("<!"); /* */ $s = 38; case 38: if($c) { $c = false; _r$23 = _r$23.$blk(); } if (_r$23 && _r$23.$blk !== undefined) { break s; }
			_r$23;
			_r$24 = p.Writer.Write($subslice(new sliceType(t$6.$array), t$6.$offset, t$6.$offset + t$6.$length)); /* */ $s = 39; case 39: if($c) { $c = false; _r$24 = _r$24.$blk(); } if (_r$24 && _r$24.$blk !== undefined) { break s; }
			_r$24;
			_r$25 = p.Writer.WriteString(">"); /* */ $s = 40; case 40: if($c) { $c = false; _r$25 = _r$25.$blk(); } if (_r$25 && _r$25.$blk !== undefined) { break s; }
			_r$25;
			$s = 8; continue;
		/* } else { */ case 7:
			t$7 = _ref;
			_r$26 = fmt.Errorf("xml: EncodeToken of invalid token type", new sliceType$5([])); /* */ $s = 41; case 41: if($c) { $c = false; _r$26 = _r$26.$blk(); } if (_r$26 && _r$26.$blk !== undefined) { break s; }
			$s = -1; return _r$26;
		/* } */ case 8:
		_r$27 = p.cachedWriteError(); /* */ $s = 42; case 42: if($c) { $c = false; _r$27 = _r$27.$blk(); } if (_r$27 && _r$27.$blk !== undefined) { break s; }
		$s = -1; return _r$27;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Encoder.ptr.prototype.EncodeToken }; } $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$23 = _r$23; $f._r$24 = _r$24; $f._r$25 = _r$25; $f._r$26 = _r$26; $f._r$27 = _r$27; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f.enc = enc; $f.err = err; $f.err$1 = err$1; $f.p = p; $f.t = t; $f.t$1 = t$1; $f.t$2 = t$2; $f.t$3 = t$3; $f.t$4 = t$4; $f.t$5 = t$5; $f.t$6 = t$6; $f.t$7 = t$7; $f.$s = $s; $f.$r = $r; return $f;
	};
	Encoder.prototype.EncodeToken = function(t) { return this.$val.EncodeToken(t); };
	isValidDirective = function(dir) {
		var _i, _ref, c, depth, dir, i, incomment, inquote, n, x$2, x$3;
		depth = 0;
		inquote = 0;
		incomment = false;
		_ref = dir;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (incomment) {
				if (c === 62) {
					n = (1 + i >> 0) - endComment.$length >> 0;
					if (n >= 0 && bytes.Equal((x$2 = $subslice(dir, n, (i + 1 >> 0)), $subslice(new sliceType(x$2.$array), x$2.$offset, x$2.$offset + x$2.$length)), endComment)) {
						incomment = false;
					}
				}
			} else if (!((inquote === 0))) {
				if (c === inquote) {
					inquote = 0;
				}
			} else if ((c === 39) || (c === 34)) {
				inquote = c;
			} else if ((c === 60)) {
				if ((i + begComment.$length >> 0) < dir.$length && bytes.Equal((x$3 = $subslice(dir, i, (i + begComment.$length >> 0)), $subslice(new sliceType(x$3.$array), x$3.$offset, x$3.$offset + x$3.$length)), begComment)) {
					incomment = true;
				} else {
					depth = depth + (1) >> 0;
				}
			} else if ((c === 62)) {
				if (depth === 0) {
					return false;
				}
				depth = depth - (1) >> 0;
			}
			_i++;
		}
		return (depth === 0) && (inquote === 0) && !incomment;
	};
	Encoder.ptr.prototype.Flush = function() {
		var _r$6, enc, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; enc = $f.enc; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		enc = this;
		_r$6 = enc.p.Writer.Flush(); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		$s = -1; return _r$6;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Encoder.ptr.prototype.Flush }; } $f._r$6 = _r$6; $f.enc = enc; $f.$s = $s; $f.$r = $r; return $f;
	};
	Encoder.prototype.Flush = function() { return this.$val.Flush(); };
	printer.ptr.prototype.createAttrPrefix = function(url) {
		var _entry, _entry$1, _entry$2, _key, _key$1, _r$10, _r$11, _r$6, _r$7, _r$8, _r$9, i, id, p, prefix, prefix$1, url, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _key = $f._key; _key$1 = $f._key$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; i = $f.i; id = $f.id; p = $f.p; prefix = $f.prefix; prefix$1 = $f.prefix$1; url = $f.url; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		prefix = (_entry = p.attrPrefix[$String.keyFor(url)], _entry !== undefined ? _entry.v : "");
		if (!(prefix === "")) {
			$s = -1; return prefix;
		}
		if (url === "http://www.w3.org/XML/1998/namespace") {
			$s = -1; return "xml";
		}
		if (p.attrPrefix === false) {
			p.attrPrefix = {};
			p.attrNS = {};
		}
		_r$6 = strings.TrimRight(url, "/"); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		prefix$1 = _r$6;
		i = strings.LastIndex(prefix$1, "/");
		if (i >= 0) {
			prefix$1 = $substring(prefix$1, (i + 1 >> 0));
		}
		if (prefix$1 === "" || !isName((new sliceType($stringToBytes(prefix$1)))) || strings.Contains(prefix$1, ":")) {
			prefix$1 = "_";
		}
		if (strings.HasPrefix(prefix$1, "xml")) {
			prefix$1 = "_" + prefix$1;
		}
		if (!((_entry$1 = p.attrNS[$String.keyFor(prefix$1)], _entry$1 !== undefined ? _entry$1.v : "") === "")) {
			p.seq = p.seq + (1) >> 0;
			while (true) {
				id = prefix$1 + "_" + strconv.Itoa(p.seq);
				if ((_entry$2 = p.attrNS[$String.keyFor(id)], _entry$2 !== undefined ? _entry$2.v : "") === "") {
					prefix$1 = id;
					break;
				}
				p.seq = p.seq + (1) >> 0;
			}
		}
		_key = url; (p.attrPrefix || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: prefix$1 };
		_key$1 = prefix$1; (p.attrNS || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key$1)] = { k: _key$1, v: url };
		_r$7 = p.Writer.WriteString("xmlns:"); /* */ $s = 2; case 2: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_r$7;
		_r$8 = p.Writer.WriteString(prefix$1); /* */ $s = 3; case 3: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		_r$8;
		_r$9 = p.Writer.WriteString("=\""); /* */ $s = 4; case 4: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
		_r$9;
		_r$10 = EscapeText(p, (new sliceType($stringToBytes(url)))); /* */ $s = 5; case 5: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
		_r$10;
		_r$11 = p.Writer.WriteString("\" "); /* */ $s = 6; case 6: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
		_r$11;
		p.prefixes = $append(p.prefixes, prefix$1);
		$s = -1; return prefix$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.createAttrPrefix }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._key = _key; $f._key$1 = _key$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f.i = i; $f.id = id; $f.p = p; $f.prefix = prefix; $f.prefix$1 = prefix$1; $f.url = url; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.createAttrPrefix = function(url) { return this.$val.createAttrPrefix(url); };
	printer.ptr.prototype.deleteAttrPrefix = function(prefix) {
		var _entry, p, prefix;
		p = this;
		delete p.attrPrefix[$String.keyFor((_entry = p.attrNS[$String.keyFor(prefix)], _entry !== undefined ? _entry.v : ""))];
		delete p.attrNS[$String.keyFor(prefix)];
	};
	printer.prototype.deleteAttrPrefix = function(prefix) { return this.$val.deleteAttrPrefix(prefix); };
	printer.ptr.prototype.markPrefix = function() {
		var p;
		p = this;
		p.prefixes = $append(p.prefixes, "");
	};
	printer.prototype.markPrefix = function() { return this.$val.markPrefix(); };
	printer.ptr.prototype.popPrefix = function() {
		var p, prefix, x$2, x$3;
		p = this;
		while (true) {
			if (!(p.prefixes.$length > 0)) { break; }
			prefix = (x$2 = p.prefixes, x$3 = p.prefixes.$length - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]));
			p.prefixes = $subslice(p.prefixes, 0, (p.prefixes.$length - 1 >> 0));
			if (prefix === "") {
				break;
			}
			p.deleteAttrPrefix(prefix);
		}
	};
	printer.prototype.popPrefix = function() { return this.$val.popPrefix(); };
	printer.ptr.prototype.marshalValue = function(val, finfo, startTemplate) {
		var _arg, _arg$1, _arg$2, _arg$3, _arg$4, _arg$5, _arg$6, _arg$7, _i, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$20, _r$21, _r$22, _r$23, _r$24, _r$25, _r$26, _r$27, _r$28, _r$29, _r$30, _r$31, _r$32, _r$33, _r$34, _r$35, _r$36, _r$37, _r$38, _r$39, _r$6, _r$7, _r$8, _r$9, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, _tuple$2, _v, _v$1, _v$2, _v$3, _v$4, b, err, err$1, err$2, err$3, err$4, err1, finfo, finfo$1, fv, i, i$1, kind, n, name, name$1, ok, p, pv, pv$1, s, start, startTemplate, tinfo, typ, v, val, x$2, xmlname, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _arg$3 = $f._arg$3; _arg$4 = $f._arg$4; _arg$5 = $f._arg$5; _arg$6 = $f._arg$6; _arg$7 = $f._arg$7; _i = $f._i; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$23 = $f._r$23; _r$24 = $f._r$24; _r$25 = $f._r$25; _r$26 = $f._r$26; _r$27 = $f._r$27; _r$28 = $f._r$28; _r$29 = $f._r$29; _r$30 = $f._r$30; _r$31 = $f._r$31; _r$32 = $f._r$32; _r$33 = $f._r$33; _r$34 = $f._r$34; _r$35 = $f._r$35; _r$36 = $f._r$36; _r$37 = $f._r$37; _r$38 = $f._r$38; _r$39 = $f._r$39; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; _v$3 = $f._v$3; _v$4 = $f._v$4; b = $f.b; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; err$4 = $f.err$4; err1 = $f.err1; finfo = $f.finfo; finfo$1 = $f.finfo$1; fv = $f.fv; i = $f.i; i$1 = $f.i$1; kind = $f.kind; n = $f.n; name = $f.name; name$1 = $f.name$1; ok = $f.ok; p = $f.p; pv = $f.pv; pv$1 = $f.pv$1; s = $f.s; start = $f.start; startTemplate = $f.startTemplate; tinfo = $f.tinfo; typ = $f.typ; v = $f.v; val = $f.val; x$2 = $f.x$2; xmlname = $f.xmlname; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		start = [start];
		p = this;
		/* */ if (!(startTemplate === ptrType$9.nil) && startTemplate.Name.Local === "") { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(startTemplate === ptrType$9.nil) && startTemplate.Name.Local === "") { */ case 1:
			_r$6 = fmt.Errorf("xml: EncodeElement of StartElement with missing name", new sliceType$5([])); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			$s = -1; return _r$6;
		/* } */ case 2:
		if (!$clone(val, reflect.Value).IsValid()) {
			$s = -1; return $ifaceNil;
		}
		if (!(finfo === ptrType$8.nil) && !(((finfo.flags & 128) === 0)) && isEmptyValue($clone(val, reflect.Value))) {
			$s = -1; return $ifaceNil;
		}
		/* while (true) { */ case 4:
			/* if (!(($clone(val, reflect.Value).Kind() === 20) || ($clone(val, reflect.Value).Kind() === 22))) { break; } */ if(!(($clone(val, reflect.Value).Kind() === 20) || ($clone(val, reflect.Value).Kind() === 22))) { $s = 5; continue; }
			if ($clone(val, reflect.Value).IsNil()) {
				$s = -1; return $ifaceNil;
			}
			_r$7 = $clone(val, reflect.Value).Elem(); /* */ $s = 6; case 6: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			val = _r$7;
		/* } */ $s = 4; continue; case 5:
		kind = $clone(val, reflect.Value).Kind();
		typ = $clone(val, reflect.Value).Type();
		if (!($clone(val, reflect.Value).CanInterface())) { _v = false; $s = 9; continue s; }
		_r$8 = typ.Implements(marshalerType); /* */ $s = 10; case 10: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		_v = _r$8; case 9:
		/* */ if (_v) { $s = 7; continue; }
		/* */ $s = 8; continue;
		/* if (_v) { */ case 7:
			_r$9 = $clone(val, reflect.Value).Interface(); /* */ $s = 11; case 11: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
			_arg = $assertType(_r$9, Marshaler);
			_r$10 = defaultStart(typ, finfo, startTemplate); /* */ $s = 12; case 12: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			_arg$1 = $clone(_r$10, StartElement);
			_r$11 = p.marshalInterface(_arg, _arg$1); /* */ $s = 13; case 13: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
			$s = -1; return _r$11;
		/* } */ case 8:
		/* */ if ($clone(val, reflect.Value).CanAddr()) { $s = 14; continue; }
		/* */ $s = 15; continue;
		/* if ($clone(val, reflect.Value).CanAddr()) { */ case 14:
			pv = $clone(val, reflect.Value).Addr();
			if (!($clone(pv, reflect.Value).CanInterface())) { _v$1 = false; $s = 18; continue s; }
			_r$12 = $clone(pv, reflect.Value).Type().Implements(marshalerType); /* */ $s = 19; case 19: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
			_v$1 = _r$12; case 18:
			/* */ if (_v$1) { $s = 16; continue; }
			/* */ $s = 17; continue;
			/* if (_v$1) { */ case 16:
				_r$13 = $clone(pv, reflect.Value).Interface(); /* */ $s = 20; case 20: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
				_arg$2 = $assertType(_r$13, Marshaler);
				_r$14 = defaultStart($clone(pv, reflect.Value).Type(), finfo, startTemplate); /* */ $s = 21; case 21: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
				_arg$3 = $clone(_r$14, StartElement);
				_r$15 = p.marshalInterface(_arg$2, _arg$3); /* */ $s = 22; case 22: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
				$s = -1; return _r$15;
			/* } */ case 17:
		/* } */ case 15:
		if (!($clone(val, reflect.Value).CanInterface())) { _v$2 = false; $s = 25; continue s; }
		_r$16 = typ.Implements(textMarshalerType); /* */ $s = 26; case 26: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
		_v$2 = _r$16; case 25:
		/* */ if (_v$2) { $s = 23; continue; }
		/* */ $s = 24; continue;
		/* if (_v$2) { */ case 23:
			_r$17 = $clone(val, reflect.Value).Interface(); /* */ $s = 27; case 27: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
			_arg$4 = $assertType(_r$17, encoding.TextMarshaler);
			_r$18 = defaultStart(typ, finfo, startTemplate); /* */ $s = 28; case 28: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
			_arg$5 = $clone(_r$18, StartElement);
			_r$19 = p.marshalTextInterface(_arg$4, _arg$5); /* */ $s = 29; case 29: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
			$s = -1; return _r$19;
		/* } */ case 24:
		/* */ if ($clone(val, reflect.Value).CanAddr()) { $s = 30; continue; }
		/* */ $s = 31; continue;
		/* if ($clone(val, reflect.Value).CanAddr()) { */ case 30:
			pv$1 = $clone(val, reflect.Value).Addr();
			if (!($clone(pv$1, reflect.Value).CanInterface())) { _v$3 = false; $s = 34; continue s; }
			_r$20 = $clone(pv$1, reflect.Value).Type().Implements(textMarshalerType); /* */ $s = 35; case 35: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
			_v$3 = _r$20; case 34:
			/* */ if (_v$3) { $s = 32; continue; }
			/* */ $s = 33; continue;
			/* if (_v$3) { */ case 32:
				_r$21 = $clone(pv$1, reflect.Value).Interface(); /* */ $s = 36; case 36: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
				_arg$6 = $assertType(_r$21, encoding.TextMarshaler);
				_r$22 = defaultStart($clone(pv$1, reflect.Value).Type(), finfo, startTemplate); /* */ $s = 37; case 37: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }
				_arg$7 = $clone(_r$22, StartElement);
				_r$23 = p.marshalTextInterface(_arg$6, _arg$7); /* */ $s = 38; case 38: if($c) { $c = false; _r$23 = _r$23.$blk(); } if (_r$23 && _r$23.$blk !== undefined) { break s; }
				$s = -1; return _r$23;
			/* } */ case 33:
		/* } */ case 31:
		if (!((kind === 23) || (kind === 17))) { _v$4 = false; $s = 41; continue s; }
		_r$24 = typ.Elem(); /* */ $s = 42; case 42: if($c) { $c = false; _r$24 = _r$24.$blk(); } if (_r$24 && _r$24.$blk !== undefined) { break s; }
		_r$25 = _r$24.Kind(); /* */ $s = 43; case 43: if($c) { $c = false; _r$25 = _r$25.$blk(); } if (_r$25 && _r$25.$blk !== undefined) { break s; }
		_v$4 = !((_r$25 === 8)); case 41:
		/* */ if (_v$4) { $s = 39; continue; }
		/* */ $s = 40; continue;
		/* if (_v$4) { */ case 39:
			_tmp = 0;
			_tmp$1 = $clone(val, reflect.Value).Len();
			i = _tmp;
			n = _tmp$1;
			/* while (true) { */ case 44:
				/* if (!(i < n)) { break; } */ if(!(i < n)) { $s = 45; continue; }
				_r$26 = $clone(val, reflect.Value).Index(i); /* */ $s = 46; case 46: if($c) { $c = false; _r$26 = _r$26.$blk(); } if (_r$26 && _r$26.$blk !== undefined) { break s; }
				_r$27 = p.marshalValue($clone(_r$26, reflect.Value), finfo, startTemplate); /* */ $s = 47; case 47: if($c) { $c = false; _r$27 = _r$27.$blk(); } if (_r$27 && _r$27.$blk !== undefined) { break s; }
				err = _r$27;
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					$s = -1; return err;
				}
				i = i + (1) >> 0;
			/* } */ $s = 44; continue; case 45:
			$s = -1; return $ifaceNil;
		/* } */ case 40:
		_r$28 = getTypeInfo(typ); /* */ $s = 48; case 48: if($c) { $c = false; _r$28 = _r$28.$blk(); } if (_r$28 && _r$28.$blk !== undefined) { break s; }
		_tuple = _r$28;
		tinfo = _tuple[0];
		err$1 = _tuple[1];
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return err$1;
		}
		start[0] = new StartElement.ptr(new Name.ptr("", ""), sliceType$6.nil);
		/* */ if (!(startTemplate === ptrType$9.nil)) { $s = 49; continue; }
		/* */ if (!(tinfo.xmlname === ptrType$8.nil)) { $s = 50; continue; }
		/* */ $s = 51; continue;
		/* if (!(startTemplate === ptrType$9.nil)) { */ case 49:
			Name.copy(start[0].Name, startTemplate.Name);
			start[0].Attr = $appendSlice(start[0].Attr, startTemplate.Attr);
			$s = 51; continue;
		/* } else if (!(tinfo.xmlname === ptrType$8.nil)) { */ case 50:
			xmlname = tinfo.xmlname;
			/* */ if (!(xmlname.name === "")) { $s = 52; continue; }
			/* */ $s = 53; continue;
			/* if (!(xmlname.name === "")) { */ case 52:
				_tmp$2 = xmlname.xmlns;
				_tmp$3 = xmlname.name;
				start[0].Name.Space = _tmp$2;
				start[0].Name.Local = _tmp$3;
				$s = 54; continue;
			/* } else { */ case 53:
				_r$29 = xmlname.value($clone(val, reflect.Value)); /* */ $s = 55; case 55: if($c) { $c = false; _r$29 = _r$29.$blk(); } if (_r$29 && _r$29.$blk !== undefined) { break s; }
				_r$30 = $clone(_r$29, reflect.Value).Interface(); /* */ $s = 56; case 56: if($c) { $c = false; _r$30 = _r$30.$blk(); } if (_r$30 && _r$30.$blk !== undefined) { break s; }
				_tuple$1 = $assertType(_r$30, Name, true);
				v = $clone(_tuple$1[0], Name);
				ok = _tuple$1[1];
				if (ok && !(v.Local === "")) {
					Name.copy(start[0].Name, v);
				}
			/* } */ case 54:
		/* } */ case 51:
		if (start[0].Name.Local === "" && !(finfo === ptrType$8.nil)) {
			_tmp$4 = finfo.xmlns;
			_tmp$5 = finfo.name;
			start[0].Name.Space = _tmp$4;
			start[0].Name.Local = _tmp$5;
		}
		/* */ if (start[0].Name.Local === "") { $s = 57; continue; }
		/* */ $s = 58; continue;
		/* if (start[0].Name.Local === "") { */ case 57:
			_r$31 = typ.Name(); /* */ $s = 59; case 59: if($c) { $c = false; _r$31 = _r$31.$blk(); } if (_r$31 && _r$31.$blk !== undefined) { break s; }
			name = _r$31;
			if (name === "") {
				$s = -1; return new UnsupportedTypeError.ptr(typ);
			}
			start[0].Name.Local = name;
		/* } */ case 58:
		_ref = tinfo.fields;
		_i = 0;
		/* while (true) { */ case 60:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 61; continue; }
			i$1 = _i;
			finfo$1 = (x$2 = tinfo.fields, ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1]));
			/* */ if ((finfo$1.flags & 2) === 0) { $s = 62; continue; }
			/* */ $s = 63; continue;
			/* if ((finfo$1.flags & 2) === 0) { */ case 62:
				_i++;
				/* continue; */ $s = 60; continue;
			/* } */ case 63:
			_r$32 = finfo$1.value($clone(val, reflect.Value)); /* */ $s = 64; case 64: if($c) { $c = false; _r$32 = _r$32.$blk(); } if (_r$32 && _r$32.$blk !== undefined) { break s; }
			fv = _r$32;
			/* */ if (!(((finfo$1.flags & 128) === 0)) && isEmptyValue($clone(fv, reflect.Value))) { $s = 65; continue; }
			/* */ $s = 66; continue;
			/* if (!(((finfo$1.flags & 128) === 0)) && isEmptyValue($clone(fv, reflect.Value))) { */ case 65:
				_i++;
				/* continue; */ $s = 60; continue;
			/* } */ case 66:
			/* */ if (($clone(fv, reflect.Value).Kind() === 20) && $clone(fv, reflect.Value).IsNil()) { $s = 67; continue; }
			/* */ $s = 68; continue;
			/* if (($clone(fv, reflect.Value).Kind() === 20) && $clone(fv, reflect.Value).IsNil()) { */ case 67:
				_i++;
				/* continue; */ $s = 60; continue;
			/* } */ case 68:
			name$1 = new Name.ptr(finfo$1.xmlns, finfo$1.name);
			_r$33 = p.marshalAttr(start[0], $clone(name$1, Name), $clone(fv, reflect.Value)); /* */ $s = 69; case 69: if($c) { $c = false; _r$33 = _r$33.$blk(); } if (_r$33 && _r$33.$blk !== undefined) { break s; }
			err$2 = _r$33;
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return err$2;
			}
			_i++;
		/* } */ $s = 60; continue; case 61:
		_r$34 = p.writeStart(start[0]); /* */ $s = 70; case 70: if($c) { $c = false; _r$34 = _r$34.$blk(); } if (_r$34 && _r$34.$blk !== undefined) { break s; }
		err$3 = _r$34;
		if (!($interfaceIsEqual(err$3, $ifaceNil))) {
			$s = -1; return err$3;
		}
		/* */ if ($clone(val, reflect.Value).Kind() === 25) { $s = 71; continue; }
		/* */ $s = 72; continue;
		/* if ($clone(val, reflect.Value).Kind() === 25) { */ case 71:
			_r$35 = p.marshalStruct(tinfo, $clone(val, reflect.Value)); /* */ $s = 74; case 74: if($c) { $c = false; _r$35 = _r$35.$blk(); } if (_r$35 && _r$35.$blk !== undefined) { break s; }
			err$1 = _r$35;
			$s = 73; continue;
		/* } else { */ case 72:
			_r$36 = p.marshalSimple(typ, $clone(val, reflect.Value)); /* */ $s = 75; case 75: if($c) { $c = false; _r$36 = _r$36.$blk(); } if (_r$36 && _r$36.$blk !== undefined) { break s; }
			_tuple$2 = _r$36;
			s = _tuple$2[0];
			b = _tuple$2[1];
			err1 = _tuple$2[2];
			/* */ if (!($interfaceIsEqual(err1, $ifaceNil))) { $s = 76; continue; }
			/* */ if (!(b === sliceType.nil)) { $s = 77; continue; }
			/* */ $s = 78; continue;
			/* if (!($interfaceIsEqual(err1, $ifaceNil))) { */ case 76:
				err$1 = err1;
				$s = 79; continue;
			/* } else if (!(b === sliceType.nil)) { */ case 77:
				_r$37 = EscapeText(p, b); /* */ $s = 80; case 80: if($c) { $c = false; _r$37 = _r$37.$blk(); } if (_r$37 && _r$37.$blk !== undefined) { break s; }
				_r$37;
				$s = 79; continue;
			/* } else { */ case 78:
				$r = p.EscapeString(s); /* */ $s = 81; case 81: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 79:
		/* } */ case 73:
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return err$1;
		}
		_r$38 = p.writeEnd($clone(start[0].Name, Name)); /* */ $s = 82; case 82: if($c) { $c = false; _r$38 = _r$38.$blk(); } if (_r$38 && _r$38.$blk !== undefined) { break s; }
		err$4 = _r$38;
		if (!($interfaceIsEqual(err$4, $ifaceNil))) {
			$s = -1; return err$4;
		}
		_r$39 = p.cachedWriteError(); /* */ $s = 83; case 83: if($c) { $c = false; _r$39 = _r$39.$blk(); } if (_r$39 && _r$39.$blk !== undefined) { break s; }
		$s = -1; return _r$39;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.marshalValue }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._arg$3 = _arg$3; $f._arg$4 = _arg$4; $f._arg$5 = _arg$5; $f._arg$6 = _arg$6; $f._arg$7 = _arg$7; $f._i = _i; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$23 = _r$23; $f._r$24 = _r$24; $f._r$25 = _r$25; $f._r$26 = _r$26; $f._r$27 = _r$27; $f._r$28 = _r$28; $f._r$29 = _r$29; $f._r$30 = _r$30; $f._r$31 = _r$31; $f._r$32 = _r$32; $f._r$33 = _r$33; $f._r$34 = _r$34; $f._r$35 = _r$35; $f._r$36 = _r$36; $f._r$37 = _r$37; $f._r$38 = _r$38; $f._r$39 = _r$39; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f._v$3 = _v$3; $f._v$4 = _v$4; $f.b = b; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.err$4 = err$4; $f.err1 = err1; $f.finfo = finfo; $f.finfo$1 = finfo$1; $f.fv = fv; $f.i = i; $f.i$1 = i$1; $f.kind = kind; $f.n = n; $f.name = name; $f.name$1 = name$1; $f.ok = ok; $f.p = p; $f.pv = pv; $f.pv$1 = pv$1; $f.s = s; $f.start = start; $f.startTemplate = startTemplate; $f.tinfo = tinfo; $f.typ = typ; $f.v = v; $f.val = val; $f.x$2 = x$2; $f.xmlname = xmlname; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.marshalValue = function(val, finfo, startTemplate) { return this.$val.marshalValue(val, finfo, startTemplate); };
	printer.ptr.prototype.marshalAttr = function(start, name, val) {
		var _1, _arg, _arg$1, _arg$2, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$20, _r$21, _r$22, _r$23, _r$24, _r$6, _r$7, _r$8, _r$9, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _v, _v$1, _v$2, _v$3, _v$4, attr, attr$1, b, err, err$1, err$2, err$3, err$4, err$5, i, n, name, p, pv, pv$1, s, start, text, text$1, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$23 = $f._r$23; _r$24 = $f._r$24; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; _v$3 = $f._v$3; _v$4 = $f._v$4; attr = $f.attr; attr$1 = $f.attr$1; b = $f.b; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; err$4 = $f.err$4; err$5 = $f.err$5; i = $f.i; n = $f.n; name = $f.name; p = $f.p; pv = $f.pv; pv$1 = $f.pv$1; s = $f.s; start = $f.start; text = $f.text; text$1 = $f.text$1; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!($clone(val, reflect.Value).CanInterface())) { _v = false; $s = 3; continue s; }
		_r$6 = $clone(val, reflect.Value).Type().Implements(marshalerAttrType); /* */ $s = 4; case 4: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_v = _r$6; case 3:
		/* */ if (_v) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_v) { */ case 1:
			_r$7 = $clone(val, reflect.Value).Interface(); /* */ $s = 5; case 5: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_r$8 = $assertType(_r$7, MarshalerAttr).MarshalXMLAttr($clone(name, Name)); /* */ $s = 6; case 6: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			_tuple = _r$8;
			attr = $clone(_tuple[0], Attr);
			err = _tuple[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			if (!(attr.Name.Local === "")) {
				start.Attr = $append(start.Attr, attr);
			}
			$s = -1; return $ifaceNil;
		/* } */ case 2:
		/* */ if ($clone(val, reflect.Value).CanAddr()) { $s = 7; continue; }
		/* */ $s = 8; continue;
		/* if ($clone(val, reflect.Value).CanAddr()) { */ case 7:
			pv = $clone(val, reflect.Value).Addr();
			if (!($clone(pv, reflect.Value).CanInterface())) { _v$1 = false; $s = 11; continue s; }
			_r$9 = $clone(pv, reflect.Value).Type().Implements(marshalerAttrType); /* */ $s = 12; case 12: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
			_v$1 = _r$9; case 11:
			/* */ if (_v$1) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_v$1) { */ case 9:
				_r$10 = $clone(pv, reflect.Value).Interface(); /* */ $s = 13; case 13: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
				_r$11 = $assertType(_r$10, MarshalerAttr).MarshalXMLAttr($clone(name, Name)); /* */ $s = 14; case 14: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
				_tuple$1 = _r$11;
				attr$1 = $clone(_tuple$1[0], Attr);
				err$1 = _tuple$1[1];
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					$s = -1; return err$1;
				}
				if (!(attr$1.Name.Local === "")) {
					start.Attr = $append(start.Attr, attr$1);
				}
				$s = -1; return $ifaceNil;
			/* } */ case 10:
		/* } */ case 8:
		if (!($clone(val, reflect.Value).CanInterface())) { _v$2 = false; $s = 17; continue s; }
		_r$12 = $clone(val, reflect.Value).Type().Implements(textMarshalerType); /* */ $s = 18; case 18: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
		_v$2 = _r$12; case 17:
		/* */ if (_v$2) { $s = 15; continue; }
		/* */ $s = 16; continue;
		/* if (_v$2) { */ case 15:
			_r$13 = $clone(val, reflect.Value).Interface(); /* */ $s = 19; case 19: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
			_r$14 = $assertType(_r$13, encoding.TextMarshaler).MarshalText(); /* */ $s = 20; case 20: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
			_tuple$2 = _r$14;
			text = _tuple$2[0];
			err$2 = _tuple$2[1];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return err$2;
			}
			start.Attr = $append(start.Attr, new Attr.ptr($clone(name, Name), ($bytesToString(text))));
			$s = -1; return $ifaceNil;
		/* } */ case 16:
		/* */ if ($clone(val, reflect.Value).CanAddr()) { $s = 21; continue; }
		/* */ $s = 22; continue;
		/* if ($clone(val, reflect.Value).CanAddr()) { */ case 21:
			pv$1 = $clone(val, reflect.Value).Addr();
			if (!($clone(pv$1, reflect.Value).CanInterface())) { _v$3 = false; $s = 25; continue s; }
			_r$15 = $clone(pv$1, reflect.Value).Type().Implements(textMarshalerType); /* */ $s = 26; case 26: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
			_v$3 = _r$15; case 25:
			/* */ if (_v$3) { $s = 23; continue; }
			/* */ $s = 24; continue;
			/* if (_v$3) { */ case 23:
				_r$16 = $clone(pv$1, reflect.Value).Interface(); /* */ $s = 27; case 27: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
				_r$17 = $assertType(_r$16, encoding.TextMarshaler).MarshalText(); /* */ $s = 28; case 28: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
				_tuple$3 = _r$17;
				text$1 = _tuple$3[0];
				err$3 = _tuple$3[1];
				if (!($interfaceIsEqual(err$3, $ifaceNil))) {
					$s = -1; return err$3;
				}
				start.Attr = $append(start.Attr, new Attr.ptr($clone(name, Name), ($bytesToString(text$1))));
				$s = -1; return $ifaceNil;
			/* } */ case 24:
		/* } */ case 22:
			_1 = $clone(val, reflect.Value).Kind();
			/* */ if ((_1 === (22)) || (_1 === (20))) { $s = 30; continue; }
			/* */ $s = 31; continue;
			/* if ((_1 === (22)) || (_1 === (20))) { */ case 30:
				if ($clone(val, reflect.Value).IsNil()) {
					$s = -1; return $ifaceNil;
				}
				_r$18 = $clone(val, reflect.Value).Elem(); /* */ $s = 32; case 32: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
				val = _r$18;
			/* } */ case 31:
		case 29:
		if (!($clone(val, reflect.Value).Kind() === 23)) { _v$4 = false; $s = 35; continue s; }
		_r$19 = $clone(val, reflect.Value).Type().Elem(); /* */ $s = 36; case 36: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
		_r$20 = _r$19.Kind(); /* */ $s = 37; case 37: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
		_v$4 = !((_r$20 === 8)); case 35:
		/* */ if (_v$4) { $s = 33; continue; }
		/* */ $s = 34; continue;
		/* if (_v$4) { */ case 33:
			n = $clone(val, reflect.Value).Len();
			i = 0;
			/* while (true) { */ case 38:
				/* if (!(i < n)) { break; } */ if(!(i < n)) { $s = 39; continue; }
				_arg = start;
				_arg$1 = $clone(name, Name);
				_r$21 = $clone(val, reflect.Value).Index(i); /* */ $s = 40; case 40: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
				_arg$2 = $clone(_r$21, reflect.Value);
				_r$22 = p.marshalAttr(_arg, _arg$1, _arg$2); /* */ $s = 41; case 41: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }
				err$4 = _r$22;
				if (!($interfaceIsEqual(err$4, $ifaceNil))) {
					$s = -1; return err$4;
				}
				i = i + (1) >> 0;
			/* } */ $s = 38; continue; case 39:
			$s = -1; return $ifaceNil;
		/* } */ case 34:
		/* */ if ($interfaceIsEqual($clone(val, reflect.Value).Type(), attrType)) { $s = 42; continue; }
		/* */ $s = 43; continue;
		/* if ($interfaceIsEqual($clone(val, reflect.Value).Type(), attrType)) { */ case 42:
			_r$23 = $clone(val, reflect.Value).Interface(); /* */ $s = 44; case 44: if($c) { $c = false; _r$23 = _r$23.$blk(); } if (_r$23 && _r$23.$blk !== undefined) { break s; }
			start.Attr = $append(start.Attr, $assertType(_r$23, Attr));
			$s = -1; return $ifaceNil;
		/* } */ case 43:
		_r$24 = p.marshalSimple($clone(val, reflect.Value).Type(), $clone(val, reflect.Value)); /* */ $s = 45; case 45: if($c) { $c = false; _r$24 = _r$24.$blk(); } if (_r$24 && _r$24.$blk !== undefined) { break s; }
		_tuple$4 = _r$24;
		s = _tuple$4[0];
		b = _tuple$4[1];
		err$5 = _tuple$4[2];
		if (!($interfaceIsEqual(err$5, $ifaceNil))) {
			$s = -1; return err$5;
		}
		if (!(b === sliceType.nil)) {
			s = ($bytesToString(b));
		}
		start.Attr = $append(start.Attr, new Attr.ptr($clone(name, Name), s));
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.marshalAttr }; } $f._1 = _1; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$23 = _r$23; $f._r$24 = _r$24; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f._v$3 = _v$3; $f._v$4 = _v$4; $f.attr = attr; $f.attr$1 = attr$1; $f.b = b; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.err$4 = err$4; $f.err$5 = err$5; $f.i = i; $f.n = n; $f.name = name; $f.p = p; $f.pv = pv; $f.pv$1 = pv$1; $f.s = s; $f.start = start; $f.text = text; $f.text$1 = text$1; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.marshalAttr = function(start, name, val) { return this.$val.marshalAttr(start, name, val); };
	defaultStart = function(typ, finfo, startTemplate) {
		var _r$6, _r$7, _r$8, _r$9, finfo, start, startTemplate, typ, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; finfo = $f.finfo; start = $f.start; startTemplate = $f.startTemplate; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		start = new StartElement.ptr(new Name.ptr("", ""), sliceType$6.nil);
		/* */ if (!(startTemplate === ptrType$9.nil)) { $s = 1; continue; }
		/* */ if (!(finfo === ptrType$8.nil) && !(finfo.name === "")) { $s = 2; continue; }
		_r$6 = typ.Name(); /* */ $s = 6; case 6: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		/* */ if (!(_r$6 === "")) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (!(startTemplate === ptrType$9.nil)) { */ case 1:
			Name.copy(start.Name, startTemplate.Name);
			start.Attr = $appendSlice(start.Attr, startTemplate.Attr);
			$s = 5; continue;
		/* } else if (!(finfo === ptrType$8.nil) && !(finfo.name === "")) { */ case 2:
			start.Name.Local = finfo.name;
			start.Name.Space = finfo.xmlns;
			$s = 5; continue;
		/* } else if (!(_r$6 === "")) { */ case 3:
			_r$7 = typ.Name(); /* */ $s = 7; case 7: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			start.Name.Local = _r$7;
			$s = 5; continue;
		/* } else { */ case 4:
			_r$8 = typ.Elem(); /* */ $s = 8; case 8: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			_r$9 = _r$8.Name(); /* */ $s = 9; case 9: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
			start.Name.Local = _r$9;
		/* } */ case 5:
		$s = -1; return start;
		/* */ } return; } if ($f === undefined) { $f = { $blk: defaultStart }; } $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f.finfo = finfo; $f.start = start; $f.startTemplate = startTemplate; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.ptr.prototype.marshalInterface = function(val, start) {
		var _arg, _arg$1, _r$6, _r$7, _r$8, err, n, p, start, val, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; err = $f.err; n = $f.n; p = $f.p; start = $f.start; val = $f.val; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		p.tags = $append(p.tags, new Name.ptr("", ""));
		n = p.tags.$length;
		_r$6 = val.MarshalXML(p.encoder, $clone(start, StartElement)); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		err = _r$6;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		/* */ if (p.tags.$length > n) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (p.tags.$length > n) { */ case 2:
			_r$7 = receiverType(val); /* */ $s = 4; case 4: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_arg = new $String(_r$7);
			_arg$1 = new $String((x$2 = p.tags, x$3 = p.tags.$length - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])).Local);
			_r$8 = fmt.Errorf("xml: %s.MarshalXML wrote invalid XML: <%s> not closed", new sliceType$5([_arg, _arg$1])); /* */ $s = 5; case 5: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			$s = -1; return _r$8;
		/* } */ case 3:
		p.tags = $subslice(p.tags, 0, (n - 1 >> 0));
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.marshalInterface }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f.err = err; $f.n = n; $f.p = p; $f.start = start; $f.val = val; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.marshalInterface = function(val, start) { return this.$val.marshalInterface(val, start); };
	printer.ptr.prototype.marshalTextInterface = function(val, start) {
		var _r$6, _r$7, _r$8, _r$9, _tuple, err, err$1, p, start, text, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; p = $f.p; start = $f.start; text = $f.text; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		start = [start];
		p = this;
		_r$6 = p.writeStart(start[0]); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		err = _r$6;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r$7 = val.MarshalText(); /* */ $s = 2; case 2: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_tuple = _r$7;
		text = _tuple[0];
		err$1 = _tuple[1];
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return err$1;
		}
		_r$8 = EscapeText(p, text); /* */ $s = 3; case 3: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		_r$8;
		_r$9 = p.writeEnd($clone(start[0].Name, Name)); /* */ $s = 4; case 4: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
		$s = -1; return _r$9;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.marshalTextInterface }; } $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.p = p; $f.start = start; $f.text = text; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.marshalTextInterface = function(val, start) { return this.$val.marshalTextInterface(val, start); };
	printer.ptr.prototype.writeStart = function(start) {
		var _i, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$6, _r$7, _r$8, _r$9, _ref, attr, name, p, start, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; attr = $f.attr; name = $f.name; p = $f.p; start = $f.start; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (start.Name.Local === "") { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (start.Name.Local === "") { */ case 1:
			_r$6 = fmt.Errorf("xml: start tag with no name", new sliceType$5([])); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			$s = -1; return _r$6;
		/* } */ case 2:
		p.tags = $append(p.tags, start.Name);
		p.markPrefix();
		$r = p.writeIndent(1); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$7 = p.Writer.WriteByte(60); /* */ $s = 5; case 5: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_r$7;
		_r$8 = p.Writer.WriteString(start.Name.Local); /* */ $s = 6; case 6: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		_r$8;
		/* */ if (!(start.Name.Space === "")) { $s = 7; continue; }
		/* */ $s = 8; continue;
		/* if (!(start.Name.Space === "")) { */ case 7:
			_r$9 = p.Writer.WriteString(" xmlns=\""); /* */ $s = 9; case 9: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
			_r$9;
			$r = p.EscapeString(start.Name.Space); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$10 = p.Writer.WriteByte(34); /* */ $s = 11; case 11: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			_r$10;
		/* } */ case 8:
		_ref = start.Attr;
		_i = 0;
		/* while (true) { */ case 12:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 13; continue; }
			attr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attr);
			name = $clone(attr.Name, Name);
			/* */ if (name.Local === "") { $s = 14; continue; }
			/* */ $s = 15; continue;
			/* if (name.Local === "") { */ case 14:
				_i++;
				/* continue; */ $s = 12; continue;
			/* } */ case 15:
			_r$11 = p.Writer.WriteByte(32); /* */ $s = 16; case 16: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
			_r$11;
			/* */ if (!(name.Space === "")) { $s = 17; continue; }
			/* */ $s = 18; continue;
			/* if (!(name.Space === "")) { */ case 17:
				_r$12 = p.createAttrPrefix(name.Space); /* */ $s = 19; case 19: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
				_r$13 = p.Writer.WriteString(_r$12); /* */ $s = 20; case 20: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
				_r$13;
				_r$14 = p.Writer.WriteByte(58); /* */ $s = 21; case 21: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
				_r$14;
			/* } */ case 18:
			_r$15 = p.Writer.WriteString(name.Local); /* */ $s = 22; case 22: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
			_r$15;
			_r$16 = p.Writer.WriteString("=\""); /* */ $s = 23; case 23: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
			_r$16;
			$r = p.EscapeString(attr.Value); /* */ $s = 24; case 24: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$17 = p.Writer.WriteByte(34); /* */ $s = 25; case 25: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
			_r$17;
			_i++;
		/* } */ $s = 12; continue; case 13:
		_r$18 = p.Writer.WriteByte(62); /* */ $s = 26; case 26: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
		_r$18;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.writeStart }; } $f._i = _i; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f.attr = attr; $f.name = name; $f.p = p; $f.start = start; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.writeStart = function(start) { return this.$val.writeStart(start); };
	printer.ptr.prototype.writeEnd = function(name) {
		var _r$10, _r$11, _r$12, _r$13, _r$6, _r$7, _r$8, _r$9, name, p, top, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; name = $f.name; p = $f.p; top = $f.top; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (name.Local === "") { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (name.Local === "") { */ case 1:
			_r$6 = fmt.Errorf("xml: end tag with no name", new sliceType$5([])); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			$s = -1; return _r$6;
		/* } */ case 2:
		/* */ if ((p.tags.$length === 0) || (x$2 = p.tags, x$3 = p.tags.$length - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])).Local === "") { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if ((p.tags.$length === 0) || (x$2 = p.tags, x$3 = p.tags.$length - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])).Local === "") { */ case 4:
			_r$7 = fmt.Errorf("xml: end tag </%s> without start tag", new sliceType$5([new $String(name.Local)])); /* */ $s = 6; case 6: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			$s = -1; return _r$7;
		/* } */ case 5:
		top = $clone((x$4 = p.tags, x$5 = p.tags.$length - 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])), Name);
		/* */ if (!($equal(top, name, Name))) { $s = 7; continue; }
		/* */ $s = 8; continue;
		/* if (!($equal(top, name, Name))) { */ case 7:
			/* */ if (!(top.Local === name.Local)) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (!(top.Local === name.Local)) { */ case 9:
				_r$8 = fmt.Errorf("xml: end tag </%s> does not match start tag <%s>", new sliceType$5([new $String(name.Local), new $String(top.Local)])); /* */ $s = 11; case 11: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				$s = -1; return _r$8;
			/* } */ case 10:
			_r$9 = fmt.Errorf("xml: end tag </%s> in namespace %s does not match start tag <%s> in namespace %s", new sliceType$5([new $String(name.Local), new $String(name.Space), new $String(top.Local), new $String(top.Space)])); /* */ $s = 12; case 12: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
			$s = -1; return _r$9;
		/* } */ case 8:
		p.tags = $subslice(p.tags, 0, (p.tags.$length - 1 >> 0));
		$r = p.writeIndent(-1); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$10 = p.Writer.WriteByte(60); /* */ $s = 14; case 14: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
		_r$10;
		_r$11 = p.Writer.WriteByte(47); /* */ $s = 15; case 15: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
		_r$11;
		_r$12 = p.Writer.WriteString(name.Local); /* */ $s = 16; case 16: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
		_r$12;
		_r$13 = p.Writer.WriteByte(62); /* */ $s = 17; case 17: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
		_r$13;
		p.popPrefix();
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.writeEnd }; } $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f.name = name; $f.p = p; $f.top = top; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.writeEnd = function(name) { return this.$val.writeEnd(name); };
	printer.ptr.prototype.marshalSimple = function(typ, val) {
		var _1, _arg, _arg$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$6, _r$7, _r$8, _r$9, bytes$1, p, typ, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _arg = $f._arg; _arg$1 = $f._arg$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; bytes$1 = $f.bytes$1; p = $f.p; typ = $f.typ; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = $clone(val, reflect.Value).Kind();
			/* */ if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { $s = 2; continue; }
			/* */ if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { $s = 3; continue; }
			/* */ if ((_1 === (13)) || (_1 === (14))) { $s = 4; continue; }
			/* */ if (_1 === (24)) { $s = 5; continue; }
			/* */ if (_1 === (1)) { $s = 6; continue; }
			/* */ if (_1 === (17)) { $s = 7; continue; }
			/* */ if (_1 === (23)) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 2:
				$s = -1; return [strconv.FormatInt($clone(val, reflect.Value).Int(), 10), sliceType.nil, $ifaceNil];
			/* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 3:
				$s = -1; return [strconv.FormatUint($clone(val, reflect.Value).Uint(), 10), sliceType.nil, $ifaceNil];
			/* } else if ((_1 === (13)) || (_1 === (14))) { */ case 4:
				_arg = $clone(val, reflect.Value).Float();
				_r$6 = $clone(val, reflect.Value).Type().Bits(); /* */ $s = 10; case 10: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_arg$1 = _r$6;
				_r$7 = strconv.FormatFloat(_arg, 103, -1, _arg$1); /* */ $s = 11; case 11: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				$s = -1; return [_r$7, sliceType.nil, $ifaceNil];
			/* } else if (_1 === (24)) { */ case 5:
				_r$8 = $clone(val, reflect.Value).String(); /* */ $s = 12; case 12: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				$s = -1; return [_r$8, sliceType.nil, $ifaceNil];
			/* } else if (_1 === (1)) { */ case 6:
				$s = -1; return [strconv.FormatBool($clone(val, reflect.Value).Bool()), sliceType.nil, $ifaceNil];
			/* } else if (_1 === (17)) { */ case 7:
				_r$9 = typ.Elem(); /* */ $s = 15; case 15: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				_r$10 = _r$9.Kind(); /* */ $s = 16; case 16: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
				/* */ if (!((_r$10 === 8))) { $s = 13; continue; }
				/* */ $s = 14; continue;
				/* if (!((_r$10 === 8))) { */ case 13:
					/* break; */ $s = 1; continue;
				/* } */ case 14:
				bytes$1 = sliceType.nil;
				/* */ if ($clone(val, reflect.Value).CanAddr()) { $s = 17; continue; }
				/* */ $s = 18; continue;
				/* if ($clone(val, reflect.Value).CanAddr()) { */ case 17:
					_r$11 = $clone(val, reflect.Value).Slice(0, $clone(val, reflect.Value).Len()); /* */ $s = 20; case 20: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
					_r$12 = $clone(_r$11, reflect.Value).Bytes(); /* */ $s = 21; case 21: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
					bytes$1 = _r$12;
					$s = 19; continue;
				/* } else { */ case 18:
					bytes$1 = $makeSlice(sliceType, $clone(val, reflect.Value).Len());
					_r$13 = reflect.ValueOf(bytes$1); /* */ $s = 22; case 22: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
					_r$14 = reflect.Copy($clone(_r$13, reflect.Value), $clone(val, reflect.Value)); /* */ $s = 23; case 23: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
					_r$14;
				/* } */ case 19:
				$s = -1; return ["", bytes$1, $ifaceNil];
			/* } else if (_1 === (23)) { */ case 8:
				_r$15 = typ.Elem(); /* */ $s = 26; case 26: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
				_r$16 = _r$15.Kind(); /* */ $s = 27; case 27: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
				/* */ if (!((_r$16 === 8))) { $s = 24; continue; }
				/* */ $s = 25; continue;
				/* if (!((_r$16 === 8))) { */ case 24:
					/* break; */ $s = 1; continue;
				/* } */ case 25:
				_r$17 = $clone(val, reflect.Value).Bytes(); /* */ $s = 28; case 28: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
				$s = -1; return ["", _r$17, $ifaceNil];
			/* } */ case 9:
		case 1:
		$s = -1; return ["", sliceType.nil, new UnsupportedTypeError.ptr(typ)];
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.marshalSimple }; } $f._1 = _1; $f._arg = _arg; $f._arg$1 = _arg$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f.bytes$1 = bytes$1; $f.p = p; $f.typ = typ; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.marshalSimple = function(typ, val) { return this.$val.marshalSimple(typ, val); };
	indirect = function(vf) {
		var _r$6, vf, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; vf = $f.vf; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* while (true) { */ case 1:
			/* if (!(($clone(vf, reflect.Value).Kind() === 20) || ($clone(vf, reflect.Value).Kind() === 22))) { break; } */ if(!(($clone(vf, reflect.Value).Kind() === 20) || ($clone(vf, reflect.Value).Kind() === 22))) { $s = 2; continue; }
			if ($clone(vf, reflect.Value).IsNil()) {
				$s = -1; return vf;
			}
			_r$6 = $clone(vf, reflect.Value).Elem(); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			vf = _r$6;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return vf;
		/* */ } return; } if ($f === undefined) { $f = { $blk: indirect }; } $f._r$6 = _r$6; $f.vf = vf; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.ptr.prototype.marshalStruct = function(tinfo, val) {
		var _1, _2, _3, _arg, _arg$1, _arg$2, _arg$3, _arg$4, _arg$5, _arg$6, _i, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$20, _r$21, _r$22, _r$23, _r$24, _r$25, _r$26, _r$27, _r$28, _r$29, _r$30, _r$31, _r$32, _r$33, _r$34, _r$35, _r$36, _r$37, _r$38, _r$39, _r$40, _r$41, _r$42, _r$43, _r$44, _r$45, _r$46, _r$47, _r$48, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, _tuple, _tuple$1, _tuple$2, _v, _v$1, _v$2, _v$3, b, dashDash, dashLast, data, data$1, elem, emit, err, err$1, err$10, err$11, err$12, err$13, err$14, err$2, err$3, err$4, err$5, err$6, err$7, err$8, err$9, finfo, i, iface, k, ok, p, pv, raw, raw$1, s, s$1, scratch, tinfo, val, vf, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _arg$3 = $f._arg$3; _arg$4 = $f._arg$4; _arg$5 = $f._arg$5; _arg$6 = $f._arg$6; _i = $f._i; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$23 = $f._r$23; _r$24 = $f._r$24; _r$25 = $f._r$25; _r$26 = $f._r$26; _r$27 = $f._r$27; _r$28 = $f._r$28; _r$29 = $f._r$29; _r$30 = $f._r$30; _r$31 = $f._r$31; _r$32 = $f._r$32; _r$33 = $f._r$33; _r$34 = $f._r$34; _r$35 = $f._r$35; _r$36 = $f._r$36; _r$37 = $f._r$37; _r$38 = $f._r$38; _r$39 = $f._r$39; _r$40 = $f._r$40; _r$41 = $f._r$41; _r$42 = $f._r$42; _r$43 = $f._r$43; _r$44 = $f._r$44; _r$45 = $f._r$45; _r$46 = $f._r$46; _r$47 = $f._r$47; _r$48 = $f._r$48; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; _v$3 = $f._v$3; b = $f.b; dashDash = $f.dashDash; dashLast = $f.dashLast; data = $f.data; data$1 = $f.data$1; elem = $f.elem; emit = $f.emit; err = $f.err; err$1 = $f.err$1; err$10 = $f.err$10; err$11 = $f.err$11; err$12 = $f.err$12; err$13 = $f.err$13; err$14 = $f.err$14; err$2 = $f.err$2; err$3 = $f.err$3; err$4 = $f.err$4; err$5 = $f.err$5; err$6 = $f.err$6; err$7 = $f.err$7; err$8 = $f.err$8; err$9 = $f.err$9; finfo = $f.finfo; i = $f.i; iface = $f.iface; k = $f.k; ok = $f.ok; p = $f.p; pv = $f.pv; raw = $f.raw; raw$1 = $f.raw$1; s = $f.s; s$1 = $f.s$1; scratch = $f.scratch; tinfo = $f.tinfo; val = $f.val; vf = $f.vf; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		s = new parentStack.ptr(p, sliceType$3.nil);
		_ref = tinfo.fields;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			finfo = (x$2 = tinfo.fields, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i]));
			/* */ if (!(((finfo.flags & 2) === 0))) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(((finfo.flags & 2) === 0))) { */ case 3:
				_i++;
				/* continue; */ $s = 1; continue;
			/* } */ case 4:
			_r$6 = finfo.value($clone(val, reflect.Value)); /* */ $s = 5; case 5: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			vf = _r$6;
				_1 = finfo.flags & 127;
				/* */ if ((_1 === (4)) || (_1 === (8))) { $s = 7; continue; }
				/* */ if (_1 === (32)) { $s = 8; continue; }
				/* */ if (_1 === (16)) { $s = 9; continue; }
				/* */ if ((_1 === (1)) || (_1 === (65))) { $s = 10; continue; }
				/* */ $s = 11; continue;
				/* if ((_1 === (4)) || (_1 === (8))) { */ case 7:
					emit = EscapeText;
					if ((finfo.flags & 127) === 4) {
						emit = emitCDATA;
					}
					_r$7 = s.trim(finfo.parents); /* */ $s = 12; case 12: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
					err = _r$7;
					if (!($interfaceIsEqual(err, $ifaceNil))) {
						$s = -1; return err;
					}
					if (!($clone(vf, reflect.Value).CanInterface())) { _v = false; $s = 15; continue s; }
					_r$8 = $clone(vf, reflect.Value).Type().Implements(textMarshalerType); /* */ $s = 16; case 16: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
					_v = _r$8; case 15:
					/* */ if (_v) { $s = 13; continue; }
					/* */ $s = 14; continue;
					/* if (_v) { */ case 13:
						_r$9 = $clone(vf, reflect.Value).Interface(); /* */ $s = 17; case 17: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
						_r$10 = $assertType(_r$9, encoding.TextMarshaler).MarshalText(); /* */ $s = 18; case 18: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
						_tuple = _r$10;
						data = _tuple[0];
						err$1 = _tuple[1];
						if (!($interfaceIsEqual(err$1, $ifaceNil))) {
							$s = -1; return err$1;
						}
						_r$11 = emit(p, data); /* */ $s = 19; case 19: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
						err$2 = _r$11;
						if (!($interfaceIsEqual(err$2, $ifaceNil))) {
							$s = -1; return err$2;
						}
						_i++;
						/* continue; */ $s = 1; continue;
					/* } */ case 14:
					/* */ if ($clone(vf, reflect.Value).CanAddr()) { $s = 20; continue; }
					/* */ $s = 21; continue;
					/* if ($clone(vf, reflect.Value).CanAddr()) { */ case 20:
						pv = $clone(vf, reflect.Value).Addr();
						if (!($clone(pv, reflect.Value).CanInterface())) { _v$1 = false; $s = 24; continue s; }
						_r$12 = $clone(pv, reflect.Value).Type().Implements(textMarshalerType); /* */ $s = 25; case 25: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
						_v$1 = _r$12; case 24:
						/* */ if (_v$1) { $s = 22; continue; }
						/* */ $s = 23; continue;
						/* if (_v$1) { */ case 22:
							_r$13 = $clone(pv, reflect.Value).Interface(); /* */ $s = 26; case 26: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
							_r$14 = $assertType(_r$13, encoding.TextMarshaler).MarshalText(); /* */ $s = 27; case 27: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
							_tuple$1 = _r$14;
							data$1 = _tuple$1[0];
							err$3 = _tuple$1[1];
							if (!($interfaceIsEqual(err$3, $ifaceNil))) {
								$s = -1; return err$3;
							}
							_r$15 = emit(p, data$1); /* */ $s = 28; case 28: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
							err$4 = _r$15;
							if (!($interfaceIsEqual(err$4, $ifaceNil))) {
								$s = -1; return err$4;
							}
							_i++;
							/* continue; */ $s = 1; continue;
						/* } */ case 23:
					/* } */ case 21:
					scratch = arrayType.zero();
					_r$16 = indirect($clone(vf, reflect.Value)); /* */ $s = 29; case 29: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
					vf = _r$16;
						_2 = $clone(vf, reflect.Value).Kind();
						/* */ if ((_2 === (2)) || (_2 === (3)) || (_2 === (4)) || (_2 === (5)) || (_2 === (6))) { $s = 31; continue; }
						/* */ if ((_2 === (7)) || (_2 === (8)) || (_2 === (9)) || (_2 === (10)) || (_2 === (11)) || (_2 === (12))) { $s = 32; continue; }
						/* */ if ((_2 === (13)) || (_2 === (14))) { $s = 33; continue; }
						/* */ if (_2 === (1)) { $s = 34; continue; }
						/* */ if (_2 === (24)) { $s = 35; continue; }
						/* */ if (_2 === (23)) { $s = 36; continue; }
						/* */ $s = 37; continue;
						/* if ((_2 === (2)) || (_2 === (3)) || (_2 === (4)) || (_2 === (5)) || (_2 === (6))) { */ case 31:
							_r$17 = emit(p, strconv.AppendInt($subslice(new sliceType(scratch), 0, 0), $clone(vf, reflect.Value).Int(), 10)); /* */ $s = 38; case 38: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
							err$5 = _r$17;
							if (!($interfaceIsEqual(err$5, $ifaceNil))) {
								$s = -1; return err$5;
							}
							$s = 37; continue;
						/* } else if ((_2 === (7)) || (_2 === (8)) || (_2 === (9)) || (_2 === (10)) || (_2 === (11)) || (_2 === (12))) { */ case 32:
							_r$18 = emit(p, strconv.AppendUint($subslice(new sliceType(scratch), 0, 0), $clone(vf, reflect.Value).Uint(), 10)); /* */ $s = 39; case 39: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
							err$6 = _r$18;
							if (!($interfaceIsEqual(err$6, $ifaceNil))) {
								$s = -1; return err$6;
							}
							$s = 37; continue;
						/* } else if ((_2 === (13)) || (_2 === (14))) { */ case 33:
							_arg = p;
							_arg$1 = $subslice(new sliceType(scratch), 0, 0);
							_arg$2 = $clone(vf, reflect.Value).Float();
							_r$19 = $clone(vf, reflect.Value).Type().Bits(); /* */ $s = 40; case 40: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
							_arg$3 = _r$19;
							_r$20 = strconv.AppendFloat(_arg$1, _arg$2, 103, -1, _arg$3); /* */ $s = 41; case 41: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
							_arg$4 = _r$20;
							_r$21 = emit(_arg, _arg$4); /* */ $s = 42; case 42: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
							err$7 = _r$21;
							if (!($interfaceIsEqual(err$7, $ifaceNil))) {
								$s = -1; return err$7;
							}
							$s = 37; continue;
						/* } else if (_2 === (1)) { */ case 34:
							_r$22 = emit(p, strconv.AppendBool($subslice(new sliceType(scratch), 0, 0), $clone(vf, reflect.Value).Bool())); /* */ $s = 43; case 43: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }
							err$8 = _r$22;
							if (!($interfaceIsEqual(err$8, $ifaceNil))) {
								$s = -1; return err$8;
							}
							$s = 37; continue;
						/* } else if (_2 === (24)) { */ case 35:
							_arg$5 = p;
							_r$23 = $clone(vf, reflect.Value).String(); /* */ $s = 44; case 44: if($c) { $c = false; _r$23 = _r$23.$blk(); } if (_r$23 && _r$23.$blk !== undefined) { break s; }
							_arg$6 = (new sliceType($stringToBytes(_r$23)));
							_r$24 = emit(_arg$5, _arg$6); /* */ $s = 45; case 45: if($c) { $c = false; _r$24 = _r$24.$blk(); } if (_r$24 && _r$24.$blk !== undefined) { break s; }
							err$9 = _r$24;
							if (!($interfaceIsEqual(err$9, $ifaceNil))) {
								$s = -1; return err$9;
							}
							$s = 37; continue;
						/* } else if (_2 === (23)) { */ case 36:
							_r$25 = $clone(vf, reflect.Value).Interface(); /* */ $s = 46; case 46: if($c) { $c = false; _r$25 = _r$25.$blk(); } if (_r$25 && _r$25.$blk !== undefined) { break s; }
							_tuple$2 = $assertType(_r$25, sliceType, true);
							elem = _tuple$2[0];
							ok = _tuple$2[1];
							/* */ if (ok) { $s = 47; continue; }
							/* */ $s = 48; continue;
							/* if (ok) { */ case 47:
								_r$26 = emit(p, elem); /* */ $s = 49; case 49: if($c) { $c = false; _r$26 = _r$26.$blk(); } if (_r$26 && _r$26.$blk !== undefined) { break s; }
								err$10 = _r$26;
								if (!($interfaceIsEqual(err$10, $ifaceNil))) {
									$s = -1; return err$10;
								}
							/* } */ case 48:
						/* } */ case 37:
					case 30:
					_i++;
					/* continue; */ $s = 1; continue;
					$s = 11; continue;
				/* } else if (_1 === (32)) { */ case 8:
					_r$27 = s.trim(finfo.parents); /* */ $s = 50; case 50: if($c) { $c = false; _r$27 = _r$27.$blk(); } if (_r$27 && _r$27.$blk !== undefined) { break s; }
					err$11 = _r$27;
					if (!($interfaceIsEqual(err$11, $ifaceNil))) {
						$s = -1; return err$11;
					}
					_r$28 = indirect($clone(vf, reflect.Value)); /* */ $s = 51; case 51: if($c) { $c = false; _r$28 = _r$28.$blk(); } if (_r$28 && _r$28.$blk !== undefined) { break s; }
					vf = _r$28;
					k = $clone(vf, reflect.Value).Kind();
					if (k === 24) { _v$2 = true; $s = 54; continue s; }
					if (!(k === 23)) { _v$3 = false; $s = 55; continue s; }
					_r$29 = $clone(vf, reflect.Value).Type().Elem(); /* */ $s = 56; case 56: if($c) { $c = false; _r$29 = _r$29.$blk(); } if (_r$29 && _r$29.$blk !== undefined) { break s; }
					_r$30 = _r$29.Kind(); /* */ $s = 57; case 57: if($c) { $c = false; _r$30 = _r$30.$blk(); } if (_r$30 && _r$30.$blk !== undefined) { break s; }
					_v$3 = _r$30 === 8; case 55:
					_v$2 = _v$3; case 54:
					/* */ if (!(_v$2)) { $s = 52; continue; }
					/* */ $s = 53; continue;
					/* if (!(_v$2)) { */ case 52:
						_r$31 = fmt.Errorf("xml: bad type for comment field of %s", new sliceType$5([$clone(val, reflect.Value).Type()])); /* */ $s = 58; case 58: if($c) { $c = false; _r$31 = _r$31.$blk(); } if (_r$31 && _r$31.$blk !== undefined) { break s; }
						$s = -1; return _r$31;
					/* } */ case 53:
					/* */ if ($clone(vf, reflect.Value).Len() === 0) { $s = 59; continue; }
					/* */ $s = 60; continue;
					/* if ($clone(vf, reflect.Value).Len() === 0) { */ case 59:
						_i++;
						/* continue; */ $s = 1; continue;
					/* } */ case 60:
					$r = p.writeIndent(0); /* */ $s = 61; case 61: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r$32 = p.Writer.WriteString("<!--"); /* */ $s = 62; case 62: if($c) { $c = false; _r$32 = _r$32.$blk(); } if (_r$32 && _r$32.$blk !== undefined) { break s; }
					_r$32;
					dashDash = false;
					dashLast = false;
						_3 = k;
						/* */ if (_3 === (24)) { $s = 64; continue; }
						/* */ if (_3 === (23)) { $s = 65; continue; }
						/* */ $s = 66; continue;
						/* if (_3 === (24)) { */ case 64:
							_r$33 = $clone(vf, reflect.Value).String(); /* */ $s = 68; case 68: if($c) { $c = false; _r$33 = _r$33.$blk(); } if (_r$33 && _r$33.$blk !== undefined) { break s; }
							s$1 = _r$33;
							dashDash = strings.Contains(s$1, "--");
							dashLast = s$1.charCodeAt((s$1.length - 1 >> 0)) === 45;
							/* */ if (!dashDash) { $s = 69; continue; }
							/* */ $s = 70; continue;
							/* if (!dashDash) { */ case 69:
								_r$34 = p.Writer.WriteString(s$1); /* */ $s = 71; case 71: if($c) { $c = false; _r$34 = _r$34.$blk(); } if (_r$34 && _r$34.$blk !== undefined) { break s; }
								_r$34;
							/* } */ case 70:
							$s = 67; continue;
						/* } else if (_3 === (23)) { */ case 65:
							_r$35 = $clone(vf, reflect.Value).Bytes(); /* */ $s = 72; case 72: if($c) { $c = false; _r$35 = _r$35.$blk(); } if (_r$35 && _r$35.$blk !== undefined) { break s; }
							b = _r$35;
							dashDash = bytes.Contains(b, ddBytes);
							dashLast = (x$3 = b.$length - 1 >> 0, ((x$3 < 0 || x$3 >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + x$3])) === 45;
							/* */ if (!dashDash) { $s = 73; continue; }
							/* */ $s = 74; continue;
							/* if (!dashDash) { */ case 73:
								_r$36 = p.Writer.Write(b); /* */ $s = 75; case 75: if($c) { $c = false; _r$36 = _r$36.$blk(); } if (_r$36 && _r$36.$blk !== undefined) { break s; }
								_r$36;
							/* } */ case 74:
							$s = 67; continue;
						/* } else { */ case 66:
							$panic(new $String("can't happen"));
						/* } */ case 67:
					case 63:
					/* */ if (dashDash) { $s = 76; continue; }
					/* */ $s = 77; continue;
					/* if (dashDash) { */ case 76:
						_r$37 = fmt.Errorf("xml: comments must not contain \"--\"", new sliceType$5([])); /* */ $s = 78; case 78: if($c) { $c = false; _r$37 = _r$37.$blk(); } if (_r$37 && _r$37.$blk !== undefined) { break s; }
						$s = -1; return _r$37;
					/* } */ case 77:
					/* */ if (dashLast) { $s = 79; continue; }
					/* */ $s = 80; continue;
					/* if (dashLast) { */ case 79:
						_r$38 = p.Writer.WriteByte(32); /* */ $s = 81; case 81: if($c) { $c = false; _r$38 = _r$38.$blk(); } if (_r$38 && _r$38.$blk !== undefined) { break s; }
						_r$38;
					/* } */ case 80:
					_r$39 = p.Writer.WriteString("-->"); /* */ $s = 82; case 82: if($c) { $c = false; _r$39 = _r$39.$blk(); } if (_r$39 && _r$39.$blk !== undefined) { break s; }
					_r$39;
					_i++;
					/* continue; */ $s = 1; continue;
					$s = 11; continue;
				/* } else if (_1 === (16)) { */ case 9:
					_r$40 = indirect($clone(vf, reflect.Value)); /* */ $s = 83; case 83: if($c) { $c = false; _r$40 = _r$40.$blk(); } if (_r$40 && _r$40.$blk !== undefined) { break s; }
					vf = _r$40;
					_r$41 = $clone(vf, reflect.Value).Interface(); /* */ $s = 84; case 84: if($c) { $c = false; _r$41 = _r$41.$blk(); } if (_r$41 && _r$41.$blk !== undefined) { break s; }
					iface = _r$41;
					_ref$1 = iface;
					/* */ if ($assertType(_ref$1, sliceType, true)[1]) { $s = 85; continue; }
					/* */ if ($assertType(_ref$1, $String, true)[1]) { $s = 86; continue; }
					/* */ $s = 87; continue;
					/* if ($assertType(_ref$1, sliceType, true)[1]) { */ case 85:
						raw = _ref$1.$val;
						_r$42 = p.Writer.Write(raw); /* */ $s = 88; case 88: if($c) { $c = false; _r$42 = _r$42.$blk(); } if (_r$42 && _r$42.$blk !== undefined) { break s; }
						_r$42;
						_i++;
						/* continue; */ $s = 1; continue;
						$s = 87; continue;
					/* } else if ($assertType(_ref$1, $String, true)[1]) { */ case 86:
						raw$1 = _ref$1.$val;
						_r$43 = p.Writer.WriteString(raw$1); /* */ $s = 89; case 89: if($c) { $c = false; _r$43 = _r$43.$blk(); } if (_r$43 && _r$43.$blk !== undefined) { break s; }
						_r$43;
						_i++;
						/* continue; */ $s = 1; continue;
					/* } */ case 87:
					$s = 11; continue;
				/* } else if ((_1 === (1)) || (_1 === (65))) { */ case 10:
					_r$44 = s.trim(finfo.parents); /* */ $s = 90; case 90: if($c) { $c = false; _r$44 = _r$44.$blk(); } if (_r$44 && _r$44.$blk !== undefined) { break s; }
					err$12 = _r$44;
					if (!($interfaceIsEqual(err$12, $ifaceNil))) {
						$s = -1; return err$12;
					}
					/* */ if (finfo.parents.$length > s.stack.$length) { $s = 91; continue; }
					/* */ $s = 92; continue;
					/* if (finfo.parents.$length > s.stack.$length) { */ case 91:
						/* */ if (!(($clone(vf, reflect.Value).Kind() === 22)) && !(($clone(vf, reflect.Value).Kind() === 20)) || !$clone(vf, reflect.Value).IsNil()) { $s = 93; continue; }
						/* */ $s = 94; continue;
						/* if (!(($clone(vf, reflect.Value).Kind() === 22)) && !(($clone(vf, reflect.Value).Kind() === 20)) || !$clone(vf, reflect.Value).IsNil()) { */ case 93:
							_r$45 = s.push($subslice(finfo.parents, s.stack.$length)); /* */ $s = 95; case 95: if($c) { $c = false; _r$45 = _r$45.$blk(); } if (_r$45 && _r$45.$blk !== undefined) { break s; }
							err$13 = _r$45;
							if (!($interfaceIsEqual(err$13, $ifaceNil))) {
								$s = -1; return err$13;
							}
						/* } */ case 94:
					/* } */ case 92:
				/* } */ case 11:
			case 6:
			_r$46 = p.marshalValue($clone(vf, reflect.Value), finfo, ptrType$9.nil); /* */ $s = 96; case 96: if($c) { $c = false; _r$46 = _r$46.$blk(); } if (_r$46 && _r$46.$blk !== undefined) { break s; }
			err$14 = _r$46;
			if (!($interfaceIsEqual(err$14, $ifaceNil))) {
				$s = -1; return err$14;
			}
			_i++;
		/* } */ $s = 1; continue; case 2:
		_r$47 = s.trim(sliceType$3.nil); /* */ $s = 97; case 97: if($c) { $c = false; _r$47 = _r$47.$blk(); } if (_r$47 && _r$47.$blk !== undefined) { break s; }
		_r$47;
		_r$48 = p.cachedWriteError(); /* */ $s = 98; case 98: if($c) { $c = false; _r$48 = _r$48.$blk(); } if (_r$48 && _r$48.$blk !== undefined) { break s; }
		$s = -1; return _r$48;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.marshalStruct }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._arg$3 = _arg$3; $f._arg$4 = _arg$4; $f._arg$5 = _arg$5; $f._arg$6 = _arg$6; $f._i = _i; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$23 = _r$23; $f._r$24 = _r$24; $f._r$25 = _r$25; $f._r$26 = _r$26; $f._r$27 = _r$27; $f._r$28 = _r$28; $f._r$29 = _r$29; $f._r$30 = _r$30; $f._r$31 = _r$31; $f._r$32 = _r$32; $f._r$33 = _r$33; $f._r$34 = _r$34; $f._r$35 = _r$35; $f._r$36 = _r$36; $f._r$37 = _r$37; $f._r$38 = _r$38; $f._r$39 = _r$39; $f._r$40 = _r$40; $f._r$41 = _r$41; $f._r$42 = _r$42; $f._r$43 = _r$43; $f._r$44 = _r$44; $f._r$45 = _r$45; $f._r$46 = _r$46; $f._r$47 = _r$47; $f._r$48 = _r$48; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f._v$3 = _v$3; $f.b = b; $f.dashDash = dashDash; $f.dashLast = dashLast; $f.data = data; $f.data$1 = data$1; $f.elem = elem; $f.emit = emit; $f.err = err; $f.err$1 = err$1; $f.err$10 = err$10; $f.err$11 = err$11; $f.err$12 = err$12; $f.err$13 = err$13; $f.err$14 = err$14; $f.err$2 = err$2; $f.err$3 = err$3; $f.err$4 = err$4; $f.err$5 = err$5; $f.err$6 = err$6; $f.err$7 = err$7; $f.err$8 = err$8; $f.err$9 = err$9; $f.finfo = finfo; $f.i = i; $f.iface = iface; $f.k = k; $f.ok = ok; $f.p = p; $f.pv = pv; $f.raw = raw; $f.raw$1 = raw$1; $f.s = s; $f.s$1 = s$1; $f.scratch = scratch; $f.tinfo = tinfo; $f.val = val; $f.vf = vf; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.marshalStruct = function(tinfo, val) { return this.$val.marshalStruct(tinfo, val); };
	printer.ptr.prototype.cachedWriteError = function() {
		var _r$6, _tuple, err, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _tuple = $f._tuple; err = $f.err; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_r$6 = p.Writer.Write(sliceType.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_tuple = _r$6;
		err = _tuple[1];
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.cachedWriteError }; } $f._r$6 = _r$6; $f._tuple = _tuple; $f.err = err; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.cachedWriteError = function() { return this.$val.cachedWriteError(); };
	printer.ptr.prototype.writeIndent = function(depthDelta) {
		var _r$6, _r$7, _r$8, depthDelta, i, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; depthDelta = $f.depthDelta; i = $f.i; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if ((p.prefix.length === 0) && (p.indent.length === 0)) {
			$s = -1; return;
		}
		if (depthDelta < 0) {
			p.depth = p.depth - (1) >> 0;
			if (p.indentedIn) {
				p.indentedIn = false;
				$s = -1; return;
			}
			p.indentedIn = false;
		}
		/* */ if (p.putNewline) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (p.putNewline) { */ case 1:
			_r$6 = p.Writer.WriteByte(10); /* */ $s = 4; case 4: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_r$6;
			$s = 3; continue;
		/* } else { */ case 2:
			p.putNewline = true;
		/* } */ case 3:
		/* */ if (p.prefix.length > 0) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (p.prefix.length > 0) { */ case 5:
			_r$7 = p.Writer.WriteString(p.prefix); /* */ $s = 7; case 7: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_r$7;
		/* } */ case 6:
		/* */ if (p.indent.length > 0) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if (p.indent.length > 0) { */ case 8:
			i = 0;
			/* while (true) { */ case 10:
				/* if (!(i < p.depth)) { break; } */ if(!(i < p.depth)) { $s = 11; continue; }
				_r$8 = p.Writer.WriteString(p.indent); /* */ $s = 12; case 12: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				_r$8;
				i = i + (1) >> 0;
			/* } */ $s = 10; continue; case 11:
		/* } */ case 9:
		if (depthDelta > 0) {
			p.depth = p.depth + (1) >> 0;
			p.indentedIn = true;
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.writeIndent }; } $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f.depthDelta = depthDelta; $f.i = i; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.writeIndent = function(depthDelta) { return this.$val.writeIndent(depthDelta); };
	parentStack.ptr.prototype.trim = function(parents) {
		var _r$6, err, i, parents, s, split, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; err = $f.err; i = $f.i; parents = $f.parents; s = $f.s; split = $f.split; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		split = 0;
		while (true) {
			if (!(split < parents.$length && split < s.stack.$length)) { break; }
			if (!(((split < 0 || split >= parents.$length) ? ($throwRuntimeError("index out of range"), undefined) : parents.$array[parents.$offset + split]) === (x$2 = s.stack, ((split < 0 || split >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + split])))) {
				break;
			}
			split = split + (1) >> 0;
		}
		i = s.stack.$length - 1 >> 0;
		/* while (true) { */ case 1:
			/* if (!(i >= split)) { break; } */ if(!(i >= split)) { $s = 2; continue; }
			_r$6 = s.p.writeEnd(new Name.ptr("", (x$3 = s.stack, ((i < 0 || i >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i])))); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			err = _r$6;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			i = i - (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		s.stack = $subslice(s.stack, 0, split);
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parentStack.ptr.prototype.trim }; } $f._r$6 = _r$6; $f.err = err; $f.i = i; $f.parents = parents; $f.s = s; $f.split = split; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	parentStack.prototype.trim = function(parents) { return this.$val.trim(parents); };
	parentStack.ptr.prototype.push = function(parents) {
		var _r$6, err, i, parents, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; err = $f.err; i = $f.i; parents = $f.parents; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < parents.$length)) { break; } */ if(!(i < parents.$length)) { $s = 2; continue; }
			_r$6 = s.p.writeStart(new StartElement.ptr(new Name.ptr("", ((i < 0 || i >= parents.$length) ? ($throwRuntimeError("index out of range"), undefined) : parents.$array[parents.$offset + i])), sliceType$6.nil)); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			err = _r$6;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		s.stack = $appendSlice(s.stack, parents);
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parentStack.ptr.prototype.push }; } $f._r$6 = _r$6; $f.err = err; $f.i = i; $f.parents = parents; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	parentStack.prototype.push = function(parents) { return this.$val.push(parents); };
	UnsupportedTypeError.ptr.prototype.Error = function() {
		var _r$6, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r$6 = e.Type.String(); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		$s = -1; return "xml: unsupported type: " + _r$6;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UnsupportedTypeError.ptr.prototype.Error }; } $f._r$6 = _r$6; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	UnsupportedTypeError.prototype.Error = function() { return this.$val.Error(); };
	isEmptyValue = function(v) {
		var _1, v, x$2, x$3;
		_1 = $clone(v, reflect.Value).Kind();
		if ((_1 === (17)) || (_1 === (21)) || (_1 === (23)) || (_1 === (24))) {
			return $clone(v, reflect.Value).Len() === 0;
		} else if (_1 === (1)) {
			return !$clone(v, reflect.Value).Bool();
		} else if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) {
			return (x$2 = $clone(v, reflect.Value).Int(), (x$2.$high === 0 && x$2.$low === 0));
		} else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) {
			return (x$3 = $clone(v, reflect.Value).Uint(), (x$3.$high === 0 && x$3.$low === 0));
		} else if ((_1 === (13)) || (_1 === (14))) {
			return $clone(v, reflect.Value).Float() === 0;
		} else if ((_1 === (20)) || (_1 === (22))) {
			return $clone(v, reflect.Value).IsNil();
		}
		return false;
	};
	Decoder.ptr.prototype.Decode = function(v) {
		var _r$6, d, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; d = $f.d; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		_r$6 = d.DecodeElement(v, ptrType$9.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		$s = -1; return _r$6;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.Decode }; } $f._r$6 = _r$6; $f.d = d; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.Decode = function(v) { return this.$val.Decode(v); };
	Decoder.ptr.prototype.DecodeElement = function(v, start) {
		var _r$6, _r$7, _r$8, d, start, v, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; d = $f.d; start = $f.start; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		_r$6 = reflect.ValueOf(v); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		val = _r$6;
		if (!(($clone(val, reflect.Value).Kind() === 22))) {
			$s = -1; return errors.New("non-pointer passed to Unmarshal");
		}
		_r$7 = $clone(val, reflect.Value).Elem(); /* */ $s = 2; case 2: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_r$8 = d.unmarshal($clone(_r$7, reflect.Value), start); /* */ $s = 3; case 3: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		$s = -1; return _r$8;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.DecodeElement }; } $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f.d = d; $f.start = start; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.DecodeElement = function(v, start) { return this.$val.DecodeElement(v, start); };
	UnmarshalError.prototype.Error = function() {
		var e;
		e = this.$val;
		return (e);
	};
	$ptrType(UnmarshalError).prototype.Error = function() { return new UnmarshalError(this.$get()).Error(); };
	receiverType = function(val) {
		var _r$6, _r$7, _r$8, t, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; t = $f.t; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = reflect.TypeOf(val);
		_r$6 = t.Name(); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		/* */ if (!(_r$6 === "")) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(_r$6 === "")) { */ case 1:
			_r$7 = t.String(); /* */ $s = 4; case 4: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			$s = -1; return _r$7;
		/* } */ case 2:
		_r$8 = t.String(); /* */ $s = 5; case 5: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		$s = -1; return "(" + _r$8 + ")";
		/* */ } return; } if ($f === undefined) { $f = { $blk: receiverType }; } $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f.t = t; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.ptr.prototype.unmarshalInterface = function(val, start) {
		var _arg, _arg$1, _r$6, _r$7, _r$8, err, p, start, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; err = $f.err; p = $f.p; start = $f.start; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		p.pushEOF();
		p.unmarshalDepth = p.unmarshalDepth + (1) >> 0;
		_r$6 = val.UnmarshalXML(p, $clone(start, StartElement)); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		err = _r$6;
		p.unmarshalDepth = p.unmarshalDepth - (1) >> 0;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			p.popEOF();
			$s = -1; return err;
		}
		/* */ if (!p.popEOF()) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!p.popEOF()) { */ case 2:
			_r$7 = receiverType(val); /* */ $s = 4; case 4: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_arg = new $String(_r$7);
			_arg$1 = new $String(start.Name.Local);
			_r$8 = fmt.Errorf("xml: %s.UnmarshalXML did not consume entire <%s> element", new sliceType$5([_arg, _arg$1])); /* */ $s = 5; case 5: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			$s = -1; return _r$8;
		/* } */ case 3:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.unmarshalInterface }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f.err = err; $f.p = p; $f.start = start; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.unmarshalInterface = function(val, start) { return this.$val.unmarshalInterface(val, start); };
	Decoder.ptr.prototype.unmarshalTextInterface = function(val) {
		var _r$6, _r$7, _ref, _tuple, buf, depth, err, p, t, t$1, t$2, t$3, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _r$7 = $f._r$7; _ref = $f._ref; _tuple = $f._tuple; buf = $f.buf; depth = $f.depth; err = $f.err; p = $f.p; t = $f.t; t$1 = $f.t$1; t$2 = $f.t$2; t$3 = $f.t$3; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		buf = sliceType.nil;
		depth = 1;
		/* while (true) { */ case 1:
			/* if (!(depth > 0)) { break; } */ if(!(depth > 0)) { $s = 2; continue; }
			_r$6 = p.Token(); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_tuple = _r$6;
			t = _tuple[0];
			err = _tuple[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			_ref = t;
			if ($assertType(_ref, CharData, true)[1]) {
				t$1 = _ref.$val;
				if (depth === 1) {
					buf = $appendSlice(buf, $subslice(new sliceType(t$1.$array), t$1.$offset, t$1.$offset + t$1.$length));
				}
			} else if ($assertType(_ref, StartElement, true)[1]) {
				t$2 = $clone(_ref.$val, StartElement);
				depth = depth + (1) >> 0;
			} else if ($assertType(_ref, EndElement, true)[1]) {
				t$3 = $clone(_ref.$val, EndElement);
				depth = depth - (1) >> 0;
			}
		/* } */ $s = 1; continue; case 2:
		_r$7 = val.UnmarshalText(buf); /* */ $s = 4; case 4: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		$s = -1; return _r$7;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.unmarshalTextInterface }; } $f._r$6 = _r$6; $f._r$7 = _r$7; $f._ref = _ref; $f._tuple = _tuple; $f.buf = buf; $f.depth = depth; $f.err = err; $f.p = p; $f.t = t; $f.t$1 = t$1; $f.t$2 = t$2; $f.t$3 = t$3; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.unmarshalTextInterface = function(val) { return this.$val.unmarshalTextInterface(val); };
	Decoder.ptr.prototype.unmarshalAttr = function(val, attr) {
		var _arg, _arg$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$20, _r$21, _r$22, _r$23, _r$24, _r$25, _r$26, _r$27, _r$28, _r$29, _r$30, _r$6, _r$7, _r$8, _r$9, _v, _v$1, _v$2, _v$3, _v$4, attr, err, n, p, pv, pv$1, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$23 = $f._r$23; _r$24 = $f._r$24; _r$25 = $f._r$25; _r$26 = $f._r$26; _r$27 = $f._r$27; _r$28 = $f._r$28; _r$29 = $f._r$29; _r$30 = $f._r$30; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; _v$3 = $f._v$3; _v$4 = $f._v$4; attr = $f.attr; err = $f.err; n = $f.n; p = $f.p; pv = $f.pv; pv$1 = $f.pv$1; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if ($clone(val, reflect.Value).Kind() === 22) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($clone(val, reflect.Value).Kind() === 22) { */ case 1:
			/* */ if ($clone(val, reflect.Value).IsNil()) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if ($clone(val, reflect.Value).IsNil()) { */ case 3:
				_r$6 = $clone(val, reflect.Value).Type().Elem(); /* */ $s = 5; case 5: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_r$7 = reflect.New(_r$6); /* */ $s = 6; case 6: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				$r = $clone(val, reflect.Value).Set($clone(_r$7, reflect.Value)); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 4:
			_r$8 = $clone(val, reflect.Value).Elem(); /* */ $s = 8; case 8: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			val = _r$8;
		/* } */ case 2:
		if (!($clone(val, reflect.Value).CanInterface())) { _v = false; $s = 11; continue s; }
		_r$9 = $clone(val, reflect.Value).Type().Implements(unmarshalerAttrType); /* */ $s = 12; case 12: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
		_v = _r$9; case 11:
		/* */ if (_v) { $s = 9; continue; }
		/* */ $s = 10; continue;
		/* if (_v) { */ case 9:
			_r$10 = $clone(val, reflect.Value).Interface(); /* */ $s = 13; case 13: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			_r$11 = $assertType(_r$10, UnmarshalerAttr).UnmarshalXMLAttr($clone(attr, Attr)); /* */ $s = 14; case 14: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
			$s = -1; return _r$11;
		/* } */ case 10:
		/* */ if ($clone(val, reflect.Value).CanAddr()) { $s = 15; continue; }
		/* */ $s = 16; continue;
		/* if ($clone(val, reflect.Value).CanAddr()) { */ case 15:
			pv = $clone(val, reflect.Value).Addr();
			if (!($clone(pv, reflect.Value).CanInterface())) { _v$1 = false; $s = 19; continue s; }
			_r$12 = $clone(pv, reflect.Value).Type().Implements(unmarshalerAttrType); /* */ $s = 20; case 20: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
			_v$1 = _r$12; case 19:
			/* */ if (_v$1) { $s = 17; continue; }
			/* */ $s = 18; continue;
			/* if (_v$1) { */ case 17:
				_r$13 = $clone(pv, reflect.Value).Interface(); /* */ $s = 21; case 21: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
				_r$14 = $assertType(_r$13, UnmarshalerAttr).UnmarshalXMLAttr($clone(attr, Attr)); /* */ $s = 22; case 22: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
				$s = -1; return _r$14;
			/* } */ case 18:
		/* } */ case 16:
		if (!($clone(val, reflect.Value).CanInterface())) { _v$2 = false; $s = 25; continue s; }
		_r$15 = $clone(val, reflect.Value).Type().Implements(textUnmarshalerType); /* */ $s = 26; case 26: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
		_v$2 = _r$15; case 25:
		/* */ if (_v$2) { $s = 23; continue; }
		/* */ $s = 24; continue;
		/* if (_v$2) { */ case 23:
			_r$16 = $clone(val, reflect.Value).Interface(); /* */ $s = 27; case 27: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
			_r$17 = $assertType(_r$16, encoding.TextUnmarshaler).UnmarshalText((new sliceType($stringToBytes(attr.Value)))); /* */ $s = 28; case 28: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
			$s = -1; return _r$17;
		/* } */ case 24:
		/* */ if ($clone(val, reflect.Value).CanAddr()) { $s = 29; continue; }
		/* */ $s = 30; continue;
		/* if ($clone(val, reflect.Value).CanAddr()) { */ case 29:
			pv$1 = $clone(val, reflect.Value).Addr();
			if (!($clone(pv$1, reflect.Value).CanInterface())) { _v$3 = false; $s = 33; continue s; }
			_r$18 = $clone(pv$1, reflect.Value).Type().Implements(textUnmarshalerType); /* */ $s = 34; case 34: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
			_v$3 = _r$18; case 33:
			/* */ if (_v$3) { $s = 31; continue; }
			/* */ $s = 32; continue;
			/* if (_v$3) { */ case 31:
				_r$19 = $clone(pv$1, reflect.Value).Interface(); /* */ $s = 35; case 35: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
				_r$20 = $assertType(_r$19, encoding.TextUnmarshaler).UnmarshalText((new sliceType($stringToBytes(attr.Value)))); /* */ $s = 36; case 36: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
				$s = -1; return _r$20;
			/* } */ case 32:
		/* } */ case 30:
		_r$21 = $clone(val, reflect.Value).Type().Kind(); /* */ $s = 40; case 40: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
		if (!(_r$21 === 23)) { _v$4 = false; $s = 39; continue s; }
		_r$22 = $clone(val, reflect.Value).Type().Elem(); /* */ $s = 41; case 41: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }
		_r$23 = _r$22.Kind(); /* */ $s = 42; case 42: if($c) { $c = false; _r$23 = _r$23.$blk(); } if (_r$23 && _r$23.$blk !== undefined) { break s; }
		_v$4 = !((_r$23 === 8)); case 39:
		/* */ if (_v$4) { $s = 37; continue; }
		/* */ $s = 38; continue;
		/* if (_v$4) { */ case 37:
			n = $clone(val, reflect.Value).Len();
			_arg = $clone(val, reflect.Value);
			_r$24 = $clone(val, reflect.Value).Type().Elem(); /* */ $s = 43; case 43: if($c) { $c = false; _r$24 = _r$24.$blk(); } if (_r$24 && _r$24.$blk !== undefined) { break s; }
			_r$25 = reflect.Zero(_r$24); /* */ $s = 44; case 44: if($c) { $c = false; _r$25 = _r$25.$blk(); } if (_r$25 && _r$25.$blk !== undefined) { break s; }
			_arg$1 = $clone(_r$25, reflect.Value);
			_r$26 = reflect.Append(_arg, new sliceType$7([_arg$1])); /* */ $s = 45; case 45: if($c) { $c = false; _r$26 = _r$26.$blk(); } if (_r$26 && _r$26.$blk !== undefined) { break s; }
			$r = $clone(val, reflect.Value).Set($clone(_r$26, reflect.Value)); /* */ $s = 46; case 46: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$27 = $clone(val, reflect.Value).Index(n); /* */ $s = 47; case 47: if($c) { $c = false; _r$27 = _r$27.$blk(); } if (_r$27 && _r$27.$blk !== undefined) { break s; }
			_r$28 = p.unmarshalAttr($clone(_r$27, reflect.Value), $clone(attr, Attr)); /* */ $s = 48; case 48: if($c) { $c = false; _r$28 = _r$28.$blk(); } if (_r$28 && _r$28.$blk !== undefined) { break s; }
			err = _r$28;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$clone(val, reflect.Value).SetLen(n);
				$s = -1; return err;
			}
			$s = -1; return $ifaceNil;
		/* } */ case 38:
		/* */ if ($interfaceIsEqual($clone(val, reflect.Value).Type(), attrType)) { $s = 49; continue; }
		/* */ $s = 50; continue;
		/* if ($interfaceIsEqual($clone(val, reflect.Value).Type(), attrType)) { */ case 49:
			_r$29 = reflect.ValueOf(new attr.constructor.elem(attr)); /* */ $s = 51; case 51: if($c) { $c = false; _r$29 = _r$29.$blk(); } if (_r$29 && _r$29.$blk !== undefined) { break s; }
			$r = $clone(val, reflect.Value).Set($clone(_r$29, reflect.Value)); /* */ $s = 52; case 52: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
		/* } */ case 50:
		_r$30 = copyValue($clone(val, reflect.Value), (new sliceType($stringToBytes(attr.Value)))); /* */ $s = 53; case 53: if($c) { $c = false; _r$30 = _r$30.$blk(); } if (_r$30 && _r$30.$blk !== undefined) { break s; }
		$s = -1; return _r$30;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.unmarshalAttr }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$23 = _r$23; $f._r$24 = _r$24; $f._r$25 = _r$25; $f._r$26 = _r$26; $f._r$27 = _r$27; $f._r$28 = _r$28; $f._r$29 = _r$29; $f._r$30 = _r$30; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f._v$3 = _v$3; $f._v$4 = _v$4; $f.attr = attr; $f.err = err; $f.n = n; $f.p = p; $f.pv = pv; $f.pv$1 = pv$1; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.unmarshalAttr = function(val, attr) { return this.$val.unmarshalAttr(val, attr); };
	Decoder.ptr.prototype.unmarshal = function(val, start) {
		var _1, _2, _3, _4, _5, _arg, _arg$1, _i, _i$1, _i$2, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$20, _r$21, _r$22, _r$23, _r$24, _r$25, _r$26, _r$27, _r$28, _r$29, _r$30, _r$31, _r$32, _r$33, _r$34, _r$35, _r$36, _r$37, _r$38, _r$39, _r$40, _r$41, _r$42, _r$43, _r$44, _r$45, _r$46, _r$47, _r$48, _r$49, _r$50, _r$51, _r$52, _r$53, _r$54, _r$55, _r$56, _r$57, _r$58, _r$59, _r$6, _r$60, _r$7, _r$8, _r$9, _ref, _ref$1, _ref$2, _ref$3, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _v, _v$1, _v$2, _v$3, _v$4, _v$5, a, any, comment, consumed, data, e, e$1, err, err$1, err$10, err$2, err$3, err$4, err$5, err$6, err$7, err$8, err$9, finfo, finfo$1, finfo$2, finfo$3, fv, handled, i, i$1, n, ok, ok$1, p, pv, pv$1, pv$2, saveAny, saveComment, saveData, saveXML, saveXMLData, saveXMLIndex, savedOffset, start, strv, strv$1, sv, t, t$1, t$2, t$3, t$4, t$5, t$6, tinfo, tok, tok$1, typ, typ$1, v, val, x$2, x$3, x$4, x$5, x$6, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _arg = $f._arg; _arg$1 = $f._arg$1; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$23 = $f._r$23; _r$24 = $f._r$24; _r$25 = $f._r$25; _r$26 = $f._r$26; _r$27 = $f._r$27; _r$28 = $f._r$28; _r$29 = $f._r$29; _r$30 = $f._r$30; _r$31 = $f._r$31; _r$32 = $f._r$32; _r$33 = $f._r$33; _r$34 = $f._r$34; _r$35 = $f._r$35; _r$36 = $f._r$36; _r$37 = $f._r$37; _r$38 = $f._r$38; _r$39 = $f._r$39; _r$40 = $f._r$40; _r$41 = $f._r$41; _r$42 = $f._r$42; _r$43 = $f._r$43; _r$44 = $f._r$44; _r$45 = $f._r$45; _r$46 = $f._r$46; _r$47 = $f._r$47; _r$48 = $f._r$48; _r$49 = $f._r$49; _r$50 = $f._r$50; _r$51 = $f._r$51; _r$52 = $f._r$52; _r$53 = $f._r$53; _r$54 = $f._r$54; _r$55 = $f._r$55; _r$56 = $f._r$56; _r$57 = $f._r$57; _r$58 = $f._r$58; _r$59 = $f._r$59; _r$6 = $f._r$6; _r$60 = $f._r$60; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _ref$3 = $f._ref$3; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; _v$3 = $f._v$3; _v$4 = $f._v$4; _v$5 = $f._v$5; a = $f.a; any = $f.any; comment = $f.comment; consumed = $f.consumed; data = $f.data; e = $f.e; e$1 = $f.e$1; err = $f.err; err$1 = $f.err$1; err$10 = $f.err$10; err$2 = $f.err$2; err$3 = $f.err$3; err$4 = $f.err$4; err$5 = $f.err$5; err$6 = $f.err$6; err$7 = $f.err$7; err$8 = $f.err$8; err$9 = $f.err$9; finfo = $f.finfo; finfo$1 = $f.finfo$1; finfo$2 = $f.finfo$2; finfo$3 = $f.finfo$3; fv = $f.fv; handled = $f.handled; i = $f.i; i$1 = $f.i$1; n = $f.n; ok = $f.ok; ok$1 = $f.ok$1; p = $f.p; pv = $f.pv; pv$1 = $f.pv$1; pv$2 = $f.pv$2; saveAny = $f.saveAny; saveComment = $f.saveComment; saveData = $f.saveData; saveXML = $f.saveXML; saveXMLData = $f.saveXMLData; saveXMLIndex = $f.saveXMLIndex; savedOffset = $f.savedOffset; start = $f.start; strv = $f.strv; strv$1 = $f.strv$1; sv = $f.sv; t = $f.t; t$1 = $f.t$1; t$2 = $f.t$2; t$3 = $f.t$3; t$4 = $f.t$4; t$5 = $f.t$5; t$6 = $f.t$6; tinfo = $f.tinfo; tok = $f.tok; tok$1 = $f.tok$1; typ = $f.typ; typ$1 = $f.typ$1; v = $f.v; val = $f.val; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (start === ptrType$9.nil) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (start === ptrType$9.nil) { */ case 1:
			/* while (true) { */ case 3:
				t = [t];
				_r$6 = p.Token(); /* */ $s = 5; case 5: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_tuple = _r$6;
				tok = _tuple[0];
				err = _tuple[1];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					$s = -1; return err;
				}
				_tuple$1 = $assertType(tok, StartElement, true);
				t[0] = $clone(_tuple$1[0], StartElement);
				ok = _tuple$1[1];
				if (ok) {
					start = t[0];
					/* break; */ $s = 4; continue;
				}
			/* } */ $s = 3; continue; case 4:
		/* } */ case 2:
		/* */ if (($clone(val, reflect.Value).Kind() === 20) && !$clone(val, reflect.Value).IsNil()) { $s = 6; continue; }
		/* */ $s = 7; continue;
		/* if (($clone(val, reflect.Value).Kind() === 20) && !$clone(val, reflect.Value).IsNil()) { */ case 6:
			_r$7 = $clone(val, reflect.Value).Elem(); /* */ $s = 8; case 8: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			e = _r$7;
			if (($clone(e, reflect.Value).Kind() === 22) && !$clone(e, reflect.Value).IsNil()) {
				val = e;
			}
		/* } */ case 7:
		/* */ if ($clone(val, reflect.Value).Kind() === 22) { $s = 9; continue; }
		/* */ $s = 10; continue;
		/* if ($clone(val, reflect.Value).Kind() === 22) { */ case 9:
			/* */ if ($clone(val, reflect.Value).IsNil()) { $s = 11; continue; }
			/* */ $s = 12; continue;
			/* if ($clone(val, reflect.Value).IsNil()) { */ case 11:
				_r$8 = $clone(val, reflect.Value).Type().Elem(); /* */ $s = 13; case 13: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				_r$9 = reflect.New(_r$8); /* */ $s = 14; case 14: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				$r = $clone(val, reflect.Value).Set($clone(_r$9, reflect.Value)); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 12:
			_r$10 = $clone(val, reflect.Value).Elem(); /* */ $s = 16; case 16: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			val = _r$10;
		/* } */ case 10:
		if (!($clone(val, reflect.Value).CanInterface())) { _v = false; $s = 19; continue s; }
		_r$11 = $clone(val, reflect.Value).Type().Implements(unmarshalerType); /* */ $s = 20; case 20: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
		_v = _r$11; case 19:
		/* */ if (_v) { $s = 17; continue; }
		/* */ $s = 18; continue;
		/* if (_v) { */ case 17:
			_r$12 = $clone(val, reflect.Value).Interface(); /* */ $s = 21; case 21: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
			_r$13 = p.unmarshalInterface($assertType(_r$12, Unmarshaler), start); /* */ $s = 22; case 22: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
			$s = -1; return _r$13;
		/* } */ case 18:
		/* */ if ($clone(val, reflect.Value).CanAddr()) { $s = 23; continue; }
		/* */ $s = 24; continue;
		/* if ($clone(val, reflect.Value).CanAddr()) { */ case 23:
			pv = $clone(val, reflect.Value).Addr();
			if (!($clone(pv, reflect.Value).CanInterface())) { _v$1 = false; $s = 27; continue s; }
			_r$14 = $clone(pv, reflect.Value).Type().Implements(unmarshalerType); /* */ $s = 28; case 28: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
			_v$1 = _r$14; case 27:
			/* */ if (_v$1) { $s = 25; continue; }
			/* */ $s = 26; continue;
			/* if (_v$1) { */ case 25:
				_r$15 = $clone(pv, reflect.Value).Interface(); /* */ $s = 29; case 29: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
				_r$16 = p.unmarshalInterface($assertType(_r$15, Unmarshaler), start); /* */ $s = 30; case 30: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
				$s = -1; return _r$16;
			/* } */ case 26:
		/* } */ case 24:
		if (!($clone(val, reflect.Value).CanInterface())) { _v$2 = false; $s = 33; continue s; }
		_r$17 = $clone(val, reflect.Value).Type().Implements(textUnmarshalerType); /* */ $s = 34; case 34: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
		_v$2 = _r$17; case 33:
		/* */ if (_v$2) { $s = 31; continue; }
		/* */ $s = 32; continue;
		/* if (_v$2) { */ case 31:
			_r$18 = $clone(val, reflect.Value).Interface(); /* */ $s = 35; case 35: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
			_r$19 = p.unmarshalTextInterface($assertType(_r$18, encoding.TextUnmarshaler)); /* */ $s = 36; case 36: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
			$s = -1; return _r$19;
		/* } */ case 32:
		/* */ if ($clone(val, reflect.Value).CanAddr()) { $s = 37; continue; }
		/* */ $s = 38; continue;
		/* if ($clone(val, reflect.Value).CanAddr()) { */ case 37:
			pv$1 = $clone(val, reflect.Value).Addr();
			if (!($clone(pv$1, reflect.Value).CanInterface())) { _v$3 = false; $s = 41; continue s; }
			_r$20 = $clone(pv$1, reflect.Value).Type().Implements(textUnmarshalerType); /* */ $s = 42; case 42: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
			_v$3 = _r$20; case 41:
			/* */ if (_v$3) { $s = 39; continue; }
			/* */ $s = 40; continue;
			/* if (_v$3) { */ case 39:
				_r$21 = $clone(pv$1, reflect.Value).Interface(); /* */ $s = 43; case 43: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
				_r$22 = p.unmarshalTextInterface($assertType(_r$21, encoding.TextUnmarshaler)); /* */ $s = 44; case 44: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }
				$s = -1; return _r$22;
			/* } */ case 40:
		/* } */ case 38:
		data = sliceType.nil;
		saveData = new reflect.Value.ptr(ptrType$11.nil, 0, 0);
		comment = sliceType.nil;
		saveComment = new reflect.Value.ptr(ptrType$11.nil, 0, 0);
		saveXML = new reflect.Value.ptr(ptrType$11.nil, 0, 0);
		saveXMLIndex = 0;
		saveXMLData = sliceType.nil;
		saveAny = new reflect.Value.ptr(ptrType$11.nil, 0, 0);
		sv = new reflect.Value.ptr(ptrType$11.nil, 0, 0);
		tinfo = ptrType$12.nil;
		err$1 = $ifaceNil;
			v = val;
			_1 = $clone(v, reflect.Value).Kind();
			/* */ if (_1 === (20)) { $s = 46; continue; }
			/* */ if (_1 === (23)) { $s = 47; continue; }
			/* */ if ((_1 === (1)) || (_1 === (13)) || (_1 === (14)) || (_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6)) || (_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12)) || (_1 === (24))) { $s = 48; continue; }
			/* */ if (_1 === (25)) { $s = 49; continue; }
			/* */ $s = 50; continue;
			/* if (_1 === (20)) { */ case 46:
				_r$23 = p.Skip(); /* */ $s = 52; case 52: if($c) { $c = false; _r$23 = _r$23.$blk(); } if (_r$23 && _r$23.$blk !== undefined) { break s; }
				$s = -1; return _r$23;
			/* } else if (_1 === (23)) { */ case 47:
				typ = $clone(v, reflect.Value).Type();
				_r$24 = typ.Elem(); /* */ $s = 55; case 55: if($c) { $c = false; _r$24 = _r$24.$blk(); } if (_r$24 && _r$24.$blk !== undefined) { break s; }
				_r$25 = _r$24.Kind(); /* */ $s = 56; case 56: if($c) { $c = false; _r$25 = _r$25.$blk(); } if (_r$25 && _r$25.$blk !== undefined) { break s; }
				/* */ if (_r$25 === 8) { $s = 53; continue; }
				/* */ $s = 54; continue;
				/* if (_r$25 === 8) { */ case 53:
					saveData = v;
					/* break; */ $s = 45; continue;
				/* } */ case 54:
				n = $clone(v, reflect.Value).Len();
				_arg = $clone(val, reflect.Value);
				_r$26 = $clone(v, reflect.Value).Type().Elem(); /* */ $s = 57; case 57: if($c) { $c = false; _r$26 = _r$26.$blk(); } if (_r$26 && _r$26.$blk !== undefined) { break s; }
				_r$27 = reflect.Zero(_r$26); /* */ $s = 58; case 58: if($c) { $c = false; _r$27 = _r$27.$blk(); } if (_r$27 && _r$27.$blk !== undefined) { break s; }
				_arg$1 = $clone(_r$27, reflect.Value);
				_r$28 = reflect.Append(_arg, new sliceType$7([_arg$1])); /* */ $s = 59; case 59: if($c) { $c = false; _r$28 = _r$28.$blk(); } if (_r$28 && _r$28.$blk !== undefined) { break s; }
				$r = $clone(v, reflect.Value).Set($clone(_r$28, reflect.Value)); /* */ $s = 60; case 60: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				_r$29 = $clone(v, reflect.Value).Index(n); /* */ $s = 61; case 61: if($c) { $c = false; _r$29 = _r$29.$blk(); } if (_r$29 && _r$29.$blk !== undefined) { break s; }
				_r$30 = p.unmarshal($clone(_r$29, reflect.Value), start); /* */ $s = 62; case 62: if($c) { $c = false; _r$30 = _r$30.$blk(); } if (_r$30 && _r$30.$blk !== undefined) { break s; }
				err$2 = _r$30;
				if (!($interfaceIsEqual(err$2, $ifaceNil))) {
					$clone(v, reflect.Value).SetLen(n);
					$s = -1; return err$2;
				}
				$s = -1; return $ifaceNil;
			/* } else if ((_1 === (1)) || (_1 === (13)) || (_1 === (14)) || (_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6)) || (_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12)) || (_1 === (24))) { */ case 48:
				saveData = v;
				$s = 51; continue;
			/* } else if (_1 === (25)) { */ case 49:
				typ$1 = $clone(v, reflect.Value).Type();
				/* */ if ($interfaceIsEqual(typ$1, nameType)) { $s = 63; continue; }
				/* */ $s = 64; continue;
				/* if ($interfaceIsEqual(typ$1, nameType)) { */ case 63:
					_r$31 = reflect.ValueOf((x$2 = start.Name, new x$2.constructor.elem(x$2))); /* */ $s = 65; case 65: if($c) { $c = false; _r$31 = _r$31.$blk(); } if (_r$31 && _r$31.$blk !== undefined) { break s; }
					$r = $clone(v, reflect.Value).Set($clone(_r$31, reflect.Value)); /* */ $s = 66; case 66: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					/* break; */ $s = 45; continue;
				/* } */ case 64:
				sv = v;
				_r$32 = getTypeInfo(typ$1); /* */ $s = 67; case 67: if($c) { $c = false; _r$32 = _r$32.$blk(); } if (_r$32 && _r$32.$blk !== undefined) { break s; }
				_tuple$2 = _r$32;
				tinfo = _tuple$2[0];
				err$1 = _tuple$2[1];
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					$s = -1; return err$1;
				}
				/* */ if (!(tinfo.xmlname === ptrType$8.nil)) { $s = 68; continue; }
				/* */ $s = 69; continue;
				/* if (!(tinfo.xmlname === ptrType$8.nil)) { */ case 68:
					finfo = tinfo.xmlname;
					if (!(finfo.name === "") && !(finfo.name === start.Name.Local)) {
						$s = -1; return new UnmarshalError(("expected element type <" + finfo.name + "> but have <" + start.Name.Local + ">"));
					}
					if (!(finfo.xmlns === "") && !(finfo.xmlns === start.Name.Space)) {
						e$1 = "expected element <" + finfo.name + "> in name space " + finfo.xmlns + " but have ";
						if (start.Name.Space === "") {
							e$1 = e$1 + ("no name space");
						} else {
							e$1 = e$1 + (start.Name.Space);
						}
						$s = -1; return new UnmarshalError((e$1));
					}
					_r$33 = finfo.value($clone(sv, reflect.Value)); /* */ $s = 70; case 70: if($c) { $c = false; _r$33 = _r$33.$blk(); } if (_r$33 && _r$33.$blk !== undefined) { break s; }
					fv = _r$33;
					_r$34 = $clone(fv, reflect.Value).Interface(); /* */ $s = 71; case 71: if($c) { $c = false; _r$34 = _r$34.$blk(); } if (_r$34 && _r$34.$blk !== undefined) { break s; }
					_tuple$3 = $assertType(_r$34, Name, true);
					ok$1 = _tuple$3[1];
					/* */ if (ok$1) { $s = 72; continue; }
					/* */ $s = 73; continue;
					/* if (ok$1) { */ case 72:
						_r$35 = reflect.ValueOf((x$3 = start.Name, new x$3.constructor.elem(x$3))); /* */ $s = 74; case 74: if($c) { $c = false; _r$35 = _r$35.$blk(); } if (_r$35 && _r$35.$blk !== undefined) { break s; }
						$r = $clone(fv, reflect.Value).Set($clone(_r$35, reflect.Value)); /* */ $s = 75; case 75: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					/* } */ case 73:
				/* } */ case 69:
				_ref = start.Attr;
				_i = 0;
				/* while (true) { */ case 76:
					/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 77; continue; }
					a = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attr);
					handled = false;
					any = -1;
					_ref$1 = tinfo.fields;
					_i$1 = 0;
					/* while (true) { */ case 78:
						/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 79; continue; }
						i = _i$1;
						finfo$1 = (x$4 = tinfo.fields, ((i < 0 || i >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + i]));
							_2 = finfo$1.flags & 127;
							/* */ if (_2 === (2)) { $s = 81; continue; }
							/* */ if (_2 === (66)) { $s = 82; continue; }
							/* */ $s = 83; continue;
							/* if (_2 === (2)) { */ case 81:
								_r$36 = finfo$1.value($clone(sv, reflect.Value)); /* */ $s = 84; case 84: if($c) { $c = false; _r$36 = _r$36.$blk(); } if (_r$36 && _r$36.$blk !== undefined) { break s; }
								strv = _r$36;
								/* */ if (a.Name.Local === finfo$1.name && (finfo$1.xmlns === "" || finfo$1.xmlns === a.Name.Space)) { $s = 85; continue; }
								/* */ $s = 86; continue;
								/* if (a.Name.Local === finfo$1.name && (finfo$1.xmlns === "" || finfo$1.xmlns === a.Name.Space)) { */ case 85:
									_r$37 = p.unmarshalAttr($clone(strv, reflect.Value), $clone(a, Attr)); /* */ $s = 87; case 87: if($c) { $c = false; _r$37 = _r$37.$blk(); } if (_r$37 && _r$37.$blk !== undefined) { break s; }
									err$3 = _r$37;
									if (!($interfaceIsEqual(err$3, $ifaceNil))) {
										$s = -1; return err$3;
									}
									handled = true;
								/* } */ case 86:
								$s = 83; continue;
							/* } else if (_2 === (66)) { */ case 82:
								if (any === -1) {
									any = i;
								}
							/* } */ case 83:
						case 80:
						_i$1++;
					/* } */ $s = 78; continue; case 79:
					/* */ if (!handled && any >= 0) { $s = 88; continue; }
					/* */ $s = 89; continue;
					/* if (!handled && any >= 0) { */ case 88:
						finfo$2 = (x$5 = tinfo.fields, ((any < 0 || any >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + any]));
						_r$38 = finfo$2.value($clone(sv, reflect.Value)); /* */ $s = 90; case 90: if($c) { $c = false; _r$38 = _r$38.$blk(); } if (_r$38 && _r$38.$blk !== undefined) { break s; }
						strv$1 = _r$38;
						_r$39 = p.unmarshalAttr($clone(strv$1, reflect.Value), $clone(a, Attr)); /* */ $s = 91; case 91: if($c) { $c = false; _r$39 = _r$39.$blk(); } if (_r$39 && _r$39.$blk !== undefined) { break s; }
						err$4 = _r$39;
						if (!($interfaceIsEqual(err$4, $ifaceNil))) {
							$s = -1; return err$4;
						}
					/* } */ case 89:
					_i++;
				/* } */ $s = 76; continue; case 77:
				_ref$2 = tinfo.fields;
				_i$2 = 0;
				/* while (true) { */ case 92:
					/* if (!(_i$2 < _ref$2.$length)) { break; } */ if(!(_i$2 < _ref$2.$length)) { $s = 93; continue; }
					i$1 = _i$2;
					finfo$3 = (x$6 = tinfo.fields, ((i$1 < 0 || i$1 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + i$1]));
						_3 = finfo$3.flags & 127;
						/* */ if ((_3 === (4)) || (_3 === (8))) { $s = 95; continue; }
						/* */ if (_3 === (32)) { $s = 96; continue; }
						/* */ if ((_3 === (64)) || (_3 === (65))) { $s = 97; continue; }
						/* */ if (_3 === (16)) { $s = 98; continue; }
						/* */ $s = 99; continue;
						/* if ((_3 === (4)) || (_3 === (8))) { */ case 95:
							/* */ if (!$clone(saveData, reflect.Value).IsValid()) { $s = 100; continue; }
							/* */ $s = 101; continue;
							/* if (!$clone(saveData, reflect.Value).IsValid()) { */ case 100:
								_r$40 = finfo$3.value($clone(sv, reflect.Value)); /* */ $s = 102; case 102: if($c) { $c = false; _r$40 = _r$40.$blk(); } if (_r$40 && _r$40.$blk !== undefined) { break s; }
								saveData = _r$40;
							/* } */ case 101:
							$s = 99; continue;
						/* } else if (_3 === (32)) { */ case 96:
							/* */ if (!$clone(saveComment, reflect.Value).IsValid()) { $s = 103; continue; }
							/* */ $s = 104; continue;
							/* if (!$clone(saveComment, reflect.Value).IsValid()) { */ case 103:
								_r$41 = finfo$3.value($clone(sv, reflect.Value)); /* */ $s = 105; case 105: if($c) { $c = false; _r$41 = _r$41.$blk(); } if (_r$41 && _r$41.$blk !== undefined) { break s; }
								saveComment = _r$41;
							/* } */ case 104:
							$s = 99; continue;
						/* } else if ((_3 === (64)) || (_3 === (65))) { */ case 97:
							/* */ if (!$clone(saveAny, reflect.Value).IsValid()) { $s = 106; continue; }
							/* */ $s = 107; continue;
							/* if (!$clone(saveAny, reflect.Value).IsValid()) { */ case 106:
								_r$42 = finfo$3.value($clone(sv, reflect.Value)); /* */ $s = 108; case 108: if($c) { $c = false; _r$42 = _r$42.$blk(); } if (_r$42 && _r$42.$blk !== undefined) { break s; }
								saveAny = _r$42;
							/* } */ case 107:
							$s = 99; continue;
						/* } else if (_3 === (16)) { */ case 98:
							/* */ if (!$clone(saveXML, reflect.Value).IsValid()) { $s = 109; continue; }
							/* */ $s = 110; continue;
							/* if (!$clone(saveXML, reflect.Value).IsValid()) { */ case 109:
								_r$43 = finfo$3.value($clone(sv, reflect.Value)); /* */ $s = 111; case 111: if($c) { $c = false; _r$43 = _r$43.$blk(); } if (_r$43 && _r$43.$blk !== undefined) { break s; }
								saveXML = _r$43;
								if (p.saved === ptrType$13.nil) {
									saveXMLIndex = 0;
									p.saved = new bytes.Buffer.ptr(sliceType.nil, 0, 0, arrayType.zero());
								} else {
									saveXMLIndex = p.savedOffset();
								}
							/* } */ case 110:
						/* } */ case 99:
					case 94:
					_i$2++;
				/* } */ $s = 92; continue; case 93:
				$s = 51; continue;
			/* } else { */ case 50:
				_r$44 = $clone(v, reflect.Value).Type().String(); /* */ $s = 112; case 112: if($c) { $c = false; _r$44 = _r$44.$blk(); } if (_r$44 && _r$44.$blk !== undefined) { break s; }
				_r$45 = errors.New("unknown type " + _r$44); /* */ $s = 113; case 113: if($c) { $c = false; _r$45 = _r$45.$blk(); } if (_r$45 && _r$45.$blk !== undefined) { break s; }
				$s = -1; return _r$45;
			/* } */ case 51:
		case 45:
		/* while (true) { */ case 114:
			t$1 = [t$1];
			savedOffset = 0;
			if ($clone(saveXML, reflect.Value).IsValid()) {
				savedOffset = p.savedOffset();
			}
			_r$46 = p.Token(); /* */ $s = 116; case 116: if($c) { $c = false; _r$46 = _r$46.$blk(); } if (_r$46 && _r$46.$blk !== undefined) { break s; }
			_tuple$4 = _r$46;
			tok$1 = _tuple$4[0];
			err$5 = _tuple$4[1];
			if (!($interfaceIsEqual(err$5, $ifaceNil))) {
				$s = -1; return err$5;
			}
			_ref$3 = tok$1;
			/* */ if ($assertType(_ref$3, StartElement, true)[1]) { $s = 117; continue; }
			/* */ if ($assertType(_ref$3, EndElement, true)[1]) { $s = 118; continue; }
			/* */ if ($assertType(_ref$3, CharData, true)[1]) { $s = 119; continue; }
			/* */ if ($assertType(_ref$3, Comment, true)[1]) { $s = 120; continue; }
			/* */ $s = 121; continue;
			/* if ($assertType(_ref$3, StartElement, true)[1]) { */ case 117:
				t$1[0] = $clone(_ref$3.$val, StartElement);
				consumed = false;
				/* */ if ($clone(sv, reflect.Value).IsValid()) { $s = 122; continue; }
				/* */ $s = 123; continue;
				/* if ($clone(sv, reflect.Value).IsValid()) { */ case 122:
					_r$47 = p.unmarshalPath(tinfo, $clone(sv, reflect.Value), sliceType$3.nil, t$1[0]); /* */ $s = 124; case 124: if($c) { $c = false; _r$47 = _r$47.$blk(); } if (_r$47 && _r$47.$blk !== undefined) { break s; }
					_tuple$5 = _r$47;
					consumed = _tuple$5[0];
					err$5 = _tuple$5[1];
					if (!($interfaceIsEqual(err$5, $ifaceNil))) {
						$s = -1; return err$5;
					}
					/* */ if (!consumed && $clone(saveAny, reflect.Value).IsValid()) { $s = 125; continue; }
					/* */ $s = 126; continue;
					/* if (!consumed && $clone(saveAny, reflect.Value).IsValid()) { */ case 125:
						consumed = true;
						_r$48 = p.unmarshal($clone(saveAny, reflect.Value), t$1[0]); /* */ $s = 127; case 127: if($c) { $c = false; _r$48 = _r$48.$blk(); } if (_r$48 && _r$48.$blk !== undefined) { break s; }
						err$6 = _r$48;
						if (!($interfaceIsEqual(err$6, $ifaceNil))) {
							$s = -1; return err$6;
						}
					/* } */ case 126:
				/* } */ case 123:
				/* */ if (!consumed) { $s = 128; continue; }
				/* */ $s = 129; continue;
				/* if (!consumed) { */ case 128:
					_r$49 = p.Skip(); /* */ $s = 130; case 130: if($c) { $c = false; _r$49 = _r$49.$blk(); } if (_r$49 && _r$49.$blk !== undefined) { break s; }
					err$7 = _r$49;
					if (!($interfaceIsEqual(err$7, $ifaceNil))) {
						$s = -1; return err$7;
					}
				/* } */ case 129:
				$s = 121; continue;
			/* } else if ($assertType(_ref$3, EndElement, true)[1]) { */ case 118:
				t$2 = $clone(_ref$3.$val, EndElement);
				if ($clone(saveXML, reflect.Value).IsValid()) {
					saveXMLData = $subslice(p.saved.Bytes(), saveXMLIndex, savedOffset);
					if (saveXMLIndex === 0) {
						p.saved = ptrType$13.nil;
					}
				}
				/* break Loop; */ $s = 115; continue s;
				$s = 121; continue;
			/* } else if ($assertType(_ref$3, CharData, true)[1]) { */ case 119:
				t$3 = _ref$3.$val;
				if ($clone(saveData, reflect.Value).IsValid()) {
					data = $appendSlice(data, $subslice(new sliceType(t$3.$array), t$3.$offset, t$3.$offset + t$3.$length));
				}
				$s = 121; continue;
			/* } else if ($assertType(_ref$3, Comment, true)[1]) { */ case 120:
				t$4 = _ref$3.$val;
				if ($clone(saveComment, reflect.Value).IsValid()) {
					comment = $appendSlice(comment, $subslice(new sliceType(t$4.$array), t$4.$offset, t$4.$offset + t$4.$length));
				}
			/* } */ case 121:
		/* } */ $s = 114; continue; case 115:
		if (!($clone(saveData, reflect.Value).IsValid() && $clone(saveData, reflect.Value).CanInterface())) { _v$4 = false; $s = 133; continue s; }
		_r$50 = $clone(saveData, reflect.Value).Type().Implements(textUnmarshalerType); /* */ $s = 134; case 134: if($c) { $c = false; _r$50 = _r$50.$blk(); } if (_r$50 && _r$50.$blk !== undefined) { break s; }
		_v$4 = _r$50; case 133:
		/* */ if (_v$4) { $s = 131; continue; }
		/* */ $s = 132; continue;
		/* if (_v$4) { */ case 131:
			_r$51 = $clone(saveData, reflect.Value).Interface(); /* */ $s = 135; case 135: if($c) { $c = false; _r$51 = _r$51.$blk(); } if (_r$51 && _r$51.$blk !== undefined) { break s; }
			_r$52 = $assertType(_r$51, encoding.TextUnmarshaler).UnmarshalText(data); /* */ $s = 136; case 136: if($c) { $c = false; _r$52 = _r$52.$blk(); } if (_r$52 && _r$52.$blk !== undefined) { break s; }
			err$8 = _r$52;
			if (!($interfaceIsEqual(err$8, $ifaceNil))) {
				$s = -1; return err$8;
			}
			saveData = new reflect.Value.ptr(ptrType$11.nil, 0, 0);
		/* } */ case 132:
		/* */ if ($clone(saveData, reflect.Value).IsValid() && $clone(saveData, reflect.Value).CanAddr()) { $s = 137; continue; }
		/* */ $s = 138; continue;
		/* if ($clone(saveData, reflect.Value).IsValid() && $clone(saveData, reflect.Value).CanAddr()) { */ case 137:
			pv$2 = $clone(saveData, reflect.Value).Addr();
			if (!($clone(pv$2, reflect.Value).CanInterface())) { _v$5 = false; $s = 141; continue s; }
			_r$53 = $clone(pv$2, reflect.Value).Type().Implements(textUnmarshalerType); /* */ $s = 142; case 142: if($c) { $c = false; _r$53 = _r$53.$blk(); } if (_r$53 && _r$53.$blk !== undefined) { break s; }
			_v$5 = _r$53; case 141:
			/* */ if (_v$5) { $s = 139; continue; }
			/* */ $s = 140; continue;
			/* if (_v$5) { */ case 139:
				_r$54 = $clone(pv$2, reflect.Value).Interface(); /* */ $s = 143; case 143: if($c) { $c = false; _r$54 = _r$54.$blk(); } if (_r$54 && _r$54.$blk !== undefined) { break s; }
				_r$55 = $assertType(_r$54, encoding.TextUnmarshaler).UnmarshalText(data); /* */ $s = 144; case 144: if($c) { $c = false; _r$55 = _r$55.$blk(); } if (_r$55 && _r$55.$blk !== undefined) { break s; }
				err$9 = _r$55;
				if (!($interfaceIsEqual(err$9, $ifaceNil))) {
					$s = -1; return err$9;
				}
				saveData = new reflect.Value.ptr(ptrType$11.nil, 0, 0);
			/* } */ case 140:
		/* } */ case 138:
		_r$56 = copyValue($clone(saveData, reflect.Value), data); /* */ $s = 145; case 145: if($c) { $c = false; _r$56 = _r$56.$blk(); } if (_r$56 && _r$56.$blk !== undefined) { break s; }
		err$10 = _r$56;
		if (!($interfaceIsEqual(err$10, $ifaceNil))) {
			$s = -1; return err$10;
		}
			t$5 = saveComment;
			_4 = $clone(t$5, reflect.Value).Kind();
			/* */ if (_4 === (24)) { $s = 147; continue; }
			/* */ if (_4 === (23)) { $s = 148; continue; }
			/* */ $s = 149; continue;
			/* if (_4 === (24)) { */ case 147:
				$clone(t$5, reflect.Value).SetString(($bytesToString(comment)));
				$s = 149; continue;
			/* } else if (_4 === (23)) { */ case 148:
				_r$57 = reflect.ValueOf(comment); /* */ $s = 150; case 150: if($c) { $c = false; _r$57 = _r$57.$blk(); } if (_r$57 && _r$57.$blk !== undefined) { break s; }
				$r = $clone(t$5, reflect.Value).Set($clone(_r$57, reflect.Value)); /* */ $s = 151; case 151: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 149:
		case 146:
			t$6 = saveXML;
			_5 = $clone(t$6, reflect.Value).Kind();
			/* */ if (_5 === (24)) { $s = 153; continue; }
			/* */ if (_5 === (23)) { $s = 154; continue; }
			/* */ $s = 155; continue;
			/* if (_5 === (24)) { */ case 153:
				$clone(t$6, reflect.Value).SetString(($bytesToString(saveXMLData)));
				$s = 155; continue;
			/* } else if (_5 === (23)) { */ case 154:
				_r$58 = $clone(t$6, reflect.Value).Type().Elem(); /* */ $s = 158; case 158: if($c) { $c = false; _r$58 = _r$58.$blk(); } if (_r$58 && _r$58.$blk !== undefined) { break s; }
				_r$59 = _r$58.Kind(); /* */ $s = 159; case 159: if($c) { $c = false; _r$59 = _r$59.$blk(); } if (_r$59 && _r$59.$blk !== undefined) { break s; }
				/* */ if (_r$59 === 8) { $s = 156; continue; }
				/* */ $s = 157; continue;
				/* if (_r$59 === 8) { */ case 156:
					_r$60 = reflect.ValueOf(saveXMLData); /* */ $s = 160; case 160: if($c) { $c = false; _r$60 = _r$60.$blk(); } if (_r$60 && _r$60.$blk !== undefined) { break s; }
					$r = $clone(t$6, reflect.Value).Set($clone(_r$60, reflect.Value)); /* */ $s = 161; case 161: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 157:
			/* } */ case 155:
		case 152:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.unmarshal }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._arg = _arg; $f._arg$1 = _arg$1; $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$23 = _r$23; $f._r$24 = _r$24; $f._r$25 = _r$25; $f._r$26 = _r$26; $f._r$27 = _r$27; $f._r$28 = _r$28; $f._r$29 = _r$29; $f._r$30 = _r$30; $f._r$31 = _r$31; $f._r$32 = _r$32; $f._r$33 = _r$33; $f._r$34 = _r$34; $f._r$35 = _r$35; $f._r$36 = _r$36; $f._r$37 = _r$37; $f._r$38 = _r$38; $f._r$39 = _r$39; $f._r$40 = _r$40; $f._r$41 = _r$41; $f._r$42 = _r$42; $f._r$43 = _r$43; $f._r$44 = _r$44; $f._r$45 = _r$45; $f._r$46 = _r$46; $f._r$47 = _r$47; $f._r$48 = _r$48; $f._r$49 = _r$49; $f._r$50 = _r$50; $f._r$51 = _r$51; $f._r$52 = _r$52; $f._r$53 = _r$53; $f._r$54 = _r$54; $f._r$55 = _r$55; $f._r$56 = _r$56; $f._r$57 = _r$57; $f._r$58 = _r$58; $f._r$59 = _r$59; $f._r$6 = _r$6; $f._r$60 = _r$60; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._ref$3 = _ref$3; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f._v$3 = _v$3; $f._v$4 = _v$4; $f._v$5 = _v$5; $f.a = a; $f.any = any; $f.comment = comment; $f.consumed = consumed; $f.data = data; $f.e = e; $f.e$1 = e$1; $f.err = err; $f.err$1 = err$1; $f.err$10 = err$10; $f.err$2 = err$2; $f.err$3 = err$3; $f.err$4 = err$4; $f.err$5 = err$5; $f.err$6 = err$6; $f.err$7 = err$7; $f.err$8 = err$8; $f.err$9 = err$9; $f.finfo = finfo; $f.finfo$1 = finfo$1; $f.finfo$2 = finfo$2; $f.finfo$3 = finfo$3; $f.fv = fv; $f.handled = handled; $f.i = i; $f.i$1 = i$1; $f.n = n; $f.ok = ok; $f.ok$1 = ok$1; $f.p = p; $f.pv = pv; $f.pv$1 = pv$1; $f.pv$2 = pv$2; $f.saveAny = saveAny; $f.saveComment = saveComment; $f.saveData = saveData; $f.saveXML = saveXML; $f.saveXMLData = saveXMLData; $f.saveXMLIndex = saveXMLIndex; $f.savedOffset = savedOffset; $f.start = start; $f.strv = strv; $f.strv$1 = strv$1; $f.sv = sv; $f.t = t; $f.t$1 = t$1; $f.t$2 = t$2; $f.t$3 = t$3; $f.t$4 = t$4; $f.t$5 = t$5; $f.t$6 = t$6; $f.tinfo = tinfo; $f.tok = tok; $f.tok$1 = tok$1; $f.typ = typ; $f.typ$1 = typ$1; $f.v = v; $f.val = val; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.unmarshal = function(val, start) { return this.$val.unmarshal(val, start); };
	copyValue = function(dst, src) {
		var _1, _arg, _arg$1, _arg$2, _arg$3, _arg$4, _arg$5, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$6, _r$7, _r$8, _r$9, _tuple, _tuple$1, _tuple$2, _tuple$3, dst, dst0, err, err$1, err$2, err$3, err$4, ftmp, itmp, src, utmp, value, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _arg$3 = $f._arg$3; _arg$4 = $f._arg$4; _arg$5 = $f._arg$5; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; dst = $f.dst; dst0 = $f.dst0; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; err$4 = $f.err$4; ftmp = $f.ftmp; itmp = $f.itmp; src = $f.src; utmp = $f.utmp; value = $f.value; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		err = $ifaceNil;
		dst0 = dst;
		/* */ if ($clone(dst, reflect.Value).Kind() === 22) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($clone(dst, reflect.Value).Kind() === 22) { */ case 1:
			/* */ if ($clone(dst, reflect.Value).IsNil()) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if ($clone(dst, reflect.Value).IsNil()) { */ case 3:
				_r$6 = $clone(dst, reflect.Value).Type().Elem(); /* */ $s = 5; case 5: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_r$7 = reflect.New(_r$6); /* */ $s = 6; case 6: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				$r = $clone(dst, reflect.Value).Set($clone(_r$7, reflect.Value)); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 4:
			_r$8 = $clone(dst, reflect.Value).Elem(); /* */ $s = 8; case 8: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			dst = _r$8;
		/* } */ case 2:
			_1 = $clone(dst, reflect.Value).Kind();
			/* */ if (_1 === (0)) { $s = 10; continue; }
			/* */ if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { $s = 11; continue; }
			/* */ if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { $s = 12; continue; }
			/* */ if ((_1 === (13)) || (_1 === (14))) { $s = 13; continue; }
			/* */ if (_1 === (1)) { $s = 14; continue; }
			/* */ if (_1 === (24)) { $s = 15; continue; }
			/* */ if (_1 === (23)) { $s = 16; continue; }
			/* */ $s = 17; continue;
			/* if (_1 === (0)) { */ case 10:
				$s = 18; continue;
			/* } else if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 11:
				if (src.$length === 0) {
					$clone(dst, reflect.Value).SetInt(new $Int64(0, 0));
					err = $ifaceNil;
					$s = -1; return err;
				}
				_arg = ($bytesToString(src));
				_r$9 = $clone(dst, reflect.Value).Type().Bits(); /* */ $s = 19; case 19: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				_arg$1 = _r$9;
				_r$10 = strconv.ParseInt(_arg, 10, _arg$1); /* */ $s = 20; case 20: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
				_tuple = _r$10;
				itmp = _tuple[0];
				err$1 = _tuple[1];
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					err = err$1;
					$s = -1; return err;
				}
				$clone(dst, reflect.Value).SetInt(itmp);
				$s = 18; continue;
			/* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 12:
				if (src.$length === 0) {
					$clone(dst, reflect.Value).SetUint(new $Uint64(0, 0));
					err = $ifaceNil;
					$s = -1; return err;
				}
				_arg$2 = ($bytesToString(src));
				_r$11 = $clone(dst, reflect.Value).Type().Bits(); /* */ $s = 21; case 21: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
				_arg$3 = _r$11;
				_r$12 = strconv.ParseUint(_arg$2, 10, _arg$3); /* */ $s = 22; case 22: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
				_tuple$1 = _r$12;
				utmp = _tuple$1[0];
				err$2 = _tuple$1[1];
				if (!($interfaceIsEqual(err$2, $ifaceNil))) {
					err = err$2;
					$s = -1; return err;
				}
				$clone(dst, reflect.Value).SetUint(utmp);
				$s = 18; continue;
			/* } else if ((_1 === (13)) || (_1 === (14))) { */ case 13:
				if (src.$length === 0) {
					$clone(dst, reflect.Value).SetFloat(0);
					err = $ifaceNil;
					$s = -1; return err;
				}
				_arg$4 = ($bytesToString(src));
				_r$13 = $clone(dst, reflect.Value).Type().Bits(); /* */ $s = 23; case 23: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
				_arg$5 = _r$13;
				_r$14 = strconv.ParseFloat(_arg$4, _arg$5); /* */ $s = 24; case 24: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
				_tuple$2 = _r$14;
				ftmp = _tuple$2[0];
				err$3 = _tuple$2[1];
				if (!($interfaceIsEqual(err$3, $ifaceNil))) {
					err = err$3;
					$s = -1; return err;
				}
				$clone(dst, reflect.Value).SetFloat(ftmp);
				$s = 18; continue;
			/* } else if (_1 === (1)) { */ case 14:
				if (src.$length === 0) {
					$clone(dst, reflect.Value).SetBool(false);
					err = $ifaceNil;
					$s = -1; return err;
				}
				_r$15 = strings.TrimSpace(($bytesToString(src))); /* */ $s = 25; case 25: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
				_r$16 = strconv.ParseBool(_r$15); /* */ $s = 26; case 26: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
				_tuple$3 = _r$16;
				value = _tuple$3[0];
				err$4 = _tuple$3[1];
				if (!($interfaceIsEqual(err$4, $ifaceNil))) {
					err = err$4;
					$s = -1; return err;
				}
				$clone(dst, reflect.Value).SetBool(value);
				$s = 18; continue;
			/* } else if (_1 === (24)) { */ case 15:
				$clone(dst, reflect.Value).SetString(($bytesToString(src)));
				$s = 18; continue;
			/* } else if (_1 === (23)) { */ case 16:
				if (src.$length === 0) {
					src = new sliceType([]);
				}
				$r = $clone(dst, reflect.Value).SetBytes(src); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 18; continue;
			/* } else { */ case 17:
				_r$17 = $clone(dst0, reflect.Value).Type().String(); /* */ $s = 28; case 28: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
				_r$18 = errors.New("cannot unmarshal into " + _r$17); /* */ $s = 29; case 29: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
				err = _r$18;
				$s = -1; return err;
			/* } */ case 18:
		case 9:
		err = $ifaceNil;
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: copyValue }; } $f._1 = _1; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._arg$3 = _arg$3; $f._arg$4 = _arg$4; $f._arg$5 = _arg$5; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.dst = dst; $f.dst0 = dst0; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.err$4 = err$4; $f.ftmp = ftmp; $f.itmp = itmp; $f.src = src; $f.utmp = utmp; $f.value = value; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.ptr.prototype.unmarshalPath = function(tinfo, sv, parents, start) {
		var _i, _i$1, _r$10, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, _ref$2, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, consumed, consumed2, err, err$1, err$2, finfo, i, j, p, parents, recurse, start, sv, t, t$1, tinfo, tok, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r$10 = $f._r$10; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; consumed = $f.consumed; consumed2 = $f.consumed2; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; finfo = $f.finfo; i = $f.i; j = $f.j; p = $f.p; parents = $f.parents; recurse = $f.recurse; start = $f.start; sv = $f.sv; t = $f.t; t$1 = $f.t$1; tinfo = $f.tinfo; tok = $f.tok; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		consumed = false;
		err = $ifaceNil;
		p = this;
		recurse = false;
		_ref = tinfo.fields;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			finfo = (x$2 = tinfo.fields, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i]));
			/* */ if (((finfo.flags & 1) === 0) || finfo.parents.$length < parents.$length || !(finfo.xmlns === "") && !(finfo.xmlns === start.Name.Space)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (((finfo.flags & 1) === 0) || finfo.parents.$length < parents.$length || !(finfo.xmlns === "") && !(finfo.xmlns === start.Name.Space)) { */ case 3:
				_i++;
				/* continue; */ $s = 1; continue;
			/* } */ case 4:
			_ref$1 = parents;
			_i$1 = 0;
			/* while (true) { */ case 5:
				/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 6; continue; }
				j = _i$1;
				if (!(((j < 0 || j >= parents.$length) ? ($throwRuntimeError("index out of range"), undefined) : parents.$array[parents.$offset + j]) === (x$3 = finfo.parents, ((j < 0 || j >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + j])))) {
					_i++;
					/* continue Loop; */ $s = 1; continue s;
				}
				_i$1++;
			/* } */ $s = 5; continue; case 6:
			/* */ if ((finfo.parents.$length === parents.$length) && finfo.name === start.Name.Local) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if ((finfo.parents.$length === parents.$length) && finfo.name === start.Name.Local) { */ case 7:
				_tmp = true;
				_r$6 = finfo.value($clone(sv, reflect.Value)); /* */ $s = 9; case 9: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_r$7 = p.unmarshal($clone(_r$6, reflect.Value), start); /* */ $s = 10; case 10: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				_tmp$1 = _r$7;
				consumed = _tmp;
				err = _tmp$1;
				$s = -1; return [consumed, err];
			/* } */ case 8:
			if (finfo.parents.$length > parents.$length && (x$4 = finfo.parents, x$5 = parents.$length, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])) === start.Name.Local) {
				recurse = true;
				parents = $subslice(finfo.parents, 0, (parents.$length + 1 >> 0));
				/* break; */ $s = 2; continue;
			}
			_i++;
		/* } */ $s = 1; continue; case 2:
		if (!recurse) {
			_tmp$2 = false;
			_tmp$3 = $ifaceNil;
			consumed = _tmp$2;
			err = _tmp$3;
			$s = -1; return [consumed, err];
		}
		/* while (true) { */ case 11:
			t = [t];
			tok = $ifaceNil;
			_r$8 = p.Token(); /* */ $s = 13; case 13: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			_tuple = _r$8;
			tok = _tuple[0];
			err = _tuple[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp$4 = true;
				_tmp$5 = err;
				consumed = _tmp$4;
				err = _tmp$5;
				$s = -1; return [consumed, err];
			}
			_ref$2 = tok;
			/* */ if ($assertType(_ref$2, StartElement, true)[1]) { $s = 14; continue; }
			/* */ if ($assertType(_ref$2, EndElement, true)[1]) { $s = 15; continue; }
			/* */ $s = 16; continue;
			/* if ($assertType(_ref$2, StartElement, true)[1]) { */ case 14:
				t[0] = $clone(_ref$2.$val, StartElement);
				_r$9 = p.unmarshalPath(tinfo, $clone(sv, reflect.Value), parents, t[0]); /* */ $s = 17; case 17: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				_tuple$1 = _r$9;
				consumed2 = _tuple$1[0];
				err$1 = _tuple$1[1];
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					_tmp$6 = true;
					_tmp$7 = err$1;
					consumed = _tmp$6;
					err = _tmp$7;
					$s = -1; return [consumed, err];
				}
				/* */ if (!consumed2) { $s = 18; continue; }
				/* */ $s = 19; continue;
				/* if (!consumed2) { */ case 18:
					_r$10 = p.Skip(); /* */ $s = 20; case 20: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
					err$2 = _r$10;
					if (!($interfaceIsEqual(err$2, $ifaceNil))) {
						_tmp$8 = true;
						_tmp$9 = err$2;
						consumed = _tmp$8;
						err = _tmp$9;
						$s = -1; return [consumed, err];
					}
				/* } */ case 19:
				$s = 16; continue;
			/* } else if ($assertType(_ref$2, EndElement, true)[1]) { */ case 15:
				t$1 = $clone(_ref$2.$val, EndElement);
				_tmp$10 = true;
				_tmp$11 = $ifaceNil;
				consumed = _tmp$10;
				err = _tmp$11;
				$s = -1; return [consumed, err];
			/* } */ case 16:
		/* } */ $s = 11; continue; case 12:
		$s = -1; return [consumed, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.unmarshalPath }; } $f._i = _i; $f._i$1 = _i$1; $f._r$10 = _r$10; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.consumed = consumed; $f.consumed2 = consumed2; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.finfo = finfo; $f.i = i; $f.j = j; $f.p = p; $f.parents = parents; $f.recurse = recurse; $f.start = start; $f.sv = sv; $f.t = t; $f.t$1 = t$1; $f.tinfo = tinfo; $f.tok = tok; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.unmarshalPath = function(tinfo, sv, parents, start) { return this.$val.unmarshalPath(tinfo, sv, parents, start); };
	Decoder.ptr.prototype.Skip = function() {
		var _r$6, _r$7, _ref, _tuple, d, err, err$1, tok, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _r$7 = $f._r$7; _ref = $f._ref; _tuple = $f._tuple; d = $f.d; err = $f.err; err$1 = $f.err$1; tok = $f.tok; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		/* while (true) { */ case 1:
			_r$6 = d.Token(); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_tuple = _r$6;
			tok = _tuple[0];
			err = _tuple[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			_ref = tok;
			/* */ if ($assertType(_ref, StartElement, true)[1]) { $s = 4; continue; }
			/* */ if ($assertType(_ref, EndElement, true)[1]) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if ($assertType(_ref, StartElement, true)[1]) { */ case 4:
				_r$7 = d.Skip(); /* */ $s = 7; case 7: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				err$1 = _r$7;
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					$s = -1; return err$1;
				}
				$s = 6; continue;
			/* } else if ($assertType(_ref, EndElement, true)[1]) { */ case 5:
				$s = -1; return $ifaceNil;
			/* } */ case 6:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.Skip }; } $f._r$6 = _r$6; $f._r$7 = _r$7; $f._ref = _ref; $f._tuple = _tuple; $f.d = d; $f.err = err; $f.err$1 = err$1; $f.tok = tok; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.Skip = function() { return this.$val.Skip(); };
	getTypeInfo = function(typ) {
		var _i, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$6, _r$7, _r$8, _r$9, _ref, _tuple, _tuple$1, _tuple$2, _tuple$3, err, err$1, err$2, err$3, f, finfo, finfo$1, i, inner, n, ok, t, ti, ti$1, tinfo, typ, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; f = $f.f; finfo = $f.finfo; finfo$1 = $f.finfo$1; i = $f.i; inner = $f.inner; n = $f.n; ok = $f.ok; t = $f.t; ti = $f.ti; ti$1 = $f.ti$1; tinfo = $f.tinfo; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r$6 = tinfoMap.Load(typ); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_tuple = _r$6;
		ti = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			$s = -1; return [$assertType(ti, ptrType$12), $ifaceNil];
		}
		tinfo = new typeInfo.ptr(ptrType$8.nil, sliceType$8.nil);
		_r$7 = typ.Kind(); /* */ $s = 4; case 4: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		/* */ if ((_r$7 === 25) && !($interfaceIsEqual(typ, nameType))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if ((_r$7 === 25) && !($interfaceIsEqual(typ, nameType))) { */ case 2:
			_r$8 = typ.NumField(); /* */ $s = 5; case 5: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			n = _r$8;
			i = 0;
			/* while (true) { */ case 6:
				/* if (!(i < n)) { break; } */ if(!(i < n)) { $s = 7; continue; }
				f = [f];
				finfo = [finfo];
				_r$9 = typ.Field(i); /* */ $s = 8; case 8: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				f[0] = $clone(_r$9, reflect.StructField);
				/* */ if ((!(f[0].PkgPath === "") && !f[0].Anonymous) || new reflect.StructTag(f[0].Tag).Get("xml") === "-") { $s = 9; continue; }
				/* */ $s = 10; continue;
				/* if ((!(f[0].PkgPath === "") && !f[0].Anonymous) || new reflect.StructTag(f[0].Tag).Get("xml") === "-") { */ case 9:
					i = i + (1) >> 0;
					/* continue; */ $s = 6; continue;
				/* } */ case 10:
				/* */ if (f[0].Anonymous) { $s = 11; continue; }
				/* */ $s = 12; continue;
				/* if (f[0].Anonymous) { */ case 11:
					t = f[0].Type;
					_r$10 = t.Kind(); /* */ $s = 15; case 15: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
					/* */ if (_r$10 === 22) { $s = 13; continue; }
					/* */ $s = 14; continue;
					/* if (_r$10 === 22) { */ case 13:
						_r$11 = t.Elem(); /* */ $s = 16; case 16: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
						t = _r$11;
					/* } */ case 14:
					_r$12 = t.Kind(); /* */ $s = 19; case 19: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
					/* */ if (_r$12 === 25) { $s = 17; continue; }
					/* */ $s = 18; continue;
					/* if (_r$12 === 25) { */ case 17:
						_r$13 = getTypeInfo(t); /* */ $s = 20; case 20: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
						_tuple$1 = _r$13;
						inner = _tuple$1[0];
						err = _tuple$1[1];
						if (!($interfaceIsEqual(err, $ifaceNil))) {
							$s = -1; return [ptrType$12.nil, err];
						}
						if (tinfo.xmlname === ptrType$8.nil) {
							tinfo.xmlname = inner.xmlname;
						}
						_ref = inner.fields;
						_i = 0;
						/* while (true) { */ case 21:
							/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 22; continue; }
							finfo[0] = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), fieldInfo);
							finfo[0].idx = $appendSlice(new sliceType$9([i]), finfo[0].idx);
							_r$14 = addFieldInfo(typ, tinfo, finfo[0]); /* */ $s = 23; case 23: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
							err$1 = _r$14;
							if (!($interfaceIsEqual(err$1, $ifaceNil))) {
								$s = -1; return [ptrType$12.nil, err$1];
							}
							_i++;
						/* } */ $s = 21; continue; case 22:
						i = i + (1) >> 0;
						/* continue; */ $s = 6; continue;
					/* } */ case 18:
				/* } */ case 12:
				_r$15 = structFieldInfo(typ, f[0]); /* */ $s = 24; case 24: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
				_tuple$2 = _r$15;
				finfo$1 = _tuple$2[0];
				err$2 = _tuple$2[1];
				if (!($interfaceIsEqual(err$2, $ifaceNil))) {
					$s = -1; return [ptrType$12.nil, err$2];
				}
				/* */ if (f[0].Name === "XMLName") { $s = 25; continue; }
				/* */ $s = 26; continue;
				/* if (f[0].Name === "XMLName") { */ case 25:
					tinfo.xmlname = finfo$1;
					i = i + (1) >> 0;
					/* continue; */ $s = 6; continue;
				/* } */ case 26:
				_r$16 = addFieldInfo(typ, tinfo, finfo$1); /* */ $s = 27; case 27: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
				err$3 = _r$16;
				if (!($interfaceIsEqual(err$3, $ifaceNil))) {
					$s = -1; return [ptrType$12.nil, err$3];
				}
				i = i + (1) >> 0;
			/* } */ $s = 6; continue; case 7:
		/* } */ case 3:
		_r$17 = tinfoMap.LoadOrStore(typ, tinfo); /* */ $s = 28; case 28: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
		_tuple$3 = _r$17;
		ti$1 = _tuple$3[0];
		$s = -1; return [$assertType(ti$1, ptrType$12), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: getTypeInfo }; } $f._i = _i; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.f = f; $f.finfo = finfo; $f.finfo$1 = finfo$1; $f.i = i; $f.inner = inner; $f.n = n; $f.ok = ok; $f.t = t; $f.ti = ti; $f.ti$1 = ti$1; $f.tinfo = tinfo; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;
	};
	structFieldInfo = function(typ, f) {
		var _1, _2, _i, _r$10, _r$11, _r$12, _r$6, _r$7, _r$8, _r$9, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, f, finfo, flag, ftyp, i, mode, parents, tag, tokens, typ, valid, x$2, x$3, xmlname, xmlname$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _i = $f._i; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; f = $f.f; finfo = $f.finfo; flag = $f.flag; ftyp = $f.ftyp; i = $f.i; mode = $f.mode; parents = $f.parents; tag = $f.tag; tokens = $f.tokens; typ = $f.typ; valid = $f.valid; x$2 = $f.x$2; x$3 = $f.x$3; xmlname = $f.xmlname; xmlname$1 = $f.xmlname$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		finfo = new fieldInfo.ptr(f.Index, "", "", 0, sliceType$3.nil);
		tag = new reflect.StructTag(f.Tag).Get("xml");
		i = strings.Index(tag, " ");
		if (i >= 0) {
			_tmp = $substring(tag, 0, i);
			_tmp$1 = $substring(tag, (i + 1 >> 0));
			finfo.xmlns = _tmp;
			tag = _tmp$1;
		}
		tokens = strings.Split(tag, ",");
		/* */ if (tokens.$length === 1) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (tokens.$length === 1) { */ case 1:
			finfo.flags = 1;
			$s = 3; continue;
		/* } else { */ case 2:
			tag = (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]);
			_ref = $subslice(tokens, 1);
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				flag = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				_1 = flag;
				if (_1 === ("attr")) {
					finfo.flags = finfo.flags | (2);
				} else if (_1 === ("cdata")) {
					finfo.flags = finfo.flags | (4);
				} else if (_1 === ("chardata")) {
					finfo.flags = finfo.flags | (8);
				} else if (_1 === ("innerxml")) {
					finfo.flags = finfo.flags | (16);
				} else if (_1 === ("comment")) {
					finfo.flags = finfo.flags | (32);
				} else if (_1 === ("any")) {
					finfo.flags = finfo.flags | (64);
				} else if (_1 === ("omitempty")) {
					finfo.flags = finfo.flags | (128);
				}
				_i++;
			}
			valid = true;
			mode = finfo.flags & 127;
			_2 = mode;
			if (_2 === (0)) {
				finfo.flags = finfo.flags | (1);
			} else if ((_2 === (2)) || (_2 === (4)) || (_2 === (8)) || (_2 === (16)) || (_2 === (32)) || (_2 === (64)) || (_2 === (66))) {
				if (f.Name === "XMLName" || !(tag === "") && !((mode === 2))) {
					valid = false;
				}
			} else {
				valid = false;
			}
			if ((finfo.flags & 127) === 64) {
				finfo.flags = finfo.flags | (1);
			}
			if (!(((finfo.flags & 128) === 0)) && ((finfo.flags & 3) === 0)) {
				valid = false;
			}
			/* */ if (!valid) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (!valid) { */ case 4:
				_r$6 = fmt.Errorf("xml: invalid tag in field %s of type %s: %q", new sliceType$5([new $String(f.Name), typ, new $String(new reflect.StructTag(f.Tag).Get("xml"))])); /* */ $s = 6; case 6: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				$s = -1; return [ptrType$8.nil, _r$6];
			/* } */ case 5:
		/* } */ case 3:
		/* */ if (!(finfo.xmlns === "") && tag === "") { $s = 7; continue; }
		/* */ $s = 8; continue;
		/* if (!(finfo.xmlns === "") && tag === "") { */ case 7:
			_r$7 = fmt.Errorf("xml: namespace without name in field %s of type %s: %q", new sliceType$5([new $String(f.Name), typ, new $String(new reflect.StructTag(f.Tag).Get("xml"))])); /* */ $s = 9; case 9: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			$s = -1; return [ptrType$8.nil, _r$7];
		/* } */ case 8:
		if (f.Name === "XMLName") {
			finfo.name = tag;
			$s = -1; return [finfo, $ifaceNil];
		}
		/* */ if (tag === "") { $s = 10; continue; }
		/* */ $s = 11; continue;
		/* if (tag === "") { */ case 10:
			_r$8 = lookupXMLName(f.Type); /* */ $s = 12; case 12: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			xmlname = _r$8;
			if (!(xmlname === ptrType$8.nil)) {
				_tmp$2 = xmlname.xmlns;
				_tmp$3 = xmlname.name;
				finfo.xmlns = _tmp$2;
				finfo.name = _tmp$3;
			} else {
				finfo.name = f.Name;
			}
			$s = -1; return [finfo, $ifaceNil];
		/* } */ case 11:
		parents = strings.Split(tag, ">");
		if ((0 >= parents.$length ? ($throwRuntimeError("index out of range"), undefined) : parents.$array[parents.$offset + 0]) === "") {
			(0 >= parents.$length ? ($throwRuntimeError("index out of range"), undefined) : parents.$array[parents.$offset + 0] = f.Name);
		}
		/* */ if ((x$2 = parents.$length - 1 >> 0, ((x$2 < 0 || x$2 >= parents.$length) ? ($throwRuntimeError("index out of range"), undefined) : parents.$array[parents.$offset + x$2])) === "") { $s = 13; continue; }
		/* */ $s = 14; continue;
		/* if ((x$2 = parents.$length - 1 >> 0, ((x$2 < 0 || x$2 >= parents.$length) ? ($throwRuntimeError("index out of range"), undefined) : parents.$array[parents.$offset + x$2])) === "") { */ case 13:
			_r$9 = fmt.Errorf("xml: trailing '>' in field %s of type %s", new sliceType$5([new $String(f.Name), typ])); /* */ $s = 15; case 15: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
			$s = -1; return [ptrType$8.nil, _r$9];
		/* } */ case 14:
		finfo.name = (x$3 = parents.$length - 1 >> 0, ((x$3 < 0 || x$3 >= parents.$length) ? ($throwRuntimeError("index out of range"), undefined) : parents.$array[parents.$offset + x$3]));
		/* */ if (parents.$length > 1) { $s = 16; continue; }
		/* */ $s = 17; continue;
		/* if (parents.$length > 1) { */ case 16:
			/* */ if (((finfo.flags & 1)) === 0) { $s = 18; continue; }
			/* */ $s = 19; continue;
			/* if (((finfo.flags & 1)) === 0) { */ case 18:
				_r$10 = fmt.Errorf("xml: %s chain not valid with %s flag", new sliceType$5([new $String(tag), new $String(strings.Join($subslice(tokens, 1), ","))])); /* */ $s = 20; case 20: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
				$s = -1; return [ptrType$8.nil, _r$10];
			/* } */ case 19:
			finfo.parents = $subslice(parents, 0, (parents.$length - 1 >> 0));
		/* } */ case 17:
		/* */ if (!(((finfo.flags & 1) === 0))) { $s = 21; continue; }
		/* */ $s = 22; continue;
		/* if (!(((finfo.flags & 1) === 0))) { */ case 21:
			ftyp = f.Type;
			_r$11 = lookupXMLName(ftyp); /* */ $s = 23; case 23: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
			xmlname$1 = _r$11;
			/* */ if (!(xmlname$1 === ptrType$8.nil) && !(xmlname$1.name === finfo.name)) { $s = 24; continue; }
			/* */ $s = 25; continue;
			/* if (!(xmlname$1 === ptrType$8.nil) && !(xmlname$1.name === finfo.name)) { */ case 24:
				_r$12 = fmt.Errorf("xml: name %q in tag of %s.%s conflicts with name %q in %s.XMLName", new sliceType$5([new $String(finfo.name), typ, new $String(f.Name), new $String(xmlname$1.name), ftyp])); /* */ $s = 26; case 26: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
				$s = -1; return [ptrType$8.nil, _r$12];
			/* } */ case 25:
		/* } */ case 22:
		$s = -1; return [finfo, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: structFieldInfo }; } $f._1 = _1; $f._2 = _2; $f._i = _i; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.f = f; $f.finfo = finfo; $f.flag = flag; $f.ftyp = ftyp; $f.i = i; $f.mode = mode; $f.parents = parents; $f.tag = tag; $f.tokens = tokens; $f.typ = typ; $f.valid = valid; $f.x$2 = x$2; $f.x$3 = x$3; $f.xmlname = xmlname; $f.xmlname$1 = xmlname$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	lookupXMLName = function(typ) {
		var _r$10, _r$11, _r$6, _r$7, _r$8, _r$9, _tmp, _tmp$1, _tuple, err, f, finfo, i, n, typ, xmlname, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; err = $f.err; f = $f.f; finfo = $f.finfo; i = $f.i; n = $f.n; typ = $f.typ; xmlname = $f.xmlname; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		xmlname = ptrType$8.nil;
		/* while (true) { */ case 1:
			_r$6 = typ.Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			/* if (!(_r$6 === 22)) { break; } */ if(!(_r$6 === 22)) { $s = 2; continue; }
			_r$7 = typ.Elem(); /* */ $s = 4; case 4: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			typ = _r$7;
		/* } */ $s = 1; continue; case 2:
		_r$8 = typ.Kind(); /* */ $s = 7; case 7: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		/* */ if (!((_r$8 === 25))) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (!((_r$8 === 25))) { */ case 5:
			xmlname = ptrType$8.nil;
			$s = -1; return xmlname;
		/* } */ case 6:
		_tmp = 0;
		_r$9 = typ.NumField(); /* */ $s = 8; case 8: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
		_tmp$1 = _r$9;
		i = _tmp;
		n = _tmp$1;
		/* while (true) { */ case 9:
			/* if (!(i < n)) { break; } */ if(!(i < n)) { $s = 10; continue; }
			f = [f];
			_r$10 = typ.Field(i); /* */ $s = 11; case 11: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			f[0] = $clone(_r$10, reflect.StructField);
			/* */ if (!(f[0].Name === "XMLName")) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if (!(f[0].Name === "XMLName")) { */ case 12:
				i = i + (1) >> 0;
				/* continue; */ $s = 9; continue;
			/* } */ case 13:
			_r$11 = structFieldInfo(typ, f[0]); /* */ $s = 14; case 14: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
			_tuple = _r$11;
			finfo = _tuple[0];
			err = _tuple[1];
			if (!(finfo.name === "") && $interfaceIsEqual(err, $ifaceNil)) {
				xmlname = finfo;
				$s = -1; return xmlname;
			}
			/* break; */ $s = 10; continue;
		/* } */ $s = 9; continue; case 10:
		xmlname = ptrType$8.nil;
		$s = -1; return xmlname;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lookupXMLName }; } $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.err = err; $f.f = f; $f.finfo = finfo; $f.i = i; $f.n = n; $f.typ = typ; $f.xmlname = xmlname; $f.$s = $s; $f.$r = $r; return $f;
	};
	min = function(a, b) {
		var a, b;
		if (a <= b) {
			return a;
		}
		return b;
	};
	addFieldInfo = function(typ, tinfo, newf) {
		var _i, _i$1, _i$2, _r$6, _r$7, _ref, _ref$1, _ref$2, c, conflicts, f1, f2, i, i$1, i$2, i$3, minl, newf, oldf, oldf$1, p, tinfo, typ, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _r$6 = $f._r$6; _r$7 = $f._r$7; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; c = $f.c; conflicts = $f.conflicts; f1 = $f.f1; f2 = $f.f2; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; minl = $f.minl; newf = $f.newf; oldf = $f.oldf; oldf$1 = $f.oldf$1; p = $f.p; tinfo = $f.tinfo; typ = $f.typ; x$10 = $f.x$10; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		conflicts = sliceType$9.nil;
		_ref = tinfo.fields;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			oldf = (x$2 = tinfo.fields, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i]));
			if (!(((oldf.flags & 127) === (newf.flags & 127)))) {
				_i++;
				/* continue; */ $s = 1; continue;
			}
			if (!(oldf.xmlns === "") && !(newf.xmlns === "") && !(oldf.xmlns === newf.xmlns)) {
				_i++;
				/* continue; */ $s = 1; continue;
			}
			minl = min(newf.parents.$length, oldf.parents.$length);
			p = 0;
			while (true) {
				if (!(p < minl)) { break; }
				if (!((x$3 = oldf.parents, ((p < 0 || p >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + p])) === (x$4 = newf.parents, ((p < 0 || p >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + p])))) {
					_i++;
					/* continue Loop; */ $s = 1; continue s;
				}
				p = p + (1) >> 0;
			}
			if (oldf.parents.$length > newf.parents.$length) {
				if ((x$5 = oldf.parents, x$6 = newf.parents.$length, ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6])) === newf.name) {
					conflicts = $append(conflicts, i);
				}
			} else if (oldf.parents.$length < newf.parents.$length) {
				if ((x$7 = newf.parents, x$8 = oldf.parents.$length, ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8])) === oldf.name) {
					conflicts = $append(conflicts, i);
				}
			} else {
				if (newf.name === oldf.name) {
					conflicts = $append(conflicts, i);
				}
			}
			_i++;
		/* } */ $s = 1; continue; case 2:
		if (conflicts === sliceType$9.nil) {
			tinfo.fields = $append(tinfo.fields, newf);
			$s = -1; return $ifaceNil;
		}
		_ref$1 = conflicts;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			if ((x$9 = tinfo.fields, ((i$1 < 0 || i$1 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + i$1])).idx.$length < newf.idx.$length) {
				$s = -1; return $ifaceNil;
			}
			_i$1++;
		}
		_ref$2 = conflicts;
		_i$2 = 0;
		/* while (true) { */ case 3:
			/* if (!(_i$2 < _ref$2.$length)) { break; } */ if(!(_i$2 < _ref$2.$length)) { $s = 4; continue; }
			i$2 = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
			oldf$1 = (x$10 = tinfo.fields, ((i$2 < 0 || i$2 >= x$10.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + i$2]));
			/* */ if (oldf$1.idx.$length === newf.idx.$length) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (oldf$1.idx.$length === newf.idx.$length) { */ case 5:
				_r$6 = typ.FieldByIndex(oldf$1.idx); /* */ $s = 7; case 7: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				f1 = $clone(_r$6, reflect.StructField);
				_r$7 = typ.FieldByIndex(newf.idx); /* */ $s = 8; case 8: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				f2 = $clone(_r$7, reflect.StructField);
				$s = -1; return new TagPathError.ptr(typ, f1.Name, new reflect.StructTag(f1.Tag).Get("xml"), f2.Name, new reflect.StructTag(f2.Tag).Get("xml"));
			/* } */ case 6:
			_i$2++;
		/* } */ $s = 3; continue; case 4:
		c = conflicts.$length - 1 >> 0;
		while (true) {
			if (!(c >= 0)) { break; }
			i$3 = ((c < 0 || c >= conflicts.$length) ? ($throwRuntimeError("index out of range"), undefined) : conflicts.$array[conflicts.$offset + c]);
			$copySlice($subslice(tinfo.fields, i$3), $subslice(tinfo.fields, (i$3 + 1 >> 0)));
			tinfo.fields = $subslice(tinfo.fields, 0, (tinfo.fields.$length - 1 >> 0));
			c = c - (1) >> 0;
		}
		tinfo.fields = $append(tinfo.fields, newf);
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: addFieldInfo }; } $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f.c = c; $f.conflicts = conflicts; $f.f1 = f1; $f.f2 = f2; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.minl = minl; $f.newf = newf; $f.oldf = oldf; $f.oldf$1 = oldf$1; $f.p = p; $f.tinfo = tinfo; $f.typ = typ; $f.x$10 = x$10; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	TagPathError.ptr.prototype.Error = function() {
		var _r$6, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r$6 = fmt.Sprintf("%s field %q with tag %q conflicts with field %q with tag %q", new sliceType$5([e.Struct, new $String(e.Field1), new $String(e.Tag1), new $String(e.Field2), new $String(e.Tag2)])); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		$s = -1; return _r$6;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TagPathError.ptr.prototype.Error }; } $f._r$6 = _r$6; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	TagPathError.prototype.Error = function() { return this.$val.Error(); };
	fieldInfo.ptr.prototype.value = function(v) {
		var _i, _r$10, _r$11, _r$12, _r$6, _r$7, _r$8, _r$9, _ref, _v, finfo, i, t, v, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _v = $f._v; finfo = $f.finfo; i = $f.i; t = $f.t; v = $f.v; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		finfo = this;
		_ref = finfo.idx;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			x$2 = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			/* */ if (i > 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (i > 0) { */ case 3:
				t = $clone(v, reflect.Value).Type();
				_r$6 = t.Kind(); /* */ $s = 8; case 8: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				if (!(_r$6 === 22)) { _v = false; $s = 7; continue s; }
				_r$7 = t.Elem(); /* */ $s = 9; case 9: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				_r$8 = _r$7.Kind(); /* */ $s = 10; case 10: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				_v = _r$8 === 25; case 7:
				/* */ if (_v) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (_v) { */ case 5:
					/* */ if ($clone(v, reflect.Value).IsNil()) { $s = 11; continue; }
					/* */ $s = 12; continue;
					/* if ($clone(v, reflect.Value).IsNil()) { */ case 11:
						_r$9 = $clone(v, reflect.Value).Type().Elem(); /* */ $s = 13; case 13: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
						_r$10 = reflect.New(_r$9); /* */ $s = 14; case 14: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
						$r = $clone(v, reflect.Value).Set($clone(_r$10, reflect.Value)); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					/* } */ case 12:
					_r$11 = $clone(v, reflect.Value).Elem(); /* */ $s = 16; case 16: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
					v = _r$11;
				/* } */ case 6:
			/* } */ case 4:
			_r$12 = $clone(v, reflect.Value).Field(x$2); /* */ $s = 17; case 17: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
			v = _r$12;
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return v;
		/* */ } return; } if ($f === undefined) { $f = { $blk: fieldInfo.ptr.prototype.value }; } $f._i = _i; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._v = _v; $f.finfo = finfo; $f.i = i; $f.t = t; $f.v = v; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	fieldInfo.prototype.value = function(v) { return this.$val.value(v); };
	SyntaxError.ptr.prototype.Error = function() {
		var e;
		e = this;
		return "XML syntax error on line " + strconv.Itoa(e.Line) + ": " + e.Msg;
	};
	SyntaxError.prototype.Error = function() { return this.$val.Error(); };
	StartElement.ptr.prototype.Copy = function() {
		var attrs, e;
		e = this;
		attrs = $makeSlice(sliceType$6, e.Attr.$length);
		$copySlice(attrs, e.Attr);
		e.Attr = attrs;
		return e;
	};
	StartElement.prototype.Copy = function() { return this.$val.Copy(); };
	StartElement.ptr.prototype.End = function() {
		var e;
		e = this;
		return new EndElement.ptr($clone(e.Name, Name));
	};
	StartElement.prototype.End = function() { return this.$val.End(); };
	makeCopy = function(b) {
		var b, b1;
		b1 = $makeSlice(sliceType, b.$length);
		$copySlice(b1, b);
		return b1;
	};
	CharData.prototype.Copy = function() {
		var c, x$2;
		c = this;
		return ((x$2 = makeCopy($subslice(new sliceType(c.$array), c.$offset, c.$offset + c.$length)), $subslice(new CharData(x$2.$array), x$2.$offset, x$2.$offset + x$2.$length)));
	};
	$ptrType(CharData).prototype.Copy = function() { return this.$get().Copy(); };
	Comment.prototype.Copy = function() {
		var c, x$2;
		c = this;
		return ((x$2 = makeCopy($subslice(new sliceType(c.$array), c.$offset, c.$offset + c.$length)), $subslice(new Comment(x$2.$array), x$2.$offset, x$2.$offset + x$2.$length)));
	};
	$ptrType(Comment).prototype.Copy = function() { return this.$get().Copy(); };
	ProcInst.ptr.prototype.Copy = function() {
		var p;
		p = this;
		p.Inst = makeCopy(p.Inst);
		return p;
	};
	ProcInst.prototype.Copy = function() { return this.$val.Copy(); };
	Directive.prototype.Copy = function() {
		var d, x$2;
		d = this;
		return ((x$2 = makeCopy($subslice(new sliceType(d.$array), d.$offset, d.$offset + d.$length)), $subslice(new Directive(x$2.$array), x$2.$offset, x$2.$offset + x$2.$length)));
	};
	$ptrType(Directive).prototype.Copy = function() { return this.$get().Copy(); };
	Decoder.ptr.prototype.Token = function() {
		var _entry, _entry$1, _i, _i$1, _key, _key$1, _r$6, _r$7, _ref, _ref$1, _ref$2, _tuple, _tuple$1, _tuple$2, _tuple$3, a, d, err, i, ok, ok$1, ok$2, t, t1, t1$1, t1$2, v, v$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _i = $f._i; _i$1 = $f._i$1; _key = $f._key; _key$1 = $f._key$1; _r$6 = $f._r$6; _r$7 = $f._r$7; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; a = $f.a; d = $f.d; err = $f.err; i = $f.i; ok = $f.ok; ok$1 = $f.ok$1; ok$2 = $f.ok$2; t = $f.t; t1 = $f.t1; t1$1 = $f.t1$1; t1$2 = $f.t1$2; v = $f.v; v$1 = $f.v$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t1 = [t1];
		d = this;
		t = $ifaceNil;
		err = $ifaceNil;
		if (!(d.stk === ptrType$14.nil) && (d.stk.kind === 2)) {
			$s = -1; return [$ifaceNil, io.EOF];
		}
		/* */ if (!($interfaceIsEqual(d.nextToken, $ifaceNil))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!($interfaceIsEqual(d.nextToken, $ifaceNil))) { */ case 1:
			t = d.nextToken;
			d.nextToken = $ifaceNil;
			$s = 3; continue;
		/* } else { */ case 2:
			_r$6 = d.rawToken(); /* */ $s = 4; case 4: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_tuple = _r$6;
			t = _tuple[0];
			err = _tuple[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				if ($interfaceIsEqual(err, io.EOF) && !(d.stk === ptrType$14.nil) && !((d.stk.kind === 2))) {
					err = d.syntaxError("unexpected EOF");
				}
				$s = -1; return [t, err];
			}
		/* } */ case 3:
		/* */ if (!d.Strict) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (!d.Strict) { */ case 5:
			_r$7 = d.autoClose(t); /* */ $s = 7; case 7: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_tuple$1 = _r$7;
			t1$1 = _tuple$1[0];
			ok = _tuple$1[1];
			if (ok) {
				d.nextToken = t;
				t = t1$1;
			}
		/* } */ case 6:
		_ref = t;
		if ($assertType(_ref, StartElement, true)[1]) {
			t1$2 = $clone(_ref.$val, StartElement);
			_ref$1 = t1$2.Attr;
			_i = 0;
			while (true) {
				if (!(_i < _ref$1.$length)) { break; }
				a = $clone(((_i < 0 || _i >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i]), Attr);
				if (a.Name.Space === "xmlns") {
					_tuple$2 = (_entry = d.ns[$String.keyFor(a.Name.Local)], _entry !== undefined ? [_entry.v, true] : ["", false]);
					v = _tuple$2[0];
					ok$1 = _tuple$2[1];
					d.pushNs(a.Name.Local, v, ok$1);
					_key = a.Name.Local; (d.ns || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: a.Value };
				}
				if (a.Name.Space === "" && a.Name.Local === "xmlns") {
					_tuple$3 = (_entry$1 = d.ns[$String.keyFor("")], _entry$1 !== undefined ? [_entry$1.v, true] : ["", false]);
					v$1 = _tuple$3[0];
					ok$2 = _tuple$3[1];
					d.pushNs("", v$1, ok$2);
					_key$1 = ""; (d.ns || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key$1)] = { k: _key$1, v: a.Value };
				}
				_i++;
			}
			d.translate(t1$2.Name, true);
			_ref$2 = t1$2.Attr;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$2.$length)) { break; }
				i = _i$1;
				d.translate((x$2 = t1$2.Attr, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i])).Name, false);
				_i$1++;
			}
			d.pushElement($clone(t1$2.Name, Name));
			t = new t1$2.constructor.elem(t1$2);
		} else if ($assertType(_ref, EndElement, true)[1]) {
			t1[0] = $clone(_ref.$val, EndElement);
			d.translate(t1[0].Name, true);
			if (!d.popElement(t1[0])) {
				$s = -1; return [$ifaceNil, d.err];
			}
			t = new t1[0].constructor.elem(t1[0]);
		}
		$s = -1; return [t, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.Token }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._i = _i; $f._i$1 = _i$1; $f._key = _key; $f._key$1 = _key$1; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.a = a; $f.d = d; $f.err = err; $f.i = i; $f.ok = ok; $f.ok$1 = ok$1; $f.ok$2 = ok$2; $f.t = t; $f.t1 = t1; $f.t1$1 = t1$1; $f.t1$2 = t1$2; $f.v = v; $f.v$1 = v$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.Token = function() { return this.$val.Token(); };
	Decoder.ptr.prototype.translate = function(n, isElementName) {
		var _entry, _tuple, d, isElementName, n, ok, v;
		d = this;
		if (n.Space === "xmlns") {
			return;
		} else if (n.Space === "" && !isElementName) {
			return;
		} else if (n.Space === "xml") {
			n.Space = "http://www.w3.org/XML/1998/namespace";
		} else if (n.Space === "" && n.Local === "xmlns") {
			return;
		}
		_tuple = (_entry = d.ns[$String.keyFor(n.Space)], _entry !== undefined ? [_entry.v, true] : ["", false]);
		v = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			n.Space = v;
		} else if (n.Space === "") {
			n.Space = d.DefaultSpace;
		}
	};
	Decoder.prototype.translate = function(n, isElementName) { return this.$val.translate(n, isElementName); };
	Decoder.ptr.prototype.switchToReader = function(r) {
		var _tuple, d, ok, r, rb;
		d = this;
		_tuple = $assertType(r, io.ByteReader, true);
		rb = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			d.r = rb;
		} else {
			d.r = bufio.NewReader(r);
		}
	};
	Decoder.prototype.switchToReader = function(r) { return this.$val.switchToReader(r); };
	Decoder.ptr.prototype.push = function(kind) {
		var d, kind, s;
		d = this;
		s = d.free;
		if (!(s === ptrType$14.nil)) {
			d.free = s.next;
		} else {
			s = new stack.ptr(ptrType$14.nil, 0, new Name.ptr("", ""), false);
		}
		s.next = d.stk;
		s.kind = kind;
		d.stk = s;
		return s;
	};
	Decoder.prototype.push = function(kind) { return this.$val.push(kind); };
	Decoder.ptr.prototype.pop = function() {
		var d, s;
		d = this;
		s = d.stk;
		if (!(s === ptrType$14.nil)) {
			d.stk = s.next;
			s.next = d.free;
			d.free = s;
		}
		return s;
	};
	Decoder.prototype.pop = function() { return this.$val.pop(); };
	Decoder.ptr.prototype.pushEOF = function() {
		var d, s, start;
		d = this;
		start = d.stk;
		while (true) {
			if (!(!((start.kind === 0)))) { break; }
			start = start.next;
		}
		while (true) {
			if (!(!(start.next === ptrType$14.nil) && (start.next.kind === 1))) { break; }
			start = start.next;
		}
		s = d.free;
		if (!(s === ptrType$14.nil)) {
			d.free = s.next;
		} else {
			s = new stack.ptr(ptrType$14.nil, 0, new Name.ptr("", ""), false);
		}
		s.kind = 2;
		s.next = start.next;
		start.next = s;
	};
	Decoder.prototype.pushEOF = function() { return this.$val.pushEOF(); };
	Decoder.ptr.prototype.popEOF = function() {
		var d;
		d = this;
		if (d.stk === ptrType$14.nil || !((d.stk.kind === 2))) {
			return false;
		}
		d.pop();
		return true;
	};
	Decoder.prototype.popEOF = function() { return this.$val.popEOF(); };
	Decoder.ptr.prototype.pushElement = function(name) {
		var d, name, s;
		d = this;
		s = d.push(0);
		Name.copy(s.name, name);
	};
	Decoder.prototype.pushElement = function(name) { return this.$val.pushElement(name); };
	Decoder.ptr.prototype.pushNs = function(local, url, ok) {
		var d, local, ok, s, url;
		d = this;
		s = d.push(1);
		s.name.Local = local;
		s.name.Space = url;
		s.ok = ok;
	};
	Decoder.prototype.pushNs = function(local, url, ok) { return this.$val.pushNs(local, url, ok); };
	Decoder.ptr.prototype.syntaxError = function(msg) {
		var d, msg;
		d = this;
		return new SyntaxError.ptr(msg, d.line);
	};
	Decoder.prototype.syntaxError = function(msg) { return this.$val.syntaxError(msg); };
	Decoder.ptr.prototype.popElement = function(t) {
		var _key, d, name, s, s$1, t;
		d = this;
		s = d.pop();
		name = $clone(t.Name, Name);
		if (s === ptrType$14.nil || !((s.kind === 0))) {
			d.err = d.syntaxError("unexpected end element </" + name.Local + ">");
			return false;
		} else if (!(s.name.Local === name.Local)) {
			if (!d.Strict) {
				d.needClose = true;
				Name.copy(d.toClose, t.Name);
				Name.copy(t.Name, s.name);
				return true;
			}
			d.err = d.syntaxError("element <" + s.name.Local + "> closed by </" + name.Local + ">");
			return false;
		} else if (!(s.name.Space === name.Space)) {
			d.err = d.syntaxError("element <" + s.name.Local + "> in space " + s.name.Space + "closed by </" + name.Local + "> in space " + name.Space);
			return false;
		}
		while (true) {
			if (!(!(d.stk === ptrType$14.nil) && !((d.stk.kind === 0)) && !((d.stk.kind === 2)))) { break; }
			s$1 = d.pop();
			if (s$1.ok) {
				_key = s$1.name.Local; (d.ns || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: s$1.name.Space };
			} else {
				delete d.ns[$String.keyFor(s$1.name.Local)];
			}
		}
		return true;
	};
	Decoder.prototype.popElement = function(t) { return this.$val.popElement(t); };
	Decoder.ptr.prototype.autoClose = function(t) {
		var _i, _r$6, _r$7, _ref, _tuple, d, et, name, ok, s, t, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r$6 = $f._r$6; _r$7 = $f._r$7; _ref = $f._ref; _tuple = $f._tuple; d = $f.d; et = $f.et; name = $f.name; ok = $f.ok; s = $f.s; t = $f.t; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		if (d.stk === ptrType$14.nil || !((d.stk.kind === 0))) {
			$s = -1; return [$ifaceNil, false];
		}
		_r$6 = strings.ToLower(d.stk.name.Local); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		name = _r$6;
		_ref = d.AutoClose;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			s = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r$7 = strings.ToLower(s); /* */ $s = 6; case 6: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			/* */ if (_r$7 === name) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_r$7 === name) { */ case 4:
				_tuple = $assertType(t, EndElement, true);
				et = $clone(_tuple[0], EndElement);
				ok = _tuple[1];
				if (!ok || !(et.Name.Local === name)) {
					$s = -1; return [(x$2 = new EndElement.ptr($clone(d.stk.name, Name)), new x$2.constructor.elem(x$2)), true];
				}
				/* break; */ $s = 3; continue;
			/* } */ case 5:
			_i++;
		/* } */ $s = 2; continue; case 3:
		$s = -1; return [$ifaceNil, false];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.autoClose }; } $f._i = _i; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._ref = _ref; $f._tuple = _tuple; $f.d = d; $f.et = et; $f.name = name; $f.ok = ok; $f.s = s; $f.t = t; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.autoClose = function(t) { return this.$val.autoClose(t); };
	Decoder.ptr.prototype.RawToken = function() {
		var _r$6, d, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; d = $f.d; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		if (d.unmarshalDepth > 0) {
			$s = -1; return [$ifaceNil, errRawToken];
		}
		_r$6 = d.rawToken(); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		$s = -1; return _r$6;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.RawToken }; } $f._r$6 = _r$6; $f.d = d; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.RawToken = function() { return this.$val.RawToken(); };
	Decoder.ptr.prototype.rawToken = function() {
		var _1, _2, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$20, _r$21, _r$22, _r$23, _r$24, _r$25, _r$26, _r$27, _r$28, _r$29, _r$30, _r$6, _r$7, _r$8, _r$9, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, _tuple$10, _tuple$11, _tuple$12, _tuple$13, _tuple$14, _tuple$15, _tuple$16, _tuple$17, _tuple$18, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, a, attr, b, b0, b0$1, b0$2, b1, b1$1, content, d, data, data$1, data$2, data$3, data$4, depth, empty, enc, err, i, i$1, inquote, j, n, nCap, name, name$1, nattr, newr, ok, s, target, ver, x$2, x$3, x$4, x$5, x$6, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$23 = $f._r$23; _r$24 = $f._r$24; _r$25 = $f._r$25; _r$26 = $f._r$26; _r$27 = $f._r$27; _r$28 = $f._r$28; _r$29 = $f._r$29; _r$30 = $f._r$30; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$10 = $f._tuple$10; _tuple$11 = $f._tuple$11; _tuple$12 = $f._tuple$12; _tuple$13 = $f._tuple$13; _tuple$14 = $f._tuple$14; _tuple$15 = $f._tuple$15; _tuple$16 = $f._tuple$16; _tuple$17 = $f._tuple$17; _tuple$18 = $f._tuple$18; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; _tuple$8 = $f._tuple$8; _tuple$9 = $f._tuple$9; a = $f.a; attr = $f.attr; b = $f.b; b0 = $f.b0; b0$1 = $f.b0$1; b0$2 = $f.b0$2; b1 = $f.b1; b1$1 = $f.b1$1; content = $f.content; d = $f.d; data = $f.data; data$1 = $f.data$1; data$2 = $f.data$2; data$3 = $f.data$3; data$4 = $f.data$4; depth = $f.depth; empty = $f.empty; enc = $f.enc; err = $f.err; i = $f.i; i$1 = $f.i$1; inquote = $f.inquote; j = $f.j; n = $f.n; nCap = $f.nCap; name = $f.name; name$1 = $f.name$1; nattr = $f.nattr; newr = $f.newr; ok = $f.ok; s = $f.s; target = $f.target; ver = $f.ver; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		if (!($interfaceIsEqual(d.err, $ifaceNil))) {
			$s = -1; return [$ifaceNil, d.err];
		}
		if (d.needClose) {
			d.needClose = false;
			$s = -1; return [(x$2 = new EndElement.ptr($clone(d.toClose, Name)), new x$2.constructor.elem(x$2)), $ifaceNil];
		}
		_r$6 = d.getc(); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_tuple = _r$6;
		b = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			$s = -1; return [$ifaceNil, d.err];
		}
		/* */ if (!((b === 60))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((b === 60))) { */ case 2:
			d.ungetc(b);
			_r$7 = d.text(-1, false); /* */ $s = 4; case 4: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			data = _r$7;
			if (data === sliceType.nil) {
				$s = -1; return [$ifaceNil, d.err];
			}
			$s = -1; return [($subslice(new CharData(data.$array), data.$offset, data.$offset + data.$length)), $ifaceNil];
		/* } */ case 3:
		_r$8 = d.mustgetc(); /* */ $s = 5; case 5: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		_tuple$1 = _r$8;
		b = _tuple$1[0];
		ok = _tuple$1[1];
		if (!ok) {
			$s = -1; return [$ifaceNil, d.err];
		}
			_1 = b;
			/* */ if (_1 === (47)) { $s = 7; continue; }
			/* */ if (_1 === (63)) { $s = 8; continue; }
			/* */ if (_1 === (33)) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_1 === (47)) { */ case 7:
				name = new Name.ptr("", "");
				_r$9 = d.nsname(); /* */ $s = 11; case 11: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				_tuple$2 = _r$9;
				Name.copy(name, _tuple$2[0]);
				ok = _tuple$2[1];
				if (!ok) {
					if ($interfaceIsEqual(d.err, $ifaceNil)) {
						d.err = d.syntaxError("expected element name after </");
					}
					$s = -1; return [$ifaceNil, d.err];
				}
				$r = d.space(); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				_r$10 = d.mustgetc(); /* */ $s = 13; case 13: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
				_tuple$3 = _r$10;
				b = _tuple$3[0];
				ok = _tuple$3[1];
				if (!ok) {
					$s = -1; return [$ifaceNil, d.err];
				}
				if (!((b === 62))) {
					d.err = d.syntaxError("invalid characters between </" + name.Local + " and >");
					$s = -1; return [$ifaceNil, d.err];
				}
				$s = -1; return [(x$3 = new EndElement.ptr($clone(name, Name)), new x$3.constructor.elem(x$3)), $ifaceNil];
			/* } else if (_1 === (63)) { */ case 8:
				target = "";
				_r$11 = d.name(); /* */ $s = 14; case 14: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
				_tuple$4 = _r$11;
				target = _tuple$4[0];
				ok = _tuple$4[1];
				if (!ok) {
					if ($interfaceIsEqual(d.err, $ifaceNil)) {
						d.err = d.syntaxError("expected target name after <?");
					}
					$s = -1; return [$ifaceNil, d.err];
				}
				$r = d.space(); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				d.buf.Reset();
				b0 = 0;
				/* while (true) { */ case 16:
					_r$12 = d.mustgetc(); /* */ $s = 18; case 18: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
					_tuple$5 = _r$12;
					b = _tuple$5[0];
					ok = _tuple$5[1];
					if (!ok) {
						$s = -1; return [$ifaceNil, d.err];
					}
					d.buf.WriteByte(b);
					if ((b0 === 63) && (b === 62)) {
						/* break; */ $s = 17; continue;
					}
					b0 = b;
				/* } */ $s = 16; continue; case 17:
				data$1 = d.buf.Bytes();
				data$1 = $subslice(data$1, 0, (data$1.$length - 2 >> 0));
				/* */ if (target === "xml") { $s = 19; continue; }
				/* */ $s = 20; continue;
				/* if (target === "xml") { */ case 19:
					content = ($bytesToString(data$1));
					ver = procInst("version", content);
					/* */ if (!(ver === "") && !(ver === "1.0")) { $s = 21; continue; }
					/* */ $s = 22; continue;
					/* if (!(ver === "") && !(ver === "1.0")) { */ case 21:
						_r$13 = fmt.Errorf("xml: unsupported version %q; only version 1.0 is supported", new sliceType$5([new $String(ver)])); /* */ $s = 23; case 23: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
						d.err = _r$13;
						$s = -1; return [$ifaceNil, d.err];
					/* } */ case 22:
					enc = procInst("encoding", content);
					/* */ if (!(enc === "") && !(enc === "utf-8") && !(enc === "UTF-8") && !strings.EqualFold(enc, "utf-8")) { $s = 24; continue; }
					/* */ $s = 25; continue;
					/* if (!(enc === "") && !(enc === "utf-8") && !(enc === "UTF-8") && !strings.EqualFold(enc, "utf-8")) { */ case 24:
						/* */ if (d.CharsetReader === $throwNilPointerError) { $s = 26; continue; }
						/* */ $s = 27; continue;
						/* if (d.CharsetReader === $throwNilPointerError) { */ case 26:
							_r$14 = fmt.Errorf("xml: encoding %q declared but Decoder.CharsetReader is nil", new sliceType$5([new $String(enc)])); /* */ $s = 28; case 28: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
							d.err = _r$14;
							$s = -1; return [$ifaceNil, d.err];
						/* } */ case 27:
						_r$15 = d.CharsetReader(enc, $assertType(d.r, io.Reader)); /* */ $s = 29; case 29: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
						_tuple$6 = _r$15;
						newr = _tuple$6[0];
						err = _tuple$6[1];
						/* */ if (!($interfaceIsEqual(err, $ifaceNil))) { $s = 30; continue; }
						/* */ $s = 31; continue;
						/* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 30:
							_r$16 = fmt.Errorf("xml: opening charset %q: %v", new sliceType$5([new $String(enc), err])); /* */ $s = 32; case 32: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
							d.err = _r$16;
							$s = -1; return [$ifaceNil, d.err];
						/* } */ case 31:
						if ($interfaceIsEqual(newr, $ifaceNil)) {
							$panic(new $String("CharsetReader returned a nil Reader for charset " + enc));
						}
						d.switchToReader(newr);
					/* } */ case 25:
				/* } */ case 20:
				$s = -1; return [(x$4 = new ProcInst.ptr(target, data$1), new x$4.constructor.elem(x$4)), $ifaceNil];
			/* } else if (_1 === (33)) { */ case 9:
				_r$17 = d.mustgetc(); /* */ $s = 33; case 33: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
				_tuple$7 = _r$17;
				b = _tuple$7[0];
				ok = _tuple$7[1];
				if (!ok) {
					$s = -1; return [$ifaceNil, d.err];
				}
					_2 = b;
					/* */ if (_2 === (45)) { $s = 35; continue; }
					/* */ if (_2 === (91)) { $s = 36; continue; }
					/* */ $s = 37; continue;
					/* if (_2 === (45)) { */ case 35:
						_r$18 = d.mustgetc(); /* */ $s = 38; case 38: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
						_tuple$8 = _r$18;
						b = _tuple$8[0];
						ok = _tuple$8[1];
						if (!ok) {
							$s = -1; return [$ifaceNil, d.err];
						}
						if (!((b === 45))) {
							d.err = d.syntaxError("invalid sequence <!- not part of <!--");
							$s = -1; return [$ifaceNil, d.err];
						}
						d.buf.Reset();
						_tmp = 0;
						_tmp$1 = 0;
						b0$1 = _tmp;
						b1 = _tmp$1;
						/* while (true) { */ case 39:
							_r$19 = d.mustgetc(); /* */ $s = 41; case 41: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
							_tuple$9 = _r$19;
							b = _tuple$9[0];
							ok = _tuple$9[1];
							if (!ok) {
								$s = -1; return [$ifaceNil, d.err];
							}
							d.buf.WriteByte(b);
							if ((b0$1 === 45) && (b1 === 45)) {
								if (!((b === 62))) {
									d.err = d.syntaxError("invalid sequence \"--\" not allowed in comments");
									$s = -1; return [$ifaceNil, d.err];
								}
								/* break; */ $s = 40; continue;
							}
							_tmp$2 = b1;
							_tmp$3 = b;
							b0$1 = _tmp$2;
							b1 = _tmp$3;
						/* } */ $s = 39; continue; case 40:
						data$2 = d.buf.Bytes();
						data$2 = $subslice(data$2, 0, (data$2.$length - 3 >> 0));
						$s = -1; return [($subslice(new Comment(data$2.$array), data$2.$offset, data$2.$offset + data$2.$length)), $ifaceNil];
					/* } else if (_2 === (91)) { */ case 36:
						i = 0;
						/* while (true) { */ case 42:
							/* if (!(i < 6)) { break; } */ if(!(i < 6)) { $s = 43; continue; }
							_r$20 = d.mustgetc(); /* */ $s = 44; case 44: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
							_tuple$10 = _r$20;
							b = _tuple$10[0];
							ok = _tuple$10[1];
							if (!ok) {
								$s = -1; return [$ifaceNil, d.err];
							}
							if (!((b === "CDATA[".charCodeAt(i)))) {
								d.err = d.syntaxError("invalid <![ sequence");
								$s = -1; return [$ifaceNil, d.err];
							}
							i = i + (1) >> 0;
						/* } */ $s = 42; continue; case 43:
						_r$21 = d.text(-1, true); /* */ $s = 45; case 45: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
						data$3 = _r$21;
						if (data$3 === sliceType.nil) {
							$s = -1; return [$ifaceNil, d.err];
						}
						$s = -1; return [($subslice(new CharData(data$3.$array), data$3.$offset, data$3.$offset + data$3.$length)), $ifaceNil];
					/* } */ case 37:
				case 34:
				d.buf.Reset();
				d.buf.WriteByte(b);
				inquote = 0;
				depth = 0;
				/* while (true) { */ case 46:
					_r$22 = d.mustgetc(); /* */ $s = 48; case 48: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }
					_tuple$11 = _r$22;
					b = _tuple$11[0];
					ok = _tuple$11[1];
					if (!ok) {
						$s = -1; return [$ifaceNil, d.err];
					}
					if ((inquote === 0) && (b === 62) && (depth === 0)) {
						/* break; */ $s = 47; continue;
					}
					/* HandleB: */ case 49:
					d.buf.WriteByte(b);
						/* */ if ((b === inquote)) { $s = 51; continue; }
						/* */ if (!((inquote === 0))) { $s = 52; continue; }
						/* */ if ((b === 39) || (b === 34)) { $s = 53; continue; }
						/* */ if ((b === 62) && (inquote === 0)) { $s = 54; continue; }
						/* */ if ((b === 60) && (inquote === 0)) { $s = 55; continue; }
						/* */ $s = 56; continue;
						/* if ((b === inquote)) { */ case 51:
							inquote = 0;
							$s = 56; continue;
						/* } else if (!((inquote === 0))) { */ case 52:
							$s = 56; continue;
						/* } else if ((b === 39) || (b === 34)) { */ case 53:
							inquote = b;
							$s = 56; continue;
						/* } else if ((b === 62) && (inquote === 0)) { */ case 54:
							depth = depth - (1) >> 0;
							$s = 56; continue;
						/* } else if ((b === 60) && (inquote === 0)) { */ case 55:
							s = "!--";
							i$1 = 0;
							/* while (true) { */ case 57:
								/* if (!(i$1 < s.length)) { break; } */ if(!(i$1 < s.length)) { $s = 58; continue; }
								_r$23 = d.mustgetc(); /* */ $s = 59; case 59: if($c) { $c = false; _r$23 = _r$23.$blk(); } if (_r$23 && _r$23.$blk !== undefined) { break s; }
								_tuple$12 = _r$23;
								b = _tuple$12[0];
								ok = _tuple$12[1];
								if (!ok) {
									$s = -1; return [$ifaceNil, d.err];
								}
								/* */ if (!((b === s.charCodeAt(i$1)))) { $s = 60; continue; }
								/* */ $s = 61; continue;
								/* if (!((b === s.charCodeAt(i$1)))) { */ case 60:
									j = 0;
									while (true) {
										if (!(j < i$1)) { break; }
										d.buf.WriteByte(s.charCodeAt(j));
										j = j + (1) >> 0;
									}
									depth = depth + (1) >> 0;
									/* goto HandleB */ $s = 49; continue;
								/* } */ case 61:
								i$1 = i$1 + (1) >> 0;
							/* } */ $s = 57; continue; case 58:
							d.buf.Truncate(d.buf.Len() - 1 >> 0);
							_tmp$4 = 0;
							_tmp$5 = 0;
							b0$2 = _tmp$4;
							b1$1 = _tmp$5;
							/* while (true) { */ case 62:
								_r$24 = d.mustgetc(); /* */ $s = 64; case 64: if($c) { $c = false; _r$24 = _r$24.$blk(); } if (_r$24 && _r$24.$blk !== undefined) { break s; }
								_tuple$13 = _r$24;
								b = _tuple$13[0];
								ok = _tuple$13[1];
								if (!ok) {
									$s = -1; return [$ifaceNil, d.err];
								}
								if ((b0$2 === 45) && (b1$1 === 45) && (b === 62)) {
									/* break; */ $s = 63; continue;
								}
								_tmp$6 = b1$1;
								_tmp$7 = b;
								b0$2 = _tmp$6;
								b1$1 = _tmp$7;
							/* } */ $s = 62; continue; case 63:
						/* } */ case 56:
					case 50:
				/* } */ $s = 46; continue; case 47:
				$s = -1; return [((x$5 = d.buf.Bytes(), $subslice(new Directive(x$5.$array), x$5.$offset, x$5.$offset + x$5.$length))), $ifaceNil];
			/* } */ case 10:
		case 6:
		d.ungetc(b);
		name$1 = new Name.ptr("", "");
		empty = false;
		attr = sliceType$6.nil;
		_r$25 = d.nsname(); /* */ $s = 65; case 65: if($c) { $c = false; _r$25 = _r$25.$blk(); } if (_r$25 && _r$25.$blk !== undefined) { break s; }
		_tuple$14 = _r$25;
		Name.copy(name$1, _tuple$14[0]);
		ok = _tuple$14[1];
		if (!ok) {
			if ($interfaceIsEqual(d.err, $ifaceNil)) {
				d.err = d.syntaxError("expected element name after <");
			}
			$s = -1; return [$ifaceNil, d.err];
		}
		attr = new sliceType$6([]);
		/* while (true) { */ case 66:
			$r = d.space(); /* */ $s = 68; case 68: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$26 = d.mustgetc(); /* */ $s = 69; case 69: if($c) { $c = false; _r$26 = _r$26.$blk(); } if (_r$26 && _r$26.$blk !== undefined) { break s; }
			_tuple$15 = _r$26;
			b = _tuple$15[0];
			ok = _tuple$15[1];
			if (!ok) {
				$s = -1; return [$ifaceNil, d.err];
			}
			/* */ if (b === 47) { $s = 70; continue; }
			/* */ $s = 71; continue;
			/* if (b === 47) { */ case 70:
				empty = true;
				_r$27 = d.mustgetc(); /* */ $s = 72; case 72: if($c) { $c = false; _r$27 = _r$27.$blk(); } if (_r$27 && _r$27.$blk !== undefined) { break s; }
				_tuple$16 = _r$27;
				b = _tuple$16[0];
				ok = _tuple$16[1];
				if (!ok) {
					$s = -1; return [$ifaceNil, d.err];
				}
				if (!((b === 62))) {
					d.err = d.syntaxError("expected /> in element");
					$s = -1; return [$ifaceNil, d.err];
				}
				/* break; */ $s = 67; continue;
			/* } */ case 71:
			if (b === 62) {
				/* break; */ $s = 67; continue;
			}
			d.ungetc(b);
			n = attr.$length;
			if (n >= attr.$capacity) {
				nCap = $imul(2, attr.$capacity);
				if (nCap === 0) {
					nCap = 4;
				}
				nattr = $makeSlice(sliceType$6, n, nCap);
				$copySlice(nattr, attr);
				attr = nattr;
			}
			attr = $subslice(attr, 0, (n + 1 >> 0));
			a = ((n < 0 || n >= attr.$length) ? ($throwRuntimeError("index out of range"), undefined) : attr.$array[attr.$offset + n]);
			_r$28 = d.nsname(); /* */ $s = 73; case 73: if($c) { $c = false; _r$28 = _r$28.$blk(); } if (_r$28 && _r$28.$blk !== undefined) { break s; }
			_tuple$17 = _r$28;
			Name.copy(a.Name, _tuple$17[0]);
			ok = _tuple$17[1];
			if (!ok) {
				if ($interfaceIsEqual(d.err, $ifaceNil)) {
					d.err = d.syntaxError("expected attribute name in element");
				}
				$s = -1; return [$ifaceNil, d.err];
			}
			$r = d.space(); /* */ $s = 74; case 74: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$29 = d.mustgetc(); /* */ $s = 75; case 75: if($c) { $c = false; _r$29 = _r$29.$blk(); } if (_r$29 && _r$29.$blk !== undefined) { break s; }
			_tuple$18 = _r$29;
			b = _tuple$18[0];
			ok = _tuple$18[1];
			if (!ok) {
				$s = -1; return [$ifaceNil, d.err];
			}
			/* */ if (!((b === 61))) { $s = 76; continue; }
			/* */ $s = 77; continue;
			/* if (!((b === 61))) { */ case 76:
				if (d.Strict) {
					d.err = d.syntaxError("attribute name without = in element");
					$s = -1; return [$ifaceNil, d.err];
				} else {
					d.ungetc(b);
					a.Value = a.Name.Local;
				}
				$s = 78; continue;
			/* } else { */ case 77:
				$r = d.space(); /* */ $s = 79; case 79: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				_r$30 = d.attrval(); /* */ $s = 80; case 80: if($c) { $c = false; _r$30 = _r$30.$blk(); } if (_r$30 && _r$30.$blk !== undefined) { break s; }
				data$4 = _r$30;
				if (data$4 === sliceType.nil) {
					$s = -1; return [$ifaceNil, d.err];
				}
				a.Value = ($bytesToString(data$4));
			/* } */ case 78:
		/* } */ $s = 66; continue; case 67:
		if (empty) {
			d.needClose = true;
			Name.copy(d.toClose, name$1);
		}
		$s = -1; return [(x$6 = new StartElement.ptr($clone(name$1, Name), attr), new x$6.constructor.elem(x$6)), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.rawToken }; } $f._1 = _1; $f._2 = _2; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$23 = _r$23; $f._r$24 = _r$24; $f._r$25 = _r$25; $f._r$26 = _r$26; $f._r$27 = _r$27; $f._r$28 = _r$28; $f._r$29 = _r$29; $f._r$30 = _r$30; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$10 = _tuple$10; $f._tuple$11 = _tuple$11; $f._tuple$12 = _tuple$12; $f._tuple$13 = _tuple$13; $f._tuple$14 = _tuple$14; $f._tuple$15 = _tuple$15; $f._tuple$16 = _tuple$16; $f._tuple$17 = _tuple$17; $f._tuple$18 = _tuple$18; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f._tuple$8 = _tuple$8; $f._tuple$9 = _tuple$9; $f.a = a; $f.attr = attr; $f.b = b; $f.b0 = b0; $f.b0$1 = b0$1; $f.b0$2 = b0$2; $f.b1 = b1; $f.b1$1 = b1$1; $f.content = content; $f.d = d; $f.data = data; $f.data$1 = data$1; $f.data$2 = data$2; $f.data$3 = data$3; $f.data$4 = data$4; $f.depth = depth; $f.empty = empty; $f.enc = enc; $f.err = err; $f.i = i; $f.i$1 = i$1; $f.inquote = inquote; $f.j = j; $f.n = n; $f.nCap = nCap; $f.name = name; $f.name$1 = name$1; $f.nattr = nattr; $f.newr = newr; $f.ok = ok; $f.s = s; $f.target = target; $f.ver = ver; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.rawToken = function() { return this.$val.rawToken(); };
	Decoder.ptr.prototype.attrval = function() {
		var _r$6, _r$7, _r$8, _tuple, _tuple$1, b, d, ok, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; b = $f.b; d = $f.d; ok = $f.ok; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		_r$6 = d.mustgetc(); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_tuple = _r$6;
		b = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			$s = -1; return sliceType.nil;
		}
		/* */ if ((b === 34) || (b === 39)) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if ((b === 34) || (b === 39)) { */ case 2:
			_r$7 = d.text(((b >> 0)), false); /* */ $s = 4; case 4: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			$s = -1; return _r$7;
		/* } */ case 3:
		if (d.Strict) {
			d.err = d.syntaxError("unquoted or missing attribute value in element");
			$s = -1; return sliceType.nil;
		}
		d.ungetc(b);
		d.buf.Reset();
		/* while (true) { */ case 5:
			_r$8 = d.mustgetc(); /* */ $s = 7; case 7: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			_tuple$1 = _r$8;
			b = _tuple$1[0];
			ok = _tuple$1[1];
			if (!ok) {
				$s = -1; return sliceType.nil;
			}
			if (97 <= b && b <= 122 || 65 <= b && b <= 90 || 48 <= b && b <= 57 || (b === 95) || (b === 58) || (b === 45)) {
				d.buf.WriteByte(b);
			} else {
				d.ungetc(b);
				/* break; */ $s = 6; continue;
			}
		/* } */ $s = 5; continue; case 6:
		$s = -1; return d.buf.Bytes();
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.attrval }; } $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.b = b; $f.d = d; $f.ok = ok; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.attrval = function() { return this.$val.attrval(); };
	Decoder.ptr.prototype.space = function() {
		var _1, _r$6, _tuple, b, d, ok, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r$6 = $f._r$6; _tuple = $f._tuple; b = $f.b; d = $f.d; ok = $f.ok; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		/* while (true) { */ case 1:
			_r$6 = d.getc(); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_tuple = _r$6;
			b = _tuple[0];
			ok = _tuple[1];
			if (!ok) {
				$s = -1; return;
			}
			_1 = b;
			if ((_1 === (32)) || (_1 === (13)) || (_1 === (10)) || (_1 === (9))) {
			} else {
				d.ungetc(b);
				$s = -1; return;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.space }; } $f._1 = _1; $f._r$6 = _r$6; $f._tuple = _tuple; $f.b = b; $f.d = d; $f.ok = ok; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.space = function() { return this.$val.space(); };
	Decoder.ptr.prototype.getc = function() {
		var _r$6, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, b, d, ok, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; b = $f.b; d = $f.d; ok = $f.ok; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = 0;
		ok = false;
		d = this;
		if (!($interfaceIsEqual(d.err, $ifaceNil))) {
			_tmp = 0;
			_tmp$1 = false;
			b = _tmp;
			ok = _tmp$1;
			$s = -1; return [b, ok];
		}
		/* */ if (d.nextByte >= 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (d.nextByte >= 0) { */ case 1:
			b = ((d.nextByte << 24 >>> 24));
			d.nextByte = -1;
			$s = 3; continue;
		/* } else { */ case 2:
			_r$6 = d.r.ReadByte(); /* */ $s = 4; case 4: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_tuple = _r$6;
			b = _tuple[0];
			d.err = _tuple[1];
			if (!($interfaceIsEqual(d.err, $ifaceNil))) {
				_tmp$2 = 0;
				_tmp$3 = false;
				b = _tmp$2;
				ok = _tmp$3;
				$s = -1; return [b, ok];
			}
			if (!(d.saved === ptrType$13.nil)) {
				d.saved.WriteByte(b);
			}
		/* } */ case 3:
		if (b === 10) {
			d.line = d.line + (1) >> 0;
		}
		d.offset = (x$2 = d.offset, x$3 = new $Int64(0, 1), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		_tmp$4 = b;
		_tmp$5 = true;
		b = _tmp$4;
		ok = _tmp$5;
		$s = -1; return [b, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.getc }; } $f._r$6 = _r$6; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.b = b; $f.d = d; $f.ok = ok; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.getc = function() { return this.$val.getc(); };
	Decoder.ptr.prototype.InputOffset = function() {
		var d;
		d = this;
		return d.offset;
	};
	Decoder.prototype.InputOffset = function() { return this.$val.InputOffset(); };
	Decoder.ptr.prototype.savedOffset = function() {
		var d, n;
		d = this;
		n = d.saved.Len();
		if (d.nextByte >= 0) {
			n = n - (1) >> 0;
		}
		return n;
	};
	Decoder.prototype.savedOffset = function() { return this.$val.savedOffset(); };
	Decoder.ptr.prototype.mustgetc = function() {
		var _r$6, _tuple, b, d, ok, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _tuple = $f._tuple; b = $f.b; d = $f.d; ok = $f.ok; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = 0;
		ok = false;
		d = this;
		_r$6 = d.getc(); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_tuple = _r$6;
		b = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			if ($interfaceIsEqual(d.err, io.EOF)) {
				d.err = d.syntaxError("unexpected EOF");
			}
		}
		$s = -1; return [b, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.mustgetc }; } $f._r$6 = _r$6; $f._tuple = _tuple; $f.b = b; $f.d = d; $f.ok = ok; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.mustgetc = function() { return this.$val.mustgetc(); };
	Decoder.ptr.prototype.ungetc = function(b) {
		var b, d, x$2, x$3;
		d = this;
		if (b === 10) {
			d.line = d.line - (1) >> 0;
		}
		d.nextByte = ((b >> 0));
		d.offset = (x$2 = d.offset, x$3 = new $Int64(0, 1), new $Int64(x$2.$high - x$3.$high, x$2.$low - x$3.$low));
	};
	Decoder.prototype.ungetc = function(b) { return this.$val.ungetc(b); };
	Decoder.ptr.prototype.text = function(quote, cdata) {
		var _entry, _entry$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$6, _r$7, _r$8, _r$9, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, b, b0, b1, base, before, buf, cdata, d, data, ent, err, haveText, n, name, ok, ok$1, ok$2, quote, r, r$1, s, s$1, size, start, text, trunc, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; _tuple$8 = $f._tuple$8; _tuple$9 = $f._tuple$9; b = $f.b; b0 = $f.b0; b1 = $f.b1; base = $f.base; before = $f.before; buf = $f.buf; cdata = $f.cdata; d = $f.d; data = $f.data; ent = $f.ent; err = $f.err; haveText = $f.haveText; n = $f.n; name = $f.name; ok = $f.ok; ok$1 = $f.ok$1; ok$2 = $f.ok$2; quote = $f.quote; r = $f.r; r$1 = $f.r$1; s = $f.s; s$1 = $f.s$1; size = $f.size; start = $f.start; text = $f.text; trunc = $f.trunc; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		_tmp = 0;
		_tmp$1 = 0;
		b0 = _tmp;
		b1 = _tmp$1;
		trunc = 0;
		d.buf.Reset();
		/* while (true) { */ case 1:
			_r$6 = d.getc(); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_tuple = _r$6;
			b = _tuple[0];
			ok = _tuple[1];
			if (!ok) {
				if (cdata) {
					if ($interfaceIsEqual(d.err, io.EOF)) {
						d.err = d.syntaxError("unexpected EOF in CDATA section");
					}
					$s = -1; return sliceType.nil;
				}
				/* break Input; */ $s = 2; continue s;
			}
			if ((b0 === 93) && (b1 === 93) && (b === 62)) {
				if (cdata) {
					trunc = 2;
					/* break Input; */ $s = 2; continue s;
				}
				d.err = d.syntaxError("unescaped ]]> not in CDATA section");
				$s = -1; return sliceType.nil;
			}
			if ((b === 60) && !cdata) {
				if (quote >= 0) {
					d.err = d.syntaxError("unescaped < inside quoted string");
					$s = -1; return sliceType.nil;
				}
				d.ungetc(60);
				/* break Input; */ $s = 2; continue s;
			}
			if (quote >= 0 && (b === ((quote << 24 >>> 24)))) {
				/* break Input; */ $s = 2; continue s;
			}
			/* */ if ((b === 38) && !cdata) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if ((b === 38) && !cdata) { */ case 4:
				before = d.buf.Len();
				d.buf.WriteByte(38);
				ok$1 = false;
				text = "";
				haveText = false;
				_r$7 = d.mustgetc(); /* */ $s = 6; case 6: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				_tuple$1 = _r$7;
				b = _tuple$1[0];
				ok$1 = _tuple$1[1];
				if (!ok$1) {
					$s = -1; return sliceType.nil;
				}
				/* */ if (b === 35) { $s = 7; continue; }
				/* */ $s = 8; continue;
				/* if (b === 35) { */ case 7:
					d.buf.WriteByte(b);
					_r$8 = d.mustgetc(); /* */ $s = 10; case 10: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
					_tuple$2 = _r$8;
					b = _tuple$2[0];
					ok$1 = _tuple$2[1];
					if (!ok$1) {
						$s = -1; return sliceType.nil;
					}
					base = 10;
					/* */ if (b === 120) { $s = 11; continue; }
					/* */ $s = 12; continue;
					/* if (b === 120) { */ case 11:
						base = 16;
						d.buf.WriteByte(b);
						_r$9 = d.mustgetc(); /* */ $s = 13; case 13: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
						_tuple$3 = _r$9;
						b = _tuple$3[0];
						ok$1 = _tuple$3[1];
						if (!ok$1) {
							$s = -1; return sliceType.nil;
						}
					/* } */ case 12:
					start = d.buf.Len();
					/* while (true) { */ case 14:
						/* if (!(48 <= b && b <= 57 || (base === 16) && 97 <= b && b <= 102 || (base === 16) && 65 <= b && b <= 70)) { break; } */ if(!(48 <= b && b <= 57 || (base === 16) && 97 <= b && b <= 102 || (base === 16) && 65 <= b && b <= 70)) { $s = 15; continue; }
						d.buf.WriteByte(b);
						_r$10 = d.mustgetc(); /* */ $s = 16; case 16: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
						_tuple$4 = _r$10;
						b = _tuple$4[0];
						ok$1 = _tuple$4[1];
						if (!ok$1) {
							$s = -1; return sliceType.nil;
						}
					/* } */ $s = 14; continue; case 15:
					if (!((b === 59))) {
						d.ungetc(b);
					} else {
						s = ($bytesToString($subslice(d.buf.Bytes(), start)));
						d.buf.WriteByte(59);
						_tuple$5 = strconv.ParseUint(s, base, 64);
						n = _tuple$5[0];
						err = _tuple$5[1];
						if ($interfaceIsEqual(err, $ifaceNil) && (n.$high < 0 || (n.$high === 0 && n.$low <= 1114111))) {
							text = ($encodeRune(n.$low));
							haveText = true;
						}
					}
					$s = 9; continue;
				/* } else { */ case 8:
					d.ungetc(b);
					_r$11 = d.readName(); /* */ $s = 19; case 19: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
					/* */ if (!_r$11) { $s = 17; continue; }
					/* */ $s = 18; continue;
					/* if (!_r$11) { */ case 17:
						if (!($interfaceIsEqual(d.err, $ifaceNil))) {
							$s = -1; return sliceType.nil;
						}
						ok$1 = false;
					/* } */ case 18:
					_r$12 = d.mustgetc(); /* */ $s = 20; case 20: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
					_tuple$6 = _r$12;
					b = _tuple$6[0];
					ok$1 = _tuple$6[1];
					if (!ok$1) {
						$s = -1; return sliceType.nil;
					}
					if (!((b === 59))) {
						d.ungetc(b);
					} else {
						name = $subslice(d.buf.Bytes(), (before + 1 >> 0));
						d.buf.WriteByte(59);
						if (isName(name)) {
							s$1 = ($bytesToString(name));
							_tuple$7 = (_entry = entity[$String.keyFor(s$1)], _entry !== undefined ? [_entry.v, true] : [0, false]);
							r = _tuple$7[0];
							ok$2 = _tuple$7[1];
							if (ok$2) {
								text = ($encodeRune(r));
								haveText = true;
							} else if (!(d.Entity === false)) {
								_tuple$8 = (_entry$1 = d.Entity[$String.keyFor(s$1)], _entry$1 !== undefined ? [_entry$1.v, true] : ["", false]);
								text = _tuple$8[0];
								haveText = _tuple$8[1];
							}
						}
					}
				/* } */ case 9:
				if (haveText) {
					d.buf.Truncate(before);
					d.buf.Write((new sliceType($stringToBytes(text))));
					_tmp$2 = 0;
					_tmp$3 = 0;
					b0 = _tmp$2;
					b1 = _tmp$3;
					/* continue Input; */ $s = 1; continue s;
				}
				if (!d.Strict) {
					_tmp$4 = 0;
					_tmp$5 = 0;
					b0 = _tmp$4;
					b1 = _tmp$5;
					/* continue Input; */ $s = 1; continue s;
				}
				ent = ($bytesToString($subslice(d.buf.Bytes(), before)));
				if (!((ent.charCodeAt((ent.length - 1 >> 0)) === 59))) {
					ent = ent + (" (no semicolon)");
				}
				d.err = d.syntaxError("invalid character entity " + ent);
				$s = -1; return sliceType.nil;
			/* } */ case 5:
			if (b === 13) {
				d.buf.WriteByte(10);
			} else if ((b1 === 13) && (b === 10)) {
			} else {
				d.buf.WriteByte(b);
			}
			_tmp$6 = b1;
			_tmp$7 = b;
			b0 = _tmp$6;
			b1 = _tmp$7;
		/* } */ $s = 1; continue; case 2:
		data = d.buf.Bytes();
		data = $subslice(data, 0, (data.$length - trunc >> 0));
		buf = data;
		/* while (true) { */ case 21:
			/* if (!(buf.$length > 0)) { break; } */ if(!(buf.$length > 0)) { $s = 22; continue; }
			_tuple$9 = utf8.DecodeRune(buf);
			r$1 = _tuple$9[0];
			size = _tuple$9[1];
			if ((r$1 === 65533) && (size === 1)) {
				d.err = d.syntaxError("invalid UTF-8");
				$s = -1; return sliceType.nil;
			}
			buf = $subslice(buf, size);
			/* */ if (!isInCharacterRange(r$1)) { $s = 23; continue; }
			/* */ $s = 24; continue;
			/* if (!isInCharacterRange(r$1)) { */ case 23:
				_r$13 = fmt.Sprintf("illegal character code %U", new sliceType$5([new $Int32(r$1)])); /* */ $s = 25; case 25: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
				_r$14 = d.syntaxError(_r$13); /* */ $s = 26; case 26: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
				d.err = _r$14;
				$s = -1; return sliceType.nil;
			/* } */ case 24:
		/* } */ $s = 21; continue; case 22:
		$s = -1; return data;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.text }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f._tuple$8 = _tuple$8; $f._tuple$9 = _tuple$9; $f.b = b; $f.b0 = b0; $f.b1 = b1; $f.base = base; $f.before = before; $f.buf = buf; $f.cdata = cdata; $f.d = d; $f.data = data; $f.ent = ent; $f.err = err; $f.haveText = haveText; $f.n = n; $f.name = name; $f.ok = ok; $f.ok$1 = ok$1; $f.ok$2 = ok$2; $f.quote = quote; $f.r = r; $f.r$1 = r$1; $f.s = s; $f.s$1 = s$1; $f.size = size; $f.start = start; $f.text = text; $f.trunc = trunc; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.text = function(quote, cdata) { return this.$val.text(quote, cdata); };
	isInCharacterRange = function(r) {
		var inrange, r;
		inrange = false;
		inrange = (r === 9) || (r === 10) || (r === 13) || r >= 32 && r <= 57207 || r >= 57344 && r <= 65533 || r >= 65536 && r <= 1114111;
		return inrange;
	};
	Decoder.ptr.prototype.nsname = function() {
		var _r$6, _tmp, _tmp$1, _tuple, d, i, name, ok, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; d = $f.d; i = $f.i; name = $f.name; ok = $f.ok; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		name = new Name.ptr("", "");
		ok = false;
		d = this;
		_r$6 = d.name(); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_tuple = _r$6;
		s = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			$s = -1; return [name, ok];
		}
		i = strings.Index(s, ":");
		if (i < 0) {
			name.Local = s;
		} else {
			name.Space = $substring(s, 0, i);
			name.Local = $substring(s, (i + 1 >> 0));
		}
		_tmp = $clone(name, Name);
		_tmp$1 = true;
		Name.copy(name, _tmp);
		ok = _tmp$1;
		$s = -1; return [name, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.nsname }; } $f._r$6 = _r$6; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.d = d; $f.i = i; $f.name = name; $f.ok = ok; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.nsname = function() { return this.$val.nsname(); };
	Decoder.ptr.prototype.name = function() {
		var _r$6, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, d, ok, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; b = $f.b; d = $f.d; ok = $f.ok; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = "";
		ok = false;
		d = this;
		d.buf.Reset();
		_r$6 = d.readName(); /* */ $s = 3; case 3: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		/* */ if (!_r$6) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!_r$6) { */ case 1:
			_tmp = "";
			_tmp$1 = false;
			s = _tmp;
			ok = _tmp$1;
			$s = -1; return [s, ok];
		/* } */ case 2:
		b = d.buf.Bytes();
		if (!isName(b)) {
			d.err = d.syntaxError("invalid XML name: " + ($bytesToString(b)));
			_tmp$2 = "";
			_tmp$3 = false;
			s = _tmp$2;
			ok = _tmp$3;
			$s = -1; return [s, ok];
		}
		_tmp$4 = ($bytesToString(b));
		_tmp$5 = true;
		s = _tmp$4;
		ok = _tmp$5;
		$s = -1; return [s, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.name }; } $f._r$6 = _r$6; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f.b = b; $f.d = d; $f.ok = ok; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.name = function() { return this.$val.name(); };
	Decoder.ptr.prototype.readName = function() {
		var _r$6, _r$7, _tuple, _tuple$1, b, d, ok, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; _r$7 = $f._r$7; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; b = $f.b; d = $f.d; ok = $f.ok; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ok = false;
		d = this;
		b = 0;
		_r$6 = d.mustgetc(); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_tuple = _r$6;
		b = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			$s = -1; return ok;
		}
		if (b < 128 && !isNameByte(b)) {
			d.ungetc(b);
			ok = false;
			$s = -1; return ok;
		}
		d.buf.WriteByte(b);
		/* while (true) { */ case 2:
			_r$7 = d.mustgetc(); /* */ $s = 4; case 4: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_tuple$1 = _r$7;
			b = _tuple$1[0];
			ok = _tuple$1[1];
			if (!ok) {
				$s = -1; return ok;
			}
			if (b < 128 && !isNameByte(b)) {
				d.ungetc(b);
				/* break; */ $s = 3; continue;
			}
			d.buf.WriteByte(b);
		/* } */ $s = 2; continue; case 3:
		ok = true;
		$s = -1; return ok;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Decoder.ptr.prototype.readName }; } $f._r$6 = _r$6; $f._r$7 = _r$7; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.b = b; $f.d = d; $f.ok = ok; $f.$s = $s; $f.$r = $r; return $f;
	};
	Decoder.prototype.readName = function() { return this.$val.readName(); };
	isNameByte = function(c) {
		var c;
		return 65 <= c && c <= 90 || 97 <= c && c <= 122 || 48 <= c && c <= 57 || (c === 95) || (c === 58) || (c === 46) || (c === 45);
	};
	isName = function(s) {
		var _tuple, _tuple$1, c, n, s;
		if (s.$length === 0) {
			return false;
		}
		_tuple = utf8.DecodeRune(s);
		c = _tuple[0];
		n = _tuple[1];
		if ((c === 65533) && (n === 1)) {
			return false;
		}
		if (!unicode.Is(first, c)) {
			return false;
		}
		while (true) {
			if (!(n < s.$length)) { break; }
			s = $subslice(s, n);
			_tuple$1 = utf8.DecodeRune(s);
			c = _tuple$1[0];
			n = _tuple$1[1];
			if ((c === 65533) && (n === 1)) {
				return false;
			}
			if (!unicode.Is(first, c) && !unicode.Is(second, c)) {
				return false;
			}
		}
		return true;
	};
	isNameString = function(s) {
		var _tuple, _tuple$1, c, n, s;
		if (s.length === 0) {
			return false;
		}
		_tuple = utf8.DecodeRuneInString(s);
		c = _tuple[0];
		n = _tuple[1];
		if ((c === 65533) && (n === 1)) {
			return false;
		}
		if (!unicode.Is(first, c)) {
			return false;
		}
		while (true) {
			if (!(n < s.length)) { break; }
			s = $substring(s, n);
			_tuple$1 = utf8.DecodeRuneInString(s);
			c = _tuple$1[0];
			n = _tuple$1[1];
			if ((c === 65533) && (n === 1)) {
				return false;
			}
			if (!unicode.Is(first, c) && !unicode.Is(second, c)) {
				return false;
			}
		}
		return true;
	};
	EscapeText = function(w, s) {
		var _r$6, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$6 = $f._r$6; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r$6 = escapeText(w, s, true); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		$s = -1; return _r$6;
		/* */ } return; } if ($f === undefined) { $f = { $blk: EscapeText }; } $f._r$6 = _r$6; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.EscapeText = EscapeText;
	escapeText = function(w, s, escapeNewline) {
		var _1, _r$6, _r$7, _r$8, _tuple, _tuple$1, _tuple$2, _tuple$3, err, err$1, err$2, esc, escapeNewline, i, last, r, s, w, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; esc = $f.esc; escapeNewline = $f.escapeNewline; i = $f.i; last = $f.last; r = $f.r; s = $f.s; w = $f.w; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		esc = sliceType.nil;
		last = 0;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < s.$length)) { break; } */ if(!(i < s.$length)) { $s = 2; continue; }
			_tuple = utf8.DecodeRune($subslice(s, i));
			r = _tuple[0];
			width = _tuple[1];
			i = i + (width) >> 0;
				_1 = r;
				if (_1 === (34)) {
					esc = esc_quot;
				} else if (_1 === (39)) {
					esc = esc_apos;
				} else if (_1 === (38)) {
					esc = esc_amp;
				} else if (_1 === (60)) {
					esc = esc_lt;
				} else if (_1 === (62)) {
					esc = esc_gt;
				} else if (_1 === (9)) {
					esc = esc_tab;
				} else if (_1 === (10)) {
					if (!escapeNewline) {
						/* continue; */ $s = 1; continue;
					}
					esc = esc_nl;
				} else if (_1 === (13)) {
					esc = esc_cr;
				} else {
					if (!isInCharacterRange(r) || ((r === 65533) && (width === 1))) {
						esc = esc_fffd;
						/* break; */ $s = 3; continue;
					}
					/* continue; */ $s = 1; continue;
				}
			case 3:
			_r$6 = w.Write($subslice(s, last, (i - width >> 0))); /* */ $s = 4; case 4: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_tuple$1 = _r$6;
			err = _tuple$1[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			_r$7 = w.Write(esc); /* */ $s = 5; case 5: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_tuple$2 = _r$7;
			err$1 = _tuple$2[1];
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				$s = -1; return err$1;
			}
			last = i;
		/* } */ $s = 1; continue; case 2:
		_r$8 = w.Write($subslice(s, last)); /* */ $s = 6; case 6: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		_tuple$3 = _r$8;
		err$2 = _tuple$3[1];
		if (!($interfaceIsEqual(err$2, $ifaceNil))) {
			$s = -1; return err$2;
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: escapeText }; } $f._1 = _1; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.esc = esc; $f.escapeNewline = escapeNewline; $f.i = i; $f.last = last; $f.r = r; $f.s = s; $f.w = w; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.ptr.prototype.EscapeString = function(s) {
		var _1, _r$6, _r$7, _r$8, _tuple, esc, i, last, p, r, s, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _tuple = $f._tuple; esc = $f.esc; i = $f.i; last = $f.last; p = $f.p; r = $f.r; s = $f.s; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		esc = sliceType.nil;
		last = 0;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < s.length)) { break; } */ if(!(i < s.length)) { $s = 2; continue; }
			_tuple = utf8.DecodeRuneInString($substring(s, i));
			r = _tuple[0];
			width = _tuple[1];
			i = i + (width) >> 0;
				_1 = r;
				if (_1 === (34)) {
					esc = esc_quot;
				} else if (_1 === (39)) {
					esc = esc_apos;
				} else if (_1 === (38)) {
					esc = esc_amp;
				} else if (_1 === (60)) {
					esc = esc_lt;
				} else if (_1 === (62)) {
					esc = esc_gt;
				} else if (_1 === (9)) {
					esc = esc_tab;
				} else if (_1 === (10)) {
					esc = esc_nl;
				} else if (_1 === (13)) {
					esc = esc_cr;
				} else {
					if (!isInCharacterRange(r) || ((r === 65533) && (width === 1))) {
						esc = esc_fffd;
						/* break; */ $s = 3; continue;
					}
					/* continue; */ $s = 1; continue;
				}
			case 3:
			_r$6 = p.Writer.WriteString($substring(s, last, (i - width >> 0))); /* */ $s = 4; case 4: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_r$6;
			_r$7 = p.Writer.Write(esc); /* */ $s = 5; case 5: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_r$7;
			last = i;
		/* } */ $s = 1; continue; case 2:
		_r$8 = p.Writer.WriteString($substring(s, last)); /* */ $s = 6; case 6: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		_r$8;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printer.ptr.prototype.EscapeString }; } $f._1 = _1; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._tuple = _tuple; $f.esc = esc; $f.i = i; $f.last = last; $f.p = p; $f.r = r; $f.s = s; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	printer.prototype.EscapeString = function(s) { return this.$val.EscapeString(s); };
	emitCDATA = function(w, s) {
		var _r$10, _r$6, _r$7, _r$8, _r$9, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, err, err$1, err$2, err$3, err$4, i, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$10 = $f._r$10; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; err$4 = $f.err$4; i = $f.i; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (s.$length === 0) {
			$s = -1; return $ifaceNil;
		}
		_r$6 = w.Write(cdataStart); /* */ $s = 1; case 1: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_tuple = _r$6;
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		/* while (true) { */ case 2:
			i = bytes.Index(s, cdataEnd);
			/* */ if (i >= 0 && (i + cdataEnd.$length >> 0) <= s.$length) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (i >= 0 && (i + cdataEnd.$length >> 0) <= s.$length) { */ case 4:
				_r$7 = w.Write($subslice(s, 0, i)); /* */ $s = 7; case 7: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				_tuple$1 = _r$7;
				err$1 = _tuple$1[1];
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					$s = -1; return err$1;
				}
				_r$8 = w.Write(cdataEscape); /* */ $s = 8; case 8: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				_tuple$2 = _r$8;
				err$2 = _tuple$2[1];
				if (!($interfaceIsEqual(err$2, $ifaceNil))) {
					$s = -1; return err$2;
				}
				i = i + (cdataEnd.$length) >> 0;
				$s = 6; continue;
			/* } else { */ case 5:
				_r$9 = w.Write(s); /* */ $s = 9; case 9: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				_tuple$3 = _r$9;
				err$3 = _tuple$3[1];
				if (!($interfaceIsEqual(err$3, $ifaceNil))) {
					$s = -1; return err$3;
				}
				/* break; */ $s = 3; continue;
			/* } */ case 6:
			s = $subslice(s, i);
		/* } */ $s = 2; continue; case 3:
		_r$10 = w.Write(cdataEnd); /* */ $s = 10; case 10: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
		_tuple$4 = _r$10;
		err$4 = _tuple$4[1];
		if (!($interfaceIsEqual(err$4, $ifaceNil))) {
			$s = -1; return err$4;
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: emitCDATA }; } $f._r$10 = _r$10; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.err$4 = err$4; $f.i = i; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	procInst = function(param, s) {
		var idx, param, s, v;
		param = param + "=";
		idx = strings.Index(s, param);
		if (idx === -1) {
			return "";
		}
		v = $substring(s, (idx + param.length >> 0));
		if (v === "") {
			return "";
		}
		if (!((v.charCodeAt(0) === 39)) && !((v.charCodeAt(0) === 34))) {
			return "";
		}
		idx = strings.IndexRune($substring(v, 1), ((v.charCodeAt(0) >> 0)));
		if (idx === -1) {
			return "";
		}
		return $substring(v, 1, (idx + 1 >> 0));
	};
	ptrType$7.methods = [{prop: "Indent", name: "Indent", pkg: "", typ: $funcType([$String, $String], [], false)}, {prop: "Encode", name: "Encode", pkg: "", typ: $funcType([$emptyInterface], [$error], false)}, {prop: "EncodeElement", name: "EncodeElement", pkg: "", typ: $funcType([$emptyInterface, StartElement], [$error], false)}, {prop: "EncodeToken", name: "EncodeToken", pkg: "", typ: $funcType([Token], [$error], false)}, {prop: "Flush", name: "Flush", pkg: "", typ: $funcType([], [$error], false)}];
	ptrType$10.methods = [{prop: "createAttrPrefix", name: "createAttrPrefix", pkg: "encoding/xml", typ: $funcType([$String], [$String], false)}, {prop: "deleteAttrPrefix", name: "deleteAttrPrefix", pkg: "encoding/xml", typ: $funcType([$String], [], false)}, {prop: "markPrefix", name: "markPrefix", pkg: "encoding/xml", typ: $funcType([], [], false)}, {prop: "popPrefix", name: "popPrefix", pkg: "encoding/xml", typ: $funcType([], [], false)}, {prop: "marshalValue", name: "marshalValue", pkg: "encoding/xml", typ: $funcType([reflect.Value, ptrType$8, ptrType$9], [$error], false)}, {prop: "marshalAttr", name: "marshalAttr", pkg: "encoding/xml", typ: $funcType([ptrType$9, Name, reflect.Value], [$error], false)}, {prop: "marshalInterface", name: "marshalInterface", pkg: "encoding/xml", typ: $funcType([Marshaler, StartElement], [$error], false)}, {prop: "marshalTextInterface", name: "marshalTextInterface", pkg: "encoding/xml", typ: $funcType([encoding.TextMarshaler, StartElement], [$error], false)}, {prop: "writeStart", name: "writeStart", pkg: "encoding/xml", typ: $funcType([ptrType$9], [$error], false)}, {prop: "writeEnd", name: "writeEnd", pkg: "encoding/xml", typ: $funcType([Name], [$error], false)}, {prop: "marshalSimple", name: "marshalSimple", pkg: "encoding/xml", typ: $funcType([reflect.Type, reflect.Value], [$String, sliceType, $error], false)}, {prop: "marshalStruct", name: "marshalStruct", pkg: "encoding/xml", typ: $funcType([ptrType$12, reflect.Value], [$error], false)}, {prop: "cachedWriteError", name: "cachedWriteError", pkg: "encoding/xml", typ: $funcType([], [$error], false)}, {prop: "writeIndent", name: "writeIndent", pkg: "encoding/xml", typ: $funcType([$Int], [], false)}, {prop: "EscapeString", name: "EscapeString", pkg: "", typ: $funcType([$String], [], false)}];
	ptrType$15.methods = [{prop: "trim", name: "trim", pkg: "encoding/xml", typ: $funcType([sliceType$3], [$error], false)}, {prop: "push", name: "push", pkg: "encoding/xml", typ: $funcType([sliceType$3], [$error], false)}];
	ptrType$16.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	UnmarshalError.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$8.methods = [{prop: "value", name: "value", pkg: "encoding/xml", typ: $funcType([reflect.Value], [reflect.Value], false)}];
	ptrType$18.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$19.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	StartElement.methods = [{prop: "Copy", name: "Copy", pkg: "", typ: $funcType([], [StartElement], false)}, {prop: "End", name: "End", pkg: "", typ: $funcType([], [EndElement], false)}];
	CharData.methods = [{prop: "Copy", name: "Copy", pkg: "", typ: $funcType([], [CharData], false)}];
	Comment.methods = [{prop: "Copy", name: "Copy", pkg: "", typ: $funcType([], [Comment], false)}];
	ProcInst.methods = [{prop: "Copy", name: "Copy", pkg: "", typ: $funcType([], [ProcInst], false)}];
	Directive.methods = [{prop: "Copy", name: "Copy", pkg: "", typ: $funcType([], [Directive], false)}];
	ptrType$17.methods = [{prop: "Decode", name: "Decode", pkg: "", typ: $funcType([$emptyInterface], [$error], false)}, {prop: "DecodeElement", name: "DecodeElement", pkg: "", typ: $funcType([$emptyInterface, ptrType$9], [$error], false)}, {prop: "unmarshalInterface", name: "unmarshalInterface", pkg: "encoding/xml", typ: $funcType([Unmarshaler, ptrType$9], [$error], false)}, {prop: "unmarshalTextInterface", name: "unmarshalTextInterface", pkg: "encoding/xml", typ: $funcType([encoding.TextUnmarshaler], [$error], false)}, {prop: "unmarshalAttr", name: "unmarshalAttr", pkg: "encoding/xml", typ: $funcType([reflect.Value, Attr], [$error], false)}, {prop: "unmarshal", name: "unmarshal", pkg: "encoding/xml", typ: $funcType([reflect.Value, ptrType$9], [$error], false)}, {prop: "unmarshalPath", name: "unmarshalPath", pkg: "encoding/xml", typ: $funcType([ptrType$12, reflect.Value, sliceType$3, ptrType$9], [$Bool, $error], false)}, {prop: "Skip", name: "Skip", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Token", name: "Token", pkg: "", typ: $funcType([], [Token, $error], false)}, {prop: "translate", name: "translate", pkg: "encoding/xml", typ: $funcType([ptrType$20, $Bool], [], false)}, {prop: "switchToReader", name: "switchToReader", pkg: "encoding/xml", typ: $funcType([io.Reader], [], false)}, {prop: "push", name: "push", pkg: "encoding/xml", typ: $funcType([$Int], [ptrType$14], false)}, {prop: "pop", name: "pop", pkg: "encoding/xml", typ: $funcType([], [ptrType$14], false)}, {prop: "pushEOF", name: "pushEOF", pkg: "encoding/xml", typ: $funcType([], [], false)}, {prop: "popEOF", name: "popEOF", pkg: "encoding/xml", typ: $funcType([], [$Bool], false)}, {prop: "pushElement", name: "pushElement", pkg: "encoding/xml", typ: $funcType([Name], [], false)}, {prop: "pushNs", name: "pushNs", pkg: "encoding/xml", typ: $funcType([$String, $String, $Bool], [], false)}, {prop: "syntaxError", name: "syntaxError", pkg: "encoding/xml", typ: $funcType([$String], [$error], false)}, {prop: "popElement", name: "popElement", pkg: "encoding/xml", typ: $funcType([ptrType$21], [$Bool], false)}, {prop: "autoClose", name: "autoClose", pkg: "encoding/xml", typ: $funcType([Token], [Token, $Bool], false)}, {prop: "RawToken", name: "RawToken", pkg: "", typ: $funcType([], [Token, $error], false)}, {prop: "rawToken", name: "rawToken", pkg: "encoding/xml", typ: $funcType([], [Token, $error], false)}, {prop: "attrval", name: "attrval", pkg: "encoding/xml", typ: $funcType([], [sliceType], false)}, {prop: "space", name: "space", pkg: "encoding/xml", typ: $funcType([], [], false)}, {prop: "getc", name: "getc", pkg: "encoding/xml", typ: $funcType([], [$Uint8, $Bool], false)}, {prop: "InputOffset", name: "InputOffset", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "savedOffset", name: "savedOffset", pkg: "encoding/xml", typ: $funcType([], [$Int], false)}, {prop: "mustgetc", name: "mustgetc", pkg: "encoding/xml", typ: $funcType([], [$Uint8, $Bool], false)}, {prop: "ungetc", name: "ungetc", pkg: "encoding/xml", typ: $funcType([$Uint8], [], false)}, {prop: "text", name: "text", pkg: "encoding/xml", typ: $funcType([$Int, $Bool], [sliceType], false)}, {prop: "nsname", name: "nsname", pkg: "encoding/xml", typ: $funcType([], [Name, $Bool], false)}, {prop: "name", name: "name", pkg: "encoding/xml", typ: $funcType([], [$String, $Bool], false)}, {prop: "readName", name: "readName", pkg: "encoding/xml", typ: $funcType([], [$Bool], false)}];
	Marshaler.init([{prop: "MarshalXML", name: "MarshalXML", pkg: "", typ: $funcType([ptrType$7, StartElement], [$error], false)}]);
	MarshalerAttr.init([{prop: "MarshalXMLAttr", name: "MarshalXMLAttr", pkg: "", typ: $funcType([Name], [Attr, $error], false)}]);
	Encoder.init("encoding/xml", [{prop: "p", name: "p", anonymous: false, exported: false, typ: printer, tag: ""}]);
	printer.init("encoding/xml", [{prop: "Writer", name: "Writer", anonymous: true, exported: true, typ: ptrType$6, tag: ""}, {prop: "encoder", name: "encoder", anonymous: false, exported: false, typ: ptrType$7, tag: ""}, {prop: "seq", name: "seq", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "indent", name: "indent", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "prefix", name: "prefix", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "depth", name: "depth", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "indentedIn", name: "indentedIn", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "putNewline", name: "putNewline", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "attrNS", name: "attrNS", anonymous: false, exported: false, typ: mapType, tag: ""}, {prop: "attrPrefix", name: "attrPrefix", anonymous: false, exported: false, typ: mapType, tag: ""}, {prop: "prefixes", name: "prefixes", anonymous: false, exported: false, typ: sliceType$3, tag: ""}, {prop: "tags", name: "tags", anonymous: false, exported: false, typ: sliceType$4, tag: ""}]);
	parentStack.init("encoding/xml", [{prop: "p", name: "p", anonymous: false, exported: false, typ: ptrType$10, tag: ""}, {prop: "stack", name: "stack", anonymous: false, exported: false, typ: sliceType$3, tag: ""}]);
	UnsupportedTypeError.init("", [{prop: "Type", name: "Type", anonymous: false, exported: true, typ: reflect.Type, tag: ""}]);
	Unmarshaler.init([{prop: "UnmarshalXML", name: "UnmarshalXML", pkg: "", typ: $funcType([ptrType$17, StartElement], [$error], false)}]);
	UnmarshalerAttr.init([{prop: "UnmarshalXMLAttr", name: "UnmarshalXMLAttr", pkg: "", typ: $funcType([Attr], [$error], false)}]);
	typeInfo.init("encoding/xml", [{prop: "xmlname", name: "xmlname", anonymous: false, exported: false, typ: ptrType$8, tag: ""}, {prop: "fields", name: "fields", anonymous: false, exported: false, typ: sliceType$8, tag: ""}]);
	fieldInfo.init("encoding/xml", [{prop: "idx", name: "idx", anonymous: false, exported: false, typ: sliceType$9, tag: ""}, {prop: "name", name: "name", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "xmlns", name: "xmlns", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "flags", name: "flags", anonymous: false, exported: false, typ: fieldFlags, tag: ""}, {prop: "parents", name: "parents", anonymous: false, exported: false, typ: sliceType$3, tag: ""}]);
	TagPathError.init("", [{prop: "Struct", name: "Struct", anonymous: false, exported: true, typ: reflect.Type, tag: ""}, {prop: "Field1", name: "Field1", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Tag1", name: "Tag1", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Field2", name: "Field2", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Tag2", name: "Tag2", anonymous: false, exported: true, typ: $String, tag: ""}]);
	SyntaxError.init("", [{prop: "Msg", name: "Msg", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Line", name: "Line", anonymous: false, exported: true, typ: $Int, tag: ""}]);
	Name.init("", [{prop: "Space", name: "Space", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Local", name: "Local", anonymous: false, exported: true, typ: $String, tag: ""}]);
	Attr.init("", [{prop: "Name", name: "Name", anonymous: false, exported: true, typ: Name, tag: ""}, {prop: "Value", name: "Value", anonymous: false, exported: true, typ: $String, tag: ""}]);
	Token.init([]);
	StartElement.init("", [{prop: "Name", name: "Name", anonymous: false, exported: true, typ: Name, tag: ""}, {prop: "Attr", name: "Attr", anonymous: false, exported: true, typ: sliceType$6, tag: ""}]);
	EndElement.init("", [{prop: "Name", name: "Name", anonymous: false, exported: true, typ: Name, tag: ""}]);
	CharData.init($Uint8);
	Comment.init($Uint8);
	ProcInst.init("", [{prop: "Target", name: "Target", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Inst", name: "Inst", anonymous: false, exported: true, typ: sliceType, tag: ""}]);
	Directive.init($Uint8);
	Decoder.init("encoding/xml", [{prop: "Strict", name: "Strict", anonymous: false, exported: true, typ: $Bool, tag: ""}, {prop: "AutoClose", name: "AutoClose", anonymous: false, exported: true, typ: sliceType$3, tag: ""}, {prop: "Entity", name: "Entity", anonymous: false, exported: true, typ: mapType, tag: ""}, {prop: "CharsetReader", name: "CharsetReader", anonymous: false, exported: true, typ: funcType, tag: ""}, {prop: "DefaultSpace", name: "DefaultSpace", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "r", name: "r", anonymous: false, exported: false, typ: io.ByteReader, tag: ""}, {prop: "buf", name: "buf", anonymous: false, exported: false, typ: bytes.Buffer, tag: ""}, {prop: "saved", name: "saved", anonymous: false, exported: false, typ: ptrType$13, tag: ""}, {prop: "stk", name: "stk", anonymous: false, exported: false, typ: ptrType$14, tag: ""}, {prop: "free", name: "free", anonymous: false, exported: false, typ: ptrType$14, tag: ""}, {prop: "needClose", name: "needClose", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "toClose", name: "toClose", anonymous: false, exported: false, typ: Name, tag: ""}, {prop: "nextToken", name: "nextToken", anonymous: false, exported: false, typ: Token, tag: ""}, {prop: "nextByte", name: "nextByte", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "ns", name: "ns", anonymous: false, exported: false, typ: mapType, tag: ""}, {prop: "err", name: "err", anonymous: false, exported: false, typ: $error, tag: ""}, {prop: "line", name: "line", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "offset", name: "offset", anonymous: false, exported: false, typ: $Int64, tag: ""}, {prop: "unmarshalDepth", name: "unmarshalDepth", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	stack.init("encoding/xml", [{prop: "next", name: "next", anonymous: false, exported: false, typ: ptrType$14, tag: ""}, {prop: "kind", name: "kind", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "name", name: "name", anonymous: false, exported: false, typ: Name, tag: ""}, {prop: "ok", name: "ok", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bufio.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytes.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = encoding.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmt.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = reflect.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		tinfoMap = new sync.Map.ptr(new sync.Mutex.ptr(0, 0), new $packages["sync/atomic"].Value.ptr(new $packages["sync/atomic"].noCopy.ptr(), $ifaceNil), false, 0);
		begComment = (new sliceType($stringToBytes("<!--")));
		endComment = (new sliceType($stringToBytes("-->")));
		endProcInst = (new sliceType($stringToBytes("?>")));
		_r = reflect.TypeOf((ptrType.nil)).Elem(); /* */ $s = 13; case 13: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		marshalerType = _r;
		_r$1 = reflect.TypeOf((ptrType$1.nil)).Elem(); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		marshalerAttrType = _r$1;
		_r$2 = reflect.TypeOf((ptrType$2.nil)).Elem(); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		textMarshalerType = _r$2;
		ddBytes = (new sliceType($stringToBytes("--")));
		attrType = reflect.TypeOf((x = new Attr.ptr(new Name.ptr("", ""), ""), new x.constructor.elem(x)));
		_r$3 = reflect.TypeOf((ptrType$3.nil)).Elem(); /* */ $s = 16; case 16: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		unmarshalerType = _r$3;
		_r$4 = reflect.TypeOf((ptrType$4.nil)).Elem(); /* */ $s = 17; case 17: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		unmarshalerAttrType = _r$4;
		_r$5 = reflect.TypeOf((ptrType$5.nil)).Elem(); /* */ $s = 18; case 18: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		textUnmarshalerType = _r$5;
		nameType = reflect.TypeOf((x$1 = new Name.ptr("", ""), new x$1.constructor.elem(x$1)));
		errRawToken = errors.New("xml: cannot use RawToken from UnmarshalXML method");
		entity = $makeMap($String.keyFor, [{ k: "lt", v: 60 }, { k: "gt", v: 62 }, { k: "amp", v: 38 }, { k: "apos", v: 39 }, { k: "quot", v: 34 }]);
		first = new unicode.RangeTable.ptr(new sliceType$1([new unicode.Range16.ptr(58, 58, 1), new unicode.Range16.ptr(65, 90, 1), new unicode.Range16.ptr(95, 95, 1), new unicode.Range16.ptr(97, 122, 1), new unicode.Range16.ptr(192, 214, 1), new unicode.Range16.ptr(216, 246, 1), new unicode.Range16.ptr(248, 255, 1), new unicode.Range16.ptr(256, 305, 1), new unicode.Range16.ptr(308, 318, 1), new unicode.Range16.ptr(321, 328, 1), new unicode.Range16.ptr(330, 382, 1), new unicode.Range16.ptr(384, 451, 1), new unicode.Range16.ptr(461, 496, 1), new unicode.Range16.ptr(500, 501, 1), new unicode.Range16.ptr(506, 535, 1), new unicode.Range16.ptr(592, 680, 1), new unicode.Range16.ptr(699, 705, 1), new unicode.Range16.ptr(902, 902, 1), new unicode.Range16.ptr(904, 906, 1), new unicode.Range16.ptr(908, 908, 1), new unicode.Range16.ptr(910, 929, 1), new unicode.Range16.ptr(931, 974, 1), new unicode.Range16.ptr(976, 982, 1), new unicode.Range16.ptr(986, 992, 2), new unicode.Range16.ptr(994, 1011, 1), new unicode.Range16.ptr(1025, 1036, 1), new unicode.Range16.ptr(1038, 1103, 1), new unicode.Range16.ptr(1105, 1116, 1), new unicode.Range16.ptr(1118, 1153, 1), new unicode.Range16.ptr(1168, 1220, 1), new unicode.Range16.ptr(1223, 1224, 1), new unicode.Range16.ptr(1227, 1228, 1), new unicode.Range16.ptr(1232, 1259, 1), new unicode.Range16.ptr(1262, 1269, 1), new unicode.Range16.ptr(1272, 1273, 1), new unicode.Range16.ptr(1329, 1366, 1), new unicode.Range16.ptr(1369, 1369, 1), new unicode.Range16.ptr(1377, 1414, 1), new unicode.Range16.ptr(1488, 1514, 1), new unicode.Range16.ptr(1520, 1522, 1), new unicode.Range16.ptr(1569, 1594, 1), new unicode.Range16.ptr(1601, 1610, 1), new unicode.Range16.ptr(1649, 1719, 1), new unicode.Range16.ptr(1722, 1726, 1), new unicode.Range16.ptr(1728, 1742, 1), new unicode.Range16.ptr(1744, 1747, 1), new unicode.Range16.ptr(1749, 1749, 1), new unicode.Range16.ptr(1765, 1766, 1), new unicode.Range16.ptr(2309, 2361, 1), new unicode.Range16.ptr(2365, 2365, 1), new unicode.Range16.ptr(2392, 2401, 1), new unicode.Range16.ptr(2437, 2444, 1), new unicode.Range16.ptr(2447, 2448, 1), new unicode.Range16.ptr(2451, 2472, 1), new unicode.Range16.ptr(2474, 2480, 1), new unicode.Range16.ptr(2482, 2482, 1), new unicode.Range16.ptr(2486, 2489, 1), new unicode.Range16.ptr(2524, 2525, 1), new unicode.Range16.ptr(2527, 2529, 1), new unicode.Range16.ptr(2544, 2545, 1), new unicode.Range16.ptr(2565, 2570, 1), new unicode.Range16.ptr(2575, 2576, 1), new unicode.Range16.ptr(2579, 2600, 1), new unicode.Range16.ptr(2602, 2608, 1), new unicode.Range16.ptr(2610, 2611, 1), new unicode.Range16.ptr(2613, 2614, 1), new unicode.Range16.ptr(2616, 2617, 1), new unicode.Range16.ptr(2649, 2652, 1), new unicode.Range16.ptr(2654, 2654, 1), new unicode.Range16.ptr(2674, 2676, 1), new unicode.Range16.ptr(2693, 2699, 1), new unicode.Range16.ptr(2701, 2701, 1), new unicode.Range16.ptr(2703, 2705, 1), new unicode.Range16.ptr(2707, 2728, 1), new unicode.Range16.ptr(2730, 2736, 1), new unicode.Range16.ptr(2738, 2739, 1), new unicode.Range16.ptr(2741, 2745, 1), new unicode.Range16.ptr(2749, 2784, 35), new unicode.Range16.ptr(2821, 2828, 1), new unicode.Range16.ptr(2831, 2832, 1), new unicode.Range16.ptr(2835, 2856, 1), new unicode.Range16.ptr(2858, 2864, 1), new unicode.Range16.ptr(2866, 2867, 1), new unicode.Range16.ptr(2870, 2873, 1), new unicode.Range16.ptr(2877, 2877, 1), new unicode.Range16.ptr(2908, 2909, 1), new unicode.Range16.ptr(2911, 2913, 1), new unicode.Range16.ptr(2949, 2954, 1), new unicode.Range16.ptr(2958, 2960, 1), new unicode.Range16.ptr(2962, 2965, 1), new unicode.Range16.ptr(2969, 2970, 1), new unicode.Range16.ptr(2972, 2972, 1), new unicode.Range16.ptr(2974, 2975, 1), new unicode.Range16.ptr(2979, 2980, 1), new unicode.Range16.ptr(2984, 2986, 1), new unicode.Range16.ptr(2990, 2997, 1), new unicode.Range16.ptr(2999, 3001, 1), new unicode.Range16.ptr(3077, 3084, 1), new unicode.Range16.ptr(3086, 3088, 1), new unicode.Range16.ptr(3090, 3112, 1), new unicode.Range16.ptr(3114, 3123, 1), new unicode.Range16.ptr(3125, 3129, 1), new unicode.Range16.ptr(3168, 3169, 1), new unicode.Range16.ptr(3205, 3212, 1), new unicode.Range16.ptr(3214, 3216, 1), new unicode.Range16.ptr(3218, 3240, 1), new unicode.Range16.ptr(3242, 3251, 1), new unicode.Range16.ptr(3253, 3257, 1), new unicode.Range16.ptr(3294, 3294, 1), new unicode.Range16.ptr(3296, 3297, 1), new unicode.Range16.ptr(3333, 3340, 1), new unicode.Range16.ptr(3342, 3344, 1), new unicode.Range16.ptr(3346, 3368, 1), new unicode.Range16.ptr(3370, 3385, 1), new unicode.Range16.ptr(3424, 3425, 1), new unicode.Range16.ptr(3585, 3630, 1), new unicode.Range16.ptr(3632, 3632, 1), new unicode.Range16.ptr(3634, 3635, 1), new unicode.Range16.ptr(3648, 3653, 1), new unicode.Range16.ptr(3713, 3714, 1), new unicode.Range16.ptr(3716, 3716, 1), new unicode.Range16.ptr(3719, 3720, 1), new unicode.Range16.ptr(3722, 3725, 3), new unicode.Range16.ptr(3732, 3735, 1), new unicode.Range16.ptr(3737, 3743, 1), new unicode.Range16.ptr(3745, 3747, 1), new unicode.Range16.ptr(3749, 3751, 2), new unicode.Range16.ptr(3754, 3755, 1), new unicode.Range16.ptr(3757, 3758, 1), new unicode.Range16.ptr(3760, 3760, 1), new unicode.Range16.ptr(3762, 3763, 1), new unicode.Range16.ptr(3773, 3773, 1), new unicode.Range16.ptr(3776, 3780, 1), new unicode.Range16.ptr(3904, 3911, 1), new unicode.Range16.ptr(3913, 3945, 1), new unicode.Range16.ptr(4256, 4293, 1), new unicode.Range16.ptr(4304, 4342, 1), new unicode.Range16.ptr(4352, 4352, 1), new unicode.Range16.ptr(4354, 4355, 1), new unicode.Range16.ptr(4357, 4359, 1), new unicode.Range16.ptr(4361, 4361, 1), new unicode.Range16.ptr(4363, 4364, 1), new unicode.Range16.ptr(4366, 4370, 1), new unicode.Range16.ptr(4412, 4416, 2), new unicode.Range16.ptr(4428, 4432, 2), new unicode.Range16.ptr(4436, 4437, 1), new unicode.Range16.ptr(4441, 4441, 1), new unicode.Range16.ptr(4447, 4449, 1), new unicode.Range16.ptr(4451, 4457, 2), new unicode.Range16.ptr(4461, 4462, 1), new unicode.Range16.ptr(4466, 4467, 1), new unicode.Range16.ptr(4469, 4510, 41), new unicode.Range16.ptr(4520, 4523, 3), new unicode.Range16.ptr(4526, 4527, 1), new unicode.Range16.ptr(4535, 4536, 1), new unicode.Range16.ptr(4538, 4538, 1), new unicode.Range16.ptr(4540, 4546, 1), new unicode.Range16.ptr(4587, 4592, 5), new unicode.Range16.ptr(4601, 4601, 1), new unicode.Range16.ptr(7680, 7835, 1), new unicode.Range16.ptr(7840, 7929, 1), new unicode.Range16.ptr(7936, 7957, 1), new unicode.Range16.ptr(7960, 7965, 1), new unicode.Range16.ptr(7968, 8005, 1), new unicode.Range16.ptr(8008, 8013, 1), new unicode.Range16.ptr(8016, 8023, 1), new unicode.Range16.ptr(8025, 8027, 2), new unicode.Range16.ptr(8029, 8029, 1), new unicode.Range16.ptr(8031, 8061, 1), new unicode.Range16.ptr(8064, 8116, 1), new unicode.Range16.ptr(8118, 8124, 1), new unicode.Range16.ptr(8126, 8126, 1), new unicode.Range16.ptr(8130, 8132, 1), new unicode.Range16.ptr(8134, 8140, 1), new unicode.Range16.ptr(8144, 8147, 1), new unicode.Range16.ptr(8150, 8155, 1), new unicode.Range16.ptr(8160, 8172, 1), new unicode.Range16.ptr(8178, 8180, 1), new unicode.Range16.ptr(8182, 8188, 1), new unicode.Range16.ptr(8486, 8486, 1), new unicode.Range16.ptr(8490, 8491, 1), new unicode.Range16.ptr(8494, 8494, 1), new unicode.Range16.ptr(8576, 8578, 1), new unicode.Range16.ptr(12295, 12295, 1), new unicode.Range16.ptr(12321, 12329, 1), new unicode.Range16.ptr(12353, 12436, 1), new unicode.Range16.ptr(12449, 12538, 1), new unicode.Range16.ptr(12549, 12588, 1), new unicode.Range16.ptr(19968, 40869, 1), new unicode.Range16.ptr(44032, 55203, 1)]), sliceType$2.nil, 0);
		second = new unicode.RangeTable.ptr(new sliceType$1([new unicode.Range16.ptr(45, 46, 1), new unicode.Range16.ptr(48, 57, 1), new unicode.Range16.ptr(183, 183, 1), new unicode.Range16.ptr(720, 721, 1), new unicode.Range16.ptr(768, 837, 1), new unicode.Range16.ptr(864, 865, 1), new unicode.Range16.ptr(903, 903, 1), new unicode.Range16.ptr(1155, 1158, 1), new unicode.Range16.ptr(1425, 1441, 1), new unicode.Range16.ptr(1443, 1465, 1), new unicode.Range16.ptr(1467, 1469, 1), new unicode.Range16.ptr(1471, 1471, 1), new unicode.Range16.ptr(1473, 1474, 1), new unicode.Range16.ptr(1476, 1600, 124), new unicode.Range16.ptr(1611, 1618, 1), new unicode.Range16.ptr(1632, 1641, 1), new unicode.Range16.ptr(1648, 1648, 1), new unicode.Range16.ptr(1750, 1756, 1), new unicode.Range16.ptr(1757, 1759, 1), new unicode.Range16.ptr(1760, 1764, 1), new unicode.Range16.ptr(1767, 1768, 1), new unicode.Range16.ptr(1770, 1773, 1), new unicode.Range16.ptr(1776, 1785, 1), new unicode.Range16.ptr(2305, 2307, 1), new unicode.Range16.ptr(2364, 2364, 1), new unicode.Range16.ptr(2366, 2380, 1), new unicode.Range16.ptr(2381, 2381, 1), new unicode.Range16.ptr(2385, 2388, 1), new unicode.Range16.ptr(2402, 2403, 1), new unicode.Range16.ptr(2406, 2415, 1), new unicode.Range16.ptr(2433, 2435, 1), new unicode.Range16.ptr(2492, 2492, 1), new unicode.Range16.ptr(2494, 2495, 1), new unicode.Range16.ptr(2496, 2500, 1), new unicode.Range16.ptr(2503, 2504, 1), new unicode.Range16.ptr(2507, 2509, 1), new unicode.Range16.ptr(2519, 2519, 1), new unicode.Range16.ptr(2530, 2531, 1), new unicode.Range16.ptr(2534, 2543, 1), new unicode.Range16.ptr(2562, 2620, 58), new unicode.Range16.ptr(2622, 2623, 1), new unicode.Range16.ptr(2624, 2626, 1), new unicode.Range16.ptr(2631, 2632, 1), new unicode.Range16.ptr(2635, 2637, 1), new unicode.Range16.ptr(2662, 2671, 1), new unicode.Range16.ptr(2672, 2673, 1), new unicode.Range16.ptr(2689, 2691, 1), new unicode.Range16.ptr(2748, 2748, 1), new unicode.Range16.ptr(2750, 2757, 1), new unicode.Range16.ptr(2759, 2761, 1), new unicode.Range16.ptr(2763, 2765, 1), new unicode.Range16.ptr(2790, 2799, 1), new unicode.Range16.ptr(2817, 2819, 1), new unicode.Range16.ptr(2876, 2876, 1), new unicode.Range16.ptr(2878, 2883, 1), new unicode.Range16.ptr(2887, 2888, 1), new unicode.Range16.ptr(2891, 2893, 1), new unicode.Range16.ptr(2902, 2903, 1), new unicode.Range16.ptr(2918, 2927, 1), new unicode.Range16.ptr(2946, 2947, 1), new unicode.Range16.ptr(3006, 3010, 1), new unicode.Range16.ptr(3014, 3016, 1), new unicode.Range16.ptr(3018, 3021, 1), new unicode.Range16.ptr(3031, 3031, 1), new unicode.Range16.ptr(3047, 3055, 1), new unicode.Range16.ptr(3073, 3075, 1), new unicode.Range16.ptr(3134, 3140, 1), new unicode.Range16.ptr(3142, 3144, 1), new unicode.Range16.ptr(3146, 3149, 1), new unicode.Range16.ptr(3157, 3158, 1), new unicode.Range16.ptr(3174, 3183, 1), new unicode.Range16.ptr(3202, 3203, 1), new unicode.Range16.ptr(3262, 3268, 1), new unicode.Range16.ptr(3270, 3272, 1), new unicode.Range16.ptr(3274, 3277, 1), new unicode.Range16.ptr(3285, 3286, 1), new unicode.Range16.ptr(3302, 3311, 1), new unicode.Range16.ptr(3330, 3331, 1), new unicode.Range16.ptr(3390, 3395, 1), new unicode.Range16.ptr(3398, 3400, 1), new unicode.Range16.ptr(3402, 3405, 1), new unicode.Range16.ptr(3415, 3415, 1), new unicode.Range16.ptr(3430, 3439, 1), new unicode.Range16.ptr(3633, 3633, 1), new unicode.Range16.ptr(3636, 3642, 1), new unicode.Range16.ptr(3654, 3654, 1), new unicode.Range16.ptr(3655, 3662, 1), new unicode.Range16.ptr(3664, 3673, 1), new unicode.Range16.ptr(3761, 3761, 1), new unicode.Range16.ptr(3764, 3769, 1), new unicode.Range16.ptr(3771, 3772, 1), new unicode.Range16.ptr(3782, 3782, 1), new unicode.Range16.ptr(3784, 3789, 1), new unicode.Range16.ptr(3792, 3801, 1), new unicode.Range16.ptr(3864, 3865, 1), new unicode.Range16.ptr(3872, 3881, 1), new unicode.Range16.ptr(3893, 3897, 2), new unicode.Range16.ptr(3902, 3903, 1), new unicode.Range16.ptr(3953, 3972, 1), new unicode.Range16.ptr(3974, 3979, 1), new unicode.Range16.ptr(3984, 3989, 1), new unicode.Range16.ptr(3991, 3991, 1), new unicode.Range16.ptr(3993, 4013, 1), new unicode.Range16.ptr(4017, 4023, 1), new unicode.Range16.ptr(4025, 4025, 1), new unicode.Range16.ptr(8400, 8412, 1), new unicode.Range16.ptr(8417, 12293, 3876), new unicode.Range16.ptr(12330, 12335, 1), new unicode.Range16.ptr(12337, 12341, 1), new unicode.Range16.ptr(12441, 12442, 1), new unicode.Range16.ptr(12445, 12446, 1), new unicode.Range16.ptr(12540, 12542, 1)]), sliceType$2.nil, 0);
		esc_quot = (new sliceType($stringToBytes("&#34;")));
		esc_apos = (new sliceType($stringToBytes("&#39;")));
		esc_amp = (new sliceType($stringToBytes("&amp;")));
		esc_lt = (new sliceType($stringToBytes("&lt;")));
		esc_gt = (new sliceType($stringToBytes("&gt;")));
		esc_tab = (new sliceType($stringToBytes("&#x9;")));
		esc_nl = (new sliceType($stringToBytes("&#xA;")));
		esc_cr = (new sliceType($stringToBytes("&#xD;")));
		esc_fffd = (new sliceType($stringToBytes("\xEF\xBF\xBD")));
		cdataStart = (new sliceType($stringToBytes("<![CDATA[")));
		cdataEnd = (new sliceType($stringToBytes("]]>")));
		cdataEscape = (new sliceType($stringToBytes("]]]]><![CDATA[>")));
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/empijei/identigen/identities/lists"] = (function() {
	var $pkg = {}, $init, Bank, Branch, City, sliceType, sliceType$1, sliceType$2, structType, sliceType$3, sliceType$4;
	Bank = $pkg.Bank = $newType(0, $kindStruct, "lists.Bank", true, "github.com/empijei/identigen/identities/lists", true, function(Name_, Branches_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = "";
			this.Branches = sliceType$1.nil;
			return;
		}
		this.Name = Name_;
		this.Branches = Branches_;
	});
	Branch = $pkg.Branch = $newType(0, $kindStruct, "lists.Branch", true, "github.com/empijei/identigen/identities/lists", true, function(ABI_, CAB_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.ABI = "";
			this.CAB = sliceType$2.nil;
			return;
		}
		this.ABI = ABI_;
		this.CAB = CAB_;
	});
	City = $pkg.City = $newType(0, $kindStruct, "lists.City", true, "github.com/empijei/identigen/identities/lists", true, function(Code_, Name_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Code = 0;
			this.Name = "";
			return;
		}
		this.Code = Code_;
		this.Name = Name_;
	});
	sliceType = $sliceType(Bank);
	sliceType$1 = $sliceType(Branch);
	sliceType$2 = $sliceType($String);
	structType = $structType("", [{prop: "CodiceCatasto", name: "CodiceCatasto", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Paese", name: "Paese", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Provincia", name: "Provincia", anonymous: false, exported: true, typ: $String, tag: ""}]);
	sliceType$3 = $sliceType(structType);
	sliceType$4 = $sliceType(City);
	Bank.init("", [{prop: "Name", name: "Name", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Branches", name: "Branches", anonymous: false, exported: true, typ: sliceType$1, tag: ""}]);
	Branch.init("", [{prop: "ABI", name: "ABI", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "CAB", name: "CAB", anonymous: false, exported: true, typ: sliceType$2, tag: ""}]);
	City.init("", [{prop: "Code", name: "Code", anonymous: false, exported: true, typ: $Int, tag: ""}, {prop: "Name", name: "Name", anonymous: false, exported: true, typ: $String, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$pkg.Banks = new sliceType([new Bank.ptr("Banca Nazionale del Lavoro Spa a Venezia (VE)", new sliceType$1([new Branch.ptr("01005", new sliceType$2(["02002", "02007", "02196", "02000", "02004", "02046", "02008", "02001", "02005", "02009", "02045"]))])), new Bank.ptr("Banca Popolare di Vicenza SCpA a Venezia (VE)", new sliceType$1([new Branch.ptr("05728", new sliceType$2(["02003", "02000", "02004", "02001", "02002", "02001"]))])), new Bank.ptr("Unicredit SpA a Trieste (TS)", new sliceType$1([new Branch.ptr("02008", new sliceType$2(["02239", "02398", "02215", "02230", "02234", "02210", "02237", "02200", "02228", "02241", "02217", "02242", "02397", "02208", "02219", "02205", "02244", "02218", "02263", "02223", "02224", "02204", "02203", "02290", "02209", "02213", "02225", "02216", "02212", "02292", "02201", "02206", "02243"]))])), new Bank.ptr("Banca Popolare di Vicenza SCpA a Trieste (TS)", new sliceType$1([new Branch.ptr("05728", new sliceType$2(["02206", "02200", "02201", "02202", "02204", "02203", "02205"]))])), new Bank.ptr("Unicredit SpA a Verona (VR)", new sliceType$1([new Branch.ptr("02008", new sliceType$2(["11733", "11756", "11712", "11705", "11710", "11757", "11770", "11736", "11794", "11750", "11725", "11739", "11744", "11713", "11718", "11740", "11732", "11708", "11734", "11704", "11782", "11730", "11772", "11707", "11758", "11724", "11709", "11720", "11746", "11764", "11773", "11795", "11796", "11727", "11738", "11715", "11741", "11723", "11728", "11717", "11711", "11706", "11714"]))])), new Bank.ptr("Banca Popolare di Vicenza SCpA a Verona (VR)", new sliceType$1([new Branch.ptr("05728", new sliceType$2(["11701", "11703", "11706", "11705", "11704", "11707", "11702", "11700"]))])), new Bank.ptr("Banca Nazionale del Lavoro Spa a Torino (TO)", new sliceType$1([new Branch.ptr("01005", new sliceType$2(["01000", "01002", "01170", "01001", "01014", "01019", "01016", "01004", "01010", "01199", "01020", "01013", "01177", "01006", "01017", "01022", "01009", "01005", "01012", "01007", "01021", "01011", "01008", "10181", "01003"]))])), new Bank.ptr("Banca Monte dei Paschi di Siena SpA a Torino (TO)", new sliceType$1([new Branch.ptr("01030", new sliceType$2(["01002", "01014", "01019", "01015", "01000", "01196", "01004", "01011", "01028", "01001", "01005", "01012", "01024", "01007", "01006", "01017", "01003", "01020"]))])), new Bank.ptr("Unicredit SpA a Torino (TO)", new sliceType$1([new Branch.ptr("02008", new sliceType$2(["01137", "09200", "01150", "01140", "01046", "01174", "01003", "01144", "01044", "01152", "01104", "01102", "01007", "01051", "01085", "01133", "01154", "01136", "01058", "01008", "01098", "01048", "01084", "01070", "01005", "01130", "01024", "01099", "01177", "01107", "01018", "01184", "01180", "01178", "09202", "01114", "01135", "01138", "01006", "01105", "01171", "01115", "01160", "01113", "01021", "01055", "01117", "01059", "01016", "01073", "01141", "01125", "01065", "01013", "01184", "01166", "01145", "01064", "01028", "01116", "01019", "01132", "01074", "01161", "01118", "01168", "01014", "01078", "01159", "01025", "01131", "01069", "01001", "01106", "01029", "01004", "01112", "01172", "01072", "01167", "01126", "01110", "01122", "01054", "01057", "01127", "01108", "01089", "01119", "01027", "01047", "01134", "01012", "01011", "01030", "01020", "01031", "01067", "01009", "01109", "01022", "01124", "01143", "01111", "01015", "01060", "01123"]))])), new Bank.ptr("Intesa Sanpaolo SpA a Torino (TO)", new sliceType$1([new Branch.ptr("03069", new sliceType$2(["01000", "09213", "01170", "09217", "01174", "01156", "01005", "01036", "01149", "09299", "09208", "01002", "01050", "01006", "01081", "01178", "09204", "01172", "09219", "01077", "09212", "09298", "01030", "01001", "01024", "01008", "01053", "01083", "01033", "01011", "01058", "01164", "01169", "01171", "09214", "01070", "09231", "01152", "09209", "01044", "01064", "09200", "01109", "01080", "01084", "01076", "01142", "09233", "01019", "01004", "01072", "09210", "01040", "09207", "01026", "01079", "01003", "01048", "01160", "01082", "01095", "01101", "01165", "01047", "01094", "01021", "01078", "01012", "01009", "01134", "01014", "01028", "01032", "01029", "01125", "01167", "09202", "01043", "01020", "01188", "01007", "01148", "01027", "01035"]))])), new Bank.ptr("Banca Popolare di Milano Scarl a Torino (TO)", new sliceType$1([new Branch.ptr("05584", new sliceType$2(["01000", "01004", "01002", "01003", "01001"]))])), new Bank.ptr("Cassa di Risparmio di Parma e Piacenza SpA a Torino (TO)", new sliceType$1([new Branch.ptr("06230", new sliceType$2(["01001", "01144", "01123", "01010", "01146", "01013", "01126", "01145", "01059", "01124", "01128", "01137", "01002", "01003", "01132", "01130", "01131", "01005", "01022", "01018", "01127", "01140", "01006"]))])), new Bank.ptr("Banca Popolare di Milano Scarl a Alessandria (AL)", new sliceType$1([new Branch.ptr("05584", new sliceType$2(["10410", "10406", "10414", "10407", "10412", "10405", "10400", "10402", "10403", "10404", "10463", "10452", "10426", "10401"]))])), new Bank.ptr("Intesa Sanpaolo SpA a Brescia (BS)", new sliceType$1([new Branch.ptr("03069", new sliceType$2(["11201", "11239", "11210", "11215", "11237", "11236", "11297", "11200", "11219", "11205", "11235"]))])), new Bank.ptr("Banca Popolare di Vicenza SCpA a Brescia (BS)", new sliceType$1([new Branch.ptr("05728", new sliceType$2(["11296", "11200", "11219", "11203", "11202", "11206", "11204", "11241", "11205"]))])), new Bank.ptr("Cassa di Risparmio di Parma e Piacenza SpA a Piacenza (PC)", new sliceType$1([new Branch.ptr("06230", new sliceType$2(["12611", "12607", "12604", "12609", "12610", "12605", "12608", "12614", "12606", "12601", "12613", "12612", "12699"]))])), new Bank.ptr("Banca Nazionale del Lavoro Spa a Bari (BA)", new sliceType$1([new Branch.ptr("01005", new sliceType$2(["04000", "04016", "04008", "04004", "04015", "04001", "04199", "04011", "04010", "04006", "04002", "04003", "04017", "04005", "04007", "04013", "04014"]))])), new Bank.ptr("Banco di Napoli SpA a Bari (BA)", new sliceType$1([new Branch.ptr("01010", new sliceType$2(["04023", "04046", "04025", "04004", "04018", "04015", "04051", "04099", "04005", "04045", "04047", "04006", "04053", "04048", "04024", "04016", "40291", "04041", "04043", "04028", "04014", "04002", "04049", "04009", "04010"]))])), new Bank.ptr("Unicredit SpA a Modena (MO)", new sliceType$1([new Branch.ptr("02008", new sliceType$2(["12916", "12914", "12905", "12903", "12909", "12917", "12923", "12935", "12900", "12932", "12913", "12915", "12931", "12911", "12908", "12902", "12940", "12930", "12906", "12933", "12907", "12904", "12910", "12920", "12925", "12938", "12930", "12926", "12927", "12924"]))])), new Bank.ptr("Banca Nazionale del Lavoro Spa a Bologna (BO)", new sliceType$1([new Branch.ptr("01005", new sliceType$2(["02400", "02599", "02403", "02400", "02408", "02404", "02402", "02412", "02410", "02411", "02407", "02598", "02406"]))])), new Bank.ptr("Banca Monte dei Paschi di Siena SpA a Bologna (BO)", new sliceType$1([new Branch.ptr("01030", new sliceType$2(["02408", "02432", "02400", "02410", "02430", "02431", "02474", "02402", "02418", "02436", "02401", "02417", "02419", "02404", "02433", "02594", "02406", "02435", "02403"]))])), new Bank.ptr("Unicredit SpA a Bologna (BO)", new sliceType$1([new Branch.ptr("02008", new sliceType$2(["02513", "02450", "02435", "02445", "02447", "02413", "02515", "02432", "02517", "02459", "02484", "02520", "02430", "02514", "02457", "02480", "02455", "02434", "02505", "02509", "02422", "02428", "02460", "02408", "02466", "02411", "02416", "02462", "02417", "02464", "02463", "02423", "02486", "02487", "02485", "02438", "02446", "02470", "02456", "02402", "02467", "02481", "02412", "02468", "02452", "02431", "02409", "02451", "02410", "02415", "02474", "02458", "02483", "02439", "02404", "02453", "02461", "02414"]))])), new Bank.ptr("Banca Popolare di Milano Scarl a Bologna (BO)", new sliceType$1([new Branch.ptr("05584", new sliceType$2(["02403", "02406", "02401", "02402", "02409", "02404", "02407", "02412", "02422", "02405", "02416", "02424", "02417", "02421", "02420", "02423", "02415"]))])), new Bank.ptr("Cassa di Risparmio di Parma e Piacenza SpA a Bologna (BO)", new sliceType$1([new Branch.ptr("06230", new sliceType$2(["02460", "02420", "02402", "02410", "02452", "02459", "02409"]))])), new Bank.ptr("Cassa di Risparmio di Parma e Piacenza SpA a Parma (PR)", new sliceType$1([new Branch.ptr("06230", new sliceType$2(["12783", "12713", "12718", "12725", "12782", "12781", "12780", "12717", "12719", "12795", "12726", "12727", "12715", "12708", "12796", "12710", "12711", "12709", "12701", "12707", "12705", "12702", "12703", "12704", "12700", "12706", "12720"]))])), new Bank.ptr("Banca Nazionale del Lavoro Spa a Milano (MI)", new sliceType$1([new Branch.ptr("01005", new sliceType$2(["01607", "01636", "01606", "01600", "01611", "01642", "01608", "01773", "01631", "01616", "01630", "01641", "01603", "01640", "01644", "01614", "01601", "01646", "01637", "01635", "01634", "01619", "01629", "01605", "01633", "01602", "01618", "01621", "01623", "01632", "01604", "01620", "01615", "01613", "01628", "01643", "01645", "01626", "01660", "01627", "01610", "01622", "01612"]))])), new Bank.ptr("Banca Monte dei Paschi di Siena SpA a Milano (MI)", new sliceType$1([new Branch.ptr("01030", new sliceType$2(["01609", "01661", "01656", "01600", "01629", "01654", "01636", "01669", "01617", "01603", "01630", "01637", "01610", "01601", "01658", "01666", "01605", "01612", "01646", "01606", "01632", "01653", "01608", "01639", "01611", "01663", "01662", "01620", "01655", "01627", "01660", "01635", "01645", "01788", "01615", "01602", "01628", "01650", "01604", "01634", "01616", "01640", "01657", "01633", "01618", "01613", "01664", "01622", "01641", "01614", "01797"]))])), new Bank.ptr("Unicredit SpA a Milano (MI)", new sliceType$1([new Branch.ptr("02008", new sliceType$2(["09429", "09459", "09463", "09412", "01733", "01740", "09431", "09440", "09419", "09436", "09423", "09420", "01670", "01760", "01621", "01737", "01611", "09455", "01603", "01613", "01770", "01612", "09438", "01618", "09433", "01625", "01602", "01775", "09462", "09402", "01699", "09428", "01600", "09461", "01731", "01628", "09430", "09432", "01616", "01614", "01641", "01638", "01680", "01629", "01661", "01758", "01645", "01757", "01633", "09403", "01620", "01744", "01749", "01768", "01623", "01624", "01669", "01778", "01773", "01622", "09434", "01642", "01640", "01743", "01746", "01617", "01682", "09464", "01696", "01781", "01668", "01672", "09446", "01604", "01755", "09408", "01631", "01601", "01667", "01637", "01753", "01646", "01652", "01681", "01671", "01774", "01610", "01606", "01683", "09427", "01632", "01747", "01766", "01673", "01662", "09418", "01615", "01779", "01626", "01664", "01732", "01634", "01653", "09401", "01745", "01767", "01636", "01643", "01730", "09448", "01679", "09465", "01627", "01663", "01650", "01635", "01648", "01659", "01639", "01619", "01647", "01752", "01608", "01748"]))])), new Bank.ptr("Intesa Sanpaolo SpA a Milano (MI)", new sliceType$1([new Branch.ptr("03069", new sliceType$2(["01706", "01783", "01616", "01798", "09595", "09797", "09431", "09492", "09571", "09579", "09400", "09441", "09784", "09477", "09780", "01722", "01773", "09434", "09420", "09483", "09793", "01641", "09526", "09454", "01680", "09478", "01626", "01757", "09460", "01771", "01629", "09788", "09458", "01642", "01631", "01669", "09790", "09465", "01695", "09548", "09710", "09432", "09443", "09473", "09599", "01762", "09484", "09573", "09532", "09495", "09533", "09513", "09791", "09530", "01601", "01766", "01738", "09536", "01604", "09451", "01775", "01687", "09436", "09459", "09479", "01612", "09583", "01787", "09509", "09551", "01765", "01685", "09794", "09537", "09528", "09589", "09498", "09543", "09590", "01749", "09520", "09463", "09450", "01777", "09471", "09752", "09445", "09564", "09502", "09547", "09550", "09552", "01674", "09553", "09531", "01770", "09541", "09507", "09567", "09525", "01736", "09521", "09545", "01772", "09554", "09523", "01614", "09540", "09469", "09448", "01628", "09457", "09506", "01617", "01645", "09524", "09515", "09496", "09542", "01602", "01767", "09587", "09565", "09501", "01686", "09563", "09534", "09569", "09591", "01603", "09557", "09508", "09511", "09559", "09576", "09586", "09556", "01620", "01799", "09462", "09504", "09546", "09578", "09544", "09796", "09505", "01605", "09518", "09474", "09561", "09468", "09489", "09456", "09558"]))])), new Bank.ptr("Banca Popolare di Milano Scarl a Milano (MI)", new sliceType$1([new Branch.ptr("05584", new sliceType$2(["01600", "01600", "01616", "01610", "01730", "01621", "01701", "01603", "01700", "01604", "01607", "01660", "01602", "01609", "01626", "01604", "01661", "01630", "01714", "01629", "01706", "01719", "01651", "01670", "01715", "01642", "01704", "01608", "01623", "01655", "01639", "01667", "01712", "01613", "01601", "01659", "01633", "01637", "01703", "01605", "01603", "01702", "01636", "01612", "01654", "01632", "01673", "01662", "01624", "01620", "01718", "01658", "01648", "01643", "01625", "01682", "01681", "01679", "01672", "01611", "01797", "01664", "01641", "01705", "01634", "01686", "01627", "01653", "01722", "01665", "01652", "01666", "01628", "01708", "01657", "01676", "01601", "01717", "01798", "01663", "01606", "01675", "01638", "01649", "01617", "01709", "01644", "01794", "01614", "01656", "01713", "01716", "01640", "01645", "01707", "01631", "01619", "01721", "01602", "01615", "01669", "01668"]))])), new Bank.ptr("Banca Popolare di Vicenza SCpA a Milano (MI)", new sliceType$1([new Branch.ptr("05728", new sliceType$2(["01608", "01600", "01617", "01607", "01601", "01789", "01604", "01606", "01602", "01605", "01659"]))])), new Bank.ptr("Cassa di Risparmio di Parma e Piacenza SpA a Milano (MI)", new sliceType$1([new Branch.ptr("06230", new sliceType$2(["01631", "01600", "09480", "01623", "01682", "01629", "09503", "09487", "01627", "09486", "01621", "01653", "01606", "09494", "09512", "09455", "01799", "09562", "09490", "01602", "01619", "01624", "01656", "09555", "01632", "01655", "09582", "09798", "09449", "01658", "01620", "09467", "01622", "01746", "09572", "01657", "01625", "01630", "01628"]))])), new Bank.ptr("Banco di Napoli SpA a Foggia (FG)", new sliceType$1([new Branch.ptr("01010", new sliceType$2(["15715", "15700", "15705", "15703", "15713", "15709", "15712", "15720", "15706"]))])), new Bank.ptr("Banca Nazionale del Lavoro Spa a Palermo (PA)", new sliceType$1([new Branch.ptr("01005", new sliceType$2(["46086", "04605", "04675", "04602", "04600", "04773", "04610", "04676", "04603", "04606", "04611", "04601", "46094", "04604"]))])), new Bank.ptr("Banca Monte dei Paschi di Siena SpA a Palermo (PA)", new sliceType$1([new Branch.ptr("01030", new sliceType$2(["04604", "04607", "04614", "04615", "04602", "04610", "04616", "04667", "04600", "04606", "04611", "04608", "04603", "04799", "04613", "04601", "04609", "04605"]))])), new Bank.ptr("Unicredit SpA a Palermo (PA)", new sliceType$1([new Branch.ptr("02008", new sliceType$2(["04620", "04694", "04670", "04679", "04631", "04671", "04636", "04666", "04629", "04656", "04622", "04612", "04623", "04691", "04682", "04689", "04672", "04700", "04698", "04650", "04609", "04692", "04657", "04690", "04637", "04624", "04664", "04648", "04686", "04613", "04685", "04688", "04642", "04676", "04615", "04697", "04617", "04696", "04610", "04600", "04659", "04618", "04616", "04638", "04630", "04621", "04667", "04652", "04653", "04619", "04674", "04662", "04677", "04632", "04628", "04686", "04635", "04668", "04614", "04660", "04627", "04644", "04611", "04626"]))])), new Bank.ptr("Intesa Sanpaolo SpA a Palermo (PA)", new sliceType$1([new Branch.ptr("03069", new sliceType$2(["04799", "04606", "04627", "04600", "04603", "04613", "04618", "04639", "04655", "04637", "04630", "04621", "04601", "04638", "04607", "04617", "04602", "04632", "04620", "04610", "04619", "04623", "04604", "04612", "04605", "04616"]))])), new Bank.ptr("Banca Nazionale del Lavoro Spa a Napoli (NA)", new sliceType$1([new Branch.ptr("01005", new sliceType$2(["03400", "03416", "03407", "03417", "03415", "03422", "03411", "03433", "03408", "03412", "03414", "03406", "03421", "03413", "03403", "03404", "03410", "03400", "03405", "03402", "03401"]))])), new Bank.ptr("Banco di Napoli SpA a Napoli (NA)", new sliceType$1([new Branch.ptr("01010", new sliceType$2(["03411", "03518", "03497", "03427", "03433", "03495", "03488", "03443", "03442", "03452", "03417", "03491", "03468", "03482", "03418", "03453", "03481", "03436", "03459", "03444", "03434", "03460", "03522", "03493", "03446", "03422", "03447", "03404", "03429", "03478", "03489", "03514", "03445", "03458", "03441", "03595", "03435", "03438", "03400", "03424", "03408", "03428", "03477", "03490", "03515", "03439", "03401", "03430", "03425", "03414", "03471", "03431", "03486", "03450", "03419", "03403", "03420", "03464", "03406", "03405", "03496", "03599", "03416", "03423", "03596", "03500", "03448", "03415", "03494", "03437", "03412", "03523", "03511", "03451", "03407", "03410", "03492", "03484"]))])), new Bank.ptr("Banca Monte dei Paschi di Siena SpA a Napoli (NA)", new sliceType$1([new Branch.ptr("01030", new sliceType$2(["03409", "03420", "03479", "03424", "03406", "03430", "03428", "03411", "03418", "03405", "03427", "03407", "03410", "03416", "03432", "03401", "03425", "03400", "03402", "03421", "03415", "03403", "03408", "03412", "03404", "03413", "03414", "03598"]))])), new Bank.ptr("Unicredit SpA a Napoli (NA)", new sliceType$1([new Branch.ptr("02008", new sliceType$2(["03466", "03428", "03433", "03440", "03476", "03435", "03479", "03445", "03481", "03446", "03460", "03478", "03473", "03469", "03464", "03426", "03477", "03465", "03454", "03441", "03437", "03450", "03483", "03462", "03434", "03442", "03493", "03443", "03475", "03484", "03438", "03474", "03427", "03431", "03495", "03436", "03449", "03451", "03444", "03452", "03455", "03457", "03447", "03456", "03453", "03463", "03458", "03467", "03470", "03461", "03420", "03459", "03471"]))])), new Bank.ptr("Cassa di Risparmio di Parma e Piacenza SpA a Napoli (NA)", new sliceType$1([new Branch.ptr("06230", new sliceType$2(["03549", "03535", "03417", "03510", "03539", "03559", "03424", "03419", "03531", "03546", "03555", "03557", "03541", "03413", "03420", "03547", "03551", "03538", "03543", "03536", "03544", "03542", "03418", "03545", "03537", "03415", "03458"]))])), new Bank.ptr("Banco di Napoli SpA a Taranto (TA)", new sliceType$1([new Branch.ptr("01010", new sliceType$2(["15809", "15813", "15820", "15812", "15807", "15815", "15804", "15801", "15802"]))])), new Bank.ptr("Banco di Napoli SpA a Salerno (SA)", new sliceType$1([new Branch.ptr("01010", new sliceType$2(["15201", "15208", "15211", "15200", "15202", "15214", "15203", "15209", "15213", "15205"]))])), new Bank.ptr("Banca Nazionale del Lavoro Spa a Roma (RM)", new sliceType$1([new Branch.ptr("01005", new sliceType$2(["03385", "03238", "03347", "03241", "03266", "03315", "03270", "03264", "32839", "03235", "39102", "03286", "03399", "03216", "03234", "03278", "03236", "03297", "03293", "03230", "03223", "03299", "03312", "03209", "03383", "03295", "03289", "03367", "03265", "03218", "03376", "03337", "33084", "03227", "03224", "03232", "03285", "03226", "03310", "03369", "03254", "03214", "03219", "03303", "03304", "03395", "03204", "03228", "03256", "03253", "03300", "03221", "03375", "03341", "03203", "03287", "03271", "03275", "03202", "03345", "03350", "03338", "03282", "03311", "03397", "03302", "03277", "03274", "03276", "03320", "03220", "03229", "03217", "03267", "03250", "03306", "03210", "03396", "03208", "03296", "03386", "03389", "03374", "03248", "03260", "03316", "03371", "03392", "03201", "03211", "03372", "03240", "03394", "03393", "03373", "03215", "03206", "03200", "32847", "03366", "03305", "03244", "03381", "03237", "00000", "03233", "03340", "03249", "03333", "03225", "03268", "03344", "03207", "03339", "03309", "03379", "03242", "03222", "03313", "03342", "03384", "03387", "03231", "03213", "03205", "03239", "03307", "03388", "03255", "03288", "03245", "03212"]))])), new Bank.ptr("Banca Monte dei Paschi di Siena SpA a Roma (RM)", new sliceType$1([new Branch.ptr("01030", new sliceType$2(["03327", "03238", "03208", "03295", "03223", "03380", "03388", "03255", "03245", "03394", "03337", "03381", "03335", "03321", "03237", "03288", "03244", "03325", "03239", "03312", "03225", "03378", "03256", "03218", "03302", "03234", "03309", "03383", "03286", "03205", "03391", "03215", "03221", "03374", "03326", "03319", "03242", "03300", "03211", "03392", "03220", "03322", "03274", "03252", "03318", "03278", "03206", "03219", "03224", "03371", "03269", "03281", "03213", "03222", "03305", "03257", "03240", "03267", "03266", "05109", "03254", "03273", "03216", "03307", "03247", "03303", "03294", "03214", "03282", "03235", "03315", "03287", "03227", "03243", "39550", "03336", "03207", "03284", "03323", "03236", "03384", "03212", "05015", "03387", "03268", "03204", "03317", "03232", "03298", "03202", "03375", "03226", "03241", "03283", "03200", "03301", "03231", "03389", "03250", "03289", "03260", "03251", "03311", "03304", "03293", "03203", "03209", "03271", "03313", "03262", "03233", "03253", "03217", "03201", "03372", "03272", "03263", "05131", "03314", "03324", "03297", "03210", "03285"]))])), new Bank.ptr("Unicredit SpA a Roma (RM)", new sliceType$1([new Branch.ptr("02008", new sliceType$2(["05107", "05138", "05339", "05238", "05243", "05213", "03368", "05231", "05023", "05294", "05023", "05068", "05183", "05153", "05182", "05126", "05185", "05316", "05223", "05224", "05127", "05174", "05073", "05157", "05317", "05047", "05242", "05145", "05359", "05257", "05163", "05044", "05131", "05236", "05013", "05233", "05303", "05265", "05372", "05071", "05247", "05049", "05202", "05028", "05096", "05200", "05284", "05377", "05067", "05142", "05334", "05062", "05225", "05137", "05134", "03285", "05090", "05352", "05297", "05129", "05310", "05085", "05097", "05373", "05198", "05309", "05132", "05026", "05086", "05051", "05333", "05255", "05301", "05144", "03287", "05057", "05270", "05179", "05295", "05276", "05063", "05150", "05304", "05318", "05023", "05315", "05245", "05268", "05140", "05061", "05052", "05251", "05031", "05228", "05216", "05327", "05012", "05319", "05248", "05003", "05053", "05188", "05239", "05226", "05165", "05346", "05192", "05365", "05102", "05173", "05264", "05139", "05379", "05149", "05118", "05104", "05175", "05263", "05252", "05054", "05250", "05336", "05184", "05141", "05089", "05109", "05335", "05371", "05212", "05280", "05111", "05027", "05119", "05105", "05070", "05220", "05344", "05037", "05180", "05161", "05322", "05079", "05034", "05095", "05275", "05124", "05066", "05229", "05078", "05269", "05136", "05148", "05314", "05282", "05235", "05041", "05204", "05273", "05195", "05152", "05083", "05168", "05321", "05267", "05292", "05113", "05355", "05039", "05254", "05253", "05006", "05190", "05043", "05058", "05218", "05222", "05194", "05232", "05046", "05130", "05029", "05286", "05206", "05293", "05160", "05237", "05032", "05378", "05159", "03337", "05302", "05171", "05014", "05093", "05186", "05299", "03277", "05300", "05209", "05009", "05308", "05227", "05203", "05005", "05166", "05022", "05221", "05154", "05205", "05074", "05311", "05181", "05084", "05189", "05087", "05259", "05347", "05147", "05351", "05001", "05172", "05094", "03200", "05364", "05211", "05307", "05082", "05320", "05038", "05156", "05338", "05258", "05075", "03286", "03284", "05030", "05081", "05261", "05312", "05272", "05059", "03377", "05323", "05370", "05278", "05055", "05024", "05162", "05208", "05007", "05340", "05103", "05285", "05214", "05207", "05374", "05008", "05135", "05017", "03298", "05101", "05099", "05110", "05092", "05341", "05167", "05108", "03295", "05133", "05021", "05178", "05114", "05240", "05020", "05122", "05170", "05377", "05143", "05120", "05128", "05056", "03292", "05343", "05283", "05337", "05187", "05040", "05164", "05016", "05098", "05077", "03289", "05121", "03339", "05324", "05219", "05277", "05199"]))])), new Bank.ptr("Intesa Sanpaolo SpA a Roma (RM)", new sliceType$1([new Branch.ptr("03069", new sliceType$2(["03374", "05088", "03212", "05133", "05068", "03220", "05128", "05124", "05161", "03239", "05167", "05045", "05079", "05149", "05002", "03215", "05071", "03225", "05135", "05123", "03312", "05131", "05118", "05061", "03272", "03208", "05099", "03303", "05106", "03202", "05120", "05035", "03317", "03237", "03207", "03257", "03258", "05165", "03214", "05093", "03308", "03398", "03350", "05025", "03392", "03201", "03221", "03344", "05033", "03254", "03231", "03293", "05086", "03273", "05102", "05196", "03345", "05008", "03232", "05136", "05104", "05096", "03256", "05078", "03356", "05050", "05066", "05148", "03281", "05006", "05108", "03396", "05119", "05097", "03245", "03218", "05394", "05052", "05005", "05060", "05064", "05073", "03376", "03206", "05098", "03241", "05163", "05197", "05399", "05046", "03378", "05115", "03222", "05114", "05139", "05058", "05100", "05110", "05138", "03325", "05122", "03342", "03224", "05047", "05116", "05140", "03234", "05137", "03290", "03395", "05004", "03204", "03328", "05080", "03203", "03271", "03298", "03213", "05162", "03299", "05395", "05084", "03267", "03235", "03343", "05020", "05057", "05000", "03240", "03353", "05003", "03200", "03346", "03380", "05036", "03354", "03259", "05090", "03223", "05055", "05141", "03336", "03287", "05091", "05069", "03315", "03248", "03301", "03355", "03216", "03329", "05007", "03388", "05075", "05070", "05077", "05009", "03227", "03286", "03219", "03243", "05042", "05048", "05143", "05087"]))])), new Bank.ptr("Banca Popolare di Milano Scarl a Roma (RM)", new sliceType$1([new Branch.ptr("05584", new sliceType$2(["03229", "03222", "03237", "03260", "03253", "03213", "03245", "03205", "03203", "03259", "03221", "03263", "03204", "03252", "03251", "03217", "03244", "03214", "03202", "03212", "03238", "03206", "03218", "03216", "03257", "03256", "03231", "03239", "03211", "03236", "03250", "03258", "03210", "03207", "03240", "03241", "03226", "03220", "03219", "03233", "03262", "03201", "03398", "03255", "03209", "03243", "03225", "03200", "03249", "03230", "03208", "03235"]))])), new Bank.ptr("Banca Popolare di Vicenza SCpA a Roma (RM)", new sliceType$1([new Branch.ptr("05728", new sliceType$2(["03206", "03207", "03204", "03205", "03208", "03212", "03201", "03210", "03211", "03209", "03202", "03203"]))])), new Bank.ptr("Cassa di Risparmio di Parma e Piacenza SpA a Roma (RM)", new sliceType$1([new Branch.ptr("06230", new sliceType$2(["03295", "03233", "03316", "03208", "03299", "05034", "03205", "05041", "05043", "03216", "03204", "03251", "03210", "05054", "03211", "03326", "03212", "03209", "03341", "03230", "03228", "05038", "05107", "05051", "03375", "03215", "03218", "03200", "05031", "03214", "05072", "03319", "05089", "03202", "05049", "03203", "05065", "03201"]))])), new Bank.ptr("Banco di Napoli SpA a Reggio Calabria (RC)", new sliceType$1([new Branch.ptr("01010", new sliceType$2(["16307", "16321", "16308", "16306", "16302", "16320", "16300", "16399", "16301", "16324", "16311"]))])), new Bank.ptr("Banca Monte dei Paschi di Siena SpA a Catania (CT)", new sliceType$1([new Branch.ptr("01030", new sliceType$2(["16915", "16995", "16908", "16916", "16909", "16910", "16905", "16918", "16919", "16900", "16913", "16920", "16914", "16902", "16917", "16997"]))])), new Bank.ptr("Intesa Sanpaolo SpA a Catania (CT)", new sliceType$1([new Branch.ptr("03069", new sliceType$2(["16927", "16924", "16923", "16904", "16901", "16915", "16905", "16906", "16900", "16910", "16920"]))])), new Bank.ptr("Intesa Sanpaolo SpA a Bergamo (BG)", new sliceType$1([new Branch.ptr("03069", new sliceType$2(["11119", "11100", "11130", "11150", "11104", "11116", "11105", "11121", "11113", "11118", "11106", "11117"]))])), new Bank.ptr("Banca Monte dei Paschi di Siena SpA a Padova (PD)", new sliceType$1([new Branch.ptr("01030", new sliceType$2(["12120", "12191", "12153", "12150", "12116", "12197", "12112", "12121", "12107", "12157", "12198", "12194", "12186", "12101", "12108", "12124", "12130", "12103", "12111", "12156", "12185", "12106", "12132", "12105", "12159", "12193", "12184", "12104", "12199", "12181", "12126", "12158", "12115", "12190", "12189", "12195", "12180", "12114", "12125"]))])), new Bank.ptr("Banca Nazionale del Lavoro Spa a Firenze (FI)", new sliceType$1([new Branch.ptr("01005", new sliceType$2(["02802", "29983", "02970", "02810", "02817", "02800", "02801", "02819", "02805", "02804", "02807", "02816", "02997", "02811", "02971", "02815", "02803", "02818", "02814"]))])), new Bank.ptr("Banca Monte dei Paschi di Siena SpA a Firenze (FI)", new sliceType$1([new Branch.ptr("01030", new sliceType$2(["02804", "02859", "02828", "02836", "02817", "02827", "02831", "02834", "02800", "02809", "02823", "02829", "02802", "02861", "02843", "02869", "02814", "02821", "02833", "02818", "02847", "02844", "02851", "02868", "02999", "02846", "02808", "02870", "02822", "02841", "02803", "02879", "02858", "02840", "02837", "02806", "02857", "02811", "02842", "02801", "02810", "02850", "02866", "02867", "02812", "02865", "02854", "02860", "02816", "02862", "02832", "02807", "02845", "02825", "02864"]))])), new Bank.ptr("Banca Popolare di Milano Scarl a Firenze (FI)", new sliceType$1([new Branch.ptr("05584", new sliceType$2(["02800", "02801", "02802", "02803", "02804"]))])), new Bank.ptr("Banca Popolare di Vicenza SCpA a Firenze (FI)", new sliceType$1([new Branch.ptr("05728", new sliceType$2(["02803", "02801", "02806", "02805", "02804", "02877"]))])), new Bank.ptr("Cassa di Risparmio di Parma e Piacenza SpA a Firenze (FI)", new sliceType$1([new Branch.ptr("06230", new sliceType$2(["02806", "02802", "02845", "02843", "02804", "02811", "02812", "02807", "02803", "02800", "02805", "02831", "02999", "02848", "02801"]))])), new Bank.ptr("Banca Nazionale del Lavoro Spa a Genova (GE)", new sliceType$1([new Branch.ptr("01005", new sliceType$2(["01403", "01400", "01407", "01404", "01405", "01577", "01408", "01597", "01402", "01406", "01401", "01443", "01410", "01412", "01576", "01409", "01413", "01411"]))])), new Bank.ptr("Unicredit SpA a Genova (GE)", new sliceType$1([new Branch.ptr("02008", new sliceType$2(["01464", "01400", "01435", "01470", "01471", "01497", "01468", "01411", "01452", "01419", "01412", "01458", "01426", "01459", "01420", "01408", "01409", "01448", "01596", "01415", "01401", "01454", "01496", "01403", "01463", "01404", "01437", "01425", "01414", "01447", "01423", "01428", "01595", "01467", "01429", "01438", "01462", "01444", "01405", "01432", "01597", "01424", "01439", "01422", "01465", "01441", "01436", "01431", "01498", "01440", "01450", "01433"]))])), new Bank.ptr("Intesa Sanpaolo SpA a Genova (GE)", new sliceType$1([new Branch.ptr("03069", new sliceType$2(["01593", "01400", "01452", "01481", "01460", "01594", "01420", "01403", "01423", "01402", "01406", "01440", "01409", "01410", "01437", "01412", "01439", "01496", "01489", "01436", "01413", "01404", "01484", "01405", "01445", "01401", "01455", "01432", "01407", "01595", "01456", "01433", "01427", "01408", "01434", "01416", "01458", "01450", "01431", "01441"]))])), new Bank.ptr("Cassa di Risparmio di Parma e Piacenza SpA a Genova (GE)", new sliceType$1([new Branch.ptr("06230", new sliceType$2(["01494", "01486", "01488", "01485", "01457", "01438"]))]))]);
		$pkg.Addresses = $makeMap($String.keyFor, [{ k: "Torino", v: "Piazza Castello, 15, 10124 Torino TO, Italia" }, { k: "Vercelli-Biella", v: "Piazza Cesare Battisti, 6, 13100 Vercelli VC, Italia" }, { k: "Novara-Verbania", v: "Corso Felice Cavallotti, 1, 28100 Novara NO, Italia" }, { k: "Cuneo", v: "Corso Nizza, 48, 12100 Cuneo CN, Italia" }, { k: "Asti", v: "Corso Dante Alighieri, 5, 14100 Asti AT, Italia" }, { k: "Alessandria", v: "Spalto Borgoglio, 2, 15121 Alessandria AL, Italia" }, { k: "Aosta", v: "Viale Partigiani, 4, 11100 Aosta AO, Italia" }, { k: "Imperia", v: "Via Ospedale, 31, 18100 Imperia IM, Italia" }, { k: "Savona", v: "Via Cristoforo Astengo, 50, 17100 Savona SV, Italia" }, { k: "Genova", v: "Piazza Giuseppe Verdi, 400, 16121 Genova GE, Italia" }, { k: "La Spezia", v: "Viale Italia, 12, 19121 La Spezia SP, Italia" }, { k: "Varese", v: "Via Cesare Battisti, 1, 21100 Varese VA, Italia" }, { k: "Como-Lecco", v: "Via dei Mille, 20, 22100 Como CO, Italia" }, { k: "Sondrio", v: "Via Pelosi, 3, 23100 Sondrio SO, Italia" }, { k: "Milano-Lodi", v: "Via Dante, 1, 20121 Milano MI, Italia" }, { k: "Bergamo", v: "Via G. Camozzi, 127, 24121 Bergamo BG, Italia" }, { k: "Brescia", v: "Via dei Mille, 5, 25122 Brescia BS, Italia" }, { k: "Pavia", v: "Corso Giuseppe Mazzini, 11, 27100 Pavia PV, Italia" }, { k: "Cremona", v: "Via Brescia, 54c, 26100 Cremona CR, Italia" }, { k: "Mantova", v: "Corso della Libert\xC3\xA0, 17, 46100 Mantova MN, Italia" }, { k: "Bolzano", v: "Via della Mostra, 8, 39100 Bolzano BZ, Italia" }, { k: "Trento", v: "Via Giovanni Segantini, 18, 38121 Trento TN, Italia" }, { k: "Verona", v: "Via Roma, 1, 37121 Verona VR, Italia" }, { k: "Vicenza", v: "Viale Giuseppe Mazzini, 5, 36100 Vicenza VI, Italia" }, { k: "Belluno", v: "Via Attilio Tissi, 29, 32100 Belluno BL, Italia" }, { k: "Treviso", v: "Piazza Duomo, 3, 31100 Treviso TV, Italia" }, { k: "Venezia", v: "Ponte della Libert\xC3\xA0, 302A, 30135 Venezia VE, Italia" }, { k: "Padova", v: "Via Daniele Manin, 1, 35122 Padova PD, Italia" }, { k: "Rovigo", v: "Viale Regina Margherita, 41, 45100 Rovigo RO, Italia" }, { k: "Udine", v: "Viale S. Daniele, 92, 33100 Udine UD, Italia" }, { k: "Gorizia", v: "Viale XXIV Maggio, 20, 34170 Gorizia GO, Italia" }, { k: "Trieste", v: "Corso Umberto Saba, 1, 34122 Trieste TS, Italia" }, { k: "Piacenza", v: "Viale Palmerio Raimondo, 4, 29121 Piacenza PC, Italia" }, { k: "Parma", v: "Piazza Giuseppe Garibaldi, 12, 43121 Parma PR, Italia" }, { k: "Reggio Emilia", v: "Via Emilia Santo Stefano, 6, 42121 Reggio Emilia RE, Italia" }, { k: "Modena", v: "Via Emilia, 207, 41121 Modena MO, Italia" }, { k: "Bologna", v: "Via dell'Indipendenza, 1, 40125 Bologna BO, Italia" }, { k: "Ferrara", v: "Largo Castello, 1, 44121 Ferrara FE, Italia" }, { k: "Ravenna", v: "Via di Roma, 164, 48121 Ravenna RA, Italia" }, { k: "Forl\xC3\xAC-Rimini", v: "Piazza Saffi Aurelio, 8, 47121 Forl\xC3\xAC FC, Italia" }, { k: "Pesaro", v: "Largo Aldo Moro, 12, 61121 Pesaro PU, Italia" }, { k: "Ancona", v: "Via Palestro, 20, 60122 Ancona AN, Italia" }, { k: "Macerata", v: "Viale Trieste, 9, 62100 Macerata MC, Italia" }, { k: "Ascoli Piceno", v: "Via Dino Angelini, 147, 63100 Ascoli Piceno AP, Italia" }, { k: "Massa Carrara", v: "Via Saldina, 7, 54011 Saldina MS, Italia" }, { k: "Lucca", v: "Via Roma, 5, 55100 Lucca LU, Italia" }, { k: "Pistoia", v: "Via Sergio Sacconi, 19, 51100 Pistoia PT, Italia" }, { k: "Firenze", v: "Via dei Calzaiuoli, 50122 Firenze FI, Italia" }, { k: "Livorno", v: "Via dei Lanzi, 1, 57123 Livorno LI, Italia" }, { k: "Pisa", v: "Via Contessa Matilde, 1, 56126 Pisa PI, Italia" }, { k: "Arezzo", v: "Via Giuseppe Garibaldi, 94, 52100 Arezzo AR, Italia" }, { k: "Siena", v: "Via di Citt\xC3\xA0, 36, 53100 Siena SI, Italia" }, { k: "Grosseto", v: "Piazza Fratelli Rosselli, 16, 58100 Grosseto GR, Italia" }, { k: "Perugia", v: "Via Giuseppe Mazzini, 15, 06121 Perugia PG, Italia" }, { k: "Terni", v: "Via Carducci, 7, 05100 Terni TR, Italia" }, { k: "Viterbo", v: "Piazza Giuseppe Verdi, 2, 01100 Viterbo VT, Italia" }, { k: "Rieti", v: "Viale Emilio Maraini, 02100 Rieti RI, Italia" }, { k: "Roma", v: "Piazza della Repubblica, 10, 00185 Roma RM, Italia" }, { k: "Latina", v: "Piazza del Popolo, 1, 04100 Latina LT, Italia" }, { k: "Frosinone", v: "Via Aldo Moro, 243, 03100 Frosinone FR, Italia" }, { k: "Caserta", v: "Piazza S. Sebastiano, 5, 81100 Caserta CE, Italia" }, { k: "Benevento", v: "Viale dei Rettori, 9, 82100 Benevento BN, Italia" }, { k: "Napoli", v: "Corso Giuseppe Garibaldi, 1115, 80142 Napoli NA, Italia" }, { k: "Avellino", v: "Via Malta, 16, 83100 Avellino AV, Italia" }, { k: "Salerno", v: "Corso Vittorio Emanuele, 230, 84100 Salerno SA, Italia" }, { k: "L'Aquila", v: "Corso Vittorio Emanuele, 60, 67100 L'Aquila AQ, Italia" }, { k: "Teramo", v: "Corso S. Giorgio, 4, 64100 Teramo TE, Italia" }, { k: "Pescara", v: "Via Firenze, 6, 65126 Pescara PE, Italia" }, { k: "Chieti", v: "Via Asinio Herio, 101, 66100 Chieti CH, Italia" }, { k: "Campobasso", v: "Corso Giuseppe Mazzini, 33, 86100 Campobasso CB, Italia" }, { k: "Foggia", v: "Corso Giuseppe Garibaldi, 31, 71121 Foggia FG, Italia" }, { k: "Bari", v: "Via Giuseppe Capruzzi, 126, 70125 Bari BA, Italia" }, { k: "Taranto", v: "Via Crispi, 104, 74123 Taranto TA, Italia" }, { k: "Brindisi", v: "Corso Roma, 146, 72100 Brindisi BR, Italia" }, { k: "Lecce", v: "Via G. Marconi, 35, 73100 Lecce LE, Italia" }, { k: "Potenza", v: "Via Pretoria, 260, 85100 Potenza PZ, Italia" }, { k: "Matera", v: "Via Don Giovanni Minzoni, 2, 75100 Matera MT, Italia" }, { k: "Cosenza", v: "Via Calabria, 6, 87100 Cosenza CS, Italia" }, { k: "Catanzaro-Crotone-ViboValentia", v: "Piazza G. Matteotti, 15, 88100 Catanzaro CZ, Italia" }, { k: "Reggio Calabria", v: "Via Palamolla, 8, 89125 Reggio Calabria RC, Italia" }, { k: "Trapani", v: "Via delle Acacie, 5, 91100 Trapani TP, Italia" }, { k: "Palermo", v: "Via Maqueda, 271, 90133 Palermo PA, Italia" }, { k: "Messina", v: "Via Sant'Agostino, 2, 98122 Messina ME, Italia" }, { k: "Agrigento", v: "Piazza Luigi Pirandello, 33, 92100 Agrigento AG, Italia" }, { k: "Caltanissetta", v: "Corso Vittorio Emanuele II, 97, 93100 Caltanissetta CL, Italia" }, { k: "Enna", v: "Via Mercato, 2, 94100 Enna EN, Italia" }, { k: "Catania", v: "Piazza S. Domenico, 6, 95124 Catania CT, Italia" }, { k: "Ragusa", v: "Via Roma, 180, 97100 Ragusa RG, Italia" }, { k: "Siracusa", v: "Viale Teocrito, 74, 96100 Siracusa SR, Italia" }, { k: "Sassari", v: "Piazza Santa Maria, 110, 07100 Sassari SS, Italia" }, { k: "Nuoro", v: "Via la Marmora, 99, 08100 Nuoro NU, Italia" }, { k: "Cagliari", v: "Via Sant'Alenixedda, 7, 09128 Cagliari CA, Italia" }, { k: "Pordenone", v: "Largo S. Giovanni, 31, 33170 Pordenone PN, Italia" }, { k: "Isernia", v: "Corso Giuseppe Garibaldi, 14, 86170 Isernia IS, Italia" }, { k: "Oristano", v: "Via Cagliari, 111, 09170 Oristano OR, Italia" }, { k: "Milano 2 (Monza)", v: "Via Italia, 12, 20052 Monza MB, Italia" }, { k: "Firenze 2 (Prato)", v: "Via Garibaldi, 50, 59100 Prato PO, Italia" }, { k: "Brescia 2", v: "Via Giovanni Battista Tiepolo 25124 Brescia BS, Italia" }, { k: "Genova 2", v: "Via Coronata, 100 16152 Genova GE, Italia" }, { k: "Roma 2", v: "Via delle Fornaci, 253 00165 Roma RM, Italia" }, { k: "Bologna 2", v: "Via della Salute, 11 40132 Bologna BO, Italia" }, { k: "Napoli 2", v: "Via Leonardo Bianchi, 23 80131 Napoli NA, Italia" }]);
		$pkg.BirthInfo = new sliceType$3([new structType.ptr("A001", "Abano Terme", "Padova (PD)"), new structType.ptr("A004", "Abbadia Cerreto", "Lodi (LO)"), new structType.ptr("A005", "Abbadia Lariana", "Lecco (LC)"), new structType.ptr("A006", "Abbadia San Salvatore", "Siena (SI)"), new structType.ptr("A007", "Abbasanta", "Oristano (OR)"), new structType.ptr("A008", "Abbateggio", "Pescara (PE)"), new structType.ptr("A010", "Abbiategrasso", "Milano (MI)"), new structType.ptr("M376", "Abetone Cutigliano", "Pistoia (PT)"), new structType.ptr("A013", "Abriola", "Potenza (PZ)"), new structType.ptr("A014", "Acate", "Ragusa (RG)"), new structType.ptr("A015", "Accadia", "Foggia (FG)"), new structType.ptr("A016", "Acceglio", "Cuneo (CN)"), new structType.ptr("A017", "Accettura", "Matera (MT)"), new structType.ptr("A018", "Acciano", "L'Aquila (AQ)"), new structType.ptr("A019", "Accumoli", "Rieti (RI)"), new structType.ptr("A020", "Acerenza", "Potenza (PZ)"), new structType.ptr("A023", "Acerno", "Salerno (SA)"), new structType.ptr("A024", "Acerra", "Napoli (NA)"), new structType.ptr("A025", "Aci Bonaccorsi", "Catania (CT)"), new structType.ptr("A026", "Aci Castello", "Catania (CT)"), new structType.ptr("A027", "Aci Catena", "Catania (CT)"), new structType.ptr("A029", "Aci Sant'Antonio", "Catania (CT)"), new structType.ptr("A028", "Acireale", "Catania (CT)"), new structType.ptr("A032", "Acquafondata", "Frosinone (FR)"), new structType.ptr("A033", "Acquaformosa", "Cosenza (CS)"), new structType.ptr("A034", "Acquafredda", "Brescia (BS)"), new structType.ptr("A035", "Acqualagna", "Pesaro e Urbino (PU)"), new structType.ptr("A039", "Acquanegra Cremonese", "Cremona (CR)"), new structType.ptr("A038", "Acquanegra Sul Chiese", "Mantova (MN)"), new structType.ptr("A040", "Acquapendente", "Viterbo (VT)"), new structType.ptr("A041", "Acquappesa", "Cosenza (CS)"), new structType.ptr("A042", "Acquarica Del Capo", "Lecce (LE)"), new structType.ptr("A043", "Acquaro", "Vibo Valentia (VV)"), new structType.ptr("A044", "Acquasanta Terme", "Ascoli Piceno (AP)"), new structType.ptr("A045", "Acquasparta", "Terni (TR)"), new structType.ptr("A050", "Acquaviva Collecroce", "Campobasso (CB)"), new structType.ptr("A048", "Acquaviva Delle Fonti", "Bari (BA)"), new structType.ptr("A051", "Acquaviva D'Isernia", "Isernia (IS)"), new structType.ptr("A047", "Acquaviva Picena", "Ascoli Piceno (AP)"), new structType.ptr("A049", "Acquaviva Platani", "Caltanissetta (CL)"), new structType.ptr("M211", "Acquedolci", "Messina (ME)"), new structType.ptr("A052", "Acqui Terme", "Alessandria (AL)"), new structType.ptr("A053", "Acri", "Cosenza (CS)"), new structType.ptr("A054", "Acuto", "Frosinone (FR)"), new structType.ptr("A055", "Adelfia", "Bari (BA)"), new structType.ptr("A056", "Adrano", "Catania (CT)"), new structType.ptr("A057", "Adrara San Martino", "Bergamo (BG)"), new structType.ptr("A058", "Adrara San Rocco", "Bergamo (BG)"), new structType.ptr("A059", "Adria", "Rovigo (RO)"), new structType.ptr("A060", "Adro", "Brescia (BS)"), new structType.ptr("A061", "Affi", "Verona (VR)"), new structType.ptr("A062", "Affile", "Roma (RM)"), new structType.ptr("A064", "Afragola", "Napoli (NA)"), new structType.ptr("A065", "Africo", "Reggio Calabria (RC)"), new structType.ptr("A067", "Agazzano", "Piacenza (PC)"), new structType.ptr("A068", "Agerola", "Napoli (NA)"), new structType.ptr("A069", "Aggius", "Olbia-Tempio (OT)"), new structType.ptr("A070", "Agira", "Enna (EN)"), new structType.ptr("A071", "Agliana", "Pistoia (PT)"), new structType.ptr("A072", "Agliano Terme", "Asti (AT)"), new structType.ptr("A074", "Agli\xC3\xA8", "Torino (TO)"), new structType.ptr("H848", "Aglientu", "Olbia-Tempio (OT)"), new structType.ptr("A075", "Agna", "Padova (PD)"), new structType.ptr("A076", "Agnadello", "Cremona (CR)"), new structType.ptr("A077", "Agnana Calabra", "Reggio Calabria (RC)"), new structType.ptr("A080", "Agnone", "Isernia (IS)"), new structType.ptr("A082", "Agnosine", "Brescia (BS)"), new structType.ptr("A083", "Agordo", "Belluno (BL)"), new structType.ptr("A084", "Agosta", "Roma (RM)"), new structType.ptr("A085", "Agra", "Varese (VA)"), new structType.ptr("A087", "Agrate Brianza", "Monza e della Brianza (MB)"), new structType.ptr("A088", "Agrate Conturbia", "Novara (NO)"), new structType.ptr("A089", "Agrigento", "Agrigento (AG)"), new structType.ptr("A091", "Agropoli", "Salerno (SA)"), new structType.ptr("A092", "Agugliano", "Ancona (AN)"), new structType.ptr("A093", "Agugliaro", "Vicenza (VI)"), new structType.ptr("A096", "Aicurzio", "Monza e della Brianza (MB)"), new structType.ptr("A097", "Aidomaggiore", "Oristano (OR)"), new structType.ptr("A098", "Aidone", "Enna (EN)"), new structType.ptr("A100", "Aielli", "L'Aquila (AQ)"), new structType.ptr("A102", "Aiello Calabro", "Cosenza (CS)"), new structType.ptr("A103", "Aiello Del Friuli", "Udine (UD)"), new structType.ptr("A101", "Aiello Del Sabato", "Avellino (AV)"), new structType.ptr("A105", "Aieta", "Cosenza (CS)"), new structType.ptr("A106", "Ailano", "Caserta (CE)"), new structType.ptr("A107", "Ailoche", "Biella (BI)"), new structType.ptr("A109", "Airasca", "Torino (TO)"), new structType.ptr("A110", "Airola", "Benevento (BN)"), new structType.ptr("A111", "Airole", "Imperia (IM)"), new structType.ptr("A112", "Airuno", "Lecco (LC)"), new structType.ptr("A113", "Aisone", "Cuneo (CN)"), new structType.ptr("A116", "Ala", "Trento (TN)"), new structType.ptr("A115", "Ala' Dei Sardi", "Olbia-Tempio (OT)"), new structType.ptr("A117", "Ala Di Stura", "Torino (TO)"), new structType.ptr("A118", "Alagna", "Pavia (PV)"), new structType.ptr("A119", "Alagna Valsesia", "Vercelli (VC)"), new structType.ptr("A120", "Alanno", "Pescara (PE)"), new structType.ptr("A121", "Alano Di Piave", "Belluno (BL)"), new structType.ptr("A122", "Alassio", "Savona (SV)"), new structType.ptr("A123", "Alatri", "Frosinone (FR)"), new structType.ptr("A124", "Alba", "Cuneo (CN)"), new structType.ptr("A125", "Alba Adriatica", "Teramo (TE)"), new structType.ptr("A126", "Albagiara", "Oristano (OR)"), new structType.ptr("A127", "Albairate", "Milano (MI)"), new structType.ptr("A128", "Albanella", "Salerno (SA)"), new structType.ptr("A131", "Albano Di Lucania", "Potenza (PZ)"), new structType.ptr("A132", "Albano Laziale", "Roma (RM)"), new structType.ptr("A129", "Albano Sant'Alessandro", "Bergamo (BG)"), new structType.ptr("A130", "Albano Vercellese", "Vercelli (VC)"), new structType.ptr("A134", "Albaredo Arnaboldi", "Pavia (PV)"), new structType.ptr("A137", "Albaredo D'Adige", "Verona (VR)"), new structType.ptr("A135", "Albaredo Per San Marco", "Sondrio (SO)"), new structType.ptr("A138", "Albareto", "Parma (PR)"), new structType.ptr("A139", "Albaretto Della Torre", "Cuneo (CN)"), new structType.ptr("A143", "Albavilla", "Como (CO)"), new structType.ptr("A145", "Albenga", "Savona (SV)"), new structType.ptr("A146", "Albera Ligure", "Alessandria (AL)"), new structType.ptr("A149", "Alberobello", "Bari (BA)"), new structType.ptr("A150", "Alberona", "Foggia (FG)"), new structType.ptr("A153", "Albese Con Cassano", "Como (CO)"), new structType.ptr("A154", "Albettone", "Vicenza (VI)"), new structType.ptr("A155", "Albi", "Catanzaro (CZ)"), new structType.ptr("A158", "Albiano", "Trento (TN)"), new structType.ptr("A157", "Albiano D'Ivrea", "Torino (TO)"), new structType.ptr("A159", "Albiate", "Monza e della Brianza (MB)"), new structType.ptr("A160", "Albidona", "Cosenza (CS)"), new structType.ptr("A161", "Albignasego", "Padova (PD)"), new structType.ptr("A162", "Albinea", "Reggio Emilia (RE)"), new structType.ptr("A163", "Albino", "Bergamo (BG)"), new structType.ptr("A164", "Albiolo", "Como (CO)"), new structType.ptr("A166", "Albisola Superiore", "Savona (SV)"), new structType.ptr("A165", "Albissola Marina", "Savona (SV)"), new structType.ptr("A167", "Albizzate", "Varese (VA)"), new structType.ptr("A171", "Albonese", "Pavia (PV)"), new structType.ptr("A172", "Albosaggia", "Sondrio (SO)"), new structType.ptr("A173", "Albugnano", "Asti (AT)"), new structType.ptr("A175", "Albuzzano", "Pavia (PV)"), new structType.ptr("A176", "Alcamo", "Trapani (TP)"), new structType.ptr("A177", "Alcara Li Fusi", "Messina (ME)"), new structType.ptr("A178", "Aldeno", "Trento (TN)"), new structType.ptr("A179", "Aldino .Aldein.", "Bolzano (BZ)"), new structType.ptr("A180", "Ales", "Oristano (OR)"), new structType.ptr("A182", "Alessandria", "Alessandria (AL)"), new structType.ptr("A183", "Alessandria Del Carretto", "Cosenza (CS)"), new structType.ptr("A181", "Alessandria Della Rocca", "Agrigento (AG)"), new structType.ptr("A184", "Alessano", "Lecce (LE)"), new structType.ptr("A185", "Alezio", "Lecce (LE)"), new structType.ptr("A186", "Alfano", "Salerno (SA)"), new structType.ptr("A187", "Alfedena", "L'Aquila (AQ)"), new structType.ptr("A188", "Alfianello", "Brescia (BS)"), new structType.ptr("A189", "Alfiano Natta", "Alessandria (AL)"), new structType.ptr("A191", "Alfonsine", "Ravenna (RA)"), new structType.ptr("A192", "Alghero", "Sassari (SS)"), new structType.ptr("A193", "Algua", "Bergamo (BG)"), new structType.ptr("A194", "Al\xC3\xAC", "Messina (ME)"), new structType.ptr("A201", "Ali' Terme", "Messina (ME)"), new structType.ptr("A195", "Alia", "Palermo (PA)"), new structType.ptr("A196", "Aliano", "Matera (MT)"), new structType.ptr("A197", "Alice Bel Colle", "Alessandria (AL)"), new structType.ptr("A198", "Alice Castello", "Vercelli (VC)"), new structType.ptr("A199", "Alice Superiore", "Torino (TO)"), new structType.ptr("A200", "Alife", "Caserta (CE)"), new structType.ptr("A202", "Alimena", "Palermo (PA)"), new structType.ptr("A203", "Aliminusa", "Palermo (PA)"), new structType.ptr("A204", "Allai", "Oristano (OR)"), new structType.ptr("A206", "Alleghe", "Belluno (BL)"), new structType.ptr("A205", "Allein", "Aosta (AO)"), new structType.ptr("A207", "Allerona", "Terni (TR)"), new structType.ptr("A208", "Alliste", "Lecce (LE)"), new structType.ptr("A210", "Allumiere", "Roma (RM)"), new structType.ptr("A211", "Alluvioni Cambi\xC3\xB2", "Alessandria (AL)"), new structType.ptr("A214", "Alm\xC3\xA8", "Bergamo (BG)"), new structType.ptr("A216", "Almenno San Bartolomeo", "Bergamo (BG)"), new structType.ptr("A217", "Almenno San Salvatore", "Bergamo (BG)"), new structType.ptr("A218", "Almese", "Torino (TO)"), new structType.ptr("A220", "Alonte", "Vicenza (VI)"), new structType.ptr("M375", "Alpago", "Belluno (BL)"), new structType.ptr("A221", "Alpette", "Torino (TO)"), new structType.ptr("A222", "Alpignano", "Torino (TO)"), new structType.ptr("A223", "Alseno", "Piacenza (PC)"), new structType.ptr("A224", "Alserio", "Como (CO)"), new structType.ptr("M383", "Alta Valle Intelvi", "Como (CO)"), new structType.ptr("A225", "Altamura", "Bari (BA)"), new structType.ptr("A226", "Altare", "Savona (SV)"), new structType.ptr("M349", "Altavalle", "Trento (TN)"), new structType.ptr("A228", "Altavilla Irpina", "Avellino (AV)"), new structType.ptr("A229", "Altavilla Milicia", "Palermo (PA)"), new structType.ptr("A227", "Altavilla Monferrato", "Alessandria (AL)"), new structType.ptr("A230", "Altavilla Silentina", "Salerno (SA)"), new structType.ptr("A231", "Altavilla Vicentina", "Vicenza (VI)"), new structType.ptr("A233", "Altidona", "Fermo (FM)"), new structType.ptr("A234", "Altilia", "Cosenza (CS)"), new structType.ptr("A235", "Altino", "Chieti (CH)"), new structType.ptr("A236", "Altissimo", "Vicenza (VI)"), new structType.ptr("A237", "Altivole", "Treviso (TV)"), new structType.ptr("A238", "Alto", "Cuneo (CN)"), new structType.ptr("M369", "Alto Reno Terme", "Bologna (BO)"), new structType.ptr("A239", "Altofonte", "Palermo (PA)"), new structType.ptr("A240", "Altomonte", "Cosenza (CS)"), new structType.ptr("A241", "Altopascio", "Lucca (LU)"), new structType.ptr("M350", "Altopiano Della Vigolana", "Trento (TN)"), new structType.ptr("A242", "Alviano", "Terni (TR)"), new structType.ptr("A243", "Alvignano", "Caserta (CE)"), new structType.ptr("A244", "Alvito", "Frosinone (FR)"), new structType.ptr("A246", "Alzano Lombardo", "Bergamo (BG)"), new structType.ptr("A245", "Alzano Scrivia", "Alessandria (AL)"), new structType.ptr("A249", "Alzate Brianza", "Como (CO)"), new structType.ptr("A251", "Amalfi", "Salerno (SA)"), new structType.ptr("A252", "Amandola", "Fermo (FM)"), new structType.ptr("A253", "Amantea", "Cosenza (CS)"), new structType.ptr("A254", "Amaro", "Udine (UD)"), new structType.ptr("A255", "Amaroni", "Catanzaro (CZ)"), new structType.ptr("A256", "Amaseno", "Frosinone (FR)"), new structType.ptr("A257", "Amato", "Catanzaro (CZ)"), new structType.ptr("A258", "Amatrice", "Rieti (RI)"), new structType.ptr("A259", "Ambivere", "Bergamo (BG)"), new structType.ptr("M351", "Amblar-Don", "Trento (TN)"), new structType.ptr("A261", "Ameglia", "La Spezia (SP)"), new structType.ptr("A262", "Amelia", "Terni (TR)"), new structType.ptr("A263", "Amendolara", "Cosenza (CS)"), new structType.ptr("A264", "Ameno", "Novara (NO)"), new structType.ptr("A265", "Amorosi", "Benevento (BN)"), new structType.ptr("A267", "Ampezzo", "Udine (UD)"), new structType.ptr("A268", "Anacapri", "Napoli (NA)"), new structType.ptr("A269", "Anagni", "Frosinone (FR)"), new structType.ptr("A270", "Ancarano", "Teramo (TE)"), new structType.ptr("A271", "Ancona", "Ancona (AN)"), new structType.ptr("A272", "Andali", "Catanzaro (CZ)"), new structType.ptr("A274", "Andalo", "Trento (TN)"), new structType.ptr("A273", "Andalo Valtellino", "Sondrio (SO)"), new structType.ptr("A275", "Andezeno", "Torino (TO)"), new structType.ptr("A278", "Andora", "Savona (SV)"), new structType.ptr("A280", "Andorno Micca", "Biella (BI)"), new structType.ptr("A281", "Andrano", "Lecce (LE)"), new structType.ptr("A282", "Andrate", "Torino (TO)"), new structType.ptr("A283", "Andreis", "Pordenone (PN)"), new structType.ptr("A284", "Andretta", "Avellino (AV)"), new structType.ptr("A285", "Andria", "Barletta-Andria-Trani (BT)"), new structType.ptr("A286", "Andriano .Andrian.", "Bolzano (BZ)"), new structType.ptr("A287", "Anela", "Sassari (SS)"), new structType.ptr("A288", "Anfo", "Brescia (BS)"), new structType.ptr("A290", "Angera", "Varese (VA)"), new structType.ptr("A291", "Anghiari", "Arezzo (AR)"), new structType.ptr("A292", "Angiari", "Verona (VR)"), new structType.ptr("A293", "Angolo Terme", "Brescia (BS)"), new structType.ptr("A294", "Angri", "Salerno (SA)"), new structType.ptr("A295", "Angrogna", "Torino (TO)"), new structType.ptr("A297", "Anguillara Sabazia", "Roma (RM)"), new structType.ptr("A296", "Anguillara Veneta", "Padova (PD)"), new structType.ptr("A299", "Annicco", "Cremona (CR)"), new structType.ptr("A301", "Annone Di Brianza", "Lecco (LC)"), new structType.ptr("A302", "Annone Veneto", "Venezia (VE)"), new structType.ptr("A303", "Anoia", "Reggio Calabria (RC)"), new structType.ptr("A304", "Antegnate", "Bergamo (BG)"), new structType.ptr("A306", "Anterivo .Altrei.", "Bolzano (BZ)"), new structType.ptr("A305", "Antey-Saint-Andr\xC3\xA8", "Aosta (AO)"), new structType.ptr("A309", "Anticoli Corrado", "Roma (RM)"), new structType.ptr("A312", "Antignano", "Asti (AT)"), new structType.ptr("A313", "Antillo", "Messina (ME)"), new structType.ptr("A314", "Antonimina", "Reggio Calabria (RC)"), new structType.ptr("A315", "Antrodoco", "Rieti (RI)"), new structType.ptr("A317", "Antrona Schieranco", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A318", "Anversa Degli Abruzzi", "L'Aquila (AQ)"), new structType.ptr("A319", "Anzano Del Parco", "Como (CO)"), new structType.ptr("A320", "Anzano Di Puglia", "Foggia (FG)"), new structType.ptr("A321", "Anzi", "Potenza (PZ)"), new structType.ptr("A323", "Anzio", "Roma (RM)"), new structType.ptr("A324", "Anzola Dell'Emilia", "Bologna (BO)"), new structType.ptr("A325", "Anzola D'Ossola", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A326", "Aosta", "Aosta (AO)"), new structType.ptr("A327", "Apecchio", "Pesaro e Urbino (PU)"), new structType.ptr("A328", "Apice", "Benevento (BN)"), new structType.ptr("A329", "Apiro", "Macerata (MC)"), new structType.ptr("A330", "Apollosa", "Benevento (BN)"), new structType.ptr("A333", "Appiano Gentile", "Como (CO)"), new structType.ptr("A332", "Appiano Sulla Strada Del Vino .Eppan An Der.", "Bolzano (BZ)"), new structType.ptr("A334", "Appignano", "Macerata (MC)"), new structType.ptr("A335", "Appignano Del Tronto", "Ascoli Piceno (AP)"), new structType.ptr("A337", "Aprica", "Sondrio (SO)"), new structType.ptr("A338", "Apricale", "Imperia (IM)"), new structType.ptr("A339", "Apricena", "Foggia (FG)"), new structType.ptr("A340", "Aprigliano", "Cosenza (CS)"), new structType.ptr("A341", "Aprilia", "Latina (LT)"), new structType.ptr("A343", "Aquara", "Salerno (SA)"), new structType.ptr("A344", "Aquila D'Arroscia", "Imperia (IM)"), new structType.ptr("A346", "Aquileia", "Udine (UD)"), new structType.ptr("A347", "Aquilonia", "Avellino (AV)"), new structType.ptr("A348", "Aquino", "Frosinone (FR)"), new structType.ptr("A350", "Aradeo", "Lecce (LE)"), new structType.ptr("A351", "Aragona", "Agrigento (AG)"), new structType.ptr("A352", "Aramengo", "Asti (AT)"), new structType.ptr("A354", "Arba", "Pordenone (PN)"), new structType.ptr("A357", "Arborea", "Oristano (OR)"), new structType.ptr("A358", "Arborio", "Vercelli (VC)"), new structType.ptr("A359", "Arbus", "Medio Campidano (VS)"), new structType.ptr("A360", "Arcade", "Treviso (TV)"), new structType.ptr("A363", "Arce", "Frosinone (FR)"), new structType.ptr("A365", "Arcene", "Bergamo (BG)"), new structType.ptr("A366", "Arcevia", "Ancona (AN)"), new structType.ptr("A367", "Archi", "Chieti (CH)"), new structType.ptr("A369", "Arcidosso", "Grosseto (GR)"), new structType.ptr("A370", "Arcinazzo Romano", "Roma (RM)"), new structType.ptr("A371", "Arcisate", "Varese (VA)"), new structType.ptr("A372", "Arco", "Trento (TN)"), new structType.ptr("A373", "Arcola", "La Spezia (SP)"), new structType.ptr("A374", "Arcole", "Verona (VR)"), new structType.ptr("A375", "Arconate", "Milano (MI)"), new structType.ptr("A376", "Arcore", "Monza e della Brianza (MB)"), new structType.ptr("A377", "Arcugnano", "Vicenza (VI)"), new structType.ptr("A379", "Ardara", "Sassari (SS)"), new structType.ptr("A380", "Ardauli", "Oristano (OR)"), new structType.ptr("M213", "Ardea", "Roma (RM)"), new structType.ptr("A382", "Ardenno", "Sondrio (SO)"), new structType.ptr("A383", "Ardesio", "Bergamo (BG)"), new structType.ptr("A385", "Ardore", "Reggio Calabria (RC)"), new structType.ptr("A386", "Arena", "Vibo Valentia (VV)"), new structType.ptr("A387", "Arena Po", "Pavia (PV)"), new structType.ptr("A388", "Arenzano", "Genova (GE)"), new structType.ptr("A389", "Arese", "Milano (MI)"), new structType.ptr("A390", "Arezzo", "Arezzo (AR)"), new structType.ptr("A391", "Argegno", "Como (CO)"), new structType.ptr("A392", "Argelato", "Bologna (BO)"), new structType.ptr("A393", "Argenta", "Ferrara (FE)"), new structType.ptr("A394", "Argentera", "Cuneo (CN)"), new structType.ptr("A396", "Arguello", "Cuneo (CN)"), new structType.ptr("A397", "Argusto", "Catanzaro (CZ)"), new structType.ptr("A398", "Ari", "Chieti (CH)"), new structType.ptr("A399", "Ariano Irpino", "Avellino (AV)"), new structType.ptr("A400", "Ariano Nel Polesine", "Rovigo (RO)"), new structType.ptr("A401", "Ariccia", "Roma (RM)"), new structType.ptr("A402", "Arielli", "Chieti (CH)"), new structType.ptr("A403", "Arienzo", "Caserta (CE)"), new structType.ptr("A405", "Arignano", "Torino (TO)"), new structType.ptr("A407", "Aritzo", "Nuoro (NU)"), new structType.ptr("A409", "Arizzano", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A412", "Arlena Di Castro", "Viterbo (VT)"), new structType.ptr("A413", "Arluno", "Milano (MI)"), new structType.ptr("A414", "Armeno", "Novara (NO)"), new structType.ptr("A415", "Armento", "Potenza (PZ)"), new structType.ptr("A418", "Armo", "Imperia (IM)"), new structType.ptr("A419", "Armungia", "Cagliari (CA)"), new structType.ptr("A424", "Arnad", "Aosta (AO)"), new structType.ptr("A421", "Arnara", "Frosinone (FR)"), new structType.ptr("A422", "Arnasco", "Savona (SV)"), new structType.ptr("A425", "Arnesano", "Lecce (LE)"), new structType.ptr("A427", "Arola", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A429", "Arona", "Novara (NO)"), new structType.ptr("A430", "Arosio", "Como (CO)"), new structType.ptr("A431", "Arpaia", "Benevento (BN)"), new structType.ptr("A432", "Arpaise", "Benevento (BN)"), new structType.ptr("A433", "Arpino", "Frosinone (FR)"), new structType.ptr("A434", "Arqua' Petrarca", "Padova (PD)"), new structType.ptr("A435", "Arqua' Polesine", "Rovigo (RO)"), new structType.ptr("A437", "Arquata Del Tronto", "Ascoli Piceno (AP)"), new structType.ptr("A436", "Arquata Scrivia", "Alessandria (AL)"), new structType.ptr("A438", "Arre", "Padova (PD)"), new structType.ptr("A439", "Arrone", "Terni (TR)"), new structType.ptr("A441", "Arsago Seprio", "Varese (VA)"), new structType.ptr("A443", "Arsi\xC3\xA8", "Belluno (BL)"), new structType.ptr("A444", "Arsiero", "Vicenza (VI)"), new structType.ptr("A445", "Arsita", "Teramo (TE)"), new structType.ptr("A446", "Arsoli", "Roma (RM)"), new structType.ptr("A447", "Arta Terme", "Udine (UD)"), new structType.ptr("A448", "Artegna", "Udine (UD)"), new structType.ptr("A449", "Artena", "Roma (RM)"), new structType.ptr("A451", "Artogne", "Brescia (BS)"), new structType.ptr("A452", "Arvier", "Aosta (AO)"), new structType.ptr("A453", "Arzachena", "Olbia-Tempio (OT)"), new structType.ptr("A440", "Arzago D'Adda", "Bergamo (BG)"), new structType.ptr("A454", "Arzana", "Ogliastra (OG)"), new structType.ptr("A455", "Arzano", "Napoli (NA)"), new structType.ptr("A458", "Arzergrande", "Padova (PD)"), new structType.ptr("A459", "Arzignano", "Vicenza (VI)"), new structType.ptr("A460", "Ascea", "Salerno (SA)"), new structType.ptr("A461", "Asciano", "Siena (SI)"), new structType.ptr("A462", "Ascoli Piceno", "Ascoli Piceno (AP)"), new structType.ptr("A463", "Ascoli Satriano", "Foggia (FG)"), new structType.ptr("A464", "Ascrea", "Rieti (RI)"), new structType.ptr("A465", "Asiago", "Vicenza (VI)"), new structType.ptr("A467", "Asigliano Veneto", "Vicenza (VI)"), new structType.ptr("A466", "Asigliano Vercellese", "Vercelli (VC)"), new structType.ptr("A470", "Asola", "Mantova (MN)"), new structType.ptr("A471", "Asolo", "Treviso (TV)"), new structType.ptr("A473", "Assago", "Milano (MI)"), new structType.ptr("A474", "Assemini", "Cagliari (CA)"), new structType.ptr("A475", "Assisi", "Perugia (PG)"), new structType.ptr("A476", "Asso", "Como (CO)"), new structType.ptr("A477", "Assolo", "Oristano (OR)"), new structType.ptr("A478", "Assoro", "Enna (EN)"), new structType.ptr("A479", "Asti", "Asti (AT)"), new structType.ptr("A480", "Asuni", "Oristano (OR)"), new structType.ptr("A481", "Ateleta", "L'Aquila (AQ)"), new structType.ptr("A482", "Atella", "Potenza (PZ)"), new structType.ptr("A484", "Atena Lucana", "Salerno (SA)"), new structType.ptr("A485", "Atessa", "Chieti (CH)"), new structType.ptr("A486", "Atina", "Frosinone (FR)"), new structType.ptr("A487", "Atrani", "Salerno (SA)"), new structType.ptr("A488", "Atri", "Teramo (TE)"), new structType.ptr("A489", "Atripalda", "Avellino (AV)"), new structType.ptr("A490", "Attigliano", "Terni (TR)"), new structType.ptr("A491", "Attimis", "Udine (UD)"), new structType.ptr("A492", "Atzara", "Nuoro (NU)"), new structType.ptr("A493", "Auditore", "Pesaro e Urbino (PU)"), new structType.ptr("A494", "Augusta", "Siracusa (SR)"), new structType.ptr("A495", "Auletta", "Salerno (SA)"), new structType.ptr("A496", "Aulla", "Massa-Carrara (MS)"), new structType.ptr("A497", "Aurano", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A499", "Aurigo", "Imperia (IM)"), new structType.ptr("A501", "Auronzo Di Cadore", "Belluno (BL)"), new structType.ptr("A502", "Ausonia", "Frosinone (FR)"), new structType.ptr("A503", "Austis", "Nuoro (NU)"), new structType.ptr("A506", "Avegno", "Genova (GE)"), new structType.ptr("A507", "Avelengo .Hafling.", "Bolzano (BZ)"), new structType.ptr("A508", "Avella", "Avellino (AV)"), new structType.ptr("A509", "Avellino", "Avellino (AV)"), new structType.ptr("A511", "Averara", "Bergamo (BG)"), new structType.ptr("A512", "Aversa", "Caserta (CE)"), new structType.ptr("A514", "Avetrana", "Taranto (TA)"), new structType.ptr("A515", "Avezzano", "L'Aquila (AQ)"), new structType.ptr("A516", "Aviano", "Pordenone (PN)"), new structType.ptr("A517", "Aviatico", "Bergamo (BG)"), new structType.ptr("A518", "Avigliana", "Torino (TO)"), new structType.ptr("A519", "Avigliano", "Potenza (PZ)"), new structType.ptr("M258", "Avigliano Umbro", "Terni (TR)"), new structType.ptr("A520", "Avio", "Trento (TN)"), new structType.ptr("A521", "Avise", "Aosta (AO)"), new structType.ptr("A522", "Avola", "Siracusa (SR)"), new structType.ptr("A523", "Avolasca", "Alessandria (AL)"), new structType.ptr("A094", "Ayas", "Aosta (AO)"), new structType.ptr("A108", "Aymavilles", "Aosta (AO)"), new structType.ptr("A525", "Azeglio", "Torino (TO)"), new structType.ptr("A526", "Azzanello", "Cremona (CR)"), new structType.ptr("A527", "Azzano D'Asti", "Asti (AT)"), new structType.ptr("A530", "Azzano Decimo", "Pordenone (PN)"), new structType.ptr("A529", "Azzano Mella", "Brescia (BS)"), new structType.ptr("A528", "Azzano San Paolo", "Bergamo (BG)"), new structType.ptr("A531", "Azzate", "Varese (VA)"), new structType.ptr("A532", "Azzio", "Varese (VA)"), new structType.ptr("A533", "Azzone", "Bergamo (BG)"), new structType.ptr("A534", "Baceno", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A535", "Bacoli", "Napoli (NA)"), new structType.ptr("A536", "Badalucco", "Imperia (IM)"), new structType.ptr("M214", "Badesi", "Olbia-Tempio (OT)"), new structType.ptr("A537", "Badia .Abtei.", "Bolzano (BZ)"), new structType.ptr("A540", "Badia Calavena", "Verona (VR)"), new structType.ptr("A538", "Badia Pavese", "Pavia (PV)"), new structType.ptr("A539", "Badia Polesine", "Rovigo (RO)"), new structType.ptr("A541", "Badia Tedalda", "Arezzo (AR)"), new structType.ptr("A542", "Badolato", "Catanzaro (CZ)"), new structType.ptr("A544", "Bagaladi", "Reggio Calabria (RC)"), new structType.ptr("A546", "Bagheria", "Palermo (PA)"), new structType.ptr("A547", "Bagnacavallo", "Ravenna (RA)"), new structType.ptr("A552", "Bagnara Calabra", "Reggio Calabria (RC)"), new structType.ptr("A551", "Bagnara Di Romagna", "Ravenna (RA)"), new structType.ptr("A550", "Bagnaria", "Pavia (PV)"), new structType.ptr("A553", "Bagnaria Arsa", "Udine (UD)"), new structType.ptr("A555", "Bagnasco", "Cuneo (CN)"), new structType.ptr("A557", "Bagnatica", "Bergamo (BG)"), new structType.ptr("A560", "Bagni Di Lucca", "Lucca (LU)"), new structType.ptr("A564", "Bagno A Ripoli", "Firenze (FI)"), new structType.ptr("A565", "Bagno Di Romagna", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("A567", "Bagnoli Del Trigno", "Isernia (IS)"), new structType.ptr("A568", "Bagnoli Di Sopra", "Padova (PD)"), new structType.ptr("A566", "Bagnoli Irpino", "Avellino (AV)"), new structType.ptr("A570", "Bagnolo Cremasco", "Cremona (CR)"), new structType.ptr("A572", "Bagnolo Del Salento", "Lecce (LE)"), new structType.ptr("A574", "Bagnolo Di Po", "Rovigo (RO)"), new structType.ptr("A573", "Bagnolo In Piano", "Reggio Emilia (RE)"), new structType.ptr("A569", "Bagnolo Mella", "Brescia (BS)"), new structType.ptr("A571", "Bagnolo Piemonte", "Cuneo (CN)"), new structType.ptr("A575", "Bagnolo San Vito", "Mantova (MN)"), new structType.ptr("A576", "Bagnone", "Massa-Carrara (MS)"), new structType.ptr("A577", "Bagnoregio", "Viterbo (VT)"), new structType.ptr("A578", "Bagolino", "Brescia (BS)"), new structType.ptr("A579", "Baia E Latina", "Caserta (CE)"), new structType.ptr("A580", "Baiano", "Avellino (AV)"), new structType.ptr("A581", "Baiardo", "Imperia (IM)"), new structType.ptr("A584", "Bairo", "Torino (TO)"), new structType.ptr("A586", "Baiso", "Reggio Emilia (RE)"), new structType.ptr("A587", "Balangero", "Torino (TO)"), new structType.ptr("A588", "Baldichieri D'Asti", "Asti (AT)"), new structType.ptr("A590", "Baldissero Canavese", "Torino (TO)"), new structType.ptr("A589", "Baldissero D'Alba", "Cuneo (CN)"), new structType.ptr("A591", "Baldissero Torinese", "Torino (TO)"), new structType.ptr("A592", "Balestrate", "Palermo (PA)"), new structType.ptr("A593", "Balestrino", "Savona (SV)"), new structType.ptr("A594", "Ballabio", "Lecco (LC)"), new structType.ptr("A597", "Ballao", "Cagliari (CA)"), new structType.ptr("A599", "Balme", "Torino (TO)"), new structType.ptr("A600", "Balmuccia", "Vercelli (VC)"), new structType.ptr("A601", "Balocco", "Vercelli (VC)"), new structType.ptr("A603", "Balsorano", "L'Aquila (AQ)"), new structType.ptr("A604", "Balvano", "Potenza (PZ)"), new structType.ptr("A605", "Balzola", "Alessandria (AL)"), new structType.ptr("A606", "Banari", "Sassari (SS)"), new structType.ptr("A607", "Banchette", "Torino (TO)"), new structType.ptr("A610", "Bannio Anzino", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A612", "Banzi", "Potenza (PZ)"), new structType.ptr("A613", "Baone", "Padova (PD)"), new structType.ptr("A614", "Baradili", "Oristano (OR)"), new structType.ptr("A615", "Baragiano", "Potenza (PZ)"), new structType.ptr("A616", "Baranello", "Campobasso (CB)"), new structType.ptr("A617", "Barano D'Ischia", "Napoli (NA)"), new structType.ptr("A618", "Baranzate", "Milano (MI)"), new structType.ptr("A619", "Barasso", "Varese (VA)"), new structType.ptr("A621", "Baratili San Pietro", "Oristano (OR)"), new structType.ptr("A625", "Barbania", "Torino (TO)"), new structType.ptr("A626", "Barbara", "Ancona (AN)"), new structType.ptr("A628", "Barbarano Romano", "Viterbo (VT)"), new structType.ptr("A627", "Barbarano Vicentino", "Vicenza (VI)"), new structType.ptr("A629", "Barbaresco", "Cuneo (CN)"), new structType.ptr("A630", "Barbariga", "Brescia (BS)"), new structType.ptr("A631", "Barbata", "Bergamo (BG)"), new structType.ptr("A632", "Barberino Di Mugello", "Firenze (FI)"), new structType.ptr("A633", "Barberino Val D'Elsa", "Firenze (FI)"), new structType.ptr("A634", "Barbianello", "Pavia (PV)"), new structType.ptr("A635", "Barbiano .Barbian.", "Bolzano (BZ)"), new structType.ptr("A637", "Barbona", "Padova (PD)"), new structType.ptr("A638", "Barcellona Pozzo Di Gotto", "Messina (ME)"), new structType.ptr("A639", "Barchi", "Pesaro e Urbino (PU)"), new structType.ptr("A640", "Barcis", "Pordenone (PN)"), new structType.ptr("A643", "Bard", "Aosta (AO)"), new structType.ptr("A645", "Bardello", "Varese (VA)"), new structType.ptr("A646", "Bardi", "Parma (PR)"), new structType.ptr("A647", "Bardineto", "Savona (SV)"), new structType.ptr("A650", "Bardolino", "Verona (VR)"), new structType.ptr("A651", "Bardonecchia", "Torino (TO)"), new structType.ptr("A652", "Bareggio", "Milano (MI)"), new structType.ptr("A653", "Barengo", "Novara (NO)"), new structType.ptr("A655", "Baressa", "Oristano (OR)"), new structType.ptr("A656", "Barete", "L'Aquila (AQ)"), new structType.ptr("A657", "Barga", "Lucca (LU)"), new structType.ptr("A658", "Bargagli", "Genova (GE)"), new structType.ptr("A660", "Barge", "Cuneo (CN)"), new structType.ptr("A661", "Barghe", "Brescia (BS)"), new structType.ptr("A662", "Bari", "Bari (BA)"), new structType.ptr("A663", "Bari Sardo", "Ogliastra (OG)"), new structType.ptr("A664", "Bariano", "Bergamo (BG)"), new structType.ptr("A665", "Baricella", "Bologna (BO)"), new structType.ptr("A666", "Barile", "Potenza (PZ)"), new structType.ptr("A667", "Barisciano", "L'Aquila (AQ)"), new structType.ptr("A668", "Barlassina", "Monza e della Brianza (MB)"), new structType.ptr("A669", "Barletta", "Barletta-Andria-Trani (BT)"), new structType.ptr("A670", "Barni", "Como (CO)"), new structType.ptr("A671", "Barolo", "Cuneo (CN)"), new structType.ptr("A673", "Barone Canavese", "Torino (TO)"), new structType.ptr("A674", "Baronissi", "Salerno (SA)"), new structType.ptr("A676", "Barrafranca", "Enna (EN)"), new structType.ptr("A677", "Barrali", "Cagliari (CA)"), new structType.ptr("A678", "Barrea", "L'Aquila (AQ)"), new structType.ptr("A681", "Barumini", "Medio Campidano (VS)"), new structType.ptr("A683", "Barzago", "Lecco (LC)"), new structType.ptr("A684", "Barzana", "Bergamo (BG)"), new structType.ptr("A686", "Barzan\xC3\xB2", "Lecco (LC)"), new structType.ptr("A687", "Barzio", "Lecco (LC)"), new structType.ptr("A689", "Basaluzzo", "Alessandria (AL)"), new structType.ptr("A690", "Bascap\xC3\xA8", "Pavia (PV)"), new structType.ptr("A691", "Baschi", "Terni (TR)"), new structType.ptr("A692", "Basciano", "Teramo (TE)"), new structType.ptr("A694", "Baselga Di Pin\xC3\xA8", "Trento (TN)"), new structType.ptr("A696", "Baselice", "Benevento (BN)"), new structType.ptr("A697", "Basiano", "Milano (MI)"), new structType.ptr("A698", "Basic\xC3\xB2", "Messina (ME)"), new structType.ptr("A699", "Basiglio", "Milano (MI)"), new structType.ptr("A700", "Basiliano", "Udine (UD)"), new structType.ptr("A702", "Bassano Bresciano", "Brescia (BS)"), new structType.ptr("A703", "Bassano Del Grappa", "Vicenza (VI)"), new structType.ptr("A706", "Bassano In Teverina", "Viterbo (VT)"), new structType.ptr("A704", "Bassano Romano", "Viterbo (VT)"), new structType.ptr("A707", "Bassiano", "Latina (LT)"), new structType.ptr("A708", "Bassignana", "Alessandria (AL)"), new structType.ptr("A709", "Bastia Mondov\xC3\xAC", "Cuneo (CN)"), new structType.ptr("A710", "Bastia Umbra", "Perugia (PG)"), new structType.ptr("A712", "Bastida Pancarana", "Pavia (PV)"), new structType.ptr("A713", "Bastiglia", "Modena (MO)"), new structType.ptr("A714", "Battaglia Terme", "Padova (PD)"), new structType.ptr("A716", "Battifollo", "Cuneo (CN)"), new structType.ptr("A717", "Battipaglia", "Salerno (SA)"), new structType.ptr("A718", "Battuda", "Pavia (PV)"), new structType.ptr("A719", "Baucina", "Palermo (PA)"), new structType.ptr("A721", "Bauladu", "Oristano (OR)"), new structType.ptr("A722", "Baunei", "Ogliastra (OG)"), new structType.ptr("A725", "Baveno", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A728", "Bedero Valcuvia", "Varese (VA)"), new structType.ptr("A729", "Bedizzole", "Brescia (BS)"), new structType.ptr("A730", "Bedollo", "Trento (TN)"), new structType.ptr("A731", "Bedonia", "Parma (PR)"), new structType.ptr("A732", "Bedulita", "Bergamo (BG)"), new structType.ptr("A733", "Bee", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A734", "Beinasco", "Torino (TO)"), new structType.ptr("A735", "Beinette", "Cuneo (CN)"), new structType.ptr("A736", "Belcastro", "Catanzaro (CZ)"), new structType.ptr("A737", "Belfiore", "Verona (VR)"), new structType.ptr("A740", "Belforte All'Isauro", "Pesaro e Urbino (PU)"), new structType.ptr("A739", "Belforte Del Chienti", "Macerata (MC)"), new structType.ptr("A738", "Belforte Monferrato", "Alessandria (AL)"), new structType.ptr("A741", "Belgioioso", "Pavia (PV)"), new structType.ptr("A742", "Belgirate", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A743", "Bella", "Potenza (PZ)"), new structType.ptr("M335", "Bellagio", "Como (CO)"), new structType.ptr("A745", "Bellano", "Lecco (LC)"), new structType.ptr("A746", "Bellante", "Teramo (TE)"), new structType.ptr("A747", "Bellaria-Igea Marina", "Rimini (RN)"), new structType.ptr("A749", "Bellegra", "Roma (RM)"), new structType.ptr("A750", "Bellino", "Cuneo (CN)"), new structType.ptr("A751", "Bellinzago Lombardo", "Milano (MI)"), new structType.ptr("A752", "Bellinzago Novarese", "Novara (NO)"), new structType.ptr("M294", "Bellizzi", "Salerno (SA)"), new structType.ptr("A755", "Bellona", "Caserta (CE)"), new structType.ptr("A756", "Bellosguardo", "Salerno (SA)"), new structType.ptr("A757", "Belluno", "Belluno (BL)"), new structType.ptr("A759", "Bellusco", "Monza e della Brianza (MB)"), new structType.ptr("A762", "Belmonte Calabro", "Cosenza (CS)"), new structType.ptr("A763", "Belmonte Castello", "Frosinone (FR)"), new structType.ptr("A761", "Belmonte Del Sannio", "Isernia (IS)"), new structType.ptr("A765", "Belmonte In Sabina", "Rieti (RI)"), new structType.ptr("A764", "Belmonte Mezzagno", "Palermo (PA)"), new structType.ptr("A760", "Belmonte Piceno", "Fermo (FM)"), new structType.ptr("A766", "Belpasso", "Catania (CT)"), new structType.ptr("A768", "Belsito", "Cosenza (CS)"), new structType.ptr("A772", "Belvedere Di Spinello", "Crotone (KR)"), new structType.ptr("A774", "Belvedere Langhe", "Cuneo (CN)"), new structType.ptr("A773", "Belvedere Marittimo", "Cosenza (CS)"), new structType.ptr("A769", "Belvedere Ostrense", "Ancona (AN)"), new structType.ptr("A770", "Belveglio", "Asti (AT)"), new structType.ptr("A776", "Belv\xC3\xAC", "Nuoro (NU)"), new structType.ptr("A777", "Bema", "Sondrio (SO)"), new structType.ptr("A778", "Bene Lario", "Como (CO)"), new structType.ptr("A779", "Bene Vagienna", "Cuneo (CN)"), new structType.ptr("A780", "Benestare", "Reggio Calabria (RC)"), new structType.ptr("A781", "Benetutti", "Sassari (SS)"), new structType.ptr("A782", "Benevello", "Cuneo (CN)"), new structType.ptr("A783", "Benevento", "Benevento (BN)"), new structType.ptr("A784", "Benna", "Biella (BI)"), new structType.ptr("A785", "Bentivoglio", "Bologna (BO)"), new structType.ptr("A786", "Berbenno", "Bergamo (BG)"), new structType.ptr("A787", "Berbenno Di Valtellina", "Sondrio (SO)"), new structType.ptr("A788", "Berceto", "Parma (PR)"), new structType.ptr("A789", "Berchidda", "Olbia-Tempio (OT)"), new structType.ptr("A791", "Beregazzo Con Figliaro", "Como (CO)"), new structType.ptr("A792", "Bereguardo", "Pavia (PV)"), new structType.ptr("A793", "Bergamasco", "Alessandria (AL)"), new structType.ptr("A794", "Bergamo", "Bergamo (BG)"), new structType.ptr("A795", "Bergantino", "Rovigo (RO)"), new structType.ptr("A796", "Bergeggi", "Savona (SV)"), new structType.ptr("A798", "Bergolo", "Cuneo (CN)"), new structType.ptr("A799", "Berlingo", "Brescia (BS)"), new structType.ptr("A801", "Bernalda", "Matera (MT)"), new structType.ptr("A802", "Bernareggio", "Monza e della Brianza (MB)"), new structType.ptr("A804", "Bernate Ticino", "Milano (MI)"), new structType.ptr("A805", "Bernezzo", "Cuneo (CN)"), new structType.ptr("A806", "Berra", "Ferrara (FE)"), new structType.ptr("A809", "Bertinoro", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("A810", "Bertiolo", "Udine (UD)"), new structType.ptr("A811", "Bertonico", "Lodi (LO)"), new structType.ptr("A812", "Berzano Di San Pietro", "Asti (AT)"), new structType.ptr("A813", "Berzano Di Tortona", "Alessandria (AL)"), new structType.ptr("A816", "Berzo Demo", "Brescia (BS)"), new structType.ptr("A817", "Berzo Inferiore", "Brescia (BS)"), new structType.ptr("A815", "Berzo San Fermo", "Bergamo (BG)"), new structType.ptr("A818", "Besana In Brianza", "Monza e della Brianza (MB)"), new structType.ptr("A819", "Besano", "Varese (VA)"), new structType.ptr("A820", "Besate", "Milano (MI)"), new structType.ptr("A821", "Besenello", "Trento (TN)"), new structType.ptr("A823", "Besenzone", "Piacenza (PC)"), new structType.ptr("A825", "Besnate", "Varese (VA)"), new structType.ptr("A826", "Besozzo", "Varese (VA)"), new structType.ptr("A827", "Bessude", "Sassari (SS)"), new structType.ptr("A831", "Bettola", "Piacenza (PC)"), new structType.ptr("A832", "Bettona", "Perugia (PG)"), new structType.ptr("A834", "Beura-Cardezza", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A835", "Bevagna", "Perugia (PG)"), new structType.ptr("A836", "Beverino", "La Spezia (SP)"), new structType.ptr("A837", "Bevilacqua", "Verona (VR)"), new structType.ptr("A841", "Biancavilla", "Catania (CT)"), new structType.ptr("A842", "Bianchi", "Cosenza (CS)"), new structType.ptr("A843", "Bianco", "Reggio Calabria (RC)"), new structType.ptr("A844", "Biandrate", "Novara (NO)"), new structType.ptr("A845", "Biandronno", "Varese (VA)"), new structType.ptr("A846", "Bianzano", "Bergamo (BG)"), new structType.ptr("A847", "Bianz\xC3\xA8", "Vercelli (VC)"), new structType.ptr("A848", "Bianzone", "Sondrio (SO)"), new structType.ptr("A849", "Biassono", "Monza e della Brianza (MB)"), new structType.ptr("A850", "Bibbiano", "Reggio Emilia (RE)"), new structType.ptr("A851", "Bibbiena", "Arezzo (AR)"), new structType.ptr("A852", "Bibbona", "Livorno (LI)"), new structType.ptr("A853", "Bibiana", "Torino (TO)"), new structType.ptr("A854", "Biccari", "Foggia (FG)"), new structType.ptr("A855", "Bicinicco", "Udine (UD)"), new structType.ptr("A856", "Bidon\xC3\xAC", "Oristano (OR)"), new structType.ptr("A859", "Biella", "Biella (BI)"), new structType.ptr("A861", "Bienno", "Brescia (BS)"), new structType.ptr("A863", "Bieno", "Trento (TN)"), new structType.ptr("A864", "Bientina", "Pisa (PI)"), new structType.ptr("A866", "Bigarello", "Mantova (MN)"), new structType.ptr("A870", "Binago", "Como (CO)"), new structType.ptr("A872", "Binasco", "Milano (MI)"), new structType.ptr("A874", "Binetto", "Bari (BA)"), new structType.ptr("A876", "Bioglio", "Biella (BI)"), new structType.ptr("A877", "Bionaz", "Aosta (AO)"), new structType.ptr("A878", "Bione", "Brescia (BS)"), new structType.ptr("A880", "Birori", "Nuoro (NU)"), new structType.ptr("A881", "Bisaccia", "Avellino (AV)"), new structType.ptr("A882", "Bisacquino", "Palermo (PA)"), new structType.ptr("A883", "Bisceglie", "Barletta-Andria-Trani (BT)"), new structType.ptr("A884", "Bisegna", "L'Aquila (AQ)"), new structType.ptr("A885", "Bisenti", "Teramo (TE)"), new structType.ptr("A887", "Bisignano", "Cosenza (CS)"), new structType.ptr("A889", "Bistagno", "Alessandria (AL)"), new structType.ptr("A891", "Bisuschio", "Varese (VA)"), new structType.ptr("A892", "Bitetto", "Bari (BA)"), new structType.ptr("A893", "Bitonto", "Bari (BA)"), new structType.ptr("A894", "Bitritto", "Bari (BA)"), new structType.ptr("A895", "Bitti", "Nuoro (NU)"), new structType.ptr("A896", "Bivona", "Agrigento (AG)"), new structType.ptr("A897", "Bivongi", "Reggio Calabria (RC)"), new structType.ptr("A898", "Bizzarone", "Como (CO)"), new structType.ptr("A902", "Bleggio Superiore", "Trento (TN)"), new structType.ptr("A903", "Blello", "Bergamo (BG)"), new structType.ptr("A857", "Blera", "Viterbo (VT)"), new structType.ptr("A904", "Blessagno", "Como (CO)"), new structType.ptr("A905", "Blevio", "Como (CO)"), new structType.ptr("M268", "Blufi", "Palermo (PA)"), new structType.ptr("A906", "Boara Pisani", "Padova (PD)"), new structType.ptr("A909", "Bobbio", "Piacenza (PC)"), new structType.ptr("A910", "Bobbio Pellice", "Torino (TO)"), new structType.ptr("A911", "Boca", "Novara (NO)"), new structType.ptr("A912", "Bocchigliero", "Cosenza (CS)"), new structType.ptr("A914", "Boccioleto", "Vercelli (VC)"), new structType.ptr("A916", "Bocenago", "Trento (TN)"), new structType.ptr("A918", "Bodio Lomnago", "Varese (VA)"), new structType.ptr("A919", "Boffalora D'Adda", "Lodi (LO)"), new structType.ptr("A920", "Boffalora Sopra Ticino", "Milano (MI)"), new structType.ptr("A922", "Bogliasco", "Genova (GE)"), new structType.ptr("A925", "Bognanco", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A929", "Bogogno", "Novara (NO)"), new structType.ptr("A931", "Boissano", "Savona (SV)"), new structType.ptr("A930", "Bojano", "Campobasso (CB)"), new structType.ptr("A932", "Bolano", "La Spezia (SP)"), new structType.ptr("A937", "Bolgare", "Bergamo (BG)"), new structType.ptr("A940", "Bollate", "Milano (MI)"), new structType.ptr("A941", "Bollengo", "Torino (TO)"), new structType.ptr("A944", "Bologna", "Bologna (BO)"), new structType.ptr("A945", "Bolognano", "Pescara (PE)"), new structType.ptr("A946", "Bolognetta", "Palermo (PA)"), new structType.ptr("A947", "Bolognola", "Macerata (MC)"), new structType.ptr("A948", "Bolotana", "Nuoro (NU)"), new structType.ptr("A949", "Bolsena", "Viterbo (VT)"), new structType.ptr("A950", "Boltiere", "Bergamo (BG)"), new structType.ptr("A952", "Bolzano .Bozen.", "Bolzano (BZ)"), new structType.ptr("A953", "Bolzano Novarese", "Novara (NO)"), new structType.ptr("A954", "Bolzano Vicentino", "Vicenza (VI)"), new structType.ptr("A955", "Bomarzo", "Viterbo (VT)"), new structType.ptr("A956", "Bomba", "Chieti (CH)"), new structType.ptr("A957", "Bompensiere", "Caltanissetta (CL)"), new structType.ptr("A958", "Bompietro", "Palermo (PA)"), new structType.ptr("A959", "Bomporto", "Modena (MO)"), new structType.ptr("A960", "Bonarcado", "Oristano (OR)"), new structType.ptr("A961", "Bonassola", "La Spezia (SP)"), new structType.ptr("A963", "Bonate Sopra", "Bergamo (BG)"), new structType.ptr("A962", "Bonate Sotto", "Bergamo (BG)"), new structType.ptr("A964", "Bonavigo", "Verona (VR)"), new structType.ptr("A965", "Bondeno", "Ferrara (FE)"), new structType.ptr("A968", "Bondone", "Trento (TN)"), new structType.ptr("A970", "Bonea", "Benevento (BN)"), new structType.ptr("A971", "Bonefro", "Campobasso (CB)"), new structType.ptr("A972", "Bonemerse", "Cremona (CR)"), new structType.ptr("A973", "Bonifati", "Cosenza (CS)"), new structType.ptr("A975", "Bonito", "Avellino (AV)"), new structType.ptr("A976", "Bonnanaro", "Sassari (SS)"), new structType.ptr("A977", "Bono", "Sassari (SS)"), new structType.ptr("A978", "Bonorva", "Sassari (SS)"), new structType.ptr("A979", "Bonvicino", "Cuneo (CN)"), new structType.ptr("A981", "Borbona", "Rieti (RI)"), new structType.ptr("A982", "Borca Di Cadore", "Belluno (BL)"), new structType.ptr("A983", "Bordano", "Udine (UD)"), new structType.ptr("A984", "Bordighera", "Imperia (IM)"), new structType.ptr("A986", "Bordolano", "Cremona (CR)"), new structType.ptr("A987", "Bore", "Parma (PR)"), new structType.ptr("A988", "Boretto", "Reggio Emilia (RE)"), new structType.ptr("A989", "Borgarello", "Pavia (PV)"), new structType.ptr("A990", "Borgaro Torinese", "Torino (TO)"), new structType.ptr("A991", "Borgetto", "Palermo (PA)"), new structType.ptr("A993", "Borghetto D'Arroscia", "Imperia (IM)"), new structType.ptr("A998", "Borghetto Di Borbera", "Alessandria (AL)"), new structType.ptr("A992", "Borghetto Di Vara", "La Spezia (SP)"), new structType.ptr("A995", "Borghetto Lodigiano", "Lodi (LO)"), new structType.ptr("A999", "Borghetto Santo Spirito", "Savona (SV)"), new structType.ptr("B001", "Borghi", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("B002", "Borgia", "Catanzaro (CZ)"), new structType.ptr("B003", "Borgiallo", "Torino (TO)"), new structType.ptr("B005", "Borgio Verezzi", "Savona (SV)"), new structType.ptr("B007", "Borgo A Mozzano", "Lucca (LU)"), new structType.ptr("M352", "Borgo Chiese", "Trento (TN)"), new structType.ptr("B009", "Borgo D'Ale", "Vercelli (VC)"), new structType.ptr("B010", "Borgo Di Terzo", "Bergamo (BG)"), new structType.ptr("M353", "Borgo Lares", "Trento (TN)"), new structType.ptr("B026", "Borgo Pace", "Pesaro e Urbino (PU)"), new structType.ptr("B028", "Borgo Priolo", "Pavia (PV)"), new structType.ptr("B033", "Borgo San Dalmazzo", "Cuneo (CN)"), new structType.ptr("B035", "Borgo San Giacomo", "Brescia (BS)"), new structType.ptr("B017", "Borgo San Giovanni", "Lodi (LO)"), new structType.ptr("B036", "Borgo San Lorenzo", "Firenze (FI)"), new structType.ptr("B037", "Borgo San Martino", "Alessandria (AL)"), new structType.ptr("B038", "Borgo San Siro", "Pavia (PV)"), new structType.ptr("B043", "Borgo Ticino", "Novara (NO)"), new structType.ptr("B044", "Borgo Tossignano", "Bologna (BO)"), new structType.ptr("B042", "Borgo Val Di Taro", "Parma (PR)"), new structType.ptr("B006", "Borgo Valsugana", "Trento (TN)"), new structType.ptr("A996", "Borgo Velino", "Rieti (RI)"), new structType.ptr("B046", "Borgo Vercelli", "Vercelli (VC)"), new structType.ptr("M340", "Borgo Virgilio", "Mantova (MN)"), new structType.ptr("B015", "Borgofranco D'Ivrea", "Torino (TO)"), new structType.ptr("B013", "Borgofranco Sul Po", "Mantova (MN)"), new structType.ptr("B016", "Borgolavezzaro", "Novara (NO)"), new structType.ptr("B018", "Borgomale", "Cuneo (CN)"), new structType.ptr("B019", "Borgomanero", "Novara (NO)"), new structType.ptr("B020", "Borgomaro", "Imperia (IM)"), new structType.ptr("B021", "Borgomasino", "Torino (TO)"), new structType.ptr("M370", "Borgomezzavalle", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("B024", "Borgone Susa", "Torino (TO)"), new structType.ptr("B025", "Borgonovo Val Tidone", "Piacenza (PC)"), new structType.ptr("B029", "Borgoratto Alessandrino", "Alessandria (AL)"), new structType.ptr("B030", "Borgoratto Mormorolo", "Pavia (PV)"), new structType.ptr("B031", "Borgoricco", "Padova (PD)"), new structType.ptr("B008", "Borgorose", "Rieti (RI)"), new structType.ptr("B040", "Borgosatollo", "Brescia (BS)"), new structType.ptr("B041", "Borgosesia", "Vercelli (VC)"), new structType.ptr("B048", "Bormida", "Savona (SV)"), new structType.ptr("B049", "Bormio", "Sondrio (SO)"), new structType.ptr("B051", "Bornasco", "Pavia (PV)"), new structType.ptr("B054", "Borno", "Brescia (BS)"), new structType.ptr("B055", "Boroneddu", "Oristano (OR)"), new structType.ptr("B056", "Borore", "Nuoro (NU)"), new structType.ptr("B057", "Borrello", "Chieti (CH)"), new structType.ptr("B058", "Borriana", "Biella (BI)"), new structType.ptr("B061", "Borso Del Grappa", "Treviso (TV)"), new structType.ptr("B062", "Bortigali", "Nuoro (NU)"), new structType.ptr("B063", "Bortigiadas", "Olbia-Tempio (OT)"), new structType.ptr("B064", "Borutta", "Sassari (SS)"), new structType.ptr("B067", "Borzonasca", "Genova (GE)"), new structType.ptr("B068", "Bosa", "Oristano (OR)"), new structType.ptr("B069", "Bosaro", "Rovigo (RO)"), new structType.ptr("B070", "Boschi Sant'Anna", "Verona (VR)"), new structType.ptr("B073", "Bosco Chiesanuova", "Verona (VR)"), new structType.ptr("B071", "Bosco Marengo", "Alessandria (AL)"), new structType.ptr("B075", "Bosconero", "Torino (TO)"), new structType.ptr("B076", "Boscoreale", "Napoli (NA)"), new structType.ptr("B077", "Boscotrecase", "Napoli (NA)"), new structType.ptr("B079", "Bosia", "Cuneo (CN)"), new structType.ptr("B080", "Bosio", "Alessandria (AL)"), new structType.ptr("B081", "Bosisio Parini", "Lecco (LC)"), new structType.ptr("B082", "Bosnasco", "Pavia (PV)"), new structType.ptr("B083", "Bossico", "Bergamo (BG)"), new structType.ptr("B084", "Bossolasco", "Cuneo (CN)"), new structType.ptr("B085", "Botricello", "Catanzaro (CZ)"), new structType.ptr("B086", "Botrugno", "Lecce (LE)"), new structType.ptr("B088", "Bottanuco", "Bergamo (BG)"), new structType.ptr("B091", "Botticino", "Brescia (BS)"), new structType.ptr("B094", "Bottidda", "Sassari (SS)"), new structType.ptr("B097", "Bova", "Reggio Calabria (RC)"), new structType.ptr("B099", "Bova Marina", "Reggio Calabria (RC)"), new structType.ptr("B098", "Bovalino", "Reggio Calabria (RC)"), new structType.ptr("B100", "Bovegno", "Brescia (BS)"), new structType.ptr("B101", "Boves", "Cuneo (CN)"), new structType.ptr("B102", "Bovezzo", "Brescia (BS)"), new structType.ptr("A720", "Boville Ernica", "Frosinone (FR)"), new structType.ptr("B104", "Bovino", "Foggia (FG)"), new structType.ptr("B105", "Bovisio-Masciago", "Monza e della Brianza (MB)"), new structType.ptr("B106", "Bovolenta", "Padova (PD)"), new structType.ptr("B107", "Bovolone", "Verona (VR)"), new structType.ptr("B109", "Bozzole", "Alessandria (AL)"), new structType.ptr("B110", "Bozzolo", "Mantova (MN)"), new structType.ptr("B111", "Bra", "Cuneo (CN)"), new structType.ptr("B112", "Bracca", "Bergamo (BG)"), new structType.ptr("B114", "Bracciano", "Roma (RM)"), new structType.ptr("B115", "Bracigliano", "Salerno (SA)"), new structType.ptr("B116", "Braies .Prags.", "Bolzano (BZ)"), new structType.ptr("B117", "Brallo Di Pregola", "Pavia (PV)"), new structType.ptr("B118", "Brancaleone", "Reggio Calabria (RC)"), new structType.ptr("B120", "Brandico", "Brescia (BS)"), new structType.ptr("B121", "Brandizzo", "Torino (TO)"), new structType.ptr("B123", "Branzi", "Bergamo (BG)"), new structType.ptr("B124", "Braone", "Brescia (BS)"), new structType.ptr("B126", "Brebbia", "Varese (VA)"), new structType.ptr("B128", "Breda Di Piave", "Treviso (TV)"), new structType.ptr("B131", "Bregano", "Varese (VA)"), new structType.ptr("B132", "Breganze", "Vicenza (VI)"), new structType.ptr("B134", "Bregnano", "Como (CO)"), new structType.ptr("B136", "Breia", "Vercelli (VC)"), new structType.ptr("B137", "Brembate", "Bergamo (BG)"), new structType.ptr("B138", "Brembate Di Sopra", "Bergamo (BG)"), new structType.ptr("B141", "Brembio", "Lodi (LO)"), new structType.ptr("B142", "Breme", "Pavia (PV)"), new structType.ptr("B143", "Brendola", "Vicenza (VI)"), new structType.ptr("B144", "Brenna", "Como (CO)"), new structType.ptr("B145", "Brennero .Brenner.", "Bolzano (BZ)"), new structType.ptr("B149", "Breno", "Brescia (BS)"), new structType.ptr("B150", "Brenta", "Varese (VA)"), new structType.ptr("B152", "Brentino Belluno", "Verona (VR)"), new structType.ptr("B153", "Brentonico", "Trento (TN)"), new structType.ptr("B154", "Brenzone", "Verona (VR)"), new structType.ptr("B156", "Brescello", "Reggio Emilia (RE)"), new structType.ptr("B157", "Brescia", "Brescia (BS)"), new structType.ptr("B158", "Bresimo", "Trento (TN)"), new structType.ptr("B159", "Bressana Bottarone", "Pavia (PV)"), new structType.ptr("B160", "Bressanone .Brixen.", "Bolzano (BZ)"), new structType.ptr("B161", "Bressanvido", "Vicenza (VI)"), new structType.ptr("B162", "Bresso", "Milano (MI)"), new structType.ptr("B165", "Brez", "Trento (TN)"), new structType.ptr("B166", "Brezzo Di Bedero", "Varese (VA)"), new structType.ptr("B167", "Briaglia", "Cuneo (CN)"), new structType.ptr("B169", "Briatico", "Vibo Valentia (VV)"), new structType.ptr("B171", "Bricherasio", "Torino (TO)"), new structType.ptr("B172", "Brienno", "Como (CO)"), new structType.ptr("B173", "Brienza", "Potenza (PZ)"), new structType.ptr("B175", "Briga Alta", "Cuneo (CN)"), new structType.ptr("B176", "Briga Novarese", "Novara (NO)"), new structType.ptr("B178", "Brignano Gera D'Adda", "Bergamo (BG)"), new structType.ptr("B179", "Brignano-Frascata", "Alessandria (AL)"), new structType.ptr("B180", "Brindisi", "Brindisi (BR)"), new structType.ptr("B181", "Brindisi Montagna", "Potenza (PZ)"), new structType.ptr("B182", "Brinzio", "Varese (VA)"), new structType.ptr("B183", "Briona", "Novara (NO)"), new structType.ptr("B184", "Brione", "Brescia (BS)"), new structType.ptr("B187", "Briosco", "Monza e della Brianza (MB)"), new structType.ptr("B188", "Brisighella", "Ravenna (RA)"), new structType.ptr("B191", "Brissago-Valtravaglia", "Varese (VA)"), new structType.ptr("B192", "Brissogne", "Aosta (AO)"), new structType.ptr("B193", "Brittoli", "Pescara (PE)"), new structType.ptr("B194", "Brivio", "Lecco (LC)"), new structType.ptr("B195", "Broccostella", "Frosinone (FR)"), new structType.ptr("B196", "Brogliano", "Vicenza (VI)"), new structType.ptr("B197", "Brognaturo", "Vibo Valentia (VV)"), new structType.ptr("B198", "Brolo", "Messina (ME)"), new structType.ptr("B200", "Brondello", "Cuneo (CN)"), new structType.ptr("B201", "Broni", "Pavia (PV)"), new structType.ptr("B202", "Bronte", "Catania (CT)"), new structType.ptr("B203", "Bronzolo .Branzoll.", "Bolzano (BZ)"), new structType.ptr("B204", "Brossasco", "Cuneo (CN)"), new structType.ptr("B205", "Brosso", "Torino (TO)"), new structType.ptr("B207", "Brovello-Carpugnino", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("B209", "Brozolo", "Torino (TO)"), new structType.ptr("B212", "Brugherio", "Monza e della Brianza (MB)"), new structType.ptr("B213", "Brugine", "Padova (PD)"), new structType.ptr("B214", "Brugnato", "La Spezia (SP)"), new structType.ptr("B215", "Brugnera", "Pordenone (PN)"), new structType.ptr("B216", "Bruino", "Torino (TO)"), new structType.ptr("B217", "Brumano", "Bergamo (BG)"), new structType.ptr("B218", "Brunate", "Como (CO)"), new structType.ptr("B219", "Brunello", "Varese (VA)"), new structType.ptr("B220", "Brunico .Bruneck.", "Bolzano (BZ)"), new structType.ptr("B221", "Bruno", "Asti (AT)"), new structType.ptr("B223", "Brusaporto", "Bergamo (BG)"), new structType.ptr("B225", "Brusasco", "Torino (TO)"), new structType.ptr("B227", "Brusciano", "Napoli (NA)"), new structType.ptr("B228", "Brusimpiano", "Varese (VA)"), new structType.ptr("B229", "Brusnengo", "Biella (BI)"), new structType.ptr("B230", "Brusson", "Aosta (AO)"), new structType.ptr("B232", "Bruzolo", "Torino (TO)"), new structType.ptr("B234", "Bruzzano Zeffirio", "Reggio Calabria (RC)"), new structType.ptr("B235", "Bubbiano", "Milano (MI)"), new structType.ptr("B236", "Bubbio", "Asti (AT)"), new structType.ptr("B237", "Buccheri", "Siracusa (SR)"), new structType.ptr("B238", "Bucchianico", "Chieti (CH)"), new structType.ptr("B239", "Bucciano", "Benevento (BN)"), new structType.ptr("B240", "Buccinasco", "Milano (MI)"), new structType.ptr("B242", "Buccino", "Salerno (SA)"), new structType.ptr("B243", "Bucine", "Arezzo (AR)"), new structType.ptr("B246", "Buddus\xC3\xB2", "Olbia-Tempio (OT)"), new structType.ptr("B247", "Budoia", "Pordenone (PN)"), new structType.ptr("B248", "Budoni", "Olbia-Tempio (OT)"), new structType.ptr("B249", "Budrio", "Bologna (BO)"), new structType.ptr("B250", "Buggerru", "Carbonia-Iglesias (CI)"), new structType.ptr("B251", "Buggiano", "Pistoia (PT)"), new structType.ptr("B255", "Buglio In Monte", "Sondrio (SO)"), new structType.ptr("B256", "Bugnara", "L'Aquila (AQ)"), new structType.ptr("B258", "Buguggiate", "Varese (VA)"), new structType.ptr("B259", "Buja", "Udine (UD)"), new structType.ptr("B261", "Bulciago", "Lecco (LC)"), new structType.ptr("B262", "Bulgarograsso", "Como (CO)"), new structType.ptr("B264", "Bultei", "Sassari (SS)"), new structType.ptr("B265", "Bulzi", "Sassari (SS)"), new structType.ptr("B266", "Buonabitacolo", "Salerno (SA)"), new structType.ptr("B267", "Buonalbergo", "Benevento (BN)"), new structType.ptr("B269", "Buonconvento", "Siena (SI)"), new structType.ptr("B270", "Buonvicino", "Cosenza (CS)"), new structType.ptr("B272", "Burago Di Molgora", "Monza e della Brianza (MB)"), new structType.ptr("B274", "Burcei", "Cagliari (CA)"), new structType.ptr("B275", "Burgio", "Agrigento (AG)"), new structType.ptr("B276", "Burgos", "Sassari (SS)"), new structType.ptr("B278", "Buriasco", "Torino (TO)"), new structType.ptr("B279", "Burolo", "Torino (TO)"), new structType.ptr("B280", "Buronzo", "Vercelli (VC)"), new structType.ptr("B281", "Busachi", "Oristano (OR)"), new structType.ptr("B282", "Busalla", "Genova (GE)"), new structType.ptr("B284", "Busano", "Torino (TO)"), new structType.ptr("B285", "Busca", "Cuneo (CN)"), new structType.ptr("B286", "Buscate", "Milano (MI)"), new structType.ptr("B287", "Buscemi", "Siracusa (SR)"), new structType.ptr("B288", "Buseto Palizzolo", "Trapani (TP)"), new structType.ptr("B289", "Busnago", "Monza e della Brianza (MB)"), new structType.ptr("B292", "Bussero", "Milano (MI)"), new structType.ptr("B293", "Busseto", "Parma (PR)"), new structType.ptr("B294", "Bussi Sul Tirino", "Pescara (PE)"), new structType.ptr("B295", "Busso", "Campobasso (CB)"), new structType.ptr("B296", "Bussolengo", "Verona (VR)"), new structType.ptr("B297", "Bussoleno", "Torino (TO)"), new structType.ptr("B300", "Busto Arsizio", "Varese (VA)"), new structType.ptr("B301", "Busto Garolfo", "Milano (MI)"), new structType.ptr("B302", "Butera", "Caltanissetta (CL)"), new structType.ptr("B303", "Buti", "Pisa (PI)"), new structType.ptr("B304", "Buttapietra", "Verona (VR)"), new structType.ptr("B305", "Buttigliera Alta", "Torino (TO)"), new structType.ptr("B306", "Buttigliera D'Asti", "Asti (AT)"), new structType.ptr("B309", "Buttrio", "Udine (UD)"), new structType.ptr("B320", "Ca' D'Andrea", "Cremona (CR)"), new structType.ptr("B311", "Cabella Ligure", "Alessandria (AL)"), new structType.ptr("B313", "Cabiate", "Como (CO)"), new structType.ptr("B314", "Cabras", "Oristano (OR)"), new structType.ptr("B315", "Caccamo", "Palermo (PA)"), new structType.ptr("B319", "Caccuri", "Crotone (KR)"), new structType.ptr("B326", "Cadegliano-Viconago", "Varese (VA)"), new structType.ptr("B328", "Cadelbosco Di Sopra", "Reggio Emilia (RE)"), new structType.ptr("B332", "Cadeo", "Piacenza (PC)"), new structType.ptr("B335", "Caderzone Terme", "Trento (TN)"), new structType.ptr("B345", "Cadoneghe", "Padova (PD)"), new structType.ptr("B346", "Cadorago", "Como (CO)"), new structType.ptr("B347", "Cadrezzate", "Varese (VA)"), new structType.ptr("B349", "Caerano Di San Marco", "Treviso (TV)"), new structType.ptr("B350", "Cafasse", "Torino (TO)"), new structType.ptr("B351", "Caggiano", "Salerno (SA)"), new structType.ptr("B352", "Cagli", "Pesaro e Urbino (PU)"), new structType.ptr("B354", "Cagliari", "Cagliari (CA)"), new structType.ptr("B355", "Caglio", "Como (CO)"), new structType.ptr("B358", "Cagnano Amiterno", "L'Aquila (AQ)"), new structType.ptr("B357", "Cagnano Varano", "Foggia (FG)"), new structType.ptr("B359", "Cagno", "Como (CO)"), new structType.ptr("B360", "Cagn\xC3\xB2", "Trento (TN)"), new structType.ptr("B361", "Caianello", "Caserta (CE)"), new structType.ptr("B362", "Caiazzo", "Caserta (CE)"), new structType.ptr("B364", "Caines .Kuens.", "Bolzano (BZ)"), new structType.ptr("B365", "Caino", "Brescia (BS)"), new structType.ptr("B366", "Caiolo", "Sondrio (SO)"), new structType.ptr("B367", "Cairano", "Avellino (AV)"), new structType.ptr("B368", "Cairate", "Varese (VA)"), new structType.ptr("B369", "Cairo Montenotte", "Savona (SV)"), new structType.ptr("B371", "Caivano", "Napoli (NA)"), new structType.ptr("B374", "Calabritto", "Avellino (AV)"), new structType.ptr("B375", "Calalzo Di Cadore", "Belluno (BL)"), new structType.ptr("B376", "Calamandrana", "Asti (AT)"), new structType.ptr("B377", "Calamonaci", "Agrigento (AG)"), new structType.ptr("B378", "Calangianus", "Olbia-Tempio (OT)"), new structType.ptr("B379", "Calanna", "Reggio Calabria (RC)"), new structType.ptr("B380", "Calasca-Castiglione", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("B381", "Calascibetta", "Enna (EN)"), new structType.ptr("B382", "Calascio", "L'Aquila (AQ)"), new structType.ptr("B383", "Calasetta", "Carbonia-Iglesias (CI)"), new structType.ptr("B384", "Calatabiano", "Catania (CT)"), new structType.ptr("B385", "Calatafimi Segesta", "Trapani (TP)"), new structType.ptr("B388", "Calcata", "Viterbo (VT)"), new structType.ptr("B389", "Calceranica Al Lago", "Trento (TN)"), new structType.ptr("B390", "Calci", "Pisa (PI)"), new structType.ptr("B391", "Calciano", "Matera (MT)"), new structType.ptr("B392", "Calcinaia", "Pisa (PI)"), new structType.ptr("B393", "Calcinate", "Bergamo (BG)"), new structType.ptr("B394", "Calcinato", "Brescia (BS)"), new structType.ptr("B395", "Calcio", "Bergamo (BG)"), new structType.ptr("B396", "Calco", "Lecco (LC)"), new structType.ptr("B397", "Caldaro Sulla Strada Del Vino .Kaltern An De.", "Bolzano (BZ)"), new structType.ptr("B398", "Caldarola", "Macerata (MC)"), new structType.ptr("B399", "Calderara Di Reno", "Bologna (BO)"), new structType.ptr("B400", "Caldes", "Trento (TN)"), new structType.ptr("B402", "Caldiero", "Verona (VR)"), new structType.ptr("B403", "Caldogno", "Vicenza (VI)"), new structType.ptr("B404", "Caldonazzo", "Trento (TN)"), new structType.ptr("B405", "Calendasco", "Piacenza (PC)"), new structType.ptr("B406", "Calenzano", "Firenze (FI)"), new structType.ptr("B408", "Calestano", "Parma (PR)"), new structType.ptr("B410", "Calice Al Cornoviglio", "La Spezia (SP)"), new structType.ptr("B409", "Calice Ligure", "Savona (SV)"), new structType.ptr("B413", "Calimera", "Lecce (LE)"), new structType.ptr("B415", "Calitri", "Avellino (AV)"), new structType.ptr("B416", "Calizzano", "Savona (SV)"), new structType.ptr("B417", "Callabiana", "Biella (BI)"), new structType.ptr("B418", "Calliano", "Asti (AT)"), new structType.ptr("B419", "Calliano", "Trento (TN)"), new structType.ptr("B423", "Calolziocorte", "Lecco (LC)"), new structType.ptr("B424", "Calopezzati", "Cosenza (CS)"), new structType.ptr("B425", "Calosso", "Asti (AT)"), new structType.ptr("B426", "Caloveto", "Cosenza (CS)"), new structType.ptr("B427", "Caltabellotta", "Agrigento (AG)"), new structType.ptr("B428", "Caltagirone", "Catania (CT)"), new structType.ptr("B429", "Caltanissetta", "Caltanissetta (CL)"), new structType.ptr("B430", "Caltavuturo", "Palermo (PA)"), new structType.ptr("B431", "Caltignaga", "Novara (NO)"), new structType.ptr("B432", "Calto", "Rovigo (RO)"), new structType.ptr("B433", "Caltrano", "Vicenza (VI)"), new structType.ptr("B434", "Calusco D'Adda", "Bergamo (BG)"), new structType.ptr("B435", "Caluso", "Torino (TO)"), new structType.ptr("B436", "Calvagese Della Riviera", "Brescia (BS)"), new structType.ptr("B437", "Calvanico", "Salerno (SA)"), new structType.ptr("B439", "Calvatone", "Cremona (CR)"), new structType.ptr("B440", "Calvello", "Potenza (PZ)"), new structType.ptr("B441", "Calvene", "Vicenza (VI)"), new structType.ptr("B442", "Calvenzano", "Bergamo (BG)"), new structType.ptr("B443", "Calvera", "Potenza (PZ)"), new structType.ptr("B444", "Calvi", "Benevento (BN)"), new structType.ptr("B446", "Calvi Dell'Umbria", "Terni (TR)"), new structType.ptr("B445", "Calvi Risorta", "Caserta (CE)"), new structType.ptr("B447", "Calvignano", "Pavia (PV)"), new structType.ptr("B448", "Calvignasco", "Milano (MI)"), new structType.ptr("B450", "Calvisano", "Brescia (BS)"), new structType.ptr("B452", "Calvizzano", "Napoli (NA)"), new structType.ptr("B453", "Camagna Monferrato", "Alessandria (AL)"), new structType.ptr("B455", "Camaiore", "Lucca (LU)"), new structType.ptr("B456", "Camairago", "Lodi (LO)"), new structType.ptr("B457", "Camandona", "Biella (BI)"), new structType.ptr("B460", "Camastra", "Agrigento (AG)"), new structType.ptr("B461", "Cambiago", "Milano (MI)"), new structType.ptr("B462", "Cambiano", "Torino (TO)"), new structType.ptr("B463", "Cambiasca", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("B465", "Camburzano", "Biella (BI)"), new structType.ptr("B467", "Camerana", "Cuneo (CN)"), new structType.ptr("B468", "Camerano", "Ancona (AN)"), new structType.ptr("B469", "Camerano Casasco", "Asti (AT)"), new structType.ptr("B471", "Camerata Cornello", "Bergamo (BG)"), new structType.ptr("B472", "Camerata Nuova", "Roma (RM)"), new structType.ptr("B470", "Camerata Picena", "Ancona (AN)"), new structType.ptr("B473", "Cameri", "Novara (NO)"), new structType.ptr("B474", "Camerino", "Macerata (MC)"), new structType.ptr("B476", "Camerota", "Salerno (SA)"), new structType.ptr("B477", "Camigliano", "Caserta (CE)"), new structType.ptr("B479", "Caminata", "Piacenza (PC)"), new structType.ptr("B481", "Camini", "Reggio Calabria (RC)"), new structType.ptr("B482", "Camino", "Alessandria (AL)"), new structType.ptr("B483", "Camino Al Tagliamento", "Udine (UD)"), new structType.ptr("B484", "Camisano", "Cremona (CR)"), new structType.ptr("B485", "Camisano Vicentino", "Vicenza (VI)"), new structType.ptr("B486", "Cammarata", "Agrigento (AG)"), new structType.ptr("B489", "Camo", "Cuneo (CN)"), new structType.ptr("B490", "Camogli", "Genova (GE)"), new structType.ptr("B492", "Campagna", "Salerno (SA)"), new structType.ptr("B493", "Campagna Lupia", "Venezia (VE)"), new structType.ptr("B496", "Campagnano Di Roma", "Roma (RM)"), new structType.ptr("B497", "Campagnatico", "Grosseto (GR)"), new structType.ptr("B498", "Campagnola Cremasca", "Cremona (CR)"), new structType.ptr("B499", "Campagnola Emilia", "Reggio Emilia (RE)"), new structType.ptr("B500", "Campana", "Cosenza (CS)"), new structType.ptr("B501", "Camparada", "Monza e della Brianza (MB)"), new structType.ptr("B502", "Campegine", "Reggio Emilia (RE)"), new structType.ptr("B504", "Campello Sul Clitunno", "Perugia (PG)"), new structType.ptr("B505", "Campertogno", "Vercelli (VC)"), new structType.ptr("B507", "Campi Bisenzio", "Firenze (FI)"), new structType.ptr("B506", "Campi Salentina", "Lecce (LE)"), new structType.ptr("M373", "Campiglia Cervo", "Biella (BI)"), new structType.ptr("B511", "Campiglia Dei Berici", "Vicenza (VI)"), new structType.ptr("B509", "Campiglia Marittima", "Livorno (LI)"), new structType.ptr("B512", "Campiglione Fenile", "Torino (TO)"), new structType.ptr("B513", "Campione D'Italia", "Como (CO)"), new structType.ptr("B514", "Campitello Di Fassa", "Trento (TN)"), new structType.ptr("B515", "Campli", "Teramo (TE)"), new structType.ptr("B516", "Campo Calabro", "Reggio Calabria (RC)"), new structType.ptr("B526", "Campo Di Giove", "L'Aquila (AQ)"), new structType.ptr("B529", "Campo Di Trens .Freienfeld.", "Bolzano (BZ)"), new structType.ptr("B538", "Campo Ligure", "Genova (GE)"), new structType.ptr("B553", "Campo Nell'Elba", "Livorno (LI)"), new structType.ptr("B564", "Campo San Martino", "Padova (PD)"), new structType.ptr("B570", "Campo Tures .Sand In Taufers.", "Bolzano (BZ)"), new structType.ptr("B519", "Campobasso", "Campobasso (CB)"), new structType.ptr("B520", "Campobello Di Licata", "Agrigento (AG)"), new structType.ptr("B521", "Campobello Di Mazara", "Trapani (TP)"), new structType.ptr("B522", "Campochiaro", "Campobasso (CB)"), new structType.ptr("B524", "Campodarsego", "Padova (PD)"), new structType.ptr("B525", "Campodenno", "Trento (TN)"), new structType.ptr("B527", "Campodimele", "Latina (LT)"), new structType.ptr("B528", "Campodipietra", "Campobasso (CB)"), new structType.ptr("B530", "Campodolcino", "Sondrio (SO)"), new structType.ptr("B531", "Campodoro", "Padova (PD)"), new structType.ptr("B533", "Campofelice Di Fitalia", "Palermo (PA)"), new structType.ptr("B532", "Campofelice Di Roccella", "Palermo (PA)"), new structType.ptr("B534", "Campofilone", "Fermo (FM)"), new structType.ptr("B535", "Campofiorito", "Palermo (PA)"), new structType.ptr("B536", "Campoformido", "Udine (UD)"), new structType.ptr("B537", "Campofranco", "Caltanissetta (CL)"), new structType.ptr("B539", "Campogalliano", "Modena (MO)"), new structType.ptr("B541", "Campolattaro", "Benevento (BN)"), new structType.ptr("B543", "Campoli Appennino", "Frosinone (FR)"), new structType.ptr("B542", "Campoli Del Monte Taburno", "Benevento (BN)"), new structType.ptr("B544", "Campolieto", "Campobasso (CB)"), new structType.ptr("B546", "Campolongo Maggiore", "Venezia (VE)"), new structType.ptr("B547", "Campolongo Sul Brenta", "Vicenza (VI)"), new structType.ptr("M311", "Campolongo Tapogliano", "Udine (UD)"), new structType.ptr("B549", "Campomaggiore", "Potenza (PZ)"), new structType.ptr("B550", "Campomarino", "Campobasso (CB)"), new structType.ptr("B551", "Campomorone", "Genova (GE)"), new structType.ptr("B554", "Camponogara", "Venezia (VE)"), new structType.ptr("B555", "Campora", "Salerno (SA)"), new structType.ptr("B556", "Camporeale", "Palermo (PA)"), new structType.ptr("B557", "Camporgiano", "Lucca (LU)"), new structType.ptr("B559", "Camporosso", "Imperia (IM)"), new structType.ptr("B562", "Camporotondo Di Fiastrone", "Macerata (MC)"), new structType.ptr("B561", "Camporotondo Etneo", "Catania (CT)"), new structType.ptr("B563", "Camposampiero", "Padova (PD)"), new structType.ptr("B565", "Camposano", "Napoli (NA)"), new structType.ptr("B566", "Camposanto", "Modena (MO)"), new structType.ptr("B567", "Campospinoso", "Pavia (PV)"), new structType.ptr("B569", "Campotosto", "L'Aquila (AQ)"), new structType.ptr("B572", "Camugnano", "Bologna (BO)"), new structType.ptr("B577", "Canal San Bovo", "Trento (TN)"), new structType.ptr("B573", "Canale", "Cuneo (CN)"), new structType.ptr("B574", "Canale D'Agordo", "Belluno (BL)"), new structType.ptr("B576", "Canale Monterano", "Roma (RM)"), new structType.ptr("B578", "Canaro", "Rovigo (RO)"), new structType.ptr("B579", "Canazei", "Trento (TN)"), new structType.ptr("B580", "Cancellara", "Potenza (PZ)"), new structType.ptr("B581", "Cancello Ed Arnone", "Caserta (CE)"), new structType.ptr("B582", "Canda", "Rovigo (RO)"), new structType.ptr("B584", "Candela", "Foggia (FG)"), new structType.ptr("B586", "Candelo", "Biella (BI)"), new structType.ptr("B588", "Candia Canavese", "Torino (TO)"), new structType.ptr("B587", "Candia Lomellina", "Pavia (PV)"), new structType.ptr("B589", "Candiana", "Padova (PD)"), new structType.ptr("B590", "Candida", "Avellino (AV)"), new structType.ptr("B591", "Candidoni", "Reggio Calabria (RC)"), new structType.ptr("B592", "Candiolo", "Torino (TO)"), new structType.ptr("B593", "Canegrate", "Milano (MI)"), new structType.ptr("B594", "Canelli", "Asti (AT)"), new structType.ptr("B597", "Canepina", "Viterbo (VT)"), new structType.ptr("B598", "Caneva", "Pordenone (PN)"), new structType.ptr("B599", "Canevino", "Pavia (PV)"), new structType.ptr("B602", "Canicatt\xC3\xAC", "Agrigento (AG)"), new structType.ptr("B603", "Canicattini Bagni", "Siracusa (SR)"), new structType.ptr("B604", "Canino", "Viterbo (VT)"), new structType.ptr("B605", "Canischio", "Torino (TO)"), new structType.ptr("B606", "Canistro", "L'Aquila (AQ)"), new structType.ptr("B607", "Canna", "Cosenza (CS)"), new structType.ptr("B608", "Cannalonga", "Salerno (SA)"), new structType.ptr("B609", "Cannara", "Perugia (PG)"), new structType.ptr("B610", "Cannero Riviera", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("B613", "Canneto Pavese", "Pavia (PV)"), new structType.ptr("B612", "Canneto Sull'Oglio", "Mantova (MN)"), new structType.ptr("B615", "Cannobio", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("B616", "Cannole", "Lecce (LE)"), new structType.ptr("B617", "Canolo", "Reggio Calabria (RC)"), new structType.ptr("B618", "Canonica D'Adda", "Bergamo (BG)"), new structType.ptr("B619", "Canosa Di Puglia", "Barletta-Andria-Trani (BT)"), new structType.ptr("B620", "Canosa Sannita", "Chieti (CH)"), new structType.ptr("B621", "Canosio", "Cuneo (CN)"), new structType.ptr("C669", "Canossa", "Reggio Emilia (RE)"), new structType.ptr("B624", "Cansano", "L'Aquila (AQ)"), new structType.ptr("B626", "Cantagallo", "Prato (PO)"), new structType.ptr("B627", "Cantalice", "Rieti (RI)"), new structType.ptr("B628", "Cantalupa", "Torino (TO)"), new structType.ptr("B631", "Cantalupo In Sabina", "Rieti (RI)"), new structType.ptr("B629", "Cantalupo Ligure", "Alessandria (AL)"), new structType.ptr("B630", "Cantalupo Nel Sannio", "Isernia (IS)"), new structType.ptr("B633", "Cantarana", "Asti (AT)"), new structType.ptr("B634", "Cantello", "Varese (VA)"), new structType.ptr("B635", "Canterano", "Roma (RM)"), new structType.ptr("B636", "Cantiano", "Pesaro e Urbino (PU)"), new structType.ptr("B637", "Cantoira", "Torino (TO)"), new structType.ptr("B639", "Cant\xC3\xB9", "Como (CO)"), new structType.ptr("B640", "Canzano", "Teramo (TE)"), new structType.ptr("B641", "Canzo", "Como (CO)"), new structType.ptr("B642", "Caorle", "Venezia (VE)"), new structType.ptr("B643", "Caorso", "Piacenza (PC)"), new structType.ptr("B644", "Capaccio", "Salerno (SA)"), new structType.ptr("B645", "Capaci", "Palermo (PA)"), new structType.ptr("B646", "Capalbio", "Grosseto (GR)"), new structType.ptr("B647", "Capannoli", "Pisa (PI)"), new structType.ptr("B648", "Capannori", "Lucca (LU)"), new structType.ptr("B649", "Capena", "Roma (RM)"), new structType.ptr("B650", "Capergnanica", "Cremona (CR)"), new structType.ptr("B651", "Capestrano", "L'Aquila (AQ)"), new structType.ptr("B653", "Capiago Intimiano", "Como (CO)"), new structType.ptr("B655", "Capistrano", "Vibo Valentia (VV)"), new structType.ptr("B656", "Capistrello", "L'Aquila (AQ)"), new structType.ptr("B658", "Capitignano", "L'Aquila (AQ)"), new structType.ptr("B660", "Capizzi", "Messina (ME)"), new structType.ptr("B661", "Capizzone", "Bergamo (BG)"), new structType.ptr("B664", "Capo Di Ponte", "Brescia (BS)"), new structType.ptr("B666", "Capo D'Orlando", "Messina (ME)"), new structType.ptr("B663", "Capodimonte", "Viterbo (VT)"), new structType.ptr("B667", "Capodrise", "Caserta (CE)"), new structType.ptr("B669", "Capoliveri", "Livorno (LI)"), new structType.ptr("B670", "Capolona", "Arezzo (AR)"), new structType.ptr("B671", "Caponago", "Monza e della Brianza (MB)"), new structType.ptr("B672", "Caporciano", "L'Aquila (AQ)"), new structType.ptr("B674", "Caposele", "Avellino (AV)"), new structType.ptr("B675", "Capoterra", "Cagliari (CA)"), new structType.ptr("B676", "Capovalle", "Brescia (BS)"), new structType.ptr("B677", "Cappadocia", "L'Aquila (AQ)"), new structType.ptr("B679", "Cappella Cantone", "Cremona (CR)"), new structType.ptr("B680", "Cappella De' Picenardi", "Cremona (CR)"), new structType.ptr("B678", "Cappella Maggiore", "Treviso (TV)"), new structType.ptr("B681", "Cappelle Sul Tavo", "Pescara (PE)"), new structType.ptr("B682", "Capracotta", "Isernia (IS)"), new structType.ptr("B684", "Capraia E Limite", "Firenze (FI)"), new structType.ptr("B685", "Capraia Isola", "Livorno (LI)"), new structType.ptr("B686", "Capralba", "Cremona (CR)"), new structType.ptr("B688", "Capranica", "Viterbo (VT)"), new structType.ptr("B687", "Capranica Prenestina", "Roma (RM)"), new structType.ptr("B690", "Caprarica Di Lecce", "Lecce (LE)"), new structType.ptr("B691", "Caprarola", "Viterbo (VT)"), new structType.ptr("B692", "Caprauna", "Cuneo (CN)"), new structType.ptr("B693", "Caprese Michelangelo", "Arezzo (AR)"), new structType.ptr("B694", "Caprezzo", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("B696", "Capri", "Napoli (NA)"), new structType.ptr("B695", "Capri Leone", "Messina (ME)"), new structType.ptr("B697", "Capriana", "Trento (TN)"), new structType.ptr("B698", "Capriano Del Colle", "Brescia (BS)"), new structType.ptr("B701", "Capriata D'Orba", "Alessandria (AL)"), new structType.ptr("B703", "Capriate San Gervasio", "Bergamo (BG)"), new structType.ptr("B704", "Capriati A Volturno", "Caserta (CE)"), new structType.ptr("B705", "Caprie", "Torino (TO)"), new structType.ptr("B706", "Capriglia Irpina", "Avellino (AV)"), new structType.ptr("B707", "Capriglio", "Asti (AT)"), new structType.ptr("B708", "Caprile", "Biella (BI)"), new structType.ptr("B710", "Caprino Bergamasco", "Bergamo (BG)"), new structType.ptr("B709", "Caprino Veronese", "Verona (VR)"), new structType.ptr("B711", "Capriolo", "Brescia (BS)"), new structType.ptr("B712", "Capriva Del Friuli", "Gorizia (GO)"), new structType.ptr("B715", "Capua", "Caserta (CE)"), new structType.ptr("B716", "Capurso", "Bari (BA)"), new structType.ptr("B718", "Caraffa Del Bianco", "Reggio Calabria (RC)"), new structType.ptr("B717", "Caraffa Di Catanzaro", "Catanzaro (CZ)"), new structType.ptr("B719", "Caraglio", "Cuneo (CN)"), new structType.ptr("B720", "Caramagna Piemonte", "Cuneo (CN)"), new structType.ptr("B722", "Caramanico Terme", "Pescara (PE)"), new structType.ptr("B723", "Carano", "Trento (TN)"), new structType.ptr("B724", "Carapelle", "Foggia (FG)"), new structType.ptr("B725", "Carapelle Calvisio", "L'Aquila (AQ)"), new structType.ptr("B726", "Carasco", "Genova (GE)"), new structType.ptr("B727", "Carassai", "Ascoli Piceno (AP)"), new structType.ptr("B729", "Carate Brianza", "Monza e della Brianza (MB)"), new structType.ptr("B730", "Carate Urio", "Como (CO)"), new structType.ptr("B731", "Caravaggio", "Bergamo (BG)"), new structType.ptr("B732", "Caravate", "Varese (VA)"), new structType.ptr("B733", "Caravino", "Torino (TO)"), new structType.ptr("B734", "Caravonica", "Imperia (IM)"), new structType.ptr("B735", "Carbognano", "Viterbo (VT)"), new structType.ptr("B741", "Carbonara Al Ticino", "Pavia (PV)"), new structType.ptr("B740", "Carbonara Di Nola", "Napoli (NA)"), new structType.ptr("B739", "Carbonara Di Po", "Mantova (MN)"), new structType.ptr("B736", "Carbonara Scrivia", "Alessandria (AL)"), new structType.ptr("B742", "Carbonate", "Como (CO)"), new structType.ptr("B743", "Carbone", "Potenza (PZ)"), new structType.ptr("B744", "Carbonera", "Treviso (TV)"), new structType.ptr("B745", "Carbonia", "Carbonia-Iglesias (CI)"), new structType.ptr("B748", "Carcare", "Savona (SV)"), new structType.ptr("B749", "Carceri", "Padova (PD)"), new structType.ptr("B752", "Carcoforo", "Vercelli (VC)"), new structType.ptr("B754", "Cardano Al Campo", "Varese (VA)"), new structType.ptr("B755", "Card\xC3\xA8", "Cuneo (CN)"), new structType.ptr("M285", "Cardedu", "Ogliastra (OG)"), new structType.ptr("B756", "Cardeto", "Reggio Calabria (RC)"), new structType.ptr("B758", "Cardinale", "Catanzaro (CZ)"), new structType.ptr("B759", "Cardito", "Napoli (NA)"), new structType.ptr("B760", "Careggine", "Lucca (LU)"), new structType.ptr("B762", "Carema", "Torino (TO)"), new structType.ptr("B763", "Carenno", "Lecco (LC)"), new structType.ptr("B765", "Carentino", "Alessandria (AL)"), new structType.ptr("B766", "Careri", "Reggio Calabria (RC)"), new structType.ptr("B767", "Caresana", "Vercelli (VC)"), new structType.ptr("B768", "Caresanablot", "Vercelli (VC)"), new structType.ptr("B769", "Carezzano", "Alessandria (AL)"), new structType.ptr("B771", "Carfizzi", "Crotone (KR)"), new structType.ptr("B772", "Cargeghe", "Sassari (SS)"), new structType.ptr("B774", "Cariati", "Cosenza (CS)"), new structType.ptr("B776", "Carife", "Avellino (AV)"), new structType.ptr("B777", "Carignano", "Torino (TO)"), new structType.ptr("B778", "Carimate", "Como (CO)"), new structType.ptr("B779", "Carinaro", "Caserta (CE)"), new structType.ptr("B780", "Carini", "Palermo (PA)"), new structType.ptr("B781", "Carinola", "Caserta (CE)"), new structType.ptr("B782", "Carisio", "Vercelli (VC)"), new structType.ptr("B783", "Carisolo", "Trento (TN)"), new structType.ptr("B784", "Carlantino", "Foggia (FG)"), new structType.ptr("B785", "Carlazzo", "Como (CO)"), new structType.ptr("B787", "Carlentini", "Siracusa (SR)"), new structType.ptr("B788", "Carlino", "Udine (UD)"), new structType.ptr("B789", "Carloforte", "Carbonia-Iglesias (CI)"), new structType.ptr("B790", "Carlopoli", "Catanzaro (CZ)"), new structType.ptr("B791", "Carmagnola", "Torino (TO)"), new structType.ptr("B792", "Carmiano", "Lecce (LE)"), new structType.ptr("B794", "Carmignano", "Prato (PO)"), new structType.ptr("B795", "Carmignano Di Brenta", "Padova (PD)"), new structType.ptr("B796", "Carnago", "Varese (VA)"), new structType.ptr("B798", "Carnate", "Monza e della Brianza (MB)"), new structType.ptr("B801", "Carobbio Degli Angeli", "Bergamo (BG)"), new structType.ptr("B802", "Carolei", "Cosenza (CS)"), new structType.ptr("B803", "Carona", "Bergamo (BG)"), new structType.ptr("B804", "Caronia", "Messina (ME)"), new structType.ptr("B805", "Caronno Pertusella", "Varese (VA)"), new structType.ptr("B807", "Caronno Varesino", "Varese (VA)"), new structType.ptr("B808", "Carosino", "Taranto (TA)"), new structType.ptr("B809", "Carovigno", "Brindisi (BR)"), new structType.ptr("B810", "Carovilli", "Isernia (IS)"), new structType.ptr("B812", "Carpaneto Piacentino", "Piacenza (PC)"), new structType.ptr("B813", "Carpanzano", "Cosenza (CS)"), new structType.ptr("B814", "Carpasio", "Imperia (IM)"), new structType.ptr("B816", "Carpegna", "Pesaro e Urbino (PU)"), new structType.ptr("B817", "Carpenedolo", "Brescia (BS)"), new structType.ptr("B818", "Carpeneto", "Alessandria (AL)"), new structType.ptr("B819", "Carpi", "Modena (MO)"), new structType.ptr("B820", "Carpiano", "Milano (MI)"), new structType.ptr("B822", "Carpignano Salentino", "Lecce (LE)"), new structType.ptr("B823", "Carpignano Sesia", "Novara (NO)"), new structType.ptr("B825", "Carpineti", "Reggio Emilia (RE)"), new structType.ptr("B827", "Carpineto Della Nora", "Pescara (PE)"), new structType.ptr("B828", "Carpineto Romano", "Roma (RM)"), new structType.ptr("B826", "Carpineto Sinello", "Chieti (CH)"), new structType.ptr("B829", "Carpino", "Foggia (FG)"), new structType.ptr("B830", "Carpinone", "Isernia (IS)"), new structType.ptr("B832", "Carrara", "Massa-Carrara (MS)"), new structType.ptr("B835", "Carr\xC3\xA8", "Vicenza (VI)"), new structType.ptr("B836", "Carrega Ligure", "Alessandria (AL)"), new structType.ptr("B838", "Carro", "La Spezia (SP)"), new structType.ptr("B839", "Carrodano", "La Spezia (SP)"), new structType.ptr("B840", "Carrosio", "Alessandria (AL)"), new structType.ptr("B841", "Carr\xC3\xB9", "Cuneo (CN)"), new structType.ptr("B842", "Carsoli", "L'Aquila (AQ)"), new structType.ptr("B844", "Cartigliano", "Vicenza (VI)"), new structType.ptr("B845", "Cartignano", "Cuneo (CN)"), new structType.ptr("B846", "Cartoceto", "Pesaro e Urbino (PU)"), new structType.ptr("B847", "Cartosio", "Alessandria (AL)"), new structType.ptr("B848", "Cartura", "Padova (PD)"), new structType.ptr("B850", "Carugate", "Milano (MI)"), new structType.ptr("B851", "Carugo", "Como (CO)"), new structType.ptr("B853", "Carunchio", "Chieti (CH)"), new structType.ptr("B854", "Carvico", "Bergamo (BG)"), new structType.ptr("B856", "Carzano", "Trento (TN)"), new structType.ptr("B857", "Casabona", "Crotone (KR)"), new structType.ptr("B858", "Casacalenda", "Campobasso (CB)"), new structType.ptr("B859", "Casacanditella", "Chieti (CH)"), new structType.ptr("B860", "Casagiove", "Caserta (CE)"), new structType.ptr("B870", "Casal Cermelli", "Alessandria (AL)"), new structType.ptr("B872", "Casal Di Principe", "Caserta (CE)"), new structType.ptr("B895", "Casal Velino", "Salerno (SA)"), new structType.ptr("B861", "Casalanguida", "Chieti (CH)"), new structType.ptr("B862", "Casalattico", "Frosinone (FR)"), new structType.ptr("B864", "Casalbeltrame", "Novara (NO)"), new structType.ptr("B865", "Casalbordino", "Chieti (CH)"), new structType.ptr("B866", "Casalbore", "Avellino (AV)"), new structType.ptr("B867", "Casalborgone", "Torino (TO)"), new structType.ptr("B868", "Casalbuono", "Salerno (SA)"), new structType.ptr("B869", "Casalbuttano Ed Uniti", "Cremona (CR)"), new structType.ptr("B871", "Casalciprano", "Campobasso (CB)"), new structType.ptr("B873", "Casalduni", "Benevento (BN)"), new structType.ptr("B876", "Casale Corte Cerro", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("B881", "Casale Cremasco-Vidolasco", "Cremona (CR)"), new structType.ptr("B877", "Casale Di Scodosia", "Padova (PD)"), new structType.ptr("B875", "Casale Litta", "Varese (VA)"), new structType.ptr("B878", "Casale Marittimo", "Pisa (PI)"), new structType.ptr("B885", "Casale Monferrato", "Alessandria (AL)"), new structType.ptr("B879", "Casale Sul Sile", "Treviso (TV)"), new structType.ptr("B880", "Casalecchio Di Reno", "Bologna (BO)"), new structType.ptr("B882", "Casaleggio Boiro", "Alessandria (AL)"), new structType.ptr("B883", "Casaleggio Novara", "Novara (NO)"), new structType.ptr("B886", "Casaleone", "Verona (VR)"), new structType.ptr("B889", "Casaletto Ceredano", "Cremona (CR)"), new structType.ptr("B890", "Casaletto Di Sopra", "Cremona (CR)"), new structType.ptr("B887", "Casaletto Lodigiano", "Lodi (LO)"), new structType.ptr("B888", "Casaletto Spartano", "Salerno (SA)"), new structType.ptr("B891", "Casaletto Vaprio", "Cremona (CR)"), new structType.ptr("B892", "Casalfiumanese", "Bologna (BO)"), new structType.ptr("B893", "Casalgrande", "Reggio Emilia (RE)"), new structType.ptr("B894", "Casalgrasso", "Cuneo (CN)"), new structType.ptr("B896", "Casalincontrada", "Chieti (CH)"), new structType.ptr("B897", "Casalino", "Novara (NO)"), new structType.ptr("B898", "Casalmaggiore", "Cremona (CR)"), new structType.ptr("B899", "Casalmaiocco", "Lodi (LO)"), new structType.ptr("B900", "Casalmorano", "Cremona (CR)"), new structType.ptr("B901", "Casalmoro", "Mantova (MN)"), new structType.ptr("B902", "Casalnoceto", "Alessandria (AL)"), new structType.ptr("B905", "Casalnuovo Di Napoli", "Napoli (NA)"), new structType.ptr("B904", "Casalnuovo Monterotaro", "Foggia (FG)"), new structType.ptr("B907", "Casaloldo", "Mantova (MN)"), new structType.ptr("B910", "Casalpusterlengo", "Lodi (LO)"), new structType.ptr("B911", "Casalromano", "Mantova (MN)"), new structType.ptr("B912", "Casalserugo", "Padova (PD)"), new structType.ptr("B916", "Casaluce", "Caserta (CE)"), new structType.ptr("B917", "Casalvecchio Di Puglia", "Foggia (FG)"), new structType.ptr("B918", "Casalvecchio Siculo", "Messina (ME)"), new structType.ptr("B919", "Casalvieri", "Frosinone (FR)"), new structType.ptr("B920", "Casalvolone", "Novara (NO)"), new structType.ptr("B921", "Casalzuigno", "Varese (VA)"), new structType.ptr("B922", "Casamarciano", "Napoli (NA)"), new structType.ptr("B923", "Casamassima", "Bari (BA)"), new structType.ptr("B924", "Casamicciola Terme", "Napoli (NA)"), new structType.ptr("B925", "Casandrino", "Napoli (NA)"), new structType.ptr("B928", "Casanova Elvo", "Vercelli (VC)"), new structType.ptr("B927", "Casanova Lerrone", "Savona (SV)"), new structType.ptr("B929", "Casanova Lonati", "Pavia (PV)"), new structType.ptr("B932", "Casape", "Roma (RM)"), new structType.ptr("M260", "Casapesenna", "Caserta (CE)"), new structType.ptr("B933", "Casapinta", "Biella (BI)"), new structType.ptr("B934", "Casaprota", "Rieti (RI)"), new structType.ptr("B935", "Casapulla", "Caserta (CE)"), new structType.ptr("B936", "Casarano", "Lecce (LE)"), new structType.ptr("B937", "Casargo", "Lecco (LC)"), new structType.ptr("B938", "Casarile", "Milano (MI)"), new structType.ptr("B940", "Casarsa Della Delizia", "Pordenone (PN)"), new structType.ptr("B939", "Casarza Ligure", "Genova (GE)"), new structType.ptr("B941", "Casasco", "Alessandria (AL)"), new structType.ptr("B942", "Casasco D'Intelvi", "Como (CO)"), new structType.ptr("B943", "Casatenovo", "Lecco (LC)"), new structType.ptr("B945", "Casatisma", "Pavia (PV)"), new structType.ptr("B946", "Casavatore", "Napoli (NA)"), new structType.ptr("B947", "Casazza", "Bergamo (BG)"), new structType.ptr("B948", "Cascia", "Perugia (PG)"), new structType.ptr("B949", "Casciago", "Varese (VA)"), new structType.ptr("M327", "Casciana Terme Lari", "Pisa (PI)"), new structType.ptr("B950", "Cascina", "Pisa (PI)"), new structType.ptr("B953", "Cascinette D'Ivrea", "Torino (TO)"), new structType.ptr("B954", "Casei Gerola", "Pavia (PV)"), new structType.ptr("B955", "Caselette", "Torino (TO)"), new structType.ptr("B956", "Casella", "Genova (GE)"), new structType.ptr("B959", "Caselle In Pittari", "Salerno (SA)"), new structType.ptr("B961", "Caselle Landi", "Lodi (LO)"), new structType.ptr("B958", "Caselle Lurani", "Lodi (LO)"), new structType.ptr("B960", "Caselle Torinese", "Torino (TO)"), new structType.ptr("B963", "Caserta", "Caserta (CE)"), new structType.ptr("B965", "Casier", "Treviso (TV)"), new structType.ptr("B966", "Casignana", "Reggio Calabria (RC)"), new structType.ptr("B967", "Casina", "Reggio Emilia (RE)"), new structType.ptr("B971", "Casirate D'Adda", "Bergamo (BG)"), new structType.ptr("B974", "Caslino D'Erba", "Como (CO)"), new structType.ptr("B977", "Casnate Con Bernate", "Como (CO)"), new structType.ptr("B978", "Casnigo", "Bergamo (BG)"), new structType.ptr("B980", "Casola Di Napoli", "Napoli (NA)"), new structType.ptr("B979", "Casola In Lunigiana", "Massa-Carrara (MS)"), new structType.ptr("B982", "Casola Valsenio", "Ravenna (RA)"), new structType.ptr("B983", "Casole Bruzio", "Cosenza (CS)"), new structType.ptr("B984", "Casole D'Elsa", "Siena (SI)"), new structType.ptr("B985", "Casoli", "Chieti (CH)"), new structType.ptr("B988", "Casorate Primo", "Pavia (PV)"), new structType.ptr("B987", "Casorate Sempione", "Varese (VA)"), new structType.ptr("B989", "Casorezzo", "Milano (MI)"), new structType.ptr("B990", "Casoria", "Napoli (NA)"), new structType.ptr("B991", "Casorzo", "Asti (AT)"), new structType.ptr("A472", "Casperia", "Rieti (RI)"), new structType.ptr("B993", "Caspoggio", "Sondrio (SO)"), new structType.ptr("B994", "Cassacco", "Udine (UD)"), new structType.ptr("B996", "Cassago Brianza", "Lecco (LC)"), new structType.ptr("C002", "Cassano All'Ionio", "Cosenza (CS)"), new structType.ptr("C003", "Cassano D'Adda", "Milano (MI)"), new structType.ptr("B998", "Cassano Delle Murge", "Bari (BA)"), new structType.ptr("B997", "Cassano Irpino", "Avellino (AV)"), new structType.ptr("C004", "Cassano Magnago", "Varese (VA)"), new structType.ptr("C005", "Cassano Spinola", "Alessandria (AL)"), new structType.ptr("B999", "Cassano Valcuvia", "Varese (VA)"), new structType.ptr("C006", "Cassaro", "Siracusa (SR)"), new structType.ptr("C007", "Cassiglio", "Bergamo (BG)"), new structType.ptr("C014", "Cassina De' Pecchi", "Milano (MI)"), new structType.ptr("C020", "Cassina Rizzardi", "Como (CO)"), new structType.ptr("C024", "Cassina Valsassina", "Lecco (LC)"), new structType.ptr("C022", "Cassinasco", "Asti (AT)"), new structType.ptr("C027", "Cassine", "Alessandria (AL)"), new structType.ptr("C030", "Cassinelle", "Alessandria (AL)"), new structType.ptr("C033", "Cassinetta Di Lugagnano", "Milano (MI)"), new structType.ptr("C034", "Cassino", "Frosinone (FR)"), new structType.ptr("C037", "Cassola", "Vicenza (VI)"), new structType.ptr("C038", "Cassolnovo", "Pavia (PV)"), new structType.ptr("C041", "Castagnaro", "Verona (VR)"), new structType.ptr("C044", "Castagneto Carducci", "Livorno (LI)"), new structType.ptr("C045", "Castagneto Po", "Torino (TO)"), new structType.ptr("C046", "Castagnito", "Cuneo (CN)"), new structType.ptr("C049", "Castagnole Delle Lanze", "Asti (AT)"), new structType.ptr("C047", "Castagnole Monferrato", "Asti (AT)"), new structType.ptr("C048", "Castagnole Piemonte", "Torino (TO)"), new structType.ptr("C050", "Castana", "Pavia (PV)"), new structType.ptr("C052", "Castano Primo", "Milano (MI)"), new structType.ptr("C053", "Casteggio", "Pavia (PV)"), new structType.ptr("C055", "Castegnato", "Brescia (BS)"), new structType.ptr("C056", "Castegnero", "Vicenza (VI)"), new structType.ptr("C058", "Castel Baronia", "Avellino (AV)"), new structType.ptr("C064", "Castel Boglione", "Asti (AT)"), new structType.ptr("C065", "Castel Bolognese", "Ravenna (RA)"), new structType.ptr("B494", "Castel Campagnano", "Caserta (CE)"), new structType.ptr("C040", "Castel Castagna", "Teramo (TE)"), new structType.ptr("C183", "Castel Condino", "Trento (TN)"), new structType.ptr("C075", "Castel D'Aiano", "Bologna (BO)"), new structType.ptr("C076", "Castel D'Ario", "Mantova (MN)"), new structType.ptr("C078", "Castel D'Azzano", "Verona (VR)"), new structType.ptr("C082", "Castel Del Giudice", "Isernia (IS)"), new structType.ptr("C083", "Castel Del Monte", "L'Aquila (AQ)"), new structType.ptr("C085", "Castel Del Piano", "Grosseto (GR)"), new structType.ptr("C086", "Castel Del Rio", "Bologna (BO)"), new structType.ptr("B969", "Castel Di Casio", "Bologna (BO)"), new structType.ptr("C090", "Castel Di Ieri", "L'Aquila (AQ)"), new structType.ptr("C091", "Castel Di Iudica", "Catania (CT)"), new structType.ptr("C093", "Castel Di Lama", "Ascoli Piceno (AP)"), new structType.ptr("C094", "Castel Di Lucio", "Messina (ME)"), new structType.ptr("C096", "Castel Di Sangro", "L'Aquila (AQ)"), new structType.ptr("C097", "Castel Di Sasso", "Caserta (CE)"), new structType.ptr("C098", "Castel Di Tora", "Rieti (RI)"), new structType.ptr("C102", "Castel Focognano", "Arezzo (AR)"), new structType.ptr("C114", "Castel Frentano", "Chieti (CH)"), new structType.ptr("C115", "Castel Gabbiano", "Cremona (CR)"), new structType.ptr("C116", "Castel Gandolfo", "Roma (RM)"), new structType.ptr("C117", "Castel Giorgio", "Terni (TR)"), new structType.ptr("C118", "Castel Goffredo", "Mantova (MN)"), new structType.ptr("C121", "Castel Guelfo Di Bologna", "Bologna (BO)"), new structType.ptr("M354", "Castel Ivano", "Trento (TN)"), new structType.ptr("C203", "Castel Madama", "Roma (RM)"), new structType.ptr("C204", "Castel Maggiore", "Bologna (BO)"), new structType.ptr("C208", "Castel Mella", "Brescia (BS)"), new structType.ptr("C211", "Castel Morrone", "Caserta (CE)"), new structType.ptr("C252", "Castel Ritaldi", "Perugia (PG)"), new structType.ptr("C253", "Castel Rocchero", "Asti (AT)"), new structType.ptr("C255", "Castel Rozzone", "Bergamo (BG)"), new structType.ptr("C259", "Castel San Giorgio", "Salerno (SA)"), new structType.ptr("C261", "Castel San Giovanni", "Piacenza (PC)"), new structType.ptr("C262", "Castel San Lorenzo", "Salerno (SA)"), new structType.ptr("C263", "Castel San Niccol\xC3\xB2", "Arezzo (AR)"), new structType.ptr("C266", "Castel San Pietro Romano", "Roma (RM)"), new structType.ptr("C265", "Castel San Pietro Terme", "Bologna (BO)"), new structType.ptr("C270", "Castel San Vincenzo", "Isernia (IS)"), new structType.ptr("C268", "Castel Sant'Angelo", "Rieti (RI)"), new structType.ptr("C269", "Castel Sant'Elia", "Viterbo (VT)"), new structType.ptr("C289", "Castel Viscardo", "Terni (TR)"), new structType.ptr("C110", "Castel Vittorio", "Imperia (IM)"), new structType.ptr("C291", "Castel Volturno", "Caserta (CE)"), new structType.ptr("C057", "Castelbaldo", "Padova (PD)"), new structType.ptr("C059", "Castelbelforte", "Mantova (MN)"), new structType.ptr("C060", "Castelbellino", "Ancona (AN)"), new structType.ptr("C062", "Castelbello Ciardes .Kastelbell Tschars.", "Bolzano (BZ)"), new structType.ptr("C063", "Castelbianco", "Savona (SV)"), new structType.ptr("C066", "Castelbottaccio", "Campobasso (CB)"), new structType.ptr("C067", "Castelbuono", "Palermo (PA)"), new structType.ptr("C069", "Castelcivita", "Salerno (SA)"), new structType.ptr("C072", "Castelcovati", "Brescia (BS)"), new structType.ptr("C073", "Castelcucco", "Treviso (TV)"), new structType.ptr("C074", "Casteldaccia", "Palermo (PA)"), new structType.ptr("C080", "Casteldelci", "Rimini (RN)"), new structType.ptr("C081", "Casteldelfino", "Cuneo (CN)"), new structType.ptr("C089", "Casteldidone", "Cremona (CR)"), new structType.ptr("C100", "Castelfidardo", "Ancona (AN)"), new structType.ptr("C101", "Castelfiorentino", "Firenze (FI)"), new structType.ptr("C103", "Castelfondo", "Trento (TN)"), new structType.ptr("C104", "Castelforte", "Latina (LT)"), new structType.ptr("C105", "Castelfranci", "Avellino (AV)"), new structType.ptr("C113", "Castelfranco Di Sotto", "Pisa (PI)"), new structType.ptr("C107", "Castelfranco Emilia", "Modena (MO)"), new structType.ptr("C106", "Castelfranco In Miscano", "Benevento (BN)"), new structType.ptr("M322", "Castelfranco Piandisc\xC3\xB2", "Arezzo (AR)"), new structType.ptr("C111", "Castelfranco Veneto", "Treviso (TV)"), new structType.ptr("C119", "Castelgomberto", "Vicenza (VI)"), new structType.ptr("C120", "Castelgrande", "Potenza (PZ)"), new structType.ptr("C122", "Castelguglielmo", "Rovigo (RO)"), new structType.ptr("C123", "Castelguidone", "Chieti (CH)"), new structType.ptr("C125", "Castellabate", "Salerno (SA)"), new structType.ptr("C126", "Castellafiume", "L'Aquila (AQ)"), new structType.ptr("C127", "Castell'Alfero", "Asti (AT)"), new structType.ptr("C128", "Castellalto", "Teramo (TE)"), new structType.ptr("C130", "Castellammare Del Golfo", "Trapani (TP)"), new structType.ptr("C129", "Castellammare Di Stabia", "Napoli (NA)"), new structType.ptr("C133", "Castellamonte", "Torino (TO)"), new structType.ptr("C134", "Castellana Grotte", "Bari (BA)"), new structType.ptr("C135", "Castellana Sicula", "Palermo (PA)"), new structType.ptr("C136", "Castellaneta", "Taranto (TA)"), new structType.ptr("C137", "Castellania", "Alessandria (AL)"), new structType.ptr("C139", "Castellanza", "Varese (VA)"), new structType.ptr("C140", "Castellar", "Cuneo (CN)"), new structType.ptr("C142", "Castellar Guidobono", "Alessandria (AL)"), new structType.ptr("C141", "Castellarano", "Reggio Emilia (RE)"), new structType.ptr("C143", "Castellaro", "Imperia (IM)"), new structType.ptr("C145", "Castell'Arquato", "Piacenza (PC)"), new structType.ptr("C147", "Castell'Azzara", "Grosseto (GR)"), new structType.ptr("C148", "Castellazzo Bormida", "Alessandria (AL)"), new structType.ptr("C149", "Castellazzo Novarese", "Novara (NO)"), new structType.ptr("C153", "Castelleone", "Cremona (CR)"), new structType.ptr("C152", "Castelleone Di Suasa", "Ancona (AN)"), new structType.ptr("C154", "Castellero", "Asti (AT)"), new structType.ptr("C155", "Castelletto Cervo", "Biella (BI)"), new structType.ptr("C156", "Castelletto D'Erro", "Alessandria (AL)"), new structType.ptr("C157", "Castelletto Di Branduzzo", "Pavia (PV)"), new structType.ptr("C158", "Castelletto D'Orba", "Alessandria (AL)"), new structType.ptr("C160", "Castelletto Merli", "Alessandria (AL)"), new structType.ptr("C161", "Castelletto Molina", "Asti (AT)"), new structType.ptr("C162", "Castelletto Monferrato", "Alessandria (AL)"), new structType.ptr("C166", "Castelletto Sopra Ticino", "Novara (NO)"), new structType.ptr("C165", "Castelletto Stura", "Cuneo (CN)"), new structType.ptr("C167", "Castelletto Uzzone", "Cuneo (CN)"), new structType.ptr("C169", "Castelli", "Teramo (TE)"), new structType.ptr("C079", "Castelli Calepio", "Bergamo (BG)"), new structType.ptr("C172", "Castellina In Chianti", "Siena (SI)"), new structType.ptr("C174", "Castellina Marittima", "Pisa (PI)"), new structType.ptr("C173", "Castellinaldo", "Cuneo (CN)"), new structType.ptr("C175", "Castellino Del Biferno", "Campobasso (CB)"), new structType.ptr("C176", "Castellino Tanaro", "Cuneo (CN)"), new structType.ptr("C177", "Castelliri", "Frosinone (FR)"), new structType.ptr("B312", "Castello Cabiaglio", "Varese (VA)"), new structType.ptr("C184", "Castello D'Agogna", "Pavia (PV)"), new structType.ptr("C185", "Castello D'Argile", "Bologna (BO)"), new structType.ptr("C178", "Castello Del Matese", "Caserta (CE)"), new structType.ptr("C186", "Castello Dell'Acqua", "Sondrio (SO)"), new structType.ptr("A300", "Castello Di Annone", "Asti (AT)"), new structType.ptr("C187", "Castello Di Brianza", "Lecco (LC)"), new structType.ptr("C188", "Castello Di Cisterna", "Napoli (NA)"), new structType.ptr("C190", "Castello Di Godego", "Treviso (TV)"), new structType.ptr("C194", "Castello Tesino", "Trento (TN)"), new structType.ptr("C189", "Castello-Molina Di Fiemme", "Trento (TN)"), new structType.ptr("C195", "Castellucchio", "Mantova (MN)"), new structType.ptr("C198", "Castelluccio Dei Sauri", "Foggia (FG)"), new structType.ptr("C199", "Castelluccio Inferiore", "Potenza (PZ)"), new structType.ptr("C201", "Castelluccio Superiore", "Potenza (PZ)"), new structType.ptr("C202", "Castelluccio Valmaggiore", "Foggia (FG)"), new structType.ptr("C051", "Castell'Umberto", "Messina (ME)"), new structType.ptr("C205", "Castelmagno", "Cuneo (CN)"), new structType.ptr("C206", "Castelmarte", "Como (CO)"), new structType.ptr("C207", "Castelmassa", "Rovigo (RO)"), new structType.ptr("C197", "Castelmauro", "Campobasso (CB)"), new structType.ptr("C209", "Castelmezzano", "Potenza (PZ)"), new structType.ptr("C210", "Castelmola", "Messina (ME)"), new structType.ptr("C213", "Castelnovetto", "Pavia (PV)"), new structType.ptr("C215", "Castelnovo Bariano", "Rovigo (RO)"), new structType.ptr("C217", "Castelnovo Del Friuli", "Pordenone (PN)"), new structType.ptr("C218", "Castelnovo Di Sotto", "Reggio Emilia (RE)"), new structType.ptr("C219", "Castelnovo Ne' Monti", "Reggio Emilia (RE)"), new structType.ptr("C216", "Castelnuovo", "Trento (TN)"), new structType.ptr("C226", "Castelnuovo Belbo", "Asti (AT)"), new structType.ptr("C227", "Castelnuovo Berardenga", "Siena (SI)"), new structType.ptr("C228", "Castelnuovo Bocca D'Adda", "Lodi (LO)"), new structType.ptr("C229", "Castelnuovo Bormida", "Alessandria (AL)"), new structType.ptr("C220", "Castelnuovo Bozzente", "Como (CO)"), new structType.ptr("C230", "Castelnuovo Calcea", "Asti (AT)"), new structType.ptr("C231", "Castelnuovo Cilento", "Salerno (SA)"), new structType.ptr("C225", "Castelnuovo Del Garda", "Verona (VR)"), new structType.ptr("C222", "Castelnuovo Della Daunia", "Foggia (FG)"), new structType.ptr("C214", "Castelnuovo Di Ceva", "Cuneo (CN)"), new structType.ptr("C235", "Castelnuovo Di Conza", "Salerno (SA)"), new structType.ptr("C224", "Castelnuovo Di Farfa", "Rieti (RI)"), new structType.ptr("C236", "Castelnuovo Di Garfagnana", "Lucca (LU)"), new structType.ptr("C237", "Castelnuovo Di Porto", "Roma (RM)"), new structType.ptr("C232", "Castelnuovo Don Bosco", "Asti (AT)"), new structType.ptr("C240", "Castelnuovo Magra", "La Spezia (SP)"), new structType.ptr("C241", "Castelnuovo Nigra", "Torino (TO)"), new structType.ptr("C223", "Castelnuovo Parano", "Frosinone (FR)"), new structType.ptr("C242", "Castelnuovo Rangone", "Modena (MO)"), new structType.ptr("C243", "Castelnuovo Scrivia", "Alessandria (AL)"), new structType.ptr("C244", "Castelnuovo Val Di Cecina", "Pisa (PI)"), new structType.ptr("C245", "Castelpagano", "Benevento (BN)"), new structType.ptr("C246", "Castelpetroso", "Isernia (IS)"), new structType.ptr("C247", "Castelpizzuto", "Isernia (IS)"), new structType.ptr("C248", "Castelplanio", "Ancona (AN)"), new structType.ptr("C250", "Castelpoto", "Benevento (BN)"), new structType.ptr("C251", "Castelraimondo", "Macerata (MC)"), new structType.ptr("C254", "Castelrotto .Kastelruth.", "Bolzano (BZ)"), new structType.ptr("C267", "Castelsantangelo Sul Nera", "Macerata (MC)"), new structType.ptr("C271", "Castelsaraceno", "Potenza (PZ)"), new structType.ptr("C272", "Castelsardo", "Sassari (SS)"), new structType.ptr("C273", "Castelseprio", "Varese (VA)"), new structType.ptr("B968", "Castelsilano", "Crotone (KR)"), new structType.ptr("C274", "Castelspina", "Alessandria (AL)"), new structType.ptr("C275", "Casteltermini", "Agrigento (AG)"), new structType.ptr("C181", "Castelveccana", "Varese (VA)"), new structType.ptr("C278", "Castelvecchio Calvisio", "L'Aquila (AQ)"), new structType.ptr("C276", "Castelvecchio Di Rocca Barbena", "Savona (SV)"), new structType.ptr("C279", "Castelvecchio Subequo", "L'Aquila (AQ)"), new structType.ptr("C280", "Castelvenere", "Benevento (BN)"), new structType.ptr("B129", "Castelverde", "Cremona (CR)"), new structType.ptr("C200", "Castelverrino", "Isernia (IS)"), new structType.ptr("C284", "Castelvetere In Val Fortore", "Benevento (BN)"), new structType.ptr("C283", "Castelvetere Sul Calore", "Avellino (AV)"), new structType.ptr("C286", "Castelvetrano", "Trapani (TP)"), new structType.ptr("C287", "Castelvetro Di Modena", "Modena (MO)"), new structType.ptr("C288", "Castelvetro Piacentino", "Piacenza (PC)"), new structType.ptr("C290", "Castelvisconti", "Cremona (CR)"), new structType.ptr("C292", "Castenaso", "Bologna (BO)"), new structType.ptr("C293", "Castenedolo", "Brescia (BS)"), new structType.ptr("M288", "Castiadas", "Cagliari (CA)"), new structType.ptr("C318", "Castiglion Fibocchi", "Arezzo (AR)"), new structType.ptr("C319", "Castiglion Fiorentino", "Arezzo (AR)"), new structType.ptr("C308", "Castiglione A Casauria", "Pescara (PE)"), new structType.ptr("C302", "Castiglione Chiavarese", "Genova (GE)"), new structType.ptr("C301", "Castiglione Cosentino", "Cosenza (CS)"), new structType.ptr("C304", "Castiglione D'Adda", "Lodi (LO)"), new structType.ptr("C296", "Castiglione Dei Pepoli", "Bologna (BO)"), new structType.ptr("C306", "Castiglione Del Genovesi", "Salerno (SA)"), new structType.ptr("C309", "Castiglione Del Lago", "Perugia (PG)"), new structType.ptr("C310", "Castiglione Della Pescaia", "Grosseto (GR)"), new structType.ptr("C312", "Castiglione Delle Stiviere", "Mantova (MN)"), new structType.ptr("C303", "Castiglione Di Garfagnana", "Lucca (LU)"), new structType.ptr("C297", "Castiglione Di Sicilia", "Catania (CT)"), new structType.ptr("C299", "Castiglione D'Intelvi", "Como (CO)"), new structType.ptr("C313", "Castiglione D'Orcia", "Siena (SI)"), new structType.ptr("C314", "Castiglione Falletto", "Cuneo (CN)"), new structType.ptr("C315", "Castiglione In Teverina", "Viterbo (VT)"), new structType.ptr("C298", "Castiglione Messer Marino", "Chieti (CH)"), new structType.ptr("C316", "Castiglione Messer Raimondo", "Teramo (TE)"), new structType.ptr("C300", "Castiglione Olona", "Varese (VA)"), new structType.ptr("C317", "Castiglione Tinella", "Cuneo (CN)"), new structType.ptr("C307", "Castiglione Torinese", "Torino (TO)"), new structType.ptr("C321", "Castignano", "Ascoli Piceno (AP)"), new structType.ptr("C322", "Castilenti", "Teramo (TE)"), new structType.ptr("C323", "Castino", "Cuneo (CN)"), new structType.ptr("C325", "Castione Andevenno", "Sondrio (SO)"), new structType.ptr("C324", "Castione Della Presolana", "Bergamo (BG)"), new structType.ptr("C327", "Castions Di Strada", "Udine (UD)"), new structType.ptr("C329", "Castiraga Vidardo", "Lodi (LO)"), new structType.ptr("C330", "Casto", "Brescia (BS)"), new structType.ptr("C331", "Castorano", "Ascoli Piceno (AP)"), new structType.ptr("C332", "Castrezzato", "Brescia (BS)"), new structType.ptr("C334", "Castri Di Lecce", "Lecce (LE)"), new structType.ptr("C335", "Castrignano De' Greci", "Lecce (LE)"), new structType.ptr("C336", "Castrignano Del Capo", "Lecce (LE)"), new structType.ptr("C337", "Castro", "Bergamo (BG)"), new structType.ptr("M261", "Castro", "Lecce (LE)"), new structType.ptr("C338", "Castro Dei Volsci", "Frosinone (FR)"), new structType.ptr("C339", "Castrocaro Terme E Terra Del Sole", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("C340", "Castrocielo", "Frosinone (FR)"), new structType.ptr("C341", "Castrofilippo", "Agrigento (AG)"), new structType.ptr("C108", "Castrolibero", "Cosenza (CS)"), new structType.ptr("C343", "Castronno", "Varese (VA)"), new structType.ptr("C344", "Castronovo Di Sicilia", "Palermo (PA)"), new structType.ptr("C345", "Castronuovo Di Sant'Andrea", "Potenza (PZ)"), new structType.ptr("C346", "Castropignano", "Campobasso (CB)"), new structType.ptr("C347", "Castroreale", "Messina (ME)"), new structType.ptr("C348", "Castroregio", "Cosenza (CS)"), new structType.ptr("C349", "Castrovillari", "Cosenza (CS)"), new structType.ptr("C351", "Catania", "Catania (CT)"), new structType.ptr("C352", "Catanzaro", "Catanzaro (CZ)"), new structType.ptr("C353", "Catenanuova", "Enna (EN)"), new structType.ptr("C354", "Catignano", "Pescara (PE)"), new structType.ptr("C357", "Cattolica", "Rimini (RN)"), new structType.ptr("C356", "Cattolica Eraclea", "Agrigento (AG)"), new structType.ptr("C285", "Caulonia", "Reggio Calabria (RC)"), new structType.ptr("C359", "Cautano", "Benevento (BN)"), new structType.ptr("C361", "Cava De' Tirreni", "Salerno (SA)"), new structType.ptr("C360", "Cava Manara", "Pavia (PV)"), new structType.ptr("C362", "Cavacurta", "Lodi (LO)"), new structType.ptr("C363", "Cavagli\xC3\xA0", "Biella (BI)"), new structType.ptr("C364", "Cavaglietto", "Novara (NO)"), new structType.ptr("C365", "Cavaglio D'Agogna", "Novara (NO)"), new structType.ptr("C367", "Cavaglio-Spoccia", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("C369", "Cavagnolo", "Torino (TO)"), new structType.ptr("C370", "Cavaion Veronese", "Verona (VR)"), new structType.ptr("C372", "Cavalese", "Trento (TN)"), new structType.ptr("C375", "Cavallerleone", "Cuneo (CN)"), new structType.ptr("C376", "Cavallermaggiore", "Cuneo (CN)"), new structType.ptr("C377", "Cavallino", "Lecce (LE)"), new structType.ptr("M308", "Cavallino-Treporti", "Venezia (VE)"), new structType.ptr("C378", "Cavallirio", "Novara (NO)"), new structType.ptr("C380", "Cavareno", "Trento (TN)"), new structType.ptr("C381", "Cavargna", "Como (CO)"), new structType.ptr("C382", "Cavaria Con Premezzo", "Varese (VA)"), new structType.ptr("C383", "Cavarzere", "Venezia (VE)"), new structType.ptr("C384", "Cavaso Del Tomba", "Treviso (TV)"), new structType.ptr("C385", "Cavasso Nuovo", "Pordenone (PN)"), new structType.ptr("C387", "Cavatore", "Alessandria (AL)"), new structType.ptr("C389", "Cavazzo Carnico", "Udine (UD)"), new structType.ptr("C390", "Cave", "Roma (RM)"), new structType.ptr("C392", "Cavedago", "Trento (TN)"), new structType.ptr("C393", "Cavedine", "Trento (TN)"), new structType.ptr("C394", "Cavenago D'Adda", "Lodi (LO)"), new structType.ptr("C395", "Cavenago Di Brianza", "Monza e della Brianza (MB)"), new structType.ptr("C396", "Cavernago", "Bergamo (BG)"), new structType.ptr("C398", "Cavezzo", "Modena (MO)"), new structType.ptr("C400", "Cavizzana", "Trento (TN)"), new structType.ptr("C404", "Cavour", "Torino (TO)"), new structType.ptr("C405", "Cavriago", "Reggio Emilia (RE)"), new structType.ptr("C406", "Cavriana", "Mantova (MN)"), new structType.ptr("C407", "Cavriglia", "Arezzo (AR)"), new structType.ptr("C409", "Cazzago Brabbia", "Varese (VA)"), new structType.ptr("C408", "Cazzago San Martino", "Brescia (BS)"), new structType.ptr("C412", "Cazzano Di Tramigna", "Verona (VR)"), new structType.ptr("C410", "Cazzano Sant'Andrea", "Bergamo (BG)"), new structType.ptr("C413", "Ceccano", "Frosinone (FR)"), new structType.ptr("C414", "Cecima", "Pavia (PV)"), new structType.ptr("C415", "Cecina", "Livorno (LI)"), new structType.ptr("C417", "Cedegolo", "Brescia (BS)"), new structType.ptr("C418", "Cedrasco", "Sondrio (SO)"), new structType.ptr("C420", "Cefala' Diana", "Palermo (PA)"), new structType.ptr("C421", "Cefal\xC3\xB9", "Palermo (PA)"), new structType.ptr("C422", "Ceggia", "Venezia (VE)"), new structType.ptr("C424", "Ceglie Messapica", "Brindisi (BR)"), new structType.ptr("C426", "Celano", "L'Aquila (AQ)"), new structType.ptr("C428", "Celenza Sul Trigno", "Chieti (CH)"), new structType.ptr("C429", "Celenza Valfortore", "Foggia (FG)"), new structType.ptr("C430", "Celico", "Cosenza (CS)"), new structType.ptr("C435", "Cella Dati", "Cremona (CR)"), new structType.ptr("C432", "Cella Monte", "Alessandria (AL)"), new structType.ptr("C436", "Cellamare", "Bari (BA)"), new structType.ptr("C437", "Cellara", "Cosenza (CS)"), new structType.ptr("C438", "Cellarengo", "Asti (AT)"), new structType.ptr("C439", "Cellatica", "Brescia (BS)"), new structType.ptr("C444", "Celle Di Bulgheria", "Salerno (SA)"), new structType.ptr("C441", "Celle Di Macra", "Cuneo (CN)"), new structType.ptr("C442", "Celle Di San Vito", "Foggia (FG)"), new structType.ptr("C440", "Celle Enomondo", "Asti (AT)"), new structType.ptr("C443", "Celle Ligure", "Savona (SV)"), new structType.ptr("C446", "Celleno", "Viterbo (VT)"), new structType.ptr("C447", "Cellere", "Viterbo (VT)"), new structType.ptr("C449", "Cellino Attanasio", "Teramo (TE)"), new structType.ptr("C448", "Cellino San Marco", "Brindisi (BR)"), new structType.ptr("C450", "Cellio", "Vercelli (VC)"), new structType.ptr("M262", "Cellole", "Caserta (CE)"), new structType.ptr("M355", "Cembra Lisignago", "Trento (TN)"), new structType.ptr("C453", "Cenadi", "Catanzaro (CZ)"), new structType.ptr("C456", "Cenate Sopra", "Bergamo (BG)"), new structType.ptr("C457", "Cenate Sotto", "Bergamo (BG)"), new structType.ptr("C458", "Cencenighe Agordino", "Belluno (BL)"), new structType.ptr("C459", "Cene", "Bergamo (BG)"), new structType.ptr("C461", "Ceneselli", "Rovigo (RO)"), new structType.ptr("C463", "Cengio", "Savona (SV)"), new structType.ptr("C466", "Centallo", "Cuneo (CN)"), new structType.ptr("C469", "Cento", "Ferrara (FE)"), new structType.ptr("C470", "Centola", "Salerno (SA)"), new structType.ptr("C472", "Centrache", "Catanzaro (CZ)"), new structType.ptr("C471", "Centuripe", "Enna (EN)"), new structType.ptr("C474", "Cepagatti", "Pescara (PE)"), new structType.ptr("C476", "Ceppaloni", "Benevento (BN)"), new structType.ptr("C478", "Ceppo Morelli", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("C479", "Ceprano", "Frosinone (FR)"), new structType.ptr("C480", "Cerami", "Enna (EN)"), new structType.ptr("C481", "Ceranesi", "Genova (GE)"), new structType.ptr("C483", "Cerano", "Novara (NO)"), new structType.ptr("C482", "Cerano D'Intelvi", "Como (CO)"), new structType.ptr("C484", "Ceranova", "Pavia (PV)"), new structType.ptr("C485", "Ceraso", "Salerno (SA)"), new structType.ptr("C486", "Cercemaggiore", "Campobasso (CB)"), new structType.ptr("C487", "Cercenasco", "Torino (TO)"), new structType.ptr("C488", "Cercepiccola", "Campobasso (CB)"), new structType.ptr("C489", "Cerchiara Di Calabria", "Cosenza (CS)"), new structType.ptr("C492", "Cerchio", "L'Aquila (AQ)"), new structType.ptr("C493", "Cercino", "Sondrio (SO)"), new structType.ptr("C494", "Cercivento", "Udine (UD)"), new structType.ptr("C495", "Cercola", "Napoli (NA)"), new structType.ptr("C496", "Cerda", "Palermo (PA)"), new structType.ptr("C498", "Cerea", "Verona (VR)"), new structType.ptr("C500", "Ceregnano", "Rovigo (RO)"), new structType.ptr("C501", "Cerenzia", "Crotone (KR)"), new structType.ptr("C497", "Ceres", "Torino (TO)"), new structType.ptr("C502", "Ceresara", "Mantova (MN)"), new structType.ptr("C503", "Cereseto", "Alessandria (AL)"), new structType.ptr("C504", "Ceresole Alba", "Cuneo (CN)"), new structType.ptr("C505", "Ceresole Reale", "Torino (TO)"), new structType.ptr("C506", "Cerete", "Bergamo (BG)"), new structType.ptr("C508", "Ceretto Lomellina", "Pavia (PV)"), new structType.ptr("C509", "Cergnago", "Pavia (PV)"), new structType.ptr("C510", "Ceriale", "Savona (SV)"), new structType.ptr("C511", "Ceriana", "Imperia (IM)"), new structType.ptr("C512", "Ceriano Laghetto", "Monza e della Brianza (MB)"), new structType.ptr("C513", "Cerignale", "Piacenza (PC)"), new structType.ptr("C514", "Cerignola", "Foggia (FG)"), new structType.ptr("C515", "Cerisano", "Cosenza (CS)"), new structType.ptr("C516", "Cermenate", "Como (CO)"), new structType.ptr("A022", "Cermes .Tscherms.", "Bolzano (BZ)"), new structType.ptr("C517", "Cermignano", "Teramo (TE)"), new structType.ptr("C520", "Cernobbio", "Como (CO)"), new structType.ptr("C521", "Cernusco Lombardone", "Lecco (LC)"), new structType.ptr("C523", "Cernusco Sul Naviglio", "Milano (MI)"), new structType.ptr("C526", "Cerreto Castello", "Biella (BI)"), new structType.ptr("C528", "Cerreto D'Asti", "Asti (AT)"), new structType.ptr("C524", "Cerreto D'Esi", "Ancona (AN)"), new structType.ptr("C527", "Cerreto Di Spoleto", "Perugia (PG)"), new structType.ptr("C507", "Cerreto Grue", "Alessandria (AL)"), new structType.ptr("C529", "Cerreto Guidi", "Firenze (FI)"), new structType.ptr("C518", "Cerreto Laziale", "Roma (RM)"), new structType.ptr("C525", "Cerreto Sannita", "Benevento (BN)"), new structType.ptr("C530", "Cerretto Langhe", "Cuneo (CN)"), new structType.ptr("C531", "Cerrina Monferrato", "Alessandria (AL)"), new structType.ptr("C532", "Cerrione", "Biella (BI)"), new structType.ptr("C536", "Cerro Al Lambro", "Milano (MI)"), new structType.ptr("C534", "Cerro Al Volturno", "Isernia (IS)"), new structType.ptr("C537", "Cerro Maggiore", "Milano (MI)"), new structType.ptr("C533", "Cerro Tanaro", "Asti (AT)"), new structType.ptr("C538", "Cerro Veronese", "Verona (VR)"), new structType.ptr("C539", "Cersosimo", "Potenza (PZ)"), new structType.ptr("C540", "Certaldo", "Firenze (FI)"), new structType.ptr("C541", "Certosa Di Pavia", "Pavia (PV)"), new structType.ptr("C542", "Cerva", "Catanzaro (CZ)"), new structType.ptr("C543", "Cervara Di Roma", "Roma (RM)"), new structType.ptr("C544", "Cervarese Santa Croce", "Padova (PD)"), new structType.ptr("C545", "Cervaro", "Frosinone (FR)"), new structType.ptr("C547", "Cervasca", "Cuneo (CN)"), new structType.ptr("C548", "Cervatto", "Vercelli (VC)"), new structType.ptr("C549", "Cerveno", "Brescia (BS)"), new structType.ptr("C550", "Cervere", "Cuneo (CN)"), new structType.ptr("C551", "Cervesina", "Pavia (PV)"), new structType.ptr("C552", "Cerveteri", "Roma (RM)"), new structType.ptr("C553", "Cervia", "Ravenna (RA)"), new structType.ptr("C554", "Cervicati", "Cosenza (CS)"), new structType.ptr("C555", "Cervignano D'Adda", "Lodi (LO)"), new structType.ptr("C556", "Cervignano Del Friuli", "Udine (UD)"), new structType.ptr("C557", "Cervinara", "Avellino (AV)"), new structType.ptr("C558", "Cervino", "Caserta (CE)"), new structType.ptr("C559", "Cervo", "Imperia (IM)"), new structType.ptr("C560", "Cerzeto", "Cosenza (CS)"), new structType.ptr("C561", "Cesa", "Caserta (CE)"), new structType.ptr("C563", "Cesana Brianza", "Lecco (LC)"), new structType.ptr("C564", "Cesana Torinese", "Torino (TO)"), new structType.ptr("C565", "Cesano Boscone", "Milano (MI)"), new structType.ptr("C566", "Cesano Maderno", "Monza e della Brianza (MB)"), new structType.ptr("C567", "Cesara", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("C568", "Cesar\xC3\xB2", "Messina (ME)"), new structType.ptr("C569", "Cesate", "Milano (MI)"), new structType.ptr("C573", "Cesena", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("C574", "Cesenatico", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("C576", "Cesinali", "Avellino (AV)"), new structType.ptr("C578", "Cesio", "Imperia (IM)"), new structType.ptr("C577", "Cesiomaggiore", "Belluno (BL)"), new structType.ptr("C580", "Cessalto", "Treviso (TV)"), new structType.ptr("C581", "Cessaniti", "Vibo Valentia (VV)"), new structType.ptr("C582", "Cessapalombo", "Macerata (MC)"), new structType.ptr("C583", "Cessole", "Asti (AT)"), new structType.ptr("C584", "Cetara", "Salerno (SA)"), new structType.ptr("C585", "Ceto", "Brescia (BS)"), new structType.ptr("C587", "Cetona", "Siena (SI)"), new structType.ptr("C588", "Cetraro", "Cosenza (CS)"), new structType.ptr("C589", "Ceva", "Cuneo (CN)"), new structType.ptr("C591", "Cevo", "Brescia (BS)"), new structType.ptr("C593", "Challand-Saint-Anselme", "Aosta (AO)"), new structType.ptr("C594", "Challand-Saint-Victor", "Aosta (AO)"), new structType.ptr("C595", "Chambave", "Aosta (AO)"), new structType.ptr("B491", "Chamois", "Aosta (AO)"), new structType.ptr("C596", "Champdepraz", "Aosta (AO)"), new structType.ptr("B540", "Champorcher", "Aosta (AO)"), new structType.ptr("C598", "Charvensod", "Aosta (AO)"), new structType.ptr("C294", "Chatillon", "Aosta (AO)"), new structType.ptr("C599", "Cherasco", "Cuneo (CN)"), new structType.ptr("C600", "Cheremule", "Sassari (SS)"), new structType.ptr("C604", "Chialamberto", "Torino (TO)"), new structType.ptr("C605", "Chiampo", "Vicenza (VI)"), new structType.ptr("C606", "Chianche", "Avellino (AV)"), new structType.ptr("C608", "Chianciano Terme", "Siena (SI)"), new structType.ptr("C609", "Chianni", "Pisa (PI)"), new structType.ptr("C610", "Chianocco", "Torino (TO)"), new structType.ptr("C612", "Chiaramonte Gulfi", "Ragusa (RG)"), new structType.ptr("C613", "Chiaramonti", "Sassari (SS)"), new structType.ptr("C614", "Chiarano", "Treviso (TV)"), new structType.ptr("C615", "Chiaravalle", "Ancona (AN)"), new structType.ptr("C616", "Chiaravalle Centrale", "Catanzaro (CZ)"), new structType.ptr("C618", "Chiari", "Brescia (BS)"), new structType.ptr("C619", "Chiaromonte", "Potenza (PZ)"), new structType.ptr("C620", "Chiauci", "Isernia (IS)"), new structType.ptr("C621", "Chiavari", "Genova (GE)"), new structType.ptr("C623", "Chiavenna", "Sondrio (SO)"), new structType.ptr("C624", "Chiaverano", "Torino (TO)"), new structType.ptr("C625", "Chienes .Kiens.", "Bolzano (BZ)"), new structType.ptr("C627", "Chieri", "Torino (TO)"), new structType.ptr("C630", "Chies D'Alpago", "Belluno (BL)"), new structType.ptr("C628", "Chiesa In Valmalenco", "Sondrio (SO)"), new structType.ptr("C629", "Chiesanuova", "Torino (TO)"), new structType.ptr("C631", "Chiesina Uzzanese", "Pistoia (PT)"), new structType.ptr("C632", "Chieti", "Chieti (CH)"), new structType.ptr("C633", "Chieuti", "Foggia (FG)"), new structType.ptr("C634", "Chieve", "Cremona (CR)"), new structType.ptr("C635", "Chignolo D'Isola", "Bergamo (BG)"), new structType.ptr("C637", "Chignolo Po", "Pavia (PV)"), new structType.ptr("C638", "Chioggia", "Venezia (VE)"), new structType.ptr("C639", "Chiomonte", "Torino (TO)"), new structType.ptr("C640", "Chions", "Pordenone (PN)"), new structType.ptr("C641", "Chiopris Viscone", "Udine (UD)"), new structType.ptr("C648", "Chitignano", "Arezzo (AR)"), new structType.ptr("C649", "Chiuduno", "Bergamo (BG)"), new structType.ptr("C650", "Chiuppano", "Vicenza (VI)"), new structType.ptr("C651", "Chiuro", "Sondrio (SO)"), new structType.ptr("C652", "Chiusa .Klausen.", "Bolzano (BZ)"), new structType.ptr("C653", "Chiusa Di Pesio", "Cuneo (CN)"), new structType.ptr("C655", "Chiusa Di San Michele", "Torino (TO)"), new structType.ptr("C654", "Chiusa Sclafani", "Palermo (PA)"), new structType.ptr("C656", "Chiusaforte", "Udine (UD)"), new structType.ptr("C657", "Chiusanico", "Imperia (IM)"), new structType.ptr("C658", "Chiusano D'Asti", "Asti (AT)"), new structType.ptr("C659", "Chiusano Di San Domenico", "Avellino (AV)"), new structType.ptr("C660", "Chiusavecchia", "Imperia (IM)"), new structType.ptr("C661", "Chiusdino", "Siena (SI)"), new structType.ptr("C662", "Chiusi", "Siena (SI)"), new structType.ptr("C663", "Chiusi Della Verna", "Arezzo (AR)"), new structType.ptr("C665", "Chivasso", "Torino (TO)"), new structType.ptr("M272", "Ciampino", "Roma (RM)"), new structType.ptr("C668", "Cianciana", "Agrigento (AG)"), new structType.ptr("C672", "Cibiana Di Cadore", "Belluno (BL)"), new structType.ptr("C673", "Cicagna", "Genova (GE)"), new structType.ptr("C674", "Cicala", "Catanzaro (CZ)"), new structType.ptr("C675", "Cicciano", "Napoli (NA)"), new structType.ptr("C676", "Cicerale", "Salerno (SA)"), new structType.ptr("C677", "Ciciliano", "Roma (RM)"), new structType.ptr("C678", "Cicognolo", "Cremona (CR)"), new structType.ptr("C679", "Ciconio", "Torino (TO)"), new structType.ptr("C680", "Cigliano", "Vercelli (VC)"), new structType.ptr("C681", "Cigli\xC3\xA8", "Cuneo (CN)"), new structType.ptr("C684", "Cigognola", "Pavia (PV)"), new structType.ptr("C685", "Cigole", "Brescia (BS)"), new structType.ptr("C686", "Cilavegna", "Pavia (PV)"), new structType.ptr("C689", "Cimadolmo", "Treviso (TV)"), new structType.ptr("C691", "Cimbergo", "Brescia (BS)"), new structType.ptr("C695", "Cimin\xC3\xA0", "Reggio Calabria (RC)"), new structType.ptr("C696", "Ciminna", "Palermo (PA)"), new structType.ptr("C697", "Cimitile", "Napoli (NA)"), new structType.ptr("C699", "Cimolais", "Pordenone (PN)"), new structType.ptr("C700", "Cimone", "Trento (TN)"), new structType.ptr("C701", "Cinaglio", "Asti (AT)"), new structType.ptr("C702", "Cineto Romano", "Roma (RM)"), new structType.ptr("C703", "Cingia De' Botti", "Cremona (CR)"), new structType.ptr("C704", "Cingoli", "Macerata (MC)"), new structType.ptr("C705", "Cinigiano", "Grosseto (GR)"), new structType.ptr("C707", "Cinisello Balsamo", "Milano (MI)"), new structType.ptr("C708", "Cinisi", "Palermo (PA)"), new structType.ptr("C709", "Cino", "Sondrio (SO)"), new structType.ptr("C710", "Cinquefrondi", "Reggio Calabria (RC)"), new structType.ptr("C711", "Cintano", "Torino (TO)"), new structType.ptr("C712", "Cinte Tesino", "Trento (TN)"), new structType.ptr("C714", "Cinto Caomaggiore", "Venezia (VE)"), new structType.ptr("C713", "Cinto Euganeo", "Padova (PD)"), new structType.ptr("C715", "Cinzano", "Torino (TO)"), new structType.ptr("C716", "Ciorlano", "Caserta (CE)"), new structType.ptr("C718", "Cipressa", "Imperia (IM)"), new structType.ptr("C719", "Circello", "Benevento (BN)"), new structType.ptr("C722", "Ciri\xC3\xA8", "Torino (TO)"), new structType.ptr("C723", "Cirigliano", "Matera (MT)"), new structType.ptr("C724", "Cirimido", "Como (CO)"), new structType.ptr("C725", "Cir\xC3\xB2", "Crotone (KR)"), new structType.ptr("C726", "Ciro' Marina", "Crotone (KR)"), new structType.ptr("C727", "Cis", "Trento (TN)"), new structType.ptr("C728", "Cisano Bergamasco", "Bergamo (BG)"), new structType.ptr("C729", "Cisano Sul Neva", "Savona (SV)"), new structType.ptr("C730", "Ciserano", "Bergamo (BG)"), new structType.ptr("C732", "Cislago", "Varese (VA)"), new structType.ptr("C733", "Cisliano", "Milano (MI)"), new structType.ptr("C734", "Cismon Del Grappa", "Vicenza (VI)"), new structType.ptr("C735", "Cison Di Valmarino", "Treviso (TV)"), new structType.ptr("C738", "Cissone", "Cuneo (CN)"), new structType.ptr("C739", "Cisterna D'Asti", "Asti (AT)"), new structType.ptr("C740", "Cisterna Di Latina", "Latina (LT)"), new structType.ptr("C741", "Cisternino", "Brindisi (BR)"), new structType.ptr("C742", "Citerna", "Perugia (PG)"), new structType.ptr("C744", "Citta' Della Pieve", "Perugia (PG)"), new structType.ptr("C745", "Citta' Di Castello", "Perugia (PG)"), new structType.ptr("C750", "Citta' Sant'Angelo", "Pescara (PE)"), new structType.ptr("C743", "Cittadella", "Padova (PD)"), new structType.ptr("C746", "Cittaducale", "Rieti (RI)"), new structType.ptr("C747", "Cittanova", "Reggio Calabria (RC)"), new structType.ptr("C749", "Cittareale", "Rieti (RI)"), new structType.ptr("C751", "Cittiglio", "Varese (VA)"), new structType.ptr("C752", "Civate", "Lecco (LC)"), new structType.ptr("C755", "Civezza", "Imperia (IM)"), new structType.ptr("C756", "Civezzano", "Trento (TN)"), new structType.ptr("C757", "Civiasco", "Vercelli (VC)"), new structType.ptr("C758", "Cividale Del Friuli", "Udine (UD)"), new structType.ptr("C759", "Cividate Al Piano", "Bergamo (BG)"), new structType.ptr("C760", "Cividate Camuno", "Brescia (BS)"), new structType.ptr("C763", "Civita", "Cosenza (CS)"), new structType.ptr("C765", "Civita Castellana", "Viterbo (VT)"), new structType.ptr("C766", "Civita D'Antino", "L'Aquila (AQ)"), new structType.ptr("C764", "Civitacampomarano", "Campobasso (CB)"), new structType.ptr("C768", "Civitaluparella", "Chieti (CH)"), new structType.ptr("C769", "Civitanova Del Sannio", "Isernia (IS)"), new structType.ptr("C770", "Civitanova Marche", "Macerata (MC)"), new structType.ptr("C771", "Civitaquana", "Pescara (PE)"), new structType.ptr("C773", "Civitavecchia", "Roma (RM)"), new structType.ptr("C778", "Civitella Alfedena", "L'Aquila (AQ)"), new structType.ptr("C779", "Civitella Casanova", "Pescara (PE)"), new structType.ptr("C780", "Civitella D'Agliano", "Viterbo (VT)"), new structType.ptr("C781", "Civitella Del Tronto", "Teramo (TE)"), new structType.ptr("C777", "Civitella Di Romagna", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("C774", "Civitella In Val Di Chiana", "Arezzo (AR)"), new structType.ptr("C776", "Civitella Messer Raimondo", "Chieti (CH)"), new structType.ptr("C782", "Civitella Paganico", "Grosseto (GR)"), new structType.ptr("C783", "Civitella Roveto", "L'Aquila (AQ)"), new structType.ptr("C784", "Civitella San Paolo", "Roma (RM)"), new structType.ptr("C785", "Civo", "Sondrio (SO)"), new structType.ptr("C787", "Claino Con Osteno", "Como (CO)"), new structType.ptr("C790", "Claut", "Pordenone (PN)"), new structType.ptr("C791", "Clauzetto", "Pordenone (PN)"), new structType.ptr("C792", "Clavesana", "Cuneo (CN)"), new structType.ptr("C793", "Claviere", "Torino (TO)"), new structType.ptr("C794", "Cles", "Trento (TN)"), new structType.ptr("C795", "Cleto", "Cosenza (CS)"), new structType.ptr("C796", "Clivio", "Varese (VA)"), new structType.ptr("C797", "Cloz", "Trento (TN)"), new structType.ptr("C800", "Clusone", "Bergamo (BG)"), new structType.ptr("C801", "Coassolo Torinese", "Torino (TO)"), new structType.ptr("C803", "Coazze", "Torino (TO)"), new structType.ptr("C804", "Coazzolo", "Asti (AT)"), new structType.ptr("C806", "Coccaglio", "Brescia (BS)"), new structType.ptr("C807", "Cocconato", "Asti (AT)"), new structType.ptr("C810", "Cocquio-Trevisago", "Varese (VA)"), new structType.ptr("C811", "Cocullo", "L'Aquila (AQ)"), new structType.ptr("C812", "Codevigo", "Padova (PD)"), new structType.ptr("C813", "Codevilla", "Pavia (PV)"), new structType.ptr("C814", "Codigoro", "Ferrara (FE)"), new structType.ptr("C815", "Codogn\xC3\xA8", "Treviso (TV)"), new structType.ptr("C816", "Codogno", "Lodi (LO)"), new structType.ptr("C817", "Codroipo", "Udine (UD)"), new structType.ptr("C818", "Codrongianos", "Sassari (SS)"), new structType.ptr("C819", "Coggiola", "Biella (BI)"), new structType.ptr("C820", "Cogliate", "Monza e della Brianza (MB)"), new structType.ptr("C821", "Cogne", "Aosta (AO)"), new structType.ptr("C823", "Cogoleto", "Genova (GE)"), new structType.ptr("C824", "Cogollo Del Cengio", "Vicenza (VI)"), new structType.ptr("C826", "Cogorno", "Genova (GE)"), new structType.ptr("C829", "Colazza", "Novara (NO)"), new structType.ptr("C835", "Colere", "Bergamo (BG)"), new structType.ptr("C836", "Colfelice", "Frosinone (FR)"), new structType.ptr("C838", "Coli", "Piacenza (PC)"), new structType.ptr("C839", "Colico", "Lecco (LC)"), new structType.ptr("C841", "Collalto Sabino", "Rieti (RI)"), new structType.ptr("C844", "Collarmele", "L'Aquila (AQ)"), new structType.ptr("C845", "Collazzone", "Perugia (PG)"), new structType.ptr("C851", "Colle Brianza", "Lecco (LC)"), new structType.ptr("C854", "Colle D'Anchise", "Campobasso (CB)"), new structType.ptr("C857", "Colle Di Tora", "Rieti (RI)"), new structType.ptr("C847", "Colle Di Val D'Elsa", "Siena (SI)"), new structType.ptr("C870", "Colle San Magno", "Frosinone (FR)"), new structType.ptr("C846", "Colle Sannita", "Benevento (BN)"), new structType.ptr("C872", "Colle Santa Lucia", "Belluno (BL)"), new structType.ptr("C848", "Colle Umberto", "Treviso (TV)"), new structType.ptr("C850", "Collebeato", "Brescia (BS)"), new structType.ptr("C852", "Collecchio", "Parma (PR)"), new structType.ptr("C853", "Collecorvino", "Pescara (PE)"), new structType.ptr("C311", "Colledara", "Teramo (TE)"), new structType.ptr("C855", "Colledimacine", "Chieti (CH)"), new structType.ptr("C856", "Colledimezzo", "Chieti (CH)"), new structType.ptr("C858", "Colleferro", "Roma (RM)"), new structType.ptr("C859", "Collegiove", "Rieti (RI)"), new structType.ptr("C860", "Collegno", "Torino (TO)"), new structType.ptr("C862", "Collelongo", "L'Aquila (AQ)"), new structType.ptr("C864", "Collepardo", "Frosinone (FR)"), new structType.ptr("C865", "Collepasso", "Lecce (LE)"), new structType.ptr("C866", "Collepietro", "L'Aquila (AQ)"), new structType.ptr("C867", "Colleretto Castelnuovo", "Torino (TO)"), new structType.ptr("C868", "Colleretto Giacosa", "Torino (TO)"), new structType.ptr("C869", "Collesalvetti", "Livorno (LI)"), new structType.ptr("C871", "Collesano", "Palermo (PA)"), new structType.ptr("C875", "Colletorto", "Campobasso (CB)"), new structType.ptr("C876", "Collevecchio", "Rieti (RI)"), new structType.ptr("C878", "Colli A Volturno", "Isernia (IS)"), new structType.ptr("M380", "Colli Al Metauro", "Pesaro e Urbino (PU)"), new structType.ptr("C877", "Colli Del Tronto", "Ascoli Piceno (AP)"), new structType.ptr("C880", "Colli Sul Velino", "Rieti (RI)"), new structType.ptr("C879", "Colliano", "Salerno (SA)"), new structType.ptr("C882", "Collinas", "Medio Campidano (VS)"), new structType.ptr("C883", "Collio", "Brescia (BS)"), new structType.ptr("C884", "Collobiano", "Vercelli (VC)"), new structType.ptr("C885", "Colloredo Di Monte Albano", "Udine (UD)"), new structType.ptr("C886", "Colmurano", "Macerata (MC)"), new structType.ptr("C888", "Colobraro", "Matera (MT)"), new structType.ptr("C890", "Cologna Veneta", "Verona (VR)"), new structType.ptr("C893", "Cologne", "Brescia (BS)"), new structType.ptr("C894", "Cologno Al Serio", "Bergamo (BG)"), new structType.ptr("C895", "Cologno Monzese", "Milano (MI)"), new structType.ptr("C897", "Colognola Ai Colli", "Verona (VR)"), new structType.ptr("C900", "Colonna", "Roma (RM)"), new structType.ptr("C901", "Colonnella", "Teramo (TE)"), new structType.ptr("C902", "Colonno", "Como (CO)"), new structType.ptr("C903", "Colorina", "Sondrio (SO)"), new structType.ptr("C904", "Colorno", "Parma (PR)"), new structType.ptr("C905", "Colosimi", "Cosenza (CS)"), new structType.ptr("C908", "Colturano", "Milano (MI)"), new structType.ptr("M336", "Colverde", "Como (CO)"), new structType.ptr("C910", "Colzate", "Bergamo (BG)"), new structType.ptr("C911", "Comabbio", "Varese (VA)"), new structType.ptr("C912", "Comacchio", "Ferrara (FE)"), new structType.ptr("C914", "Comano", "Massa-Carrara (MS)"), new structType.ptr("M314", "Comano Terme", "Trento (TN)"), new structType.ptr("C917", "Comazzo", "Lodi (LO)"), new structType.ptr("C918", "Comeglians", "Udine (UD)"), new structType.ptr("C920", "Comelico Superiore", "Belluno (BL)"), new structType.ptr("C922", "Comerio", "Varese (VA)"), new structType.ptr("C925", "Comezzano-Cizzago", "Brescia (BS)"), new structType.ptr("C926", "Comignago", "Novara (NO)"), new structType.ptr("C927", "Comiso", "Ragusa (RG)"), new structType.ptr("C928", "Comitini", "Agrigento (AG)"), new structType.ptr("C929", "Comiziano", "Napoli (NA)"), new structType.ptr("C930", "Commessaggio", "Mantova (MN)"), new structType.ptr("C931", "Commezzadura", "Trento (TN)"), new structType.ptr("C933", "Como", "Como (CO)"), new structType.ptr("C934", "Compiano", "Parma (PR)"), new structType.ptr("C937", "Comun Nuovo", "Bergamo (BG)"), new structType.ptr("C935", "Comunanza", "Ascoli Piceno (AP)"), new structType.ptr("C938", "Cona", "Venezia (VE)"), new structType.ptr("C941", "Conca Casale", "Isernia (IS)"), new structType.ptr("C940", "Conca Dei Marini", "Salerno (SA)"), new structType.ptr("C939", "Conca Della Campania", "Caserta (CE)"), new structType.ptr("C943", "Concamarise", "Verona (VR)"), new structType.ptr("C946", "Concerviano", "Rieti (RI)"), new structType.ptr("C948", "Concesio", "Brescia (BS)"), new structType.ptr("C949", "Conco", "Vicenza (VI)"), new structType.ptr("C950", "Concordia Sagittaria", "Venezia (VE)"), new structType.ptr("C951", "Concordia Sulla Secchia", "Modena (MO)"), new structType.ptr("C952", "Concorezzo", "Monza e della Brianza (MB)"), new structType.ptr("C954", "Condofuri", "Reggio Calabria (RC)"), new structType.ptr("C955", "Condove", "Torino (TO)"), new structType.ptr("C956", "Condr\xC3\xB2", "Messina (ME)"), new structType.ptr("C957", "Conegliano", "Treviso (TV)"), new structType.ptr("C958", "Confienza", "Pavia (PV)"), new structType.ptr("C959", "Configni", "Rieti (RI)"), new structType.ptr("C960", "Conflenti", "Catanzaro (CZ)"), new structType.ptr("C962", "Coniolo", "Alessandria (AL)"), new structType.ptr("C963", "Conselice", "Ravenna (RA)"), new structType.ptr("C964", "Conselve", "Padova (PD)"), new structType.ptr("M356", "Cont\xC3\xA0", "Trento (TN)"), new structType.ptr("C968", "Contessa Entellina", "Palermo (PA)"), new structType.ptr("C969", "Contigliano", "Rieti (RI)"), new structType.ptr("C971", "Contrada", "Avellino (AV)"), new structType.ptr("C972", "Controguerra", "Teramo (TE)"), new structType.ptr("C973", "Controne", "Salerno (SA)"), new structType.ptr("C974", "Contursi Terme", "Salerno (SA)"), new structType.ptr("C975", "Conversano", "Bari (BA)"), new structType.ptr("C976", "Conza Della Campania", "Avellino (AV)"), new structType.ptr("C977", "Conzano", "Alessandria (AL)"), new structType.ptr("C978", "Copertino", "Lecce (LE)"), new structType.ptr("C979", "Copiano", "Pavia (PV)"), new structType.ptr("C980", "Copparo", "Ferrara (FE)"), new structType.ptr("C982", "Corana", "Pavia (PV)"), new structType.ptr("C983", "Corato", "Bari (BA)"), new structType.ptr("C984", "Corbara", "Salerno (SA)"), new structType.ptr("C986", "Corbetta", "Milano (MI)"), new structType.ptr("C987", "Corbola", "Rovigo (RO)"), new structType.ptr("C988", "Corchiano", "Viterbo (VT)"), new structType.ptr("C990", "Corciano", "Perugia (PG)"), new structType.ptr("C991", "Cordenons", "Pordenone (PN)"), new structType.ptr("C992", "Cordignano", "Treviso (TV)"), new structType.ptr("C993", "Cordovado", "Pordenone (PN)"), new structType.ptr("C996", "Coreglia Antelminelli", "Lucca (LU)"), new structType.ptr("C995", "Coreglia Ligure", "Genova (GE)"), new structType.ptr("C998", "Coreno Ausonio", "Frosinone (FR)"), new structType.ptr("C999", "Corfinio", "L'Aquila (AQ)"), new structType.ptr("D003", "Cori", "Latina (LT)"), new structType.ptr("D004", "Coriano", "Rimini (RN)"), new structType.ptr("D005", "Corigliano Calabro", "Cosenza (CS)"), new structType.ptr("D006", "Corigliano D'Otranto", "Lecce (LE)"), new structType.ptr("D007", "Corinaldo", "Ancona (AN)"), new structType.ptr("D008", "Corio", "Torino (TO)"), new structType.ptr("D009", "Corleone", "Palermo (PA)"), new structType.ptr("D011", "Corleto Monforte", "Salerno (SA)"), new structType.ptr("D010", "Corleto Perticara", "Potenza (PZ)"), new structType.ptr("D013", "Cormano", "Milano (MI)"), new structType.ptr("D014", "Cormons", "Gorizia (GO)"), new structType.ptr("D015", "Corna Imagna", "Bergamo (BG)"), new structType.ptr("D016", "Cornalba", "Bergamo (BG)"), new structType.ptr("M338", "Cornale E Bastida", "Pavia (PV)"), new structType.ptr("D018", "Cornaredo", "Milano (MI)"), new structType.ptr("D019", "Cornate D'Adda", "Monza e della Brianza (MB)"), new structType.ptr("B799", "Cornedo All'Isarco .Karneid.", "Bolzano (BZ)"), new structType.ptr("D020", "Cornedo Vicentino", "Vicenza (VI)"), new structType.ptr("D021", "Cornegliano Laudense", "Lodi (LO)"), new structType.ptr("D022", "Corneliano D'Alba", "Cuneo (CN)"), new structType.ptr("D026", "Corniglio", "Parma (PR)"), new structType.ptr("D027", "Corno Di Rosazzo", "Udine (UD)"), new structType.ptr("D028", "Corno Giovine", "Lodi (LO)"), new structType.ptr("D029", "Cornovecchio", "Lodi (LO)"), new structType.ptr("D030", "Cornuda", "Treviso (TV)"), new structType.ptr("D037", "Correggio", "Reggio Emilia (RE)"), new structType.ptr("D038", "Correzzana", "Monza e della Brianza (MB)"), new structType.ptr("D040", "Correzzola", "Padova (PD)"), new structType.ptr("D041", "Corrido", "Como (CO)"), new structType.ptr("D042", "Corridonia", "Macerata (MC)"), new structType.ptr("D043", "Corropoli", "Teramo (TE)"), new structType.ptr("D044", "Corsano", "Lecce (LE)"), new structType.ptr("D045", "Corsico", "Milano (MI)"), new structType.ptr("D046", "Corsione", "Asti (AT)"), new structType.ptr("D048", "Cortaccia Sulla Strada Del Vino .Kurtatsch A.", "Bolzano (BZ)"), new structType.ptr("D049", "Cortale", "Catanzaro (CZ)"), new structType.ptr("D050", "Cortandone", "Asti (AT)"), new structType.ptr("D051", "Cortanze", "Asti (AT)"), new structType.ptr("D052", "Cortazzone", "Asti (AT)"), new structType.ptr("D054", "Corte Brugnatella", "Piacenza (PC)"), new structType.ptr("D056", "Corte De' Cortesi Con Cignone", "Cremona (CR)"), new structType.ptr("D057", "Corte De' Frati", "Cremona (CR)"), new structType.ptr("D058", "Corte Franca", "Brescia (BS)"), new structType.ptr("D068", "Corte Palasio", "Lodi (LO)"), new structType.ptr("D061", "Cortemaggiore", "Piacenza (PC)"), new structType.ptr("D062", "Cortemilia", "Cuneo (CN)"), new structType.ptr("D064", "Corteno Golgi", "Brescia (BS)"), new structType.ptr("D065", "Cortenova", "Lecco (LC)"), new structType.ptr("D066", "Cortenuova", "Bergamo (BG)"), new structType.ptr("M372", "Corteolona E Genzone", "Pavia (PV)"), new structType.ptr("D072", "Cortiglione", "Asti (AT)"), new structType.ptr("A266", "Cortina D'Ampezzo", "Belluno (BL)"), new structType.ptr("D075", "Cortina Sulla Strada Del Vino .Kurtinig An D.", "Bolzano (BZ)"), new structType.ptr("D076", "Cortino", "Teramo (TE)"), new structType.ptr("D077", "Cortona", "Arezzo (AR)"), new structType.ptr("D078", "Corvara", "Pescara (PE)"), new structType.ptr("D079", "Corvara In Badia .Corvara.", "Bolzano (BZ)"), new structType.ptr("D081", "Corvino San Quirico", "Pavia (PV)"), new structType.ptr("D082", "Corzano", "Brescia (BS)"), new structType.ptr("D085", "Coseano", "Udine (UD)"), new structType.ptr("D086", "Cosenza", "Cosenza (CS)"), new structType.ptr("D087", "Cosio D'Arroscia", "Imperia (IM)"), new structType.ptr("D088", "Cosio Valtellino", "Sondrio (SO)"), new structType.ptr("D089", "Cosoleto", "Reggio Calabria (RC)"), new structType.ptr("D093", "Cossano Belbo", "Cuneo (CN)"), new structType.ptr("D092", "Cossano Canavese", "Torino (TO)"), new structType.ptr("D094", "Cossato", "Biella (BI)"), new structType.ptr("D095", "Cosseria", "Savona (SV)"), new structType.ptr("D096", "Cossignano", "Ascoli Piceno (AP)"), new structType.ptr("D099", "Cossogno", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("D100", "Cossoine", "Sassari (SS)"), new structType.ptr("D101", "Cossombrato", "Asti (AT)"), new structType.ptr("D109", "Costa De' Nobili", "Pavia (PV)"), new structType.ptr("D110", "Costa Di Mezzate", "Bergamo (BG)"), new structType.ptr("D105", "Costa Di Rovigo", "Rovigo (RO)"), new structType.ptr("D112", "Costa Masnaga", "Lecco (LC)"), new structType.ptr("D111", "Costa Serina", "Bergamo (BG)"), new structType.ptr("D103", "Costa Valle Imagna", "Bergamo (BG)"), new structType.ptr("D102", "Costa Vescovato", "Alessandria (AL)"), new structType.ptr("D117", "Costa Volpino", "Bergamo (BG)"), new structType.ptr("D107", "Costabissara", "Vicenza (VI)"), new structType.ptr("D108", "Costacciaro", "Perugia (PG)"), new structType.ptr("D113", "Costanzana", "Vercelli (VC)"), new structType.ptr("D114", "Costarainera", "Imperia (IM)"), new structType.ptr("D118", "Costermano", "Verona (VR)"), new structType.ptr("D119", "Costigliole D'Asti", "Asti (AT)"), new structType.ptr("D120", "Costigliole Saluzzo", "Cuneo (CN)"), new structType.ptr("D121", "Cotignola", "Ravenna (RA)"), new structType.ptr("D123", "Cotronei", "Crotone (KR)"), new structType.ptr("D124", "Cottanello", "Rieti (RI)"), new structType.ptr("D012", "Courmayeur", "Aosta (AO)"), new structType.ptr("D126", "Covo", "Bergamo (BG)"), new structType.ptr("D127", "Cozzo", "Pavia (PV)"), new structType.ptr("D128", "Craco", "Matera (MT)"), new structType.ptr("D131", "Crandola Valsassina", "Lecco (LC)"), new structType.ptr("D132", "Cravagliana", "Vercelli (VC)"), new structType.ptr("D133", "Cravanzana", "Cuneo (CN)"), new structType.ptr("D134", "Craveggia", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("D136", "Creazzo", "Vicenza (VI)"), new structType.ptr("D137", "Crecchio", "Chieti (CH)"), new structType.ptr("D139", "Credaro", "Bergamo (BG)"), new structType.ptr("D141", "Credera Rubbiano", "Cremona (CR)"), new structType.ptr("D142", "Crema", "Cremona (CR)"), new structType.ptr("D143", "Cremella", "Lecco (LC)"), new structType.ptr("D144", "Cremenaga", "Varese (VA)"), new structType.ptr("D145", "Cremeno", "Lecco (LC)"), new structType.ptr("D147", "Cremia", "Como (CO)"), new structType.ptr("D149", "Cremolino", "Alessandria (AL)"), new structType.ptr("D150", "Cremona", "Cremona (CR)"), new structType.ptr("D151", "Cremosano", "Cremona (CR)"), new structType.ptr("D154", "Crescentino", "Vercelli (VC)"), new structType.ptr("D156", "Crespadoro", "Vicenza (VI)"), new structType.ptr("D157", "Crespano Del Grappa", "Treviso (TV)"), new structType.ptr("D159", "Crespiatica", "Lodi (LO)"), new structType.ptr("M328", "Crespina Lorenzana", "Pisa (PI)"), new structType.ptr("D161", "Crespino", "Rovigo (RO)"), new structType.ptr("D162", "Cressa", "Novara (NO)"), new structType.ptr("D165", "Crevacuore", "Biella (BI)"), new structType.ptr("D166", "Crevalcore", "Bologna (BO)"), new structType.ptr("D168", "Crevoladossola", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("D170", "Crispano", "Napoli (NA)"), new structType.ptr("D171", "Crispiano", "Taranto (TA)"), new structType.ptr("D172", "Crissolo", "Cuneo (CN)"), new structType.ptr("D175", "Crocefieschi", "Genova (GE)"), new structType.ptr("C670", "Crocetta Del Montello", "Treviso (TV)"), new structType.ptr("D177", "Crodo", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("D179", "Crognaleto", "Teramo (TE)"), new structType.ptr("D180", "Cropalati", "Cosenza (CS)"), new structType.ptr("D181", "Cropani", "Catanzaro (CZ)"), new structType.ptr("D184", "Crosia", "Cosenza (CS)"), new structType.ptr("D185", "Crosio Della Valle", "Varese (VA)"), new structType.ptr("D122", "Crotone", "Crotone (KR)"), new structType.ptr("D186", "Crotta D'Adda", "Cremona (CR)"), new structType.ptr("D187", "Crova", "Vercelli (VC)"), new structType.ptr("D188", "Croviana", "Trento (TN)"), new structType.ptr("D189", "Crucoli", "Crotone (KR)"), new structType.ptr("D192", "Cuasso Al Monte", "Varese (VA)"), new structType.ptr("D194", "Cuccaro Monferrato", "Alessandria (AL)"), new structType.ptr("D195", "Cuccaro Vetere", "Salerno (SA)"), new structType.ptr("D196", "Cucciago", "Como (CO)"), new structType.ptr("D197", "Cuceglio", "Torino (TO)"), new structType.ptr("D198", "Cuggiono", "Milano (MI)"), new structType.ptr("D199", "Cugliate-Fabiasco", "Varese (VA)"), new structType.ptr("D200", "Cuglieri", "Oristano (OR)"), new structType.ptr("D201", "Cugnoli", "Pescara (PE)"), new structType.ptr("D202", "Cumiana", "Torino (TO)"), new structType.ptr("D203", "Cumignano Sul Naviglio", "Cremona (CR)"), new structType.ptr("D204", "Cunardo", "Varese (VA)"), new structType.ptr("D205", "Cuneo", "Cuneo (CN)"), new structType.ptr("D207", "Cunico", "Asti (AT)"), new structType.ptr("D208", "Cuorgn\xC3\xA8", "Torino (TO)"), new structType.ptr("D209", "Cupello", "Chieti (CH)"), new structType.ptr("D210", "Cupra Marittima", "Ascoli Piceno (AP)"), new structType.ptr("D211", "Cupramontana", "Ancona (AN)"), new structType.ptr("B824", "Cura Carpignano", "Pavia (PV)"), new structType.ptr("D214", "Curcuris", "Oristano (OR)"), new structType.ptr("D216", "Cureggio", "Novara (NO)"), new structType.ptr("D217", "Curiglia Con Monteviasco", "Varese (VA)"), new structType.ptr("D218", "Curinga", "Catanzaro (CZ)"), new structType.ptr("D219", "Curino", "Biella (BI)"), new structType.ptr("D221", "Curno", "Bergamo (BG)"), new structType.ptr("D222", "Curon Venosta .Graun Im Vinschgau.", "Bolzano (BZ)"), new structType.ptr("D223", "Cursi", "Lecce (LE)"), new structType.ptr("D225", "Cursolo-Orasso", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("D226", "Curtarolo", "Padova (PD)"), new structType.ptr("D227", "Curtatone", "Mantova (MN)"), new structType.ptr("D228", "Curti", "Caserta (CE)"), new structType.ptr("D229", "Cusago", "Milano (MI)"), new structType.ptr("D231", "Cusano Milanino", "Milano (MI)"), new structType.ptr("D230", "Cusano Mutri", "Benevento (BN)"), new structType.ptr("D232", "Cusino", "Como (CO)"), new structType.ptr("D233", "Cusio", "Bergamo (BG)"), new structType.ptr("D234", "Custonaci", "Trapani (TP)"), new structType.ptr("D236", "Cutro", "Crotone (KR)"), new structType.ptr("D237", "Cutrofiano", "Lecce (LE)"), new structType.ptr("D238", "Cuveglio", "Varese (VA)"), new structType.ptr("D239", "Cuvio", "Varese (VA)"), new structType.ptr("D243", "Daiano", "Trento (TN)"), new structType.ptr("D244", "Dairago", "Milano (MI)"), new structType.ptr("D245", "Dalmine", "Bergamo (BG)"), new structType.ptr("D246", "Dambel", "Trento (TN)"), new structType.ptr("D247", "Danta Di Cadore", "Belluno (BL)"), new structType.ptr("D251", "Darfo Boario Terme", "Brescia (BS)"), new structType.ptr("D253", "Das\xC3\xA0", "Vibo Valentia (VV)"), new structType.ptr("D255", "Davagna", "Genova (GE)"), new structType.ptr("D256", "Daverio", "Varese (VA)"), new structType.ptr("D257", "Davoli", "Catanzaro (CZ)"), new structType.ptr("D258", "Dazio", "Sondrio (SO)"), new structType.ptr("D259", "Decimomannu", "Cagliari (CA)"), new structType.ptr("D260", "Decimoputzu", "Cagliari (CA)"), new structType.ptr("D261", "Decollatura", "Catanzaro (CZ)"), new structType.ptr("D264", "Dego", "Savona (SV)"), new structType.ptr("D265", "Deiva Marina", "La Spezia (SP)"), new structType.ptr("D266", "Delebio", "Sondrio (SO)"), new structType.ptr("D267", "Delia", "Caltanissetta (CL)"), new structType.ptr("D268", "Delianuova", "Reggio Calabria (RC)"), new structType.ptr("D269", "Deliceto", "Foggia (FG)"), new structType.ptr("D270", "Dello", "Brescia (BS)"), new structType.ptr("D271", "Demonte", "Cuneo (CN)"), new structType.ptr("D272", "Denice", "Alessandria (AL)"), new structType.ptr("D273", "Denno", "Trento (TN)"), new structType.ptr("D277", "Dernice", "Alessandria (AL)"), new structType.ptr("D278", "Derovere", "Cremona (CR)"), new structType.ptr("D279", "Deruta", "Perugia (PG)"), new structType.ptr("D280", "Dervio", "Lecco (LC)"), new structType.ptr("D281", "Desana", "Vercelli (VC)"), new structType.ptr("D284", "Desenzano Del Garda", "Brescia (BS)"), new structType.ptr("D286", "Desio", "Monza e della Brianza (MB)"), new structType.ptr("D287", "Desulo", "Nuoro (NU)"), new structType.ptr("D289", "Diamante", "Cosenza (CS)"), new structType.ptr("D293", "Diano Arentino", "Imperia (IM)"), new structType.ptr("D296", "Diano Castello", "Imperia (IM)"), new structType.ptr("D291", "Diano D'Alba", "Cuneo (CN)"), new structType.ptr("D297", "Diano Marina", "Imperia (IM)"), new structType.ptr("D298", "Diano San Pietro", "Imperia (IM)"), new structType.ptr("D299", "Dicomano", "Firenze (FI)"), new structType.ptr("D300", "Dignano", "Udine (UD)"), new structType.ptr("M366", "Dimaro Folgarida", "Trento (TN)"), new structType.ptr("D303", "Dinami", "Vibo Valentia (VV)"), new structType.ptr("D304", "Dipignano", "Cosenza (CS)"), new structType.ptr("D305", "Diso", "Lecce (LE)"), new structType.ptr("D309", "Divignano", "Novara (NO)"), new structType.ptr("D310", "Dizzasco", "Como (CO)"), new structType.ptr("D311", "Dobbiaco .Toblach.", "Bolzano (BZ)"), new structType.ptr("D312", "Doberdo' Del Lago", "Gorizia (GO)"), new structType.ptr("D314", "Dogliani", "Cuneo (CN)"), new structType.ptr("D315", "Dogliola", "Chieti (CH)"), new structType.ptr("D316", "Dogna", "Udine (UD)"), new structType.ptr("D317", "Dolc\xC3\xA8", "Verona (VR)"), new structType.ptr("D318", "Dolceacqua", "Imperia (IM)"), new structType.ptr("D319", "Dolcedo", "Imperia (IM)"), new structType.ptr("D321", "Dolegna Del Collio", "Gorizia (GO)"), new structType.ptr("D323", "Dolianova", "Cagliari (CA)"), new structType.ptr("D325", "Dolo", "Venezia (VE)"), new structType.ptr("D327", "Dolzago", "Lecco (LC)"), new structType.ptr("D328", "Domanico", "Cosenza (CS)"), new structType.ptr("D329", "Domaso", "Como (CO)"), new structType.ptr("D330", "Domegge Di Cadore", "Belluno (BL)"), new structType.ptr("D331", "Domicella", "Avellino (AV)"), new structType.ptr("D332", "Domodossola", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("D333", "Domus De Maria", "Cagliari (CA)"), new structType.ptr("D334", "Domusnovas", "Carbonia-Iglesias (CI)"), new structType.ptr("D339", "Donato", "Biella (BI)"), new structType.ptr("D341", "Dongo", "Como (CO)"), new structType.ptr("D338", "Donnas", "Aosta (AO)"), new structType.ptr("D344", "Donori", "Cagliari (CA)"), new structType.ptr("D345", "Dorgali", "Nuoro (NU)"), new structType.ptr("D346", "Dorio", "Lecco (LC)"), new structType.ptr("D347", "Dormelletto", "Novara (NO)"), new structType.ptr("D348", "Dorno", "Pavia (PV)"), new structType.ptr("D350", "Dorzano", "Biella (BI)"), new structType.ptr("D351", "Dosolo", "Mantova (MN)"), new structType.ptr("D352", "Dossena", "Bergamo (BG)"), new structType.ptr("D355", "Dosso Del Liro", "Como (CO)"), new structType.ptr("D356", "Doues", "Aosta (AO)"), new structType.ptr("D357", "Dovadola", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("D358", "Dovera", "Cremona (CR)"), new structType.ptr("D360", "Dozza", "Bologna (BO)"), new structType.ptr("D361", "Dragoni", "Caserta (CE)"), new structType.ptr("D364", "Drapia", "Vibo Valentia (VV)"), new structType.ptr("D365", "Drena", "Trento (TN)"), new structType.ptr("D366", "Drenchia", "Udine (UD)"), new structType.ptr("D367", "Dresano", "Milano (MI)"), new structType.ptr("D370", "Drizzona", "Cremona (CR)"), new structType.ptr("D371", "Dro", "Trento (TN)"), new structType.ptr("D372", "Dronero", "Cuneo (CN)"), new structType.ptr("D373", "Druento", "Torino (TO)"), new structType.ptr("D374", "Druogno", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("D376", "Dualchi", "Nuoro (NU)"), new structType.ptr("D377", "Dubino", "Sondrio (SO)"), new structType.ptr("M300", "Due Carrare", "Padova (PD)"), new structType.ptr("D379", "Dueville", "Vicenza (VI)"), new structType.ptr("D380", "Dugenta", "Benevento (BN)"), new structType.ptr("D383", "Duino-Aurisina", "Trieste (TS)"), new structType.ptr("D384", "Dumenza", "Varese (VA)"), new structType.ptr("D385", "Duno", "Varese (VA)"), new structType.ptr("D386", "Durazzano", "Benevento (BN)"), new structType.ptr("C772", "Duronia", "Campobasso (CB)"), new structType.ptr("D388", "Dusino San Michele", "Asti (AT)"), new structType.ptr("D390", "Eboli", "Salerno (SA)"), new structType.ptr("D391", "Edolo", "Brescia (BS)"), new structType.ptr("D392", "Egna .Neumarkt.", "Bolzano (BZ)"), new structType.ptr("D394", "Elice", "Pescara (PE)"), new structType.ptr("D395", "Elini", "Ogliastra (OG)"), new structType.ptr("D398", "Ello", "Lecco (LC)"), new structType.ptr("D399", "Elmas", "Cagliari (CA)"), new structType.ptr("D401", "Elva", "Cuneo (CN)"), new structType.ptr("D402", "Emarese", "Aosta (AO)"), new structType.ptr("D403", "Empoli", "Firenze (FI)"), new structType.ptr("D406", "Endine Gaiano", "Bergamo (BG)"), new structType.ptr("D407", "Enego", "Vicenza (VI)"), new structType.ptr("D408", "Enemonzo", "Udine (UD)"), new structType.ptr("C342", "Enna", "Enna (EN)"), new structType.ptr("D410", "Entracque", "Cuneo (CN)"), new structType.ptr("D411", "Entratico", "Bergamo (BG)"), new structType.ptr("D412", "Envie", "Cuneo (CN)"), new structType.ptr("D414", "Episcopia", "Potenza (PZ)"), new structType.ptr("D415", "Eraclea", "Venezia (VE)"), new structType.ptr("D416", "Erba", "Como (CO)"), new structType.ptr("D419", "Erb\xC3\xA8", "Verona (VR)"), new structType.ptr("D420", "Erbezzo", "Verona (VR)"), new structType.ptr("D421", "Erbusco", "Brescia (BS)"), new structType.ptr("D422", "Erchie", "Brindisi (BR)"), new structType.ptr("H243", "Ercolano", "Napoli (NA)"), new structType.ptr("D423", "Erice", "Trapani (TP)"), new structType.ptr("D424", "Erli", "Savona (SV)"), new structType.ptr("D426", "Erto E Casso", "Pordenone (PN)"), new structType.ptr("M292", "Erula", "Sassari (SS)"), new structType.ptr("D428", "Erve", "Lecco (LC)"), new structType.ptr("D429", "Esanatoglia", "Macerata (MC)"), new structType.ptr("D430", "Escalaplano", "Cagliari (CA)"), new structType.ptr("D431", "Escolca", "Cagliari (CA)"), new structType.ptr("D434", "Esine", "Brescia (BS)"), new structType.ptr("D436", "Esino Lario", "Lecco (LC)"), new structType.ptr("D440", "Esperia", "Frosinone (FR)"), new structType.ptr("D441", "Esporlatu", "Sassari (SS)"), new structType.ptr("D442", "Este", "Padova (PD)"), new structType.ptr("D443", "Esterzili", "Cagliari (CA)"), new structType.ptr("D444", "Etroubles", "Aosta (AO)"), new structType.ptr("D445", "Eupilio", "Como (CO)"), new structType.ptr("D433", "Exilles", "Torino (TO)"), new structType.ptr("D447", "Fabbrica Curone", "Alessandria (AL)"), new structType.ptr("M319", "Fabbriche Di Vergemoli", "Lucca (LU)"), new structType.ptr("D450", "Fabbrico", "Reggio Emilia (RE)"), new structType.ptr("D451", "Fabriano", "Ancona (AN)"), new structType.ptr("D452", "Fabrica Di Roma", "Viterbo (VT)"), new structType.ptr("D453", "Fabrizia", "Vibo Valentia (VV)"), new structType.ptr("D454", "Fabro", "Terni (TR)"), new structType.ptr("D455", "Faedis", "Udine (UD)"), new structType.ptr("D457", "Faedo", "Trento (TN)"), new structType.ptr("D456", "Faedo Valtellino", "Sondrio (SO)"), new structType.ptr("D458", "Faenza", "Ravenna (RA)"), new structType.ptr("D459", "Faeto", "Foggia (FG)"), new structType.ptr("D461", "Fagagna", "Udine (UD)"), new structType.ptr("D462", "Faggeto Lario", "Como (CO)"), new structType.ptr("D463", "Faggiano", "Taranto (TA)"), new structType.ptr("D465", "Fagnano Alto", "L'Aquila (AQ)"), new structType.ptr("D464", "Fagnano Castello", "Cosenza (CS)"), new structType.ptr("D467", "Fagnano Olona", "Varese (VA)"), new structType.ptr("D468", "Fai Della Paganella", "Trento (TN)"), new structType.ptr("D469", "Faicchio", "Benevento (BN)"), new structType.ptr("D470", "Falcade", "Belluno (BL)"), new structType.ptr("D471", "Falciano Del Massico", "Caserta (CE)"), new structType.ptr("D473", "Falconara Albanese", "Cosenza (CS)"), new structType.ptr("D472", "Falconara Marittima", "Ancona (AN)"), new structType.ptr("D474", "Falcone", "Messina (ME)"), new structType.ptr("D475", "Faleria", "Viterbo (VT)"), new structType.ptr("D476", "Falerna", "Catanzaro (CZ)"), new structType.ptr("D477", "Falerone", "Fermo (FM)"), new structType.ptr("D480", "Fallo", "Chieti (CH)"), new structType.ptr("D481", "Falmenta", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("D482", "Faloppio", "Como (CO)"), new structType.ptr("D483", "Falvaterra", "Frosinone (FR)"), new structType.ptr("D484", "Falzes .Pfalzen.", "Bolzano (BZ)"), new structType.ptr("D486", "Fanano", "Modena (MO)"), new structType.ptr("D487", "Fanna", "Pordenone (PN)"), new structType.ptr("D488", "Fano", "Pesaro e Urbino (PU)"), new structType.ptr("D489", "Fano Adriano", "Teramo (TE)"), new structType.ptr("D494", "Fara Filiorum Petri", "Chieti (CH)"), new structType.ptr("D490", "Fara Gera D'Adda", "Bergamo (BG)"), new structType.ptr("D493", "Fara In Sabina", "Rieti (RI)"), new structType.ptr("D492", "Fara Novarese", "Novara (NO)"), new structType.ptr("D491", "Fara Olivana Con Sola", "Bergamo (BG)"), new structType.ptr("D495", "Fara San Martino", "Chieti (CH)"), new structType.ptr("D496", "Fara Vicentino", "Vicenza (VI)"), new structType.ptr("D497", "Fardella", "Potenza (PZ)"), new structType.ptr("D499", "Farigliano", "Cuneo (CN)"), new structType.ptr("D501", "Farindola", "Pescara (PE)"), new structType.ptr("D502", "Farini", "Piacenza (PC)"), new structType.ptr("D503", "Farnese", "Viterbo (VT)"), new structType.ptr("D505", "Farra Di Soligo", "Treviso (TV)"), new structType.ptr("D504", "Farra D'Isonzo", "Gorizia (GO)"), new structType.ptr("D508", "Fasano", "Brindisi (BR)"), new structType.ptr("D509", "Fascia", "Genova (GE)"), new structType.ptr("D510", "Fauglia", "Pisa (PI)"), new structType.ptr("D511", "Faule", "Cuneo (CN)"), new structType.ptr("D512", "Favale Di Malvaro", "Genova (GE)"), new structType.ptr("D514", "Favara", "Agrigento (AG)"), new structType.ptr("D518", "Favignana", "Trapani (TP)"), new structType.ptr("D520", "Favria", "Torino (TO)"), new structType.ptr("D523", "Feisoglio", "Cuneo (CN)"), new structType.ptr("D524", "Feletto", "Torino (TO)"), new structType.ptr("D526", "Felino", "Parma (PR)"), new structType.ptr("D527", "Felitto", "Salerno (SA)"), new structType.ptr("D528", "Felizzano", "Alessandria (AL)"), new structType.ptr("D529", "Felonica", "Mantova (MN)"), new structType.ptr("D530", "Feltre", "Belluno (BL)"), new structType.ptr("D531", "Fenegr\xC3\xB2", "Como (CO)"), new structType.ptr("D532", "Fenestrelle", "Torino (TO)"), new structType.ptr("D537", "Fenis", "Aosta (AO)"), new structType.ptr("D538", "Ferentillo", "Terni (TR)"), new structType.ptr("D539", "Ferentino", "Frosinone (FR)"), new structType.ptr("D540", "Ferla", "Siracusa (SR)"), new structType.ptr("D541", "Fermignano", "Pesaro e Urbino (PU)"), new structType.ptr("D542", "Fermo", "Fermo (FM)"), new structType.ptr("D543", "Ferno", "Varese (VA)"), new structType.ptr("D544", "Feroleto Antico", "Catanzaro (CZ)"), new structType.ptr("D545", "Feroleto Della Chiesa", "Reggio Calabria (RC)"), new structType.ptr("D547", "Ferrandina", "Matera (MT)"), new structType.ptr("D548", "Ferrara", "Ferrara (FE)"), new structType.ptr("D549", "Ferrara Di Monte Baldo", "Verona (VR)"), new structType.ptr("D550", "Ferrazzano", "Campobasso (CB)"), new structType.ptr("D551", "Ferrera Di Varese", "Varese (VA)"), new structType.ptr("D552", "Ferrera Erbognone", "Pavia (PV)"), new structType.ptr("D554", "Ferrere", "Asti (AT)"), new structType.ptr("D555", "Ferriere", "Piacenza (PC)"), new structType.ptr("D557", "Ferruzzano", "Reggio Calabria (RC)"), new structType.ptr("D560", "Fiamignano", "Rieti (RI)"), new structType.ptr("D562", "Fiano", "Torino (TO)"), new structType.ptr("D561", "Fiano Romano", "Roma (RM)"), new structType.ptr("D564", "Fiastra", "Macerata (MC)"), new structType.ptr("D565", "Fiav\xC3\xA8", "Trento (TN)"), new structType.ptr("D567", "Ficarazzi", "Palermo (PA)"), new structType.ptr("D568", "Ficarolo", "Rovigo (RO)"), new structType.ptr("D569", "Ficarra", "Messina (ME)"), new structType.ptr("D570", "Ficulle", "Terni (TR)"), new structType.ptr("B034", "Fidenza", "Parma (PR)"), new structType.ptr("D571", "Fie' Allo Sciliar .Voels Am Schlern.", "Bolzano (BZ)"), new structType.ptr("D573", "Fierozzo", "Trento (TN)"), new structType.ptr("D574", "Fiesco", "Cremona (CR)"), new structType.ptr("D575", "Fiesole", "Firenze (FI)"), new structType.ptr("D576", "Fiesse", "Brescia (BS)"), new structType.ptr("D578", "Fiesso D'Artico", "Venezia (VE)"), new structType.ptr("D577", "Fiesso Umbertiano", "Rovigo (RO)"), new structType.ptr("D579", "Figino Serenza", "Como (CO)"), new structType.ptr("M321", "Figline E Incisa Valdarno", "Firenze (FI)"), new structType.ptr("D582", "Figline Vegliaturo", "Cosenza (CS)"), new structType.ptr("D586", "Filacciano", "Roma (RM)"), new structType.ptr("D587", "Filadelfia", "Vibo Valentia (VV)"), new structType.ptr("D588", "Filago", "Bergamo (BG)"), new structType.ptr("D589", "Filandari", "Vibo Valentia (VV)"), new structType.ptr("D590", "Filattiera", "Massa-Carrara (MS)"), new structType.ptr("D591", "Filettino", "Frosinone (FR)"), new structType.ptr("D592", "Filetto", "Chieti (CH)"), new structType.ptr("D593", "Filiano", "Potenza (PZ)"), new structType.ptr("D594", "Filighera", "Pavia (PV)"), new structType.ptr("D595", "Filignano", "Isernia (IS)"), new structType.ptr("D596", "Filogaso", "Vibo Valentia (VV)"), new structType.ptr("D597", "Filottrano", "Ancona (AN)"), new structType.ptr("D599", "Finale Emilia", "Modena (MO)"), new structType.ptr("D600", "Finale Ligure", "Savona (SV)"), new structType.ptr("D604", "Fino Del Monte", "Bergamo (BG)"), new structType.ptr("D605", "Fino Mornasco", "Como (CO)"), new structType.ptr("D606", "Fiorano Al Serio", "Bergamo (BG)"), new structType.ptr("D608", "Fiorano Canavese", "Torino (TO)"), new structType.ptr("D607", "Fiorano Modenese", "Modena (MO)"), new structType.ptr("D611", "Fiorenzuola D'Arda", "Piacenza (PC)"), new structType.ptr("D612", "Firenze", "Firenze (FI)"), new structType.ptr("D613", "Firenzuola", "Firenze (FI)"), new structType.ptr("D614", "Firmo", "Cosenza (CS)"), new structType.ptr("M323", "Fiscaglia", "Ferrara (FE)"), new structType.ptr("D615", "Fisciano", "Salerno (SA)"), new structType.ptr("A310", "Fiuggi", "Frosinone (FR)"), new structType.ptr("D617", "Fiumalbo", "Modena (MO)"), new structType.ptr("D619", "Fiumara", "Reggio Calabria (RC)"), new structType.ptr("D621", "Fiume Veneto", "Pordenone (PN)"), new structType.ptr("D622", "Fiumedinisi", "Messina (ME)"), new structType.ptr("D624", "Fiumefreddo Bruzio", "Cosenza (CS)"), new structType.ptr("D623", "Fiumefreddo Di Sicilia", "Catania (CT)"), new structType.ptr("D627", "Fiumicello", "Udine (UD)"), new structType.ptr("M297", "Fiumicino", "Roma (RM)"), new structType.ptr("D628", "Fiuminata", "Macerata (MC)"), new structType.ptr("D629", "Fivizzano", "Massa-Carrara (MS)"), new structType.ptr("D630", "Flaibano", "Udine (UD)"), new structType.ptr("D634", "Flero", "Brescia (BS)"), new structType.ptr("D635", "Floresta", "Messina (ME)"), new structType.ptr("D636", "Floridia", "Siracusa (SR)"), new structType.ptr("D637", "Florinas", "Sassari (SS)"), new structType.ptr("D638", "Flumeri", "Avellino (AV)"), new structType.ptr("D639", "Fluminimaggiore", "Carbonia-Iglesias (CI)"), new structType.ptr("D640", "Flussio", "Oristano (OR)"), new structType.ptr("D641", "Fobello", "Vercelli (VC)"), new structType.ptr("D643", "Foggia", "Foggia (FG)"), new structType.ptr("D644", "Foglianise", "Benevento (BN)"), new structType.ptr("D645", "Fogliano Redipuglia", "Gorizia (GO)"), new structType.ptr("D646", "Foglizzo", "Torino (TO)"), new structType.ptr("D649", "Foiano Della Chiana", "Arezzo (AR)"), new structType.ptr("D650", "Foiano Di Val Fortore", "Benevento (BN)"), new structType.ptr("D651", "Folgaria", "Trento (TN)"), new structType.ptr("D652", "Folignano", "Ascoli Piceno (AP)"), new structType.ptr("D653", "Foligno", "Perugia (PG)"), new structType.ptr("D654", "Follina", "Treviso (TV)"), new structType.ptr("D655", "Follo", "La Spezia (SP)"), new structType.ptr("D656", "Follonica", "Grosseto (GR)"), new structType.ptr("D660", "Fombio", "Lodi (LO)"), new structType.ptr("D661", "Fondachelli-Fantina", "Messina (ME)"), new structType.ptr("D662", "Fondi", "Latina (LT)"), new structType.ptr("D663", "Fondo", "Trento (TN)"), new structType.ptr("D665", "Fonni", "Nuoro (NU)"), new structType.ptr("D666", "Fontainemore", "Aosta (AO)"), new structType.ptr("D667", "Fontana Liri", "Frosinone (FR)"), new structType.ptr("D670", "Fontanafredda", "Pordenone (PN)"), new structType.ptr("D671", "Fontanarosa", "Avellino (AV)"), new structType.ptr("D668", "Fontanelice", "Bologna (BO)"), new structType.ptr("D672", "Fontanella", "Bergamo (BG)"), new structType.ptr("D673", "Fontanellato", "Parma (PR)"), new structType.ptr("D674", "Fontanelle", "Treviso (TV)"), new structType.ptr("D675", "Fontaneto D'Agogna", "Novara (NO)"), new structType.ptr("D676", "Fontanetto Po", "Vercelli (VC)"), new structType.ptr("D677", "Fontanigorda", "Genova (GE)"), new structType.ptr("D678", "Fontanile", "Asti (AT)"), new structType.ptr("D679", "Fontaniva", "Padova (PD)"), new structType.ptr("D680", "Fonte", "Treviso (TV)"), new structType.ptr("M309", "Fonte Nuova", "Roma (RM)"), new structType.ptr("D681", "Fontecchio", "L'Aquila (AQ)"), new structType.ptr("D682", "Fontechiari", "Frosinone (FR)"), new structType.ptr("D683", "Fontegreca", "Caserta (CE)"), new structType.ptr("D684", "Fonteno", "Bergamo (BG)"), new structType.ptr("D685", "Fontevivo", "Parma (PR)"), new structType.ptr("D686", "Fonzaso", "Belluno (BL)"), new structType.ptr("D688", "Foppolo", "Bergamo (BG)"), new structType.ptr("D689", "Forano", "Rieti (RI)"), new structType.ptr("D691", "Force", "Ascoli Piceno (AP)"), new structType.ptr("D693", "Forchia", "Benevento (BN)"), new structType.ptr("D694", "Forcola", "Sondrio (SO)"), new structType.ptr("D695", "Fordongianus", "Oristano (OR)"), new structType.ptr("D696", "Forenza", "Potenza (PZ)"), new structType.ptr("D697", "Foresto Sparso", "Bergamo (BG)"), new structType.ptr("D700", "Forgaria Nel Friuli", "Udine (UD)"), new structType.ptr("D701", "Forino", "Avellino (AV)"), new structType.ptr("D702", "Forio", "Napoli (NA)"), new structType.ptr("D704", "Forl\xC3\xAC", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("D703", "Forli' Del Sannio", "Isernia (IS)"), new structType.ptr("D705", "Forlimpopoli", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("D706", "Formazza", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("D707", "Formello", "Roma (RM)"), new structType.ptr("D708", "Formia", "Latina (LT)"), new structType.ptr("D709", "Formicola", "Caserta (CE)"), new structType.ptr("D710", "Formigara", "Cremona (CR)"), new structType.ptr("D711", "Formigine", "Modena (MO)"), new structType.ptr("D712", "Formigliana", "Vercelli (VC)"), new structType.ptr("D713", "Formignana", "Ferrara (FE)"), new structType.ptr("D714", "Fornace", "Trento (TN)"), new structType.ptr("D715", "Fornelli", "Isernia (IS)"), new structType.ptr("D718", "Forni Avoltri", "Udine (UD)"), new structType.ptr("D719", "Forni Di Sopra", "Udine (UD)"), new structType.ptr("D720", "Forni Di Sotto", "Udine (UD)"), new structType.ptr("D725", "Forno Canavese", "Torino (TO)"), new structType.ptr("D728", "Fornovo Di Taro", "Parma (PR)"), new structType.ptr("D727", "Fornovo San Giovanni", "Bergamo (BG)"), new structType.ptr("D730", "Forte Dei Marmi", "Lucca (LU)"), new structType.ptr("D731", "Fortezza .Franzensfeste.", "Bolzano (BZ)"), new structType.ptr("D732", "Fortunago", "Pavia (PV)"), new structType.ptr("D733", "Forza D'Agr\xC3\xB2", "Messina (ME)"), new structType.ptr("D734", "Fosciandora", "Lucca (LU)"), new structType.ptr("D735", "Fosdinovo", "Massa-Carrara (MS)"), new structType.ptr("D736", "Fossa", "L'Aquila (AQ)"), new structType.ptr("D738", "Fossacesia", "Chieti (CH)"), new structType.ptr("D740", "Fossalta Di Piave", "Venezia (VE)"), new structType.ptr("D741", "Fossalta Di Portogruaro", "Venezia (VE)"), new structType.ptr("D737", "Fossalto", "Campobasso (CB)"), new structType.ptr("D742", "Fossano", "Cuneo (CN)"), new structType.ptr("D745", "Fossato Di Vico", "Perugia (PG)"), new structType.ptr("D744", "Fossato Serralta", "Catanzaro (CZ)"), new structType.ptr("D748", "Foss\xC3\xB2", "Venezia (VE)"), new structType.ptr("D749", "Fossombrone", "Pesaro e Urbino (PU)"), new structType.ptr("D750", "Foza", "Vicenza (VI)"), new structType.ptr("D751", "Frabosa Soprana", "Cuneo (CN)"), new structType.ptr("D752", "Frabosa Sottana", "Cuneo (CN)"), new structType.ptr("D559", "Fraconalto", "Alessandria (AL)"), new structType.ptr("D754", "Fragagnano", "Taranto (TA)"), new structType.ptr("D755", "Fragneto L'Abate", "Benevento (BN)"), new structType.ptr("D756", "Fragneto Monforte", "Benevento (BN)"), new structType.ptr("D757", "Fraine", "Chieti (CH)"), new structType.ptr("D758", "Framura", "La Spezia (SP)"), new structType.ptr("D763", "Francavilla Al Mare", "Chieti (CH)"), new structType.ptr("D762", "Francavilla Angitola", "Vibo Valentia (VV)"), new structType.ptr("D759", "Francavilla Bisio", "Alessandria (AL)"), new structType.ptr("D760", "Francavilla D'Ete", "Fermo (FM)"), new structType.ptr("D765", "Francavilla Di Sicilia", "Messina (ME)"), new structType.ptr("D761", "Francavilla Fontana", "Brindisi (BR)"), new structType.ptr("D766", "Francavilla In Sinni", "Potenza (PZ)"), new structType.ptr("D764", "Francavilla Marittima", "Cosenza (CS)"), new structType.ptr("D767", "Francica", "Vibo Valentia (VV)"), new structType.ptr("D768", "Francofonte", "Siracusa (SR)"), new structType.ptr("D769", "Francolise", "Caserta (CE)"), new structType.ptr("D770", "Frascaro", "Alessandria (AL)"), new structType.ptr("D771", "Frascarolo", "Pavia (PV)"), new structType.ptr("D773", "Frascati", "Roma (RM)"), new structType.ptr("D774", "Frascineto", "Cosenza (CS)"), new structType.ptr("D775", "Frassilongo", "Trento (TN)"), new structType.ptr("D776", "Frassinelle Polesine", "Rovigo (RO)"), new structType.ptr("D777", "Frassinello Monferrato", "Alessandria (AL)"), new structType.ptr("D780", "Frassineto Po", "Alessandria (AL)"), new structType.ptr("D781", "Frassinetto", "Torino (TO)"), new structType.ptr("D782", "Frassino", "Cuneo (CN)"), new structType.ptr("D783", "Frassinoro", "Modena (MO)"), new structType.ptr("D785", "Frasso Sabino", "Rieti (RI)"), new structType.ptr("D784", "Frasso Telesino", "Benevento (BN)"), new structType.ptr("D788", "Fratta Polesine", "Rovigo (RO)"), new structType.ptr("D787", "Fratta Todina", "Perugia (PG)"), new structType.ptr("D789", "Frattamaggiore", "Napoli (NA)"), new structType.ptr("D790", "Frattaminore", "Napoli (NA)"), new structType.ptr("D791", "Fratte Rosa", "Pesaro e Urbino (PU)"), new structType.ptr("D793", "Frazzan\xC3\xB2", "Messina (ME)"), new structType.ptr("D794", "Fregona", "Treviso (TV)"), new structType.ptr("D796", "Fresagrandinaria", "Chieti (CH)"), new structType.ptr("D797", "Fresonara", "Alessandria (AL)"), new structType.ptr("D798", "Frigento", "Avellino (AV)"), new structType.ptr("D799", "Frignano", "Caserta (CE)"), new structType.ptr("D802", "Frinco", "Asti (AT)"), new structType.ptr("D803", "Frisa", "Chieti (CH)"), new structType.ptr("D804", "Frisanco", "Pordenone (PN)"), new structType.ptr("D805", "Front", "Torino (TO)"), new structType.ptr("D807", "Frontino", "Pesaro e Urbino (PU)"), new structType.ptr("D808", "Frontone", "Pesaro e Urbino (PU)"), new structType.ptr("D810", "Frosinone", "Frosinone (FR)"), new structType.ptr("D811", "Frosolone", "Isernia (IS)"), new structType.ptr("D812", "Frossasco", "Torino (TO)"), new structType.ptr("D813", "Frugarolo", "Alessandria (AL)"), new structType.ptr("D814", "Fubine", "Alessandria (AL)"), new structType.ptr("D815", "Fucecchio", "Firenze (FI)"), new structType.ptr("D817", "Fuipiano Valle Imagna", "Bergamo (BG)"), new structType.ptr("D818", "Fumane", "Verona (VR)"), new structType.ptr("D819", "Fumone", "Frosinone (FR)"), new structType.ptr("D821", "Funes .Villnoess.", "Bolzano (BZ)"), new structType.ptr("D823", "Furci", "Chieti (CH)"), new structType.ptr("D824", "Furci Siculo", "Messina (ME)"), new structType.ptr("D825", "Furnari", "Messina (ME)"), new structType.ptr("D826", "Furore", "Salerno (SA)"), new structType.ptr("D827", "Furtei", "Medio Campidano (VS)"), new structType.ptr("D828", "Fuscaldo", "Cosenza (CS)"), new structType.ptr("D829", "Fusignano", "Ravenna (RA)"), new structType.ptr("D830", "Fusine", "Sondrio (SO)"), new structType.ptr("D832", "Futani", "Salerno (SA)"), new structType.ptr("D834", "Gabbioneta Binanuova", "Cremona (CR)"), new structType.ptr("D835", "Gabiano", "Alessandria (AL)"), new structType.ptr("D836", "Gabicce Mare", "Pesaro e Urbino (PU)"), new structType.ptr("D839", "Gaby", "Aosta (AO)"), new structType.ptr("D841", "Gadesco Pieve Delmona", "Cremona (CR)"), new structType.ptr("D842", "Gadoni", "Nuoro (NU)"), new structType.ptr("D843", "Gaeta", "Latina (LT)"), new structType.ptr("D844", "Gaggi", "Messina (ME)"), new structType.ptr("D845", "Gaggiano", "Milano (MI)"), new structType.ptr("D847", "Gaggio Montano", "Bologna (BO)"), new structType.ptr("D848", "Gaglianico", "Biella (BI)"), new structType.ptr("D850", "Gagliano Aterno", "L'Aquila (AQ)"), new structType.ptr("D849", "Gagliano Castelferrato", "Enna (EN)"), new structType.ptr("D851", "Gagliano Del Capo", "Lecce (LE)"), new structType.ptr("D852", "Gagliato", "Catanzaro (CZ)"), new structType.ptr("D853", "Gagliole", "Macerata (MC)"), new structType.ptr("D854", "Gaiarine", "Treviso (TV)"), new structType.ptr("D855", "Gaiba", "Rovigo (RO)"), new structType.ptr("D856", "Gaiola", "Cuneo (CN)"), new structType.ptr("D858", "Gaiole In Chianti", "Siena (SI)"), new structType.ptr("D859", "Gairo", "Ogliastra (OG)"), new structType.ptr("D860", "Gais .Gais.", "Bolzano (BZ)"), new structType.ptr("D861", "Galati Mamertino", "Messina (ME)"), new structType.ptr("D862", "Galatina", "Lecce (LE)"), new structType.ptr("D863", "Galatone", "Lecce (LE)"), new structType.ptr("D864", "Galatro", "Reggio Calabria (RC)"), new structType.ptr("D865", "Galbiate", "Lecco (LC)"), new structType.ptr("D867", "Galeata", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("D868", "Galgagnano", "Lodi (LO)"), new structType.ptr("D869", "Gallarate", "Varese (VA)"), new structType.ptr("D870", "Gallese", "Viterbo (VT)"), new structType.ptr("D872", "Galliate", "Novara (NO)"), new structType.ptr("D871", "Galliate Lombardo", "Varese (VA)"), new structType.ptr("D873", "Galliavola", "Pavia (PV)"), new structType.ptr("D874", "Gallicano", "Lucca (LU)"), new structType.ptr("D875", "Gallicano Nel Lazio", "Roma (RM)"), new structType.ptr("D876", "Gallicchio", "Potenza (PZ)"), new structType.ptr("D878", "Galliera", "Bologna (BO)"), new structType.ptr("D879", "Galliera Veneta", "Padova (PD)"), new structType.ptr("D881", "Gallinaro", "Frosinone (FR)"), new structType.ptr("D882", "Gallio", "Vicenza (VI)"), new structType.ptr("D883", "Gallipoli", "Lecce (LE)"), new structType.ptr("D884", "Gallo Matese", "Caserta (CE)"), new structType.ptr("D885", "Gallodoro", "Messina (ME)"), new structType.ptr("D886", "Galluccio", "Caserta (CE)"), new structType.ptr("D888", "Galtell\xC3\xAC", "Nuoro (NU)"), new structType.ptr("D889", "Galzignano Terme", "Padova (PD)"), new structType.ptr("D890", "Gamalero", "Alessandria (AL)"), new structType.ptr("D891", "Gambara", "Brescia (BS)"), new structType.ptr("D892", "Gambarana", "Pavia (PV)"), new structType.ptr("D894", "Gambasca", "Cuneo (CN)"), new structType.ptr("D895", "Gambassi Terme", "Firenze (FI)"), new structType.ptr("D896", "Gambatesa", "Campobasso (CB)"), new structType.ptr("D897", "Gambellara", "Vicenza (VI)"), new structType.ptr("D898", "Gamberale", "Chieti (CH)"), new structType.ptr("D899", "Gambettola", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("D901", "Gambol\xC3\xB2", "Pavia (PV)"), new structType.ptr("D902", "Gambugliano", "Vicenza (VI)"), new structType.ptr("D903", "Gandellino", "Bergamo (BG)"), new structType.ptr("D905", "Gandino", "Bergamo (BG)"), new structType.ptr("D906", "Gandosso", "Bergamo (BG)"), new structType.ptr("D907", "Gangi", "Palermo (PA)"), new structType.ptr("D909", "Garaguso", "Matera (MT)"), new structType.ptr("D910", "Garbagna", "Alessandria (AL)"), new structType.ptr("D911", "Garbagna Novarese", "Novara (NO)"), new structType.ptr("D912", "Garbagnate Milanese", "Milano (MI)"), new structType.ptr("D913", "Garbagnate Monastero", "Lecco (LC)"), new structType.ptr("D915", "Garda", "Verona (VR)"), new structType.ptr("D917", "Gardone Riviera", "Brescia (BS)"), new structType.ptr("D918", "Gardone Val Trompia", "Brescia (BS)"), new structType.ptr("D920", "Garessio", "Cuneo (CN)"), new structType.ptr("D921", "Gargallo", "Novara (NO)"), new structType.ptr("D923", "Gargazzone .Gargazon.", "Bolzano (BZ)"), new structType.ptr("D924", "Gargnano", "Brescia (BS)"), new structType.ptr("D925", "Garlasco", "Pavia (PV)"), new structType.ptr("D926", "Garlate", "Lecco (LC)"), new structType.ptr("D927", "Garlenda", "Savona (SV)"), new structType.ptr("D928", "Garniga Terme", "Trento (TN)"), new structType.ptr("D930", "Garzeno", "Como (CO)"), new structType.ptr("D931", "Garzigliana", "Torino (TO)"), new structType.ptr("D932", "Gasperina", "Catanzaro (CZ)"), new structType.ptr("D933", "Gassino Torinese", "Torino (TO)"), new structType.ptr("D934", "Gattatico", "Reggio Emilia (RE)"), new structType.ptr("D935", "Gatteo", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("D937", "Gattico", "Novara (NO)"), new structType.ptr("D938", "Gattinara", "Vercelli (VC)"), new structType.ptr("D940", "Gavardo", "Brescia (BS)"), new structType.ptr("D941", "Gavazzana", "Alessandria (AL)"), new structType.ptr("D942", "Gavello", "Rovigo (RO)"), new structType.ptr("D943", "Gaverina Terme", "Bergamo (BG)"), new structType.ptr("D944", "Gavi", "Alessandria (AL)"), new structType.ptr("D945", "Gavignano", "Roma (RM)"), new structType.ptr("D946", "Gavirate", "Varese (VA)"), new structType.ptr("D947", "Gavoi", "Nuoro (NU)"), new structType.ptr("D948", "Gavorrano", "Grosseto (GR)"), new structType.ptr("D949", "Gazoldo Degli Ippoliti", "Mantova (MN)"), new structType.ptr("D951", "Gazzada Schianno", "Varese (VA)"), new structType.ptr("D952", "Gazzaniga", "Bergamo (BG)"), new structType.ptr("D956", "Gazzo", "Padova (PD)"), new structType.ptr("D957", "Gazzo Veronese", "Verona (VR)"), new structType.ptr("D958", "Gazzola", "Piacenza (PC)"), new structType.ptr("D959", "Gazzuolo", "Mantova (MN)"), new structType.ptr("D960", "Gela", "Caltanissetta (CL)"), new structType.ptr("D961", "Gemmano", "Rimini (RN)"), new structType.ptr("D962", "Gemona Del Friuli", "Udine (UD)"), new structType.ptr("D963", "Gemonio", "Varese (VA)"), new structType.ptr("D964", "Genazzano", "Roma (RM)"), new structType.ptr("D965", "Genga", "Ancona (AN)"), new structType.ptr("D966", "Genivolta", "Cremona (CR)"), new structType.ptr("D967", "Genola", "Cuneo (CN)"), new structType.ptr("D968", "Genoni", "Oristano (OR)"), new structType.ptr("D969", "Genova", "Genova (GE)"), new structType.ptr("D970", "Genuri", "Medio Campidano (VS)"), new structType.ptr("D971", "Genzano Di Lucania", "Potenza (PZ)"), new structType.ptr("D972", "Genzano Di Roma", "Roma (RM)"), new structType.ptr("D974", "Gera Lario", "Como (CO)"), new structType.ptr("D975", "Gerace", "Reggio Calabria (RC)"), new structType.ptr("D977", "Geraci Siculo", "Palermo (PA)"), new structType.ptr("D978", "Gerano", "Roma (RM)"), new structType.ptr("D980", "Gerenzago", "Pavia (PV)"), new structType.ptr("D981", "Gerenzano", "Varese (VA)"), new structType.ptr("D982", "Gergei", "Cagliari (CA)"), new structType.ptr("D983", "Germagnano", "Torino (TO)"), new structType.ptr("D984", "Germagno", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("D987", "Germignaga", "Varese (VA)"), new structType.ptr("D988", "Gerocarne", "Vibo Valentia (VV)"), new structType.ptr("D990", "Gerola Alta", "Sondrio (SO)"), new structType.ptr("D993", "Gerre De' Caprioli", "Cremona (CR)"), new structType.ptr("D994", "Gesico", "Cagliari (CA)"), new structType.ptr("D995", "Gessate", "Milano (MI)"), new structType.ptr("D996", "Gessopalena", "Chieti (CH)"), new structType.ptr("D997", "Gesturi", "Medio Campidano (VS)"), new structType.ptr("D998", "Gesualdo", "Avellino (AV)"), new structType.ptr("D999", "Ghedi", "Brescia (BS)"), new structType.ptr("E001", "Ghemme", "Novara (NO)"), new structType.ptr("E003", "Ghiffa", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("E004", "Ghilarza", "Oristano (OR)"), new structType.ptr("E006", "Ghisalba", "Bergamo (BG)"), new structType.ptr("E007", "Ghislarengo", "Vercelli (VC)"), new structType.ptr("E008", "Giacciano Con Baruchella", "Rovigo (RO)"), new structType.ptr("E009", "Giaglione", "Torino (TO)"), new structType.ptr("E010", "Gianico", "Brescia (BS)"), new structType.ptr("E012", "Giano Dell'Umbria", "Perugia (PG)"), new structType.ptr("E011", "Giano Vetusto", "Caserta (CE)"), new structType.ptr("E013", "Giardinello", "Palermo (PA)"), new structType.ptr("E014", "Giardini-Naxos", "Messina (ME)"), new structType.ptr("E015", "Giarole", "Alessandria (AL)"), new structType.ptr("E016", "Giarratana", "Ragusa (RG)"), new structType.ptr("E017", "Giarre", "Catania (CT)"), new structType.ptr("E019", "Giave", "Sassari (SS)"), new structType.ptr("E020", "Giaveno", "Torino (TO)"), new structType.ptr("E021", "Giavera Del Montello", "Treviso (TV)"), new structType.ptr("E022", "Giba", "Carbonia-Iglesias (CI)"), new structType.ptr("E023", "Gibellina", "Trapani (TP)"), new structType.ptr("E024", "Gifflenga", "Biella (BI)"), new structType.ptr("E025", "Giffone", "Reggio Calabria (RC)"), new structType.ptr("E026", "Giffoni Sei Casali", "Salerno (SA)"), new structType.ptr("E027", "Giffoni Valle Piana", "Salerno (SA)"), new structType.ptr("E028", "Gignese", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("E029", "Gignod", "Aosta (AO)"), new structType.ptr("E030", "Gildone", "Campobasso (CB)"), new structType.ptr("E031", "Gimigliano", "Catanzaro (CZ)"), new structType.ptr("E033", "Ginestra", "Potenza (PZ)"), new structType.ptr("E034", "Ginestra Degli Schiavoni", "Benevento (BN)"), new structType.ptr("E036", "Ginosa", "Taranto (TA)"), new structType.ptr("E037", "Gioi", "Salerno (SA)"), new structType.ptr("E040", "Gioia Dei Marsi", "L'Aquila (AQ)"), new structType.ptr("E038", "Gioia Del Colle", "Bari (BA)"), new structType.ptr("E039", "Gioia Sannitica", "Caserta (CE)"), new structType.ptr("E041", "Gioia Tauro", "Reggio Calabria (RC)"), new structType.ptr("E044", "Gioiosa Ionica", "Reggio Calabria (RC)"), new structType.ptr("E043", "Gioiosa Marea", "Messina (ME)"), new structType.ptr("E045", "Giove", "Terni (TR)"), new structType.ptr("E047", "Giovinazzo", "Bari (BA)"), new structType.ptr("E048", "Giovo", "Trento (TN)"), new structType.ptr("E049", "Girasole", "Ogliastra (OG)"), new structType.ptr("E050", "Girifalco", "Catanzaro (CZ)"), new structType.ptr("E052", "Gissi", "Chieti (CH)"), new structType.ptr("E053", "Giuggianello", "Lecce (LE)"), new structType.ptr("E054", "Giugliano In Campania", "Napoli (NA)"), new structType.ptr("E055", "Giuliana", "Palermo (PA)"), new structType.ptr("E057", "Giuliano Di Roma", "Frosinone (FR)"), new structType.ptr("E056", "Giuliano Teatino", "Chieti (CH)"), new structType.ptr("E058", "Giulianova", "Teramo (TE)"), new structType.ptr("E060", "Giungano", "Salerno (SA)"), new structType.ptr("E061", "Giurdignano", "Lecce (LE)"), new structType.ptr("E062", "Giussago", "Pavia (PV)"), new structType.ptr("E063", "Giussano", "Monza e della Brianza (MB)"), new structType.ptr("E064", "Giustenice", "Savona (SV)"), new structType.ptr("E065", "Giustino", "Trento (TN)"), new structType.ptr("E066", "Giusvalla", "Savona (SV)"), new structType.ptr("E067", "Givoletto", "Torino (TO)"), new structType.ptr("E068", "Gizzeria", "Catanzaro (CZ)"), new structType.ptr("E069", "Glorenza .Glurns.", "Bolzano (BZ)"), new structType.ptr("E071", "Godega Di Sant'Urbano", "Treviso (TV)"), new structType.ptr("E072", "Godiasco", "Pavia (PV)"), new structType.ptr("E074", "Godrano", "Palermo (PA)"), new structType.ptr("E078", "Goito", "Mantova (MN)"), new structType.ptr("E079", "Golasecca", "Varese (VA)"), new structType.ptr("E081", "Golferenzo", "Pavia (PV)"), new structType.ptr("M274", "Golfo Aranci", "Olbia-Tempio (OT)"), new structType.ptr("E082", "Gombito", "Cremona (CR)"), new structType.ptr("E083", "Gonars", "Udine (UD)"), new structType.ptr("E084", "Goni", "Cagliari (CA)"), new structType.ptr("E086", "Gonnesa", "Carbonia-Iglesias (CI)"), new structType.ptr("E087", "Gonnoscodina", "Oristano (OR)"), new structType.ptr("E085", "Gonnosfanadiga", "Medio Campidano (VS)"), new structType.ptr("D585", "Gonnosn\xC3\xB2", "Oristano (OR)"), new structType.ptr("E088", "Gonnostramatza", "Oristano (OR)"), new structType.ptr("E089", "Gonzaga", "Mantova (MN)"), new structType.ptr("E090", "Gordona", "Sondrio (SO)"), new structType.ptr("E091", "Gorga", "Roma (RM)"), new structType.ptr("E092", "Gorgo Al Monticano", "Treviso (TV)"), new structType.ptr("E093", "Gorgoglione", "Matera (MT)"), new structType.ptr("E094", "Gorgonzola", "Milano (MI)"), new structType.ptr("E096", "Goriano Sicoli", "L'Aquila (AQ)"), new structType.ptr("E098", "Gorizia", "Gorizia (GO)"), new structType.ptr("E101", "Gorla Maggiore", "Varese (VA)"), new structType.ptr("E102", "Gorla Minore", "Varese (VA)"), new structType.ptr("E100", "Gorlago", "Bergamo (BG)"), new structType.ptr("E103", "Gorle", "Bergamo (BG)"), new structType.ptr("E104", "Gornate-Olona", "Varese (VA)"), new structType.ptr("E106", "Gorno", "Bergamo (BG)"), new structType.ptr("E107", "Goro", "Ferrara (FE)"), new structType.ptr("E109", "Gorreto", "Genova (GE)"), new structType.ptr("E111", "Gorzegno", "Cuneo (CN)"), new structType.ptr("E113", "Gosaldo", "Belluno (BL)"), new structType.ptr("E114", "Gossolengo", "Piacenza (PC)"), new structType.ptr("E115", "Gottasecca", "Cuneo (CN)"), new structType.ptr("E116", "Gottolengo", "Brescia (BS)"), new structType.ptr("E118", "Govone", "Cuneo (CN)"), new structType.ptr("E120", "Gozzano", "Novara (NO)"), new structType.ptr("E122", "Gradara", "Pesaro e Urbino (PU)"), new structType.ptr("E124", "Gradisca D'Isonzo", "Gorizia (GO)"), new structType.ptr("E125", "Grado", "Gorizia (GO)"), new structType.ptr("E126", "Gradoli", "Viterbo (VT)"), new structType.ptr("E127", "Graffignana", "Lodi (LO)"), new structType.ptr("E128", "Graffignano", "Viterbo (VT)"), new structType.ptr("E130", "Graglia", "Biella (BI)"), new structType.ptr("E131", "Gragnano", "Napoli (NA)"), new structType.ptr("E132", "Gragnano Trebbiense", "Piacenza (PC)"), new structType.ptr("E133", "Grammichele", "Catania (CT)"), new structType.ptr("E134", "Grana", "Asti (AT)"), new structType.ptr("E136", "Granarolo Dell'Emilia", "Bologna (BO)"), new structType.ptr("E138", "Grancona", "Vicenza (VI)"), new structType.ptr("E139", "Grandate", "Como (CO)"), new structType.ptr("E141", "Grandola Ed Uniti", "Como (CO)"), new structType.ptr("E142", "Graniti", "Messina (ME)"), new structType.ptr("E143", "Granozzo Con Monticello", "Novara (NO)"), new structType.ptr("E144", "Grantola", "Varese (VA)"), new structType.ptr("E145", "Grantorto", "Padova (PD)"), new structType.ptr("E146", "Granze", "Padova (PD)"), new structType.ptr("E147", "Grassano", "Matera (MT)"), new structType.ptr("E148", "Grassobbio", "Bergamo (BG)"), new structType.ptr("E149", "Gratteri", "Palermo (PA)"), new structType.ptr("M315", "Gravedona Ed Uniti", "Como (CO)"), new structType.ptr("E152", "Gravellona Lomellina", "Pavia (PV)"), new structType.ptr("E153", "Gravellona Toce", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("E154", "Gravere", "Torino (TO)"), new structType.ptr("E156", "Gravina Di Catania", "Catania (CT)"), new structType.ptr("E155", "Gravina In Puglia", "Bari (BA)"), new structType.ptr("E158", "Grazzanise", "Caserta (CE)"), new structType.ptr("E159", "Grazzano Badoglio", "Asti (AT)"), new structType.ptr("E160", "Greccio", "Rieti (RI)"), new structType.ptr("E161", "Greci", "Avellino (AV)"), new structType.ptr("E163", "Greggio", "Vercelli (VC)"), new structType.ptr("E164", "Gremiasco", "Alessandria (AL)"), new structType.ptr("E165", "Gressan", "Aosta (AO)"), new structType.ptr("E167", "Gressoney-La-Trinit\xC3\xA8", "Aosta (AO)"), new structType.ptr("E168", "Gressoney-Saint-Jean", "Aosta (AO)"), new structType.ptr("E169", "Greve In Chianti", "Firenze (FI)"), new structType.ptr("E170", "Grezzago", "Milano (MI)"), new structType.ptr("E171", "Grezzana", "Verona (VR)"), new structType.ptr("E172", "Griante", "Como (CO)"), new structType.ptr("E173", "Gricignano Di Aversa", "Caserta (CE)"), new structType.ptr("E177", "Grignasco", "Novara (NO)"), new structType.ptr("E178", "Grigno", "Trento (TN)"), new structType.ptr("E179", "Grimacco", "Udine (UD)"), new structType.ptr("E180", "Grimaldi", "Cosenza (CS)"), new structType.ptr("E182", "Grinzane Cavour", "Cuneo (CN)"), new structType.ptr("E184", "Grisignano Di Zocco", "Vicenza (VI)"), new structType.ptr("E185", "Grisolia", "Cosenza (CS)"), new structType.ptr("E187", "Grizzana Morandi", "Bologna (BO)"), new structType.ptr("E188", "Grognardo", "Alessandria (AL)"), new structType.ptr("E189", "Gromo", "Bergamo (BG)"), new structType.ptr("E191", "Grondona", "Alessandria (AL)"), new structType.ptr("E192", "Grone", "Bergamo (BG)"), new structType.ptr("E193", "Grontardo", "Cremona (CR)"), new structType.ptr("E195", "Gropello Cairoli", "Pavia (PV)"), new structType.ptr("E196", "Gropparello", "Piacenza (PC)"), new structType.ptr("E199", "Groscavallo", "Torino (TO)"), new structType.ptr("E200", "Grosio", "Sondrio (SO)"), new structType.ptr("E201", "Grosotto", "Sondrio (SO)"), new structType.ptr("E202", "Grosseto", "Grosseto (GR)"), new structType.ptr("E203", "Grosso", "Torino (TO)"), new structType.ptr("E204", "Grottaferrata", "Roma (RM)"), new structType.ptr("E205", "Grottaglie", "Taranto (TA)"), new structType.ptr("E206", "Grottaminarda", "Avellino (AV)"), new structType.ptr("E207", "Grottammare", "Ascoli Piceno (AP)"), new structType.ptr("E208", "Grottazzolina", "Fermo (FM)"), new structType.ptr("E209", "Grotte", "Agrigento (AG)"), new structType.ptr("E210", "Grotte Di Castro", "Viterbo (VT)"), new structType.ptr("E212", "Grotteria", "Reggio Calabria (RC)"), new structType.ptr("E213", "Grottole", "Matera (MT)"), new structType.ptr("E214", "Grottolella", "Avellino (AV)"), new structType.ptr("E215", "Gruaro", "Venezia (VE)"), new structType.ptr("E216", "Grugliasco", "Torino (TO)"), new structType.ptr("E217", "Grumello Cremonese Ed Uniti", "Cremona (CR)"), new structType.ptr("E219", "Grumello Del Monte", "Bergamo (BG)"), new structType.ptr("E221", "Grumento Nova", "Potenza (PZ)"), new structType.ptr("E223", "Grumo Appula", "Bari (BA)"), new structType.ptr("E224", "Grumo Nevano", "Napoli (NA)"), new structType.ptr("E226", "Grumolo Delle Abbadesse", "Vicenza (VI)"), new structType.ptr("E227", "Guagnano", "Lecce (LE)"), new structType.ptr("E228", "Gualdo", "Macerata (MC)"), new structType.ptr("E229", "Gualdo Cattaneo", "Perugia (PG)"), new structType.ptr("E230", "Gualdo Tadino", "Perugia (PG)"), new structType.ptr("E232", "Gualtieri", "Reggio Emilia (RE)"), new structType.ptr("E233", "Gualtieri Sicamin\xC3\xB2", "Messina (ME)"), new structType.ptr("E234", "Guamaggiore", "Cagliari (CA)"), new structType.ptr("E235", "Guanzate", "Como (CO)"), new structType.ptr("E236", "Guarcino", "Frosinone (FR)"), new structType.ptr("E240", "Guarda Veneta", "Rovigo (RO)"), new structType.ptr("E237", "Guardabosone", "Vercelli (VC)"), new structType.ptr("E238", "Guardamiglio", "Lodi (LO)"), new structType.ptr("E239", "Guardavalle", "Catanzaro (CZ)"), new structType.ptr("E241", "Guardea", "Terni (TR)"), new structType.ptr("E245", "Guardia Lombardi", "Avellino (AV)"), new structType.ptr("E246", "Guardia Perticara", "Potenza (PZ)"), new structType.ptr("E242", "Guardia Piemontese", "Cosenza (CS)"), new structType.ptr("E249", "Guardia Sanframondi", "Benevento (BN)"), new structType.ptr("E243", "Guardiagrele", "Chieti (CH)"), new structType.ptr("E244", "Guardialfiera", "Campobasso (CB)"), new structType.ptr("E248", "Guardiaregia", "Campobasso (CB)"), new structType.ptr("E250", "Guardistallo", "Pisa (PI)"), new structType.ptr("E251", "Guarene", "Cuneo (CN)"), new structType.ptr("E252", "Guasila", "Cagliari (CA)"), new structType.ptr("E253", "Guastalla", "Reggio Emilia (RE)"), new structType.ptr("E255", "Guazzora", "Alessandria (AL)"), new structType.ptr("E256", "Gubbio", "Perugia (PG)"), new structType.ptr("E258", "Gudo Visconti", "Milano (MI)"), new structType.ptr("E259", "Guglionesi", "Campobasso (CB)"), new structType.ptr("E261", "Guidizzolo", "Mantova (MN)"), new structType.ptr("E263", "Guidonia Montecelio", "Roma (RM)"), new structType.ptr("E264", "Guiglia", "Modena (MO)"), new structType.ptr("E266", "Guilmi", "Chieti (CH)"), new structType.ptr("E269", "Gurro", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("E270", "Guspini", "Medio Campidano (VS)"), new structType.ptr("E271", "Gussago", "Brescia (BS)"), new structType.ptr("E272", "Gussola", "Cremona (CR)"), new structType.ptr("E273", "Hone", "Aosta (AO)"), new structType.ptr("E280", "Idro", "Brescia (BS)"), new structType.ptr("E281", "Iglesias", "Carbonia-Iglesias (CI)"), new structType.ptr("E282", "Igliano", "Cuneo (CN)"), new structType.ptr("E283", "Ilbono", "Ogliastra (OG)"), new structType.ptr("E284", "Illasi", "Verona (VR)"), new structType.ptr("E285", "Illorai", "Sassari (SS)"), new structType.ptr("E287", "Imbersago", "Lecco (LC)"), new structType.ptr("E288", "Imer", "Trento (TN)"), new structType.ptr("E289", "Imola", "Bologna (BO)"), new structType.ptr("E290", "Imperia", "Imperia (IM)"), new structType.ptr("E291", "Impruneta", "Firenze (FI)"), new structType.ptr("E292", "Inarzo", "Varese (VA)"), new structType.ptr("E295", "Incisa Scapaccino", "Asti (AT)"), new structType.ptr("E297", "Incudine", "Brescia (BS)"), new structType.ptr("E299", "Induno Olona", "Varese (VA)"), new structType.ptr("E301", "Ingria", "Torino (TO)"), new structType.ptr("E304", "Intragna", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("E305", "Introbio", "Lecco (LC)"), new structType.ptr("E306", "Introd", "Aosta (AO)"), new structType.ptr("E307", "Introdacqua", "L'Aquila (AQ)"), new structType.ptr("E308", "Introzzo", "Lecco (LC)"), new structType.ptr("E309", "Inverigo", "Como (CO)"), new structType.ptr("E310", "Inverno E Monteleone", "Pavia (PV)"), new structType.ptr("E311", "Inverso Pinasca", "Torino (TO)"), new structType.ptr("E313", "Inveruno", "Milano (MI)"), new structType.ptr("E314", "Invorio", "Novara (NO)"), new structType.ptr("E317", "Inzago", "Milano (MI)"), new structType.ptr("E321", "Ionadi", "Vibo Valentia (VV)"), new structType.ptr("E323", "Irgoli", "Nuoro (NU)"), new structType.ptr("E325", "Irma", "Brescia (BS)"), new structType.ptr("E326", "Irsina", "Matera (MT)"), new structType.ptr("E327", "Isasca", "Cuneo (CN)"), new structType.ptr("E328", "Isca Sullo Ionio", "Catanzaro (CZ)"), new structType.ptr("E329", "Ischia", "Napoli (NA)"), new structType.ptr("E330", "Ischia Di Castro", "Viterbo (VT)"), new structType.ptr("E332", "Ischitella", "Foggia (FG)"), new structType.ptr("E333", "Iseo", "Brescia (BS)"), new structType.ptr("E334", "Isera", "Trento (TN)"), new structType.ptr("E335", "Isernia", "Isernia (IS)"), new structType.ptr("E336", "Isili", "Cagliari (CA)"), new structType.ptr("E337", "Isnello", "Palermo (PA)"), new structType.ptr("E338", "Isola D'Asti", "Asti (AT)"), new structType.ptr("E341", "Isola Del Cantone", "Genova (GE)"), new structType.ptr("E348", "Isola Del Giglio", "Grosseto (GR)"), new structType.ptr("E343", "Isola Del Gran Sasso D'Italia", "Teramo (TE)"), new structType.ptr("E340", "Isola Del Liri", "Frosinone (FR)"), new structType.ptr("E351", "Isola Del Piano", "Pesaro e Urbino (PU)"), new structType.ptr("E349", "Isola Della Scala", "Verona (VR)"), new structType.ptr("E350", "Isola Delle Femmine", "Palermo (PA)"), new structType.ptr("E339", "Isola Di Capo Rizzuto", "Crotone (KR)"), new structType.ptr("E353", "Isola Di Fondra", "Bergamo (BG)"), new structType.ptr("E356", "Isola Dovarese", "Cremona (CR)"), new structType.ptr("E358", "Isola Rizza", "Verona (VR)"), new structType.ptr("E360", "Isola Sant'Antonio", "Alessandria (AL)"), new structType.ptr("E354", "Isola Vicentina", "Vicenza (VI)"), new structType.ptr("E345", "Isolabella", "Torino (TO)"), new structType.ptr("E346", "Isolabona", "Imperia (IM)"), new structType.ptr("E363", "Isole Tremiti", "Foggia (FG)"), new structType.ptr("E364", "Isorella", "Brescia (BS)"), new structType.ptr("E365", "Ispani", "Salerno (SA)"), new structType.ptr("E366", "Ispica", "Ragusa (RG)"), new structType.ptr("E367", "Ispra", "Varese (VA)"), new structType.ptr("E368", "Issiglio", "Torino (TO)"), new structType.ptr("E369", "Issime", "Aosta (AO)"), new structType.ptr("E370", "Isso", "Bergamo (BG)"), new structType.ptr("E371", "Issogne", "Aosta (AO)"), new structType.ptr("E373", "Istrana", "Treviso (TV)"), new structType.ptr("E374", "Itala", "Messina (ME)"), new structType.ptr("E375", "Itri", "Latina (LT)"), new structType.ptr("E376", "Ittireddu", "Sassari (SS)"), new structType.ptr("E377", "Ittiri", "Sassari (SS)"), new structType.ptr("E379", "Ivrea", "Torino (TO)"), new structType.ptr("E380", "Izano", "Cremona (CR)"), new structType.ptr("E274", "Jacurso", "Catanzaro (CZ)"), new structType.ptr("E381", "Jelsi", "Campobasso (CB)"), new structType.ptr("E382", "Jenne", "Roma (RM)"), new structType.ptr("E386", "Jerago Con Orago", "Varese (VA)"), new structType.ptr("E387", "Jerzu", "Ogliastra (OG)"), new structType.ptr("E388", "Jesi", "Ancona (AN)"), new structType.ptr("C388", "Jesolo", "Venezia (VE)"), new structType.ptr("E320", "Jolanda Di Savoia", "Ferrara (FE)"), new structType.ptr("E389", "Joppolo", "Vibo Valentia (VV)"), new structType.ptr("E390", "Joppolo Giancaxio", "Agrigento (AG)"), new structType.ptr("E391", "Jovencan", "Aosta (AO)"), new structType.ptr("E394", "La Cassa", "Torino (TO)"), new structType.ptr("E423", "La Loggia", "Torino (TO)"), new structType.ptr("E425", "La Maddalena", "Olbia-Tempio (OT)"), new structType.ptr("A308", "La Magdeleine", "Aosta (AO)"), new structType.ptr("E430", "La Morra", "Cuneo (CN)"), new structType.ptr("E458", "La Salle", "Aosta (AO)"), new structType.ptr("E463", "La Spezia", "La Spezia (SP)"), new structType.ptr("E470", "La Thuile", "Aosta (AO)"), new structType.ptr("E491", "La Valle .Wengen.", "Bolzano (BZ)"), new structType.ptr("E490", "La Valle Agordina", "Belluno (BL)"), new structType.ptr("M348", "La Valletta Brianza", "Lecco (LC)"), new structType.ptr("E392", "Labico", "Roma (RM)"), new structType.ptr("E393", "Labro", "Rieti (RI)"), new structType.ptr("E395", "Lacchiarella", "Milano (MI)"), new structType.ptr("E396", "Lacco Ameno", "Napoli (NA)"), new structType.ptr("E397", "Lacedonia", "Avellino (AV)"), new structType.ptr("E398", "Laces .Latsch.", "Bolzano (BZ)"), new structType.ptr("E400", "Laconi", "Oristano (OR)"), new structType.ptr("M212", "Ladispoli", "Roma (RM)"), new structType.ptr("E401", "Laerru", "Sassari (SS)"), new structType.ptr("E402", "Laganadi", "Reggio Calabria (RC)"), new structType.ptr("E403", "Laghi", "Vicenza (VI)"), new structType.ptr("E405", "Laglio", "Como (CO)"), new structType.ptr("E406", "Lagnasco", "Cuneo (CN)"), new structType.ptr("E407", "Lago", "Cosenza (CS)"), new structType.ptr("E409", "Lagonegro", "Potenza (PZ)"), new structType.ptr("E410", "Lagosanto", "Ferrara (FE)"), new structType.ptr("E412", "Lagundo .Algund.", "Bolzano (BZ)"), new structType.ptr("E414", "Laigueglia", "Savona (SV)"), new structType.ptr("E415", "Lainate", "Milano (MI)"), new structType.ptr("E416", "Laino", "Como (CO)"), new structType.ptr("E417", "Laino Borgo", "Cosenza (CS)"), new structType.ptr("E419", "Laino Castello", "Cosenza (CS)"), new structType.ptr("E420", "Laion .Lajen.", "Bolzano (BZ)"), new structType.ptr("E421", "Laives .Leifers.", "Bolzano (BZ)"), new structType.ptr("E413", "Lajatico", "Pisa (PI)"), new structType.ptr("E422", "Lallio", "Bergamo (BG)"), new structType.ptr("E424", "Lama Dei Peligni", "Chieti (CH)"), new structType.ptr("E426", "Lama Mocogno", "Modena (MO)"), new structType.ptr("E428", "Lambrugo", "Como (CO)"), new structType.ptr("M208", "Lamezia Terme", "Catanzaro (CZ)"), new structType.ptr("E429", "Lamon", "Belluno (BL)"), new structType.ptr("E431", "Lampedusa E Linosa", "Agrigento (AG)"), new structType.ptr("E432", "Lamporecchio", "Pistoia (PT)"), new structType.ptr("E433", "Lamporo", "Vercelli (VC)"), new structType.ptr("E434", "Lana .Lana.", "Bolzano (BZ)"), new structType.ptr("E435", "Lanciano", "Chieti (CH)"), new structType.ptr("E436", "Landiona", "Novara (NO)"), new structType.ptr("E437", "Landriano", "Pavia (PV)"), new structType.ptr("E438", "Langhirano", "Parma (PR)"), new structType.ptr("E439", "Langosco", "Pavia (PV)"), new structType.ptr("E441", "Lanusei", "Ogliastra (OG)"), new structType.ptr("C767", "Lanuvio", "Roma (RM)"), new structType.ptr("E443", "Lanzada", "Sondrio (SO)"), new structType.ptr("E445", "Lanzo Torinese", "Torino (TO)"), new structType.ptr("E447", "Lapedona", "Fermo (FM)"), new structType.ptr("E448", "Lapio", "Avellino (AV)"), new structType.ptr("E450", "Lappano", "Cosenza (CS)"), new structType.ptr("A345", "L'Aquila", "L'Aquila (AQ)"), new structType.ptr("E451", "Larciano", "Pistoia (PT)"), new structType.ptr("E454", "Lardirago", "Pavia (PV)"), new structType.ptr("M207", "Lariano", "Roma (RM)"), new structType.ptr("E456", "Larino", "Campobasso (CB)"), new structType.ptr("E464", "Las Plassas", "Medio Campidano (VS)"), new structType.ptr("E457", "Lasa .Laas.", "Bolzano (BZ)"), new structType.ptr("E459", "Lascari", "Palermo (PA)"), new structType.ptr("E462", "Lasnigo", "Como (CO)"), new structType.ptr("E465", "Lastebasse", "Vicenza (VI)"), new structType.ptr("E466", "Lastra A Signa", "Firenze (FI)"), new structType.ptr("E467", "Latera", "Viterbo (VT)"), new structType.ptr("E468", "Laterina", "Arezzo (AR)"), new structType.ptr("E469", "Laterza", "Taranto (TA)"), new structType.ptr("E471", "Latiano", "Brindisi (BR)"), new structType.ptr("E472", "Latina", "Latina (LT)"), new structType.ptr("E473", "Latisana", "Udine (UD)"), new structType.ptr("E474", "Latronico", "Potenza (PZ)"), new structType.ptr("E475", "Lattarico", "Cosenza (CS)"), new structType.ptr("E476", "Lauco", "Udine (UD)"), new structType.ptr("E480", "Laureana Cilento", "Salerno (SA)"), new structType.ptr("E479", "Laureana Di Borrello", "Reggio Calabria (RC)"), new structType.ptr("E481", "Lauregno .Laurein.", "Bolzano (BZ)"), new structType.ptr("E482", "Laurenzana", "Potenza (PZ)"), new structType.ptr("E483", "Lauria", "Potenza (PZ)"), new structType.ptr("E484", "Lauriano", "Torino (TO)"), new structType.ptr("E485", "Laurino", "Salerno (SA)"), new structType.ptr("E486", "Laurito", "Salerno (SA)"), new structType.ptr("E487", "Lauro", "Avellino (AV)"), new structType.ptr("E488", "Lavagna", "Genova (GE)"), new structType.ptr("E489", "Lavagno", "Verona (VR)"), new structType.ptr("E492", "Lavarone", "Trento (TN)"), new structType.ptr("E493", "Lavello", "Potenza (PZ)"), new structType.ptr("E494", "Lavena Ponte Tresa", "Varese (VA)"), new structType.ptr("E496", "Laveno Mombello", "Varese (VA)"), new structType.ptr("E497", "Lavenone", "Brescia (BS)"), new structType.ptr("E498", "Laviano", "Salerno (SA)"), new structType.ptr("E500", "Lavis", "Trento (TN)"), new structType.ptr("E502", "Lazise", "Verona (VR)"), new structType.ptr("E504", "Lazzate", "Monza e della Brianza (MB)"), new structType.ptr("E506", "Lecce", "Lecce (LE)"), new structType.ptr("E505", "Lecce Nei Marsi", "L'Aquila (AQ)"), new structType.ptr("E507", "Lecco", "Lecco (LC)"), new structType.ptr("M313", "Ledro", "Trento (TN)"), new structType.ptr("E509", "Leffe", "Bergamo (BG)"), new structType.ptr("E510", "Leggiuno", "Varese (VA)"), new structType.ptr("E512", "Legnago", "Verona (VR)"), new structType.ptr("E514", "Legnano", "Milano (MI)"), new structType.ptr("E515", "Legnaro", "Padova (PD)"), new structType.ptr("E517", "Lei", "Nuoro (NU)"), new structType.ptr("E518", "Leini", "Torino (TO)"), new structType.ptr("E519", "Leivi", "Genova (GE)"), new structType.ptr("E520", "Lemie", "Torino (TO)"), new structType.ptr("E522", "Lendinara", "Rovigo (RO)"), new structType.ptr("E523", "Leni", "Messina (ME)"), new structType.ptr("E524", "Lenna", "Bergamo (BG)"), new structType.ptr("E526", "Leno", "Brescia (BS)"), new structType.ptr("E527", "Lenola", "Latina (LT)"), new structType.ptr("E528", "Lenta", "Vercelli (VC)"), new structType.ptr("E530", "Lentate Sul Seveso", "Monza e della Brianza (MB)"), new structType.ptr("E531", "Lentella", "Chieti (CH)"), new structType.ptr("C562", "Lentiai", "Belluno (BL)"), new structType.ptr("E532", "Lentini", "Siracusa (SR)"), new structType.ptr("E535", "Leonessa", "Rieti (RI)"), new structType.ptr("E536", "Leonforte", "Enna (EN)"), new structType.ptr("E537", "Leporano", "Taranto (TA)"), new structType.ptr("E538", "Lequile", "Lecce (LE)"), new structType.ptr("E540", "Lequio Berria", "Cuneo (CN)"), new structType.ptr("E539", "Lequio Tanaro", "Cuneo (CN)"), new structType.ptr("E541", "Lercara Friddi", "Palermo (PA)"), new structType.ptr("E542", "Lerici", "La Spezia (SP)"), new structType.ptr("E543", "Lerma", "Alessandria (AL)"), new structType.ptr("E544", "Lesa", "Novara (NO)"), new structType.ptr("E546", "Lesegno", "Cuneo (CN)"), new structType.ptr("E547", "Lesignano De' Bagni", "Parma (PR)"), new structType.ptr("E549", "Lesina", "Foggia (FG)"), new structType.ptr("E550", "Lesmo", "Monza e della Brianza (MB)"), new structType.ptr("E551", "Lessolo", "Torino (TO)"), new structType.ptr("M371", "Lessona", "Biella (BI)"), new structType.ptr("E553", "Lestizza", "Udine (UD)"), new structType.ptr("E554", "Letino", "Caserta (CE)"), new structType.ptr("E555", "Letojanni", "Messina (ME)"), new structType.ptr("E557", "Lettere", "Napoli (NA)"), new structType.ptr("E558", "Lettomanoppello", "Pescara (PE)"), new structType.ptr("E559", "Lettopalena", "Chieti (CH)"), new structType.ptr("E560", "Levanto", "La Spezia (SP)"), new structType.ptr("E562", "Levate", "Bergamo (BG)"), new structType.ptr("E563", "Leverano", "Lecce (LE)"), new structType.ptr("E564", "Levice", "Cuneo (CN)"), new structType.ptr("E565", "Levico Terme", "Trento (TN)"), new structType.ptr("E566", "Levone", "Torino (TO)"), new structType.ptr("E569", "Lezzeno", "Como (CO)"), new structType.ptr("E570", "Liberi", "Caserta (CE)"), new structType.ptr("E571", "Librizzi", "Messina (ME)"), new structType.ptr("E573", "Licata", "Agrigento (AG)"), new structType.ptr("E574", "Licciana Nardi", "Massa-Carrara (MS)"), new structType.ptr("E576", "Licenza", "Roma (RM)"), new structType.ptr("E578", "Licodia Eubea", "Catania (CT)"), new structType.ptr("E581", "Lierna", "Lecco (LC)"), new structType.ptr("E583", "Lignana", "Vercelli (VC)"), new structType.ptr("E584", "Lignano Sabbiadoro", "Udine (UD)"), new structType.ptr("E586", "Ligosullo", "Udine (UD)"), new structType.ptr("E587", "Lillianes", "Aosta (AO)"), new structType.ptr("E588", "Limana", "Belluno (BL)"), new structType.ptr("E589", "Limatola", "Benevento (BN)"), new structType.ptr("E590", "Limbadi", "Vibo Valentia (VV)"), new structType.ptr("E591", "Limbiate", "Monza e della Brianza (MB)"), new structType.ptr("E592", "Limena", "Padova (PD)"), new structType.ptr("E593", "Limido Comasco", "Como (CO)"), new structType.ptr("E594", "Limina", "Messina (ME)"), new structType.ptr("E597", "Limone Piemonte", "Cuneo (CN)"), new structType.ptr("E596", "Limone Sul Garda", "Brescia (BS)"), new structType.ptr("E599", "Limosano", "Campobasso (CB)"), new structType.ptr("E600", "Linarolo", "Pavia (PV)"), new structType.ptr("E602", "Linguaglossa", "Catania (CT)"), new structType.ptr("E605", "Lioni", "Avellino (AV)"), new structType.ptr("E606", "Lipari", "Messina (ME)"), new structType.ptr("E607", "Lipomo", "Como (CO)"), new structType.ptr("E608", "Lirio", "Pavia (PV)"), new structType.ptr("E610", "Liscate", "Milano (MI)"), new structType.ptr("E611", "Liscia", "Chieti (CH)"), new structType.ptr("E613", "Lisciano Niccone", "Perugia (PG)"), new structType.ptr("E615", "Lisio", "Cuneo (CN)"), new structType.ptr("E617", "Lissone", "Monza e della Brianza (MB)"), new structType.ptr("E620", "Liveri", "Napoli (NA)"), new structType.ptr("E621", "Livigno", "Sondrio (SO)"), new structType.ptr("E622", "Livinallongo Del Col Di Lana", "Belluno (BL)"), new structType.ptr("E623", "Livo", "Como (CO)"), new structType.ptr("E624", "Livo", "Trento (TN)"), new structType.ptr("E625", "Livorno", "Livorno (LI)"), new structType.ptr("E626", "Livorno Ferraris", "Vercelli (VC)"), new structType.ptr("E627", "Livraga", "Lodi (LO)"), new structType.ptr("E629", "Lizzanello", "Lecce (LE)"), new structType.ptr("E630", "Lizzano", "Taranto (TA)"), new structType.ptr("A771", "Lizzano In Belvedere", "Bologna (BO)"), new structType.ptr("E632", "Loano", "Savona (SV)"), new structType.ptr("E633", "Loazzolo", "Asti (AT)"), new structType.ptr("E635", "Locana", "Torino (TO)"), new structType.ptr("E639", "Locate Di Triulzi", "Milano (MI)"), new structType.ptr("E638", "Locate Varesino", "Como (CO)"), new structType.ptr("E640", "Locatello", "Bergamo (BG)"), new structType.ptr("E644", "Loceri", "Ogliastra (OG)"), new structType.ptr("E645", "Locorotondo", "Bari (BA)"), new structType.ptr("D976", "Locri", "Reggio Calabria (RC)"), new structType.ptr("E646", "Loculi", "Nuoro (NU)"), new structType.ptr("E647", "Lod\xC3\xA8", "Nuoro (NU)"), new structType.ptr("E648", "Lodi", "Lodi (LO)"), new structType.ptr("E651", "Lodi Vecchio", "Lodi (LO)"), new structType.ptr("E649", "Lodine", "Nuoro (NU)"), new structType.ptr("E652", "Lodrino", "Brescia (BS)"), new structType.ptr("E654", "Lograto", "Brescia (BS)"), new structType.ptr("E655", "Loiano", "Bologna (BO)"), new structType.ptr("M275", "Loiri Porto San Paolo", "Olbia-Tempio (OT)"), new structType.ptr("E656", "Lomagna", "Lecco (LC)"), new structType.ptr("E659", "Lomazzo", "Como (CO)"), new structType.ptr("E660", "Lombardore", "Torino (TO)"), new structType.ptr("E661", "Lombriasco", "Torino (TO)"), new structType.ptr("E662", "Lomello", "Pavia (PV)"), new structType.ptr("E664", "Lona Lases", "Trento (TN)"), new structType.ptr("E665", "Lonate Ceppino", "Varese (VA)"), new structType.ptr("E666", "Lonate Pozzolo", "Varese (VA)"), new structType.ptr("E667", "Lonato", "Brescia (BS)"), new structType.ptr("M312", "Lonato Del Garda", "Brescia (BS)"), new structType.ptr("E668", "Londa", "Firenze (FI)"), new structType.ptr("E669", "Longano", "Isernia (IS)"), new structType.ptr("E671", "Longare", "Vicenza (VI)"), new structType.ptr("M342", "Longarone", "Belluno (BL)"), new structType.ptr("E673", "Longhena", "Brescia (BS)"), new structType.ptr("E674", "Longi", "Messina (ME)"), new structType.ptr("E675", "Longiano", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("E677", "Longobardi", "Cosenza (CS)"), new structType.ptr("E678", "Longobucco", "Cosenza (CS)"), new structType.ptr("E679", "Longone Al Segrino", "Como (CO)"), new structType.ptr("E681", "Longone Sabino", "Rieti (RI)"), new structType.ptr("E682", "Lonigo", "Vicenza (VI)"), new structType.ptr("E683", "Loranz\xC3\xA8", "Torino (TO)"), new structType.ptr("E684", "Loreggia", "Padova (PD)"), new structType.ptr("E685", "Loreglia", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("E687", "Lorenzago Di Cadore", "Belluno (BL)"), new structType.ptr("E689", "Loreo", "Rovigo (RO)"), new structType.ptr("E690", "Loreto", "Ancona (AN)"), new structType.ptr("E691", "Loreto Aprutino", "Pescara (PE)"), new structType.ptr("E692", "Loria", "Treviso (TV)"), new structType.ptr("E693", "Loro Ciuffenna", "Arezzo (AR)"), new structType.ptr("E694", "Loro Piceno", "Macerata (MC)"), new structType.ptr("E695", "Lorsica", "Genova (GE)"), new structType.ptr("E698", "Losine", "Brescia (BS)"), new structType.ptr("E700", "Lotzorai", "Ogliastra (OG)"), new structType.ptr("E704", "Lovere", "Bergamo (BG)"), new structType.ptr("E705", "Lovero", "Sondrio (SO)"), new structType.ptr("E706", "Lozio", "Brescia (BS)"), new structType.ptr("E707", "Lozza", "Varese (VA)"), new structType.ptr("E709", "Lozzo Atestino", "Padova (PD)"), new structType.ptr("E708", "Lozzo Di Cadore", "Belluno (BL)"), new structType.ptr("E711", "Lozzolo", "Vercelli (VC)"), new structType.ptr("E712", "Lu", "Alessandria (AL)"), new structType.ptr("E713", "Lubriano", "Viterbo (VT)"), new structType.ptr("E715", "Lucca", "Lucca (LU)"), new structType.ptr("E714", "Lucca Sicula", "Agrigento (AG)"), new structType.ptr("E716", "Lucera", "Foggia (FG)"), new structType.ptr("E718", "Lucignano", "Arezzo (AR)"), new structType.ptr("E719", "Lucinasco", "Imperia (IM)"), new structType.ptr("E722", "Lucito", "Campobasso (CB)"), new structType.ptr("E723", "Luco Dei Marsi", "L'Aquila (AQ)"), new structType.ptr("E724", "Lucoli", "L'Aquila (AQ)"), new structType.ptr("E726", "Lugagnano Val D'Arda", "Piacenza (PC)"), new structType.ptr("E727", "Lugnacco", "Torino (TO)"), new structType.ptr("E729", "Lugnano In Teverina", "Terni (TR)"), new structType.ptr("E730", "Lugo", "Ravenna (RA)"), new structType.ptr("E731", "Lugo Di Vicenza", "Vicenza (VI)"), new structType.ptr("E734", "Luino", "Varese (VA)"), new structType.ptr("E735", "Luisago", "Como (CO)"), new structType.ptr("E736", "Lula", "Nuoro (NU)"), new structType.ptr("E737", "Lumarzo", "Genova (GE)"), new structType.ptr("E738", "Lumezzane", "Brescia (BS)"), new structType.ptr("E742", "Lunamatrona", "Medio Campidano (VS)"), new structType.ptr("E743", "Lunano", "Pesaro e Urbino (PU)"), new structType.ptr("B387", "Lungavilla", "Pavia (PV)"), new structType.ptr("E745", "Lungro", "Cosenza (CS)"), new structType.ptr("E746", "Luogosano", "Avellino (AV)"), new structType.ptr("E747", "Luogosanto", "Olbia-Tempio (OT)"), new structType.ptr("E748", "Lupara", "Campobasso (CB)"), new structType.ptr("E749", "Lurago D'Erba", "Como (CO)"), new structType.ptr("E750", "Lurago Marinone", "Como (CO)"), new structType.ptr("E751", "Lurano", "Bergamo (BG)"), new structType.ptr("E752", "Luras", "Olbia-Tempio (OT)"), new structType.ptr("E753", "Lurate Caccivio", "Como (CO)"), new structType.ptr("E754", "Lusciano", "Caserta (CE)"), new structType.ptr("E757", "Luserna", "Trento (TN)"), new structType.ptr("E758", "Luserna San Giovanni", "Torino (TO)"), new structType.ptr("E759", "Lusernetta", "Torino (TO)"), new structType.ptr("E760", "Lusevera", "Udine (UD)"), new structType.ptr("E761", "Lusia", "Rovigo (RO)"), new structType.ptr("E762", "Lusiana", "Vicenza (VI)"), new structType.ptr("E763", "Lusigli\xC3\xA8", "Torino (TO)"), new structType.ptr("E764", "Luson .Luesen.", "Bolzano (BZ)"), new structType.ptr("E767", "Lustra", "Salerno (SA)"), new structType.ptr("E769", "Luvinate", "Varese (VA)"), new structType.ptr("E770", "Luzzana", "Bergamo (BG)"), new structType.ptr("E772", "Luzzara", "Reggio Emilia (RE)"), new structType.ptr("E773", "Luzzi", "Cosenza (CS)"), new structType.ptr("M339", "Maccagno Con Pino E Veddasca", "Varese (VA)"), new structType.ptr("E777", "Maccastorna", "Lodi (LO)"), new structType.ptr("E778", "Macchia D'Isernia", "Isernia (IS)"), new structType.ptr("E780", "Macchia Valfortore", "Campobasso (CB)"), new structType.ptr("E779", "Macchiagodena", "Isernia (IS)"), new structType.ptr("E782", "Macello", "Torino (TO)"), new structType.ptr("E783", "Macerata", "Macerata (MC)"), new structType.ptr("E784", "Macerata Campania", "Caserta (CE)"), new structType.ptr("E785", "Macerata Feltria", "Pesaro e Urbino (PU)"), new structType.ptr("E786", "Macherio", "Monza e della Brianza (MB)"), new structType.ptr("E787", "Maclodio", "Brescia (BS)"), new structType.ptr("E788", "Macomer", "Nuoro (NU)"), new structType.ptr("E789", "Macra", "Cuneo (CN)"), new structType.ptr("E790", "Macugnaga", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("E791", "Maddaloni", "Caserta (CE)"), new structType.ptr("E342", "Madesimo", "Sondrio (SO)"), new structType.ptr("E793", "Madignano", "Cremona (CR)"), new structType.ptr("E794", "Madone", "Bergamo (BG)"), new structType.ptr("E795", "Madonna Del Sasso", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("M357", "Madruzzo", "Trento (TN)"), new structType.ptr("E798", "Maenza", "Latina (LT)"), new structType.ptr("E799", "Mafalda", "Campobasso (CB)"), new structType.ptr("E800", "Magasa", "Brescia (BS)"), new structType.ptr("E801", "Magenta", "Milano (MI)"), new structType.ptr("E803", "Maggiora", "Novara (NO)"), new structType.ptr("E804", "Magherno", "Pavia (PV)"), new structType.ptr("E805", "Magione", "Perugia (PG)"), new structType.ptr("E806", "Magisano", "Catanzaro (CZ)"), new structType.ptr("E809", "Magliano Alfieri", "Cuneo (CN)"), new structType.ptr("E808", "Magliano Alpi", "Cuneo (CN)"), new structType.ptr("E811", "Magliano De' Marsi", "L'Aquila (AQ)"), new structType.ptr("E807", "Magliano Di Tenna", "Fermo (FM)"), new structType.ptr("E810", "Magliano In Toscana", "Grosseto (GR)"), new structType.ptr("E813", "Magliano Romano", "Roma (RM)"), new structType.ptr("E812", "Magliano Sabina", "Rieti (RI)"), new structType.ptr("E814", "Magliano Vetere", "Salerno (SA)"), new structType.ptr("E815", "Maglie", "Lecce (LE)"), new structType.ptr("E816", "Magliolo", "Savona (SV)"), new structType.ptr("E817", "Maglione", "Torino (TO)"), new structType.ptr("E818", "Magnacavallo", "Mantova (MN)"), new structType.ptr("E819", "Magnago", "Milano (MI)"), new structType.ptr("E821", "Magnano", "Biella (BI)"), new structType.ptr("E820", "Magnano In Riviera", "Udine (UD)"), new structType.ptr("E825", "Magomadas", "Oristano (OR)"), new structType.ptr("E829", "Magre' Sulla Strada Del Vino .Margreid An De.", "Bolzano (BZ)"), new structType.ptr("E830", "Magreglio", "Como (CO)"), new structType.ptr("E834", "Maida", "Catanzaro (CZ)"), new structType.ptr("E835", "Maier\xC3\xA0", "Cosenza (CS)"), new structType.ptr("E836", "Maierato", "Vibo Valentia (VV)"), new structType.ptr("E837", "Maiolati Spontini", "Ancona (AN)"), new structType.ptr("E838", "Maiolo", "Rimini (RN)"), new structType.ptr("E839", "Maiori", "Salerno (SA)"), new structType.ptr("E840", "Mairago", "Lodi (LO)"), new structType.ptr("E841", "Mairano", "Brescia (BS)"), new structType.ptr("E842", "Maissana", "La Spezia (SP)"), new structType.ptr("E833", "Majano", "Udine (UD)"), new structType.ptr("E843", "Malagnino", "Cremona (CR)"), new structType.ptr("E844", "Malalbergo", "Bologna (BO)"), new structType.ptr("E847", "Malborghetto-Valbruna", "Udine (UD)"), new structType.ptr("E848", "Malcesine", "Verona (VR)"), new structType.ptr("E850", "Mal\xC3\xA8", "Trento (TN)"), new structType.ptr("E851", "Malegno", "Brescia (BS)"), new structType.ptr("E852", "Maleo", "Lodi (LO)"), new structType.ptr("E853", "Malesco", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("E854", "Maletto", "Catania (CT)"), new structType.ptr("E855", "Malfa", "Messina (ME)"), new structType.ptr("E856", "Malgesso", "Varese (VA)"), new structType.ptr("E858", "Malgrate", "Lecco (LC)"), new structType.ptr("E859", "Malito", "Cosenza (CS)"), new structType.ptr("E860", "Mallare", "Savona (SV)"), new structType.ptr("E862", "Malles Venosta .Mals.", "Bolzano (BZ)"), new structType.ptr("E863", "Malnate", "Varese (VA)"), new structType.ptr("E864", "Malo", "Vicenza (VI)"), new structType.ptr("E865", "Malonno", "Brescia (BS)"), new structType.ptr("E866", "Malosco", "Trento (TN)"), new structType.ptr("E868", "Maltignano", "Ascoli Piceno (AP)"), new structType.ptr("E869", "Malvagna", "Messina (ME)"), new structType.ptr("E870", "Malvicino", "Alessandria (AL)"), new structType.ptr("E872", "Malvito", "Cosenza (CS)"), new structType.ptr("E873", "Mammola", "Reggio Calabria (RC)"), new structType.ptr("E874", "Mamoiada", "Nuoro (NU)"), new structType.ptr("E875", "Manciano", "Grosseto (GR)"), new structType.ptr("E876", "Mandanici", "Messina (ME)"), new structType.ptr("E877", "Mandas", "Cagliari (CA)"), new structType.ptr("E878", "Mandatoriccio", "Cosenza (CS)"), new structType.ptr("B632", "Mandela", "Roma (RM)"), new structType.ptr("E879", "Mandello Del Lario", "Lecco (LC)"), new structType.ptr("E880", "Mandello Vitta", "Novara (NO)"), new structType.ptr("E882", "Manduria", "Taranto (TA)"), new structType.ptr("E883", "Manerba Del Garda", "Brescia (BS)"), new structType.ptr("E884", "Manerbio", "Brescia (BS)"), new structType.ptr("E885", "Manfredonia", "Foggia (FG)"), new structType.ptr("E887", "Mango", "Cuneo (CN)"), new structType.ptr("E888", "Mangone", "Cosenza (CS)"), new structType.ptr("M283", "Maniace", "Catania (CT)"), new structType.ptr("E889", "Maniago", "Pordenone (PN)"), new structType.ptr("E891", "Manocalzati", "Avellino (AV)"), new structType.ptr("E892", "Manoppello", "Pescara (PE)"), new structType.ptr("E893", "Mansu\xC3\xA8", "Treviso (TV)"), new structType.ptr("E894", "Manta", "Cuneo (CN)"), new structType.ptr("E896", "Mantello", "Sondrio (SO)"), new structType.ptr("E897", "Mantova", "Mantova (MN)"), new structType.ptr("E899", "Manzano", "Udine (UD)"), new structType.ptr("E900", "Manziana", "Roma (RM)"), new structType.ptr("E901", "Mapello", "Bergamo (BG)"), new structType.ptr("E902", "Mara", "Sassari (SS)"), new structType.ptr("E903", "Maracalagonis", "Cagliari (CA)"), new structType.ptr("E904", "Maranello", "Modena (MO)"), new structType.ptr("E906", "Marano Di Napoli", "Napoli (NA)"), new structType.ptr("E911", "Marano Di Valpolicella", "Verona (VR)"), new structType.ptr("E908", "Marano Equo", "Roma (RM)"), new structType.ptr("E910", "Marano Lagunare", "Udine (UD)"), new structType.ptr("E914", "Marano Marchesato", "Cosenza (CS)"), new structType.ptr("E915", "Marano Principato", "Cosenza (CS)"), new structType.ptr("E905", "Marano Sul Panaro", "Modena (MO)"), new structType.ptr("E907", "Marano Ticino", "Novara (NO)"), new structType.ptr("E912", "Marano Vicentino", "Vicenza (VI)"), new structType.ptr("E917", "Maranzana", "Asti (AT)"), new structType.ptr("E919", "Maratea", "Potenza (PZ)"), new structType.ptr("E921", "Marcallo Con Casone", "Milano (MI)"), new structType.ptr("E922", "Marcaria", "Mantova (MN)"), new structType.ptr("E923", "Marcedusa", "Catanzaro (CZ)"), new structType.ptr("E924", "Marcellina", "Roma (RM)"), new structType.ptr("E925", "Marcellinara", "Catanzaro (CZ)"), new structType.ptr("E927", "Marcetelli", "Rieti (RI)"), new structType.ptr("E928", "Marcheno", "Brescia (BS)"), new structType.ptr("E929", "Marchirolo", "Varese (VA)"), new structType.ptr("E930", "Marciana", "Livorno (LI)"), new structType.ptr("E931", "Marciana Marina", "Livorno (LI)"), new structType.ptr("E932", "Marcianise", "Caserta (CE)"), new structType.ptr("E933", "Marciano Della Chiana", "Arezzo (AR)"), new structType.ptr("E934", "Marcignago", "Pavia (PV)"), new structType.ptr("E936", "Marcon", "Venezia (VE)"), new structType.ptr("E938", "Marebbe .Enneberg.", "Bolzano (BZ)"), new structType.ptr("E939", "Marene", "Cuneo (CN)"), new structType.ptr("E940", "Mareno Di Piave", "Treviso (TV)"), new structType.ptr("E941", "Marentino", "Torino (TO)"), new structType.ptr("E944", "Maretto", "Asti (AT)"), new structType.ptr("E945", "Margarita", "Cuneo (CN)"), new structType.ptr("E946", "Margherita Di Savoia", "Barletta-Andria-Trani (BT)"), new structType.ptr("E947", "Margno", "Lecco (LC)"), new structType.ptr("E949", "Mariana Mantovana", "Mantova (MN)"), new structType.ptr("E951", "Mariano Comense", "Como (CO)"), new structType.ptr("E952", "Mariano Del Friuli", "Gorizia (GO)"), new structType.ptr("E953", "Marianopoli", "Caltanissetta (CL)"), new structType.ptr("E954", "Mariglianella", "Napoli (NA)"), new structType.ptr("E955", "Marigliano", "Napoli (NA)"), new structType.ptr("E956", "Marina Di Gioiosa Ionica", "Reggio Calabria (RC)"), new structType.ptr("E957", "Marineo", "Palermo (PA)"), new structType.ptr("E958", "Marino", "Roma (RM)"), new structType.ptr("E959", "Marlengo .Marling.", "Bolzano (BZ)"), new structType.ptr("E960", "Marliana", "Pistoia (PT)"), new structType.ptr("E961", "Marmentino", "Brescia (BS)"), new structType.ptr("E962", "Marmirolo", "Mantova (MN)"), new structType.ptr("E963", "Marmora", "Cuneo (CN)"), new structType.ptr("E965", "Marnate", "Varese (VA)"), new structType.ptr("E967", "Marone", "Brescia (BS)"), new structType.ptr("E968", "Maropati", "Reggio Calabria (RC)"), new structType.ptr("E970", "Marostica", "Vicenza (VI)"), new structType.ptr("E971", "Marradi", "Firenze (FI)"), new structType.ptr("E972", "Marrubiu", "Oristano (OR)"), new structType.ptr("E973", "Marsaglia", "Cuneo (CN)"), new structType.ptr("E974", "Marsala", "Trapani (TP)"), new structType.ptr("E975", "Marsciano", "Perugia (PG)"), new structType.ptr("E976", "Marsico Nuovo", "Potenza (PZ)"), new structType.ptr("E977", "Marsicovetere", "Potenza (PZ)"), new structType.ptr("E978", "Marta", "Viterbo (VT)"), new structType.ptr("E979", "Martano", "Lecce (LE)"), new structType.ptr("E980", "Martellago", "Venezia (VE)"), new structType.ptr("E981", "Martello .Martell.", "Bolzano (BZ)"), new structType.ptr("E982", "Martignacco", "Udine (UD)"), new structType.ptr("E983", "Martignana Di Po", "Cremona (CR)"), new structType.ptr("E984", "Martignano", "Lecce (LE)"), new structType.ptr("E986", "Martina Franca", "Taranto (TA)"), new structType.ptr("E987", "Martinengo", "Bergamo (BG)"), new structType.ptr("E988", "Martiniana Po", "Cuneo (CN)"), new structType.ptr("E989", "Martinsicuro", "Teramo (TE)"), new structType.ptr("E990", "Martirano", "Catanzaro (CZ)"), new structType.ptr("E991", "Martirano Lombardo", "Catanzaro (CZ)"), new structType.ptr("E992", "Martis", "Sassari (SS)"), new structType.ptr("E993", "Martone", "Reggio Calabria (RC)"), new structType.ptr("E994", "Marudo", "Lodi (LO)"), new structType.ptr("E995", "Maruggio", "Taranto (TA)"), new structType.ptr("B689", "Marzabotto", "Bologna (BO)"), new structType.ptr("E999", "Marzano", "Pavia (PV)"), new structType.ptr("E998", "Marzano Appio", "Caserta (CE)"), new structType.ptr("E997", "Marzano Di Nola", "Avellino (AV)"), new structType.ptr("F001", "Marzi", "Cosenza (CS)"), new structType.ptr("F002", "Marzio", "Varese (VA)"), new structType.ptr("M270", "Masainas", "Carbonia-Iglesias (CI)"), new structType.ptr("F003", "Masate", "Milano (MI)"), new structType.ptr("F004", "Mascali", "Catania (CT)"), new structType.ptr("F005", "Mascalucia", "Catania (CT)"), new structType.ptr("F006", "Maschito", "Potenza (PZ)"), new structType.ptr("F007", "Masciago Primo", "Varese (VA)"), new structType.ptr("F009", "Maser", "Treviso (TV)"), new structType.ptr("F010", "Masera", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("F011", "Masera' Di Padova", "Padova (PD)"), new structType.ptr("F012", "Maserada Sul Piave", "Treviso (TV)"), new structType.ptr("F013", "Masi", "Padova (PD)"), new structType.ptr("F016", "Masi Torello", "Ferrara (FE)"), new structType.ptr("F015", "Masio", "Alessandria (AL)"), new structType.ptr("F017", "Maslianico", "Como (CO)"), new structType.ptr("F019", "Mason Vicentino", "Vicenza (VI)"), new structType.ptr("F020", "Masone", "Genova (GE)"), new structType.ptr("F023", "Massa", "Massa-Carrara (MS)"), new structType.ptr("F022", "Massa D'Albe", "L'Aquila (AQ)"), new structType.ptr("M289", "Massa Di Somma", "Napoli (NA)"), new structType.ptr("F025", "Massa E Cozzile", "Pistoia (PT)"), new structType.ptr("F021", "Massa Fermana", "Fermo (FM)"), new structType.ptr("F029", "Massa Lombarda", "Ravenna (RA)"), new structType.ptr("F030", "Massa Lubrense", "Napoli (NA)"), new structType.ptr("F032", "Massa Marittima", "Grosseto (GR)"), new structType.ptr("F024", "Massa Martana", "Perugia (PG)"), new structType.ptr("F027", "Massafra", "Taranto (TA)"), new structType.ptr("F028", "Massalengo", "Lodi (LO)"), new structType.ptr("F033", "Massanzago", "Padova (PD)"), new structType.ptr("F035", "Massarosa", "Lucca (LU)"), new structType.ptr("F037", "Massazza", "Biella (BI)"), new structType.ptr("F041", "Massello", "Torino (TO)"), new structType.ptr("F042", "Masserano", "Biella (BI)"), new structType.ptr("F044", "Massignano", "Ascoli Piceno (AP)"), new structType.ptr("F045", "Massimeno", "Trento (TN)"), new structType.ptr("F046", "Massimino", "Savona (SV)"), new structType.ptr("F047", "Massino Visconti", "Novara (NO)"), new structType.ptr("F048", "Massiola", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("F050", "Masullas", "Oristano (OR)"), new structType.ptr("F051", "Matelica", "Macerata (MC)"), new structType.ptr("F052", "Matera", "Matera (MT)"), new structType.ptr("F053", "Mathi", "Torino (TO)"), new structType.ptr("F054", "Matino", "Lecce (LE)"), new structType.ptr("F055", "Matrice", "Campobasso (CB)"), new structType.ptr("F058", "Mattie", "Torino (TO)"), new structType.ptr("F059", "Mattinata", "Foggia (FG)"), new structType.ptr("F061", "Mazara Del Vallo", "Trapani (TP)"), new structType.ptr("F063", "Mazzano", "Brescia (BS)"), new structType.ptr("F064", "Mazzano Romano", "Roma (RM)"), new structType.ptr("F065", "Mazzarino", "Caltanissetta (CL)"), new structType.ptr("F066", "Mazzarra' Sant'Andrea", "Messina (ME)"), new structType.ptr("M271", "Mazzarrone", "Catania (CT)"), new structType.ptr("F067", "Mazz\xC3\xA8", "Torino (TO)"), new structType.ptr("F068", "Mazzin", "Trento (TN)"), new structType.ptr("F070", "Mazzo Di Valtellina", "Sondrio (SO)"), new structType.ptr("F074", "Meana Di Susa", "Torino (TO)"), new structType.ptr("F073", "Meana Sardo", "Nuoro (NU)"), new structType.ptr("F078", "Meda", "Monza e della Brianza (MB)"), new structType.ptr("F080", "Mede", "Pavia (PV)"), new structType.ptr("F081", "Medea", "Gorizia (GO)"), new structType.ptr("F082", "Medesano", "Parma (PR)"), new structType.ptr("F083", "Medicina", "Bologna (BO)"), new structType.ptr("F084", "Mediglia", "Milano (MI)"), new structType.ptr("F085", "Medolago", "Bergamo (BG)"), new structType.ptr("F086", "Medole", "Mantova (MN)"), new structType.ptr("F087", "Medolla", "Modena (MO)"), new structType.ptr("F088", "Meduna Di Livenza", "Treviso (TV)"), new structType.ptr("F089", "Meduno", "Pordenone (PN)"), new structType.ptr("F091", "Megliadino San Fidenzio", "Padova (PD)"), new structType.ptr("F092", "Megliadino San Vitale", "Padova (PD)"), new structType.ptr("F093", "Meina", "Novara (NO)"), new structType.ptr("F094", "Mel", "Belluno (BL)"), new structType.ptr("F095", "Melara", "Rovigo (RO)"), new structType.ptr("F096", "Melazzo", "Alessandria (AL)"), new structType.ptr("F097", "Meldola", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("F098", "Mele", "Genova (GE)"), new structType.ptr("F100", "Melegnano", "Milano (MI)"), new structType.ptr("F101", "Melendugno", "Lecce (LE)"), new structType.ptr("F102", "Meleti", "Lodi (LO)"), new structType.ptr("F104", "Melfi", "Potenza (PZ)"), new structType.ptr("F105", "Melicucc\xC3\xA0", "Reggio Calabria (RC)"), new structType.ptr("F106", "Melicucco", "Reggio Calabria (RC)"), new structType.ptr("F107", "Melilli", "Siracusa (SR)"), new structType.ptr("F108", "Melissa", "Crotone (KR)"), new structType.ptr("F109", "Melissano", "Lecce (LE)"), new structType.ptr("F111", "Melito Di Napoli", "Napoli (NA)"), new structType.ptr("F112", "Melito Di Porto Salvo", "Reggio Calabria (RC)"), new structType.ptr("F110", "Melito Irpino", "Avellino (AV)"), new structType.ptr("F113", "Melizzano", "Benevento (BN)"), new structType.ptr("F114", "Melle", "Cuneo (CN)"), new structType.ptr("F115", "Mello", "Sondrio (SO)"), new structType.ptr("F117", "Melpignano", "Lecce (LE)"), new structType.ptr("F118", "Meltina .Moelten.", "Bolzano (BZ)"), new structType.ptr("F119", "Melzo", "Milano (MI)"), new structType.ptr("F120", "Menaggio", "Como (CO)"), new structType.ptr("F122", "Menconico", "Pavia (PV)"), new structType.ptr("F123", "Mendatica", "Imperia (IM)"), new structType.ptr("F125", "Mendicino", "Cosenza (CS)"), new structType.ptr("F126", "Menfi", "Agrigento (AG)"), new structType.ptr("F127", "Mentana", "Roma (RM)"), new structType.ptr("F130", "Meolo", "Venezia (VE)"), new structType.ptr("F131", "Merana", "Alessandria (AL)"), new structType.ptr("F132", "Merano .Meran.", "Bolzano (BZ)"), new structType.ptr("F133", "Merate", "Lecco (LC)"), new structType.ptr("F134", "Mercallo", "Varese (VA)"), new structType.ptr("F135", "Mercatello Sul Metauro", "Pesaro e Urbino (PU)"), new structType.ptr("F136", "Mercatino Conca", "Pesaro e Urbino (PU)"), new structType.ptr("F138", "Mercato San Severino", "Salerno (SA)"), new structType.ptr("F139", "Mercato Saraceno", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("F140", "Mercenasco", "Torino (TO)"), new structType.ptr("F141", "Mercogliano", "Avellino (AV)"), new structType.ptr("F144", "Mereto Di Tomba", "Udine (UD)"), new structType.ptr("F145", "Mergo", "Ancona (AN)"), new structType.ptr("F146", "Mergozzo", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("F147", "Mer\xC3\xAC", "Messina (ME)"), new structType.ptr("F148", "Merlara", "Padova (PD)"), new structType.ptr("F149", "Merlino", "Lodi (LO)"), new structType.ptr("F151", "Merone", "Como (CO)"), new structType.ptr("F152", "Mesagne", "Brindisi (BR)"), new structType.ptr("F153", "Mese", "Sondrio (SO)"), new structType.ptr("F154", "Mesenzana", "Varese (VA)"), new structType.ptr("F155", "Mesero", "Milano (MI)"), new structType.ptr("F156", "Mesola", "Ferrara (FE)"), new structType.ptr("F157", "Mesoraca", "Crotone (KR)"), new structType.ptr("F158", "Messina", "Messina (ME)"), new structType.ptr("F161", "Mestrino", "Padova (PD)"), new structType.ptr("F162", "Meta", "Napoli (NA)"), new structType.ptr("F164", "Meugliano", "Torino (TO)"), new structType.ptr("F165", "Mezzago", "Monza e della Brianza (MB)"), new structType.ptr("F168", "Mezzana", "Trento (TN)"), new structType.ptr("F170", "Mezzana Bigli", "Pavia (PV)"), new structType.ptr("F167", "Mezzana Mortigliengo", "Biella (BI)"), new structType.ptr("F171", "Mezzana Rabattone", "Pavia (PV)"), new structType.ptr("F172", "Mezzane Di Sotto", "Verona (VR)"), new structType.ptr("F173", "Mezzanego", "Genova (GE)"), new structType.ptr("F174", "Mezzani", "Parma (PR)"), new structType.ptr("F175", "Mezzanino", "Pavia (PV)"), new structType.ptr("F176", "Mezzano", "Trento (TN)"), new structType.ptr("F182", "Mezzenile", "Torino (TO)"), new structType.ptr("F183", "Mezzocorona", "Trento (TN)"), new structType.ptr("F184", "Mezzojuso", "Palermo (PA)"), new structType.ptr("F186", "Mezzoldo", "Bergamo (BG)"), new structType.ptr("F187", "Mezzolombardo", "Trento (TN)"), new structType.ptr("F188", "Mezzomerico", "Novara (NO)"), new structType.ptr("F189", "Miagliano", "Biella (BI)"), new structType.ptr("F190", "Miane", "Treviso (TV)"), new structType.ptr("F191", "Miasino", "Novara (NO)"), new structType.ptr("F192", "Miazzina", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("F193", "Micigliano", "Rieti (RI)"), new structType.ptr("F194", "Miggiano", "Lecce (LE)"), new structType.ptr("F196", "Miglianico", "Chieti (CH)"), new structType.ptr("F200", "Miglierina", "Catanzaro (CZ)"), new structType.ptr("F201", "Miglionico", "Matera (MT)"), new structType.ptr("F202", "Mignanego", "Genova (GE)"), new structType.ptr("F203", "Mignano Monte Lungo", "Caserta (CE)"), new structType.ptr("F205", "Milano", "Milano (MI)"), new structType.ptr("F206", "Milazzo", "Messina (ME)"), new structType.ptr("E618", "Milena", "Caltanissetta (CL)"), new structType.ptr("F207", "Mileto", "Vibo Valentia (VV)"), new structType.ptr("F208", "Milis", "Oristano (OR)"), new structType.ptr("F209", "Militello In Val Di Catania", "Catania (CT)"), new structType.ptr("F210", "Militello Rosmarino", "Messina (ME)"), new structType.ptr("F213", "Millesimo", "Savona (SV)"), new structType.ptr("F214", "Milo", "Catania (CT)"), new structType.ptr("F216", "Milzano", "Brescia (BS)"), new structType.ptr("F217", "Mineo", "Catania (CT)"), new structType.ptr("F218", "Minerbe", "Verona (VR)"), new structType.ptr("F219", "Minerbio", "Bologna (BO)"), new structType.ptr("F221", "Minervino Di Lecce", "Lecce (LE)"), new structType.ptr("F220", "Minervino Murge", "Barletta-Andria-Trani (BT)"), new structType.ptr("F223", "Minori", "Salerno (SA)"), new structType.ptr("F224", "Minturno", "Latina (LT)"), new structType.ptr("F225", "Minucciano", "Lucca (LU)"), new structType.ptr("F226", "Mioglia", "Savona (SV)"), new structType.ptr("F229", "Mira", "Venezia (VE)"), new structType.ptr("F230", "Mirabella Eclano", "Avellino (AV)"), new structType.ptr("F231", "Mirabella Imbaccari", "Catania (CT)"), new structType.ptr("F232", "Mirabello Monferrato", "Alessandria (AL)"), new structType.ptr("F233", "Mirabello Sannitico", "Campobasso (CB)"), new structType.ptr("F238", "Miradolo Terme", "Pavia (PV)"), new structType.ptr("F239", "Miranda", "Isernia (IS)"), new structType.ptr("F240", "Mirandola", "Modena (MO)"), new structType.ptr("F241", "Mirano", "Venezia (VE)"), new structType.ptr("F242", "Mirto", "Messina (ME)"), new structType.ptr("F244", "Misano Adriatico", "Rimini (RN)"), new structType.ptr("F243", "Misano Di Gera D'Adda", "Bergamo (BG)"), new structType.ptr("F246", "Misilmeri", "Palermo (PA)"), new structType.ptr("F247", "Misinto", "Monza e della Brianza (MB)"), new structType.ptr("F248", "Missaglia", "Lecco (LC)"), new structType.ptr("F249", "Missanello", "Potenza (PZ)"), new structType.ptr("F250", "Misterbianco", "Catania (CT)"), new structType.ptr("F251", "Mistretta", "Messina (ME)"), new structType.ptr("F254", "Moasca", "Asti (AT)"), new structType.ptr("F256", "Moconesi", "Genova (GE)"), new structType.ptr("F257", "Modena", "Modena (MO)"), new structType.ptr("F258", "Modica", "Ragusa (RG)"), new structType.ptr("F259", "Modigliana", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("F261", "Modolo", "Oristano (OR)"), new structType.ptr("F262", "Modugno", "Bari (BA)"), new structType.ptr("F263", "Moena", "Trento (TN)"), new structType.ptr("F265", "Moggio", "Lecco (LC)"), new structType.ptr("F266", "Moggio Udinese", "Udine (UD)"), new structType.ptr("F267", "Moglia", "Mantova (MN)"), new structType.ptr("F268", "Mogliano", "Macerata (MC)"), new structType.ptr("F269", "Mogliano Veneto", "Treviso (TV)"), new structType.ptr("F270", "Mogorella", "Oristano (OR)"), new structType.ptr("F272", "Mogoro", "Oristano (OR)"), new structType.ptr("F274", "Moiano", "Benevento (BN)"), new structType.ptr("F275", "Moimacco", "Udine (UD)"), new structType.ptr("F277", "Moio Alcantara", "Messina (ME)"), new structType.ptr("F276", "Moio De' Calvi", "Bergamo (BG)"), new structType.ptr("F278", "Moio Della Civitella", "Salerno (SA)"), new structType.ptr("F279", "Moiola", "Cuneo (CN)"), new structType.ptr("F280", "Mola Di Bari", "Bari (BA)"), new structType.ptr("F281", "Molare", "Alessandria (AL)"), new structType.ptr("F283", "Molazzana", "Lucca (LU)"), new structType.ptr("F284", "Molfetta", "Bari (BA)"), new structType.ptr("M255", "Molina Aterno", "L'Aquila (AQ)"), new structType.ptr("F287", "Molinara", "Benevento (BN)"), new structType.ptr("F288", "Molinella", "Bologna (BO)"), new structType.ptr("F290", "Molini Di Triora", "Imperia (IM)"), new structType.ptr("F293", "Molino Dei Torti", "Alessandria (AL)"), new structType.ptr("F294", "Molise", "Campobasso (CB)"), new structType.ptr("F295", "Moliterno", "Potenza (PZ)"), new structType.ptr("F297", "Mollia", "Vercelli (VC)"), new structType.ptr("F301", "Molochio", "Reggio Calabria (RC)"), new structType.ptr("F304", "Molteno", "Lecco (LC)"), new structType.ptr("F305", "Moltrasio", "Como (CO)"), new structType.ptr("F306", "Molvena", "Vicenza (VI)"), new structType.ptr("F307", "Molveno", "Trento (TN)"), new structType.ptr("F308", "Mombaldone", "Asti (AT)"), new structType.ptr("F309", "Mombarcaro", "Cuneo (CN)"), new structType.ptr("F310", "Mombaroccio", "Pesaro e Urbino (PU)"), new structType.ptr("F311", "Mombaruzzo", "Asti (AT)"), new structType.ptr("F312", "Mombasiglio", "Cuneo (CN)"), new structType.ptr("F315", "Mombello Di Torino", "Torino (TO)"), new structType.ptr("F313", "Mombello Monferrato", "Alessandria (AL)"), new structType.ptr("F316", "Mombercelli", "Asti (AT)"), new structType.ptr("F317", "Momo", "Novara (NO)"), new structType.ptr("F318", "Mompantero", "Torino (TO)"), new structType.ptr("F319", "Mompeo", "Rieti (RI)"), new structType.ptr("F320", "Momperone", "Alessandria (AL)"), new structType.ptr("F322", "Monacilioni", "Campobasso (CB)"), new structType.ptr("F323", "Monale", "Asti (AT)"), new structType.ptr("F324", "Monasterace", "Reggio Calabria (RC)"), new structType.ptr("F325", "Monastero Bormida", "Asti (AT)"), new structType.ptr("F327", "Monastero Di Lanzo", "Torino (TO)"), new structType.ptr("F326", "Monastero Di Vasco", "Cuneo (CN)"), new structType.ptr("F329", "Monasterolo Casotto", "Cuneo (CN)"), new structType.ptr("F328", "Monasterolo Del Castello", "Bergamo (BG)"), new structType.ptr("F330", "Monasterolo Di Savigliano", "Cuneo (CN)"), new structType.ptr("F332", "Monastier Di Treviso", "Treviso (TV)"), new structType.ptr("F333", "Monastir", "Cagliari (CA)"), new structType.ptr("F335", "Moncalieri", "Torino (TO)"), new structType.ptr("F336", "Moncalvo", "Asti (AT)"), new structType.ptr("D553", "Moncenisio", "Torino (TO)"), new structType.ptr("F337", "Moncestino", "Alessandria (AL)"), new structType.ptr("F338", "Monchiero", "Cuneo (CN)"), new structType.ptr("F340", "Monchio Delle Corti", "Parma (PR)"), new structType.ptr("F342", "Moncrivello", "Vercelli (VC)"), new structType.ptr("F343", "Moncucco Torinese", "Asti (AT)"), new structType.ptr("F346", "Mondaino", "Rimini (RN)"), new structType.ptr("F347", "Mondavio", "Pesaro e Urbino (PU)"), new structType.ptr("F348", "Mondolfo", "Pesaro e Urbino (PU)"), new structType.ptr("F351", "Mondov\xC3\xAC", "Cuneo (CN)"), new structType.ptr("F352", "Mondragone", "Caserta (CE)"), new structType.ptr("F354", "Moneglia", "Genova (GE)"), new structType.ptr("F355", "Monesiglio", "Cuneo (CN)"), new structType.ptr("F356", "Monfalcone", "Gorizia (GO)"), new structType.ptr("F358", "Monforte D'Alba", "Cuneo (CN)"), new structType.ptr("F359", "Monforte San Giorgio", "Messina (ME)"), new structType.ptr("F360", "Monfumo", "Treviso (TV)"), new structType.ptr("F361", "Mongardino", "Asti (AT)"), new structType.ptr("F363", "Monghidoro", "Bologna (BO)"), new structType.ptr("F364", "Mongiana", "Vibo Valentia (VV)"), new structType.ptr("F365", "Mongiardino Ligure", "Alessandria (AL)"), new structType.ptr("F368", "Mongiuffi Melia", "Messina (ME)"), new structType.ptr("F369", "Mongrando", "Biella (BI)"), new structType.ptr("F370", "Mongrassano", "Cosenza (CS)"), new structType.ptr("F371", "Monguelfo-Tesido .Welsberg-Taisten.", "Bolzano (BZ)"), new structType.ptr("F372", "Monguzzo", "Como (CO)"), new structType.ptr("F373", "Moniga Del Garda", "Brescia (BS)"), new structType.ptr("F374", "Monleale", "Alessandria (AL)"), new structType.ptr("F375", "Monno", "Brescia (BS)"), new structType.ptr("F376", "Monopoli", "Bari (BA)"), new structType.ptr("F377", "Monreale", "Palermo (PA)"), new structType.ptr("F378", "Monrupino", "Trieste (TS)"), new structType.ptr("F379", "Monsampietro Morico", "Fermo (FM)"), new structType.ptr("F380", "Monsampolo Del Tronto", "Ascoli Piceno (AP)"), new structType.ptr("F381", "Monsano", "Ancona (AN)"), new structType.ptr("F382", "Monselice", "Padova (PD)"), new structType.ptr("F383", "Monserrato", "Cagliari (CA)"), new structType.ptr("F384", "Monsummano Terme", "Pistoia (PT)"), new structType.ptr("F385", "Mont\xC3\xA0", "Cuneo (CN)"), new structType.ptr("F386", "Montabone", "Asti (AT)"), new structType.ptr("F387", "Montacuto", "Alessandria (AL)"), new structType.ptr("F390", "Montafia", "Asti (AT)"), new structType.ptr("F391", "Montagano", "Campobasso (CB)"), new structType.ptr("F392", "Montagna .Montan.", "Bolzano (BZ)"), new structType.ptr("F393", "Montagna In Valtellina", "Sondrio (SO)"), new structType.ptr("F394", "Montagnana", "Padova (PD)"), new structType.ptr("F395", "Montagnareale", "Messina (ME)"), new structType.ptr("F397", "Montaguto", "Avellino (AV)"), new structType.ptr("F398", "Montaione", "Firenze (FI)"), new structType.ptr("F400", "Montalbano Elicona", "Messina (ME)"), new structType.ptr("F399", "Montalbano Jonico", "Matera (MT)"), new structType.ptr("M378", "Montalcino", "Siena (SI)"), new structType.ptr("F403", "Montaldeo", "Alessandria (AL)"), new structType.ptr("F404", "Montaldo Bormida", "Alessandria (AL)"), new structType.ptr("F405", "Montaldo Di Mondov\xC3\xAC", "Cuneo (CN)"), new structType.ptr("F408", "Montaldo Roero", "Cuneo (CN)"), new structType.ptr("F409", "Montaldo Scarampi", "Asti (AT)"), new structType.ptr("F407", "Montaldo Torinese", "Torino (TO)"), new structType.ptr("F410", "Montale", "Pistoia (PT)"), new structType.ptr("F411", "Montalenghe", "Torino (TO)"), new structType.ptr("F414", "Montallegro", "Agrigento (AG)"), new structType.ptr("F415", "Montalto Delle Marche", "Ascoli Piceno (AP)"), new structType.ptr("F419", "Montalto Di Castro", "Viterbo (VT)"), new structType.ptr("F420", "Montalto Dora", "Torino (TO)"), new structType.ptr("F406", "Montalto Ligure", "Imperia (IM)"), new structType.ptr("F417", "Montalto Pavese", "Pavia (PV)"), new structType.ptr("F416", "Montalto Uffugo", "Cosenza (CS)"), new structType.ptr("F422", "Montanaro", "Torino (TO)"), new structType.ptr("F423", "Montanaso Lombardo", "Lodi (LO)"), new structType.ptr("F424", "Montanera", "Cuneo (CN)"), new structType.ptr("F426", "Montano Antilia", "Salerno (SA)"), new structType.ptr("F427", "Montano Lucino", "Como (CO)"), new structType.ptr("F428", "Montappone", "Fermo (FM)"), new structType.ptr("F429", "Montaquila", "Isernia (IS)"), new structType.ptr("F430", "Montasola", "Rieti (RI)"), new structType.ptr("F432", "Montauro", "Catanzaro (CZ)"), new structType.ptr("F433", "Montazzoli", "Chieti (CH)"), new structType.ptr("F437", "Monte Argentario", "Grosseto (GR)"), new structType.ptr("F456", "Monte Castello Di Vibio", "Perugia (PG)"), new structType.ptr("F460", "Monte Cavallo", "Macerata (MC)"), new structType.ptr("F467", "Monte Cerignone", "Pesaro e Urbino (PU)"), new structType.ptr("F477", "Monte Compatri", "Roma (RM)"), new structType.ptr("F434", "Monte Cremasco", "Cremona (CR)"), new structType.ptr("F486", "Monte Di Malo", "Vicenza (VI)"), new structType.ptr("F488", "Monte Di Procida", "Napoli (NA)"), new structType.ptr("F517", "Monte Giberto", "Fermo (FM)"), new structType.ptr("F524", "Monte Grimano Terme", "Pesaro e Urbino (PU)"), new structType.ptr("F532", "Monte Isola", "Brescia (BS)"), new structType.ptr("F561", "Monte Marenzo", "Lecco (LC)"), new structType.ptr("F589", "Monte Porzio", "Pesaro e Urbino (PU)"), new structType.ptr("F590", "Monte Porzio Catone", "Roma (RM)"), new structType.ptr("F599", "Monte Rinaldo", "Fermo (FM)"), new structType.ptr("F600", "Monte Roberto", "Ancona (AN)"), new structType.ptr("F603", "Monte Romano", "Viterbo (VT)"), new structType.ptr("F616", "Monte San Biagio", "Latina (LT)"), new structType.ptr("F618", "Monte San Giacomo", "Salerno (SA)"), new structType.ptr("F620", "Monte San Giovanni Campano", "Frosinone (FR)"), new structType.ptr("F619", "Monte San Giovanni In Sabina", "Rieti (RI)"), new structType.ptr("F621", "Monte San Giusto", "Macerata (MC)"), new structType.ptr("F622", "Monte San Martino", "Macerata (MC)"), new structType.ptr("F626", "Monte San Pietrangeli", "Fermo (FM)"), new structType.ptr("F627", "Monte San Pietro", "Bologna (BO)"), new structType.ptr("F628", "Monte San Savino", "Arezzo (AR)"), new structType.ptr("F634", "Monte San Vito", "Ancona (AN)"), new structType.ptr("F629", "Monte Santa Maria Tiberina", "Perugia (PG)"), new structType.ptr("F631", "Monte Sant'Angelo", "Foggia (FG)"), new structType.ptr("F653", "Monte Urano", "Fermo (FM)"), new structType.ptr("F664", "Monte Vidon Combatte", "Fermo (FM)"), new structType.ptr("F665", "Monte Vidon Corrado", "Fermo (FM)"), new structType.ptr("F440", "Montebello Della Battaglia", "Pavia (PV)"), new structType.ptr("F441", "Montebello Di Bertona", "Pescara (PE)"), new structType.ptr("D746", "Montebello Ionico", "Reggio Calabria (RC)"), new structType.ptr("B268", "Montebello Sul Sangro", "Chieti (CH)"), new structType.ptr("F442", "Montebello Vicentino", "Vicenza (VI)"), new structType.ptr("F443", "Montebelluna", "Treviso (TV)"), new structType.ptr("F445", "Montebruno", "Genova (GE)"), new structType.ptr("F446", "Montebuono", "Rieti (RI)"), new structType.ptr("F450", "Montecalvo In Foglia", "Pesaro e Urbino (PU)"), new structType.ptr("F448", "Montecalvo Irpino", "Avellino (AV)"), new structType.ptr("F449", "Montecalvo Versiggia", "Pavia (PV)"), new structType.ptr("F452", "Montecarlo", "Lucca (LU)"), new structType.ptr("F453", "Montecarotto", "Ancona (AN)"), new structType.ptr("F454", "Montecassiano", "Macerata (MC)"), new structType.ptr("F455", "Montecastello", "Alessandria (AL)"), new structType.ptr("F457", "Montecastrilli", "Terni (TR)"), new structType.ptr("A561", "Montecatini Terme", "Pistoia (PT)"), new structType.ptr("F458", "Montecatini Val Di Cecina", "Pisa (PI)"), new structType.ptr("F461", "Montecchia Di Crosara", "Verona (VR)"), new structType.ptr("F462", "Montecchio", "Terni (TR)"), new structType.ptr("F463", "Montecchio Emilia", "Reggio Emilia (RE)"), new structType.ptr("F464", "Montecchio Maggiore", "Vicenza (VI)"), new structType.ptr("F465", "Montecchio Precalcino", "Vicenza (VI)"), new structType.ptr("F469", "Montechiaro D'Acqui", "Alessandria (AL)"), new structType.ptr("F468", "Montechiaro D'Asti", "Asti (AT)"), new structType.ptr("F473", "Montechiarugolo", "Parma (PR)"), new structType.ptr("F474", "Monteciccardo", "Pesaro e Urbino (PU)"), new structType.ptr("F475", "Montecilfone", "Campobasso (CB)"), new structType.ptr("F478", "Montecopiolo", "Pesaro e Urbino (PU)"), new structType.ptr("F479", "Montecorice", "Salerno (SA)"), new structType.ptr("F480", "Montecorvino Pugliano", "Salerno (SA)"), new structType.ptr("F481", "Montecorvino Rovella", "Salerno (SA)"), new structType.ptr("F482", "Montecosaro", "Macerata (MC)"), new structType.ptr("F483", "Montecrestese", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("F484", "Montecreto", "Modena (MO)"), new structType.ptr("F487", "Montedinove", "Ascoli Piceno (AP)"), new structType.ptr("F489", "Montedoro", "Caltanissetta (CL)"), new structType.ptr("F491", "Montefalcione", "Avellino (AV)"), new structType.ptr("F492", "Montefalco", "Perugia (PG)"), new structType.ptr("F493", "Montefalcone Appennino", "Fermo (FM)"), new structType.ptr("F494", "Montefalcone Di Val Fortore", "Benevento (BN)"), new structType.ptr("F495", "Montefalcone Nel Sannio", "Campobasso (CB)"), new structType.ptr("F496", "Montefano", "Macerata (MC)"), new structType.ptr("F497", "Montefelcino", "Pesaro e Urbino (PU)"), new structType.ptr("F498", "Monteferrante", "Chieti (CH)"), new structType.ptr("F499", "Montefiascone", "Viterbo (VT)"), new structType.ptr("F500", "Montefino", "Teramo (TE)"), new structType.ptr("F502", "Montefiore Conca", "Rimini (RN)"), new structType.ptr("F501", "Montefiore Dell'Aso", "Ascoli Piceno (AP)"), new structType.ptr("F503", "Montefiorino", "Modena (MO)"), new structType.ptr("F504", "Monteflavio", "Roma (RM)"), new structType.ptr("F507", "Monteforte Cilento", "Salerno (SA)"), new structType.ptr("F508", "Monteforte D'Alpone", "Verona (VR)"), new structType.ptr("F506", "Monteforte Irpino", "Avellino (AV)"), new structType.ptr("F509", "Montefortino", "Fermo (FM)"), new structType.ptr("F510", "Montefranco", "Terni (TR)"), new structType.ptr("F511", "Montefredane", "Avellino (AV)"), new structType.ptr("F512", "Montefusco", "Avellino (AV)"), new structType.ptr("F513", "Montegabbione", "Terni (TR)"), new structType.ptr("F514", "Montegalda", "Vicenza (VI)"), new structType.ptr("F515", "Montegaldella", "Vicenza (VI)"), new structType.ptr("F516", "Montegallo", "Ascoli Piceno (AP)"), new structType.ptr("F518", "Montegioco", "Alessandria (AL)"), new structType.ptr("F519", "Montegiordano", "Cosenza (CS)"), new structType.ptr("F520", "Montegiorgio", "Fermo (FM)"), new structType.ptr("F522", "Montegranaro", "Fermo (FM)"), new structType.ptr("F523", "Montegridolfo", "Rimini (RN)"), new structType.ptr("F526", "Montegrino Valtravaglia", "Varese (VA)"), new structType.ptr("F527", "Montegrosso D'Asti", "Asti (AT)"), new structType.ptr("F528", "Montegrosso Pian Latte", "Imperia (IM)"), new structType.ptr("F529", "Montegrotto Terme", "Padova (PD)"), new structType.ptr("F531", "Monteiasi", "Taranto (TA)"), new structType.ptr("F533", "Montelabbate", "Pesaro e Urbino (PU)"), new structType.ptr("F534", "Montelanico", "Roma (RM)"), new structType.ptr("F535", "Montelapiano", "Chieti (CH)"), new structType.ptr("F536", "Monteleone Di Fermo", "Fermo (FM)"), new structType.ptr("F538", "Monteleone Di Puglia", "Foggia (FG)"), new structType.ptr("F540", "Monteleone Di Spoleto", "Perugia (PG)"), new structType.ptr("F543", "Monteleone D'Orvieto", "Terni (TR)"), new structType.ptr("F542", "Monteleone Rocca Doria", "Sassari (SS)"), new structType.ptr("F541", "Monteleone Sabino", "Rieti (RI)"), new structType.ptr("F544", "Montelepre", "Palermo (PA)"), new structType.ptr("F545", "Montelibretti", "Roma (RM)"), new structType.ptr("F546", "Montella", "Avellino (AV)"), new structType.ptr("F547", "Montello", "Bergamo (BG)"), new structType.ptr("F548", "Montelongo", "Campobasso (CB)"), new structType.ptr("F549", "Montelparo", "Fermo (FM)"), new structType.ptr("F550", "Montelupo Albese", "Cuneo (CN)"), new structType.ptr("F551", "Montelupo Fiorentino", "Firenze (FI)"), new structType.ptr("F552", "Montelupone", "Macerata (MC)"), new structType.ptr("F553", "Montemaggiore Belsito", "Palermo (PA)"), new structType.ptr("F556", "Montemagno", "Asti (AT)"), new structType.ptr("F558", "Montemale Di Cuneo", "Cuneo (CN)"), new structType.ptr("F559", "Montemarano", "Avellino (AV)"), new structType.ptr("F560", "Montemarciano", "Ancona (AN)"), new structType.ptr("F562", "Montemarzino", "Alessandria (AL)"), new structType.ptr("F563", "Montemesola", "Taranto (TA)"), new structType.ptr("F564", "Montemezzo", "Como (CO)"), new structType.ptr("F565", "Montemignaio", "Arezzo (AR)"), new structType.ptr("F566", "Montemiletto", "Avellino (AV)"), new structType.ptr("F568", "Montemilone", "Potenza (PZ)"), new structType.ptr("F569", "Montemitro", "Campobasso (CB)"), new structType.ptr("F570", "Montemonaco", "Ascoli Piceno (AP)"), new structType.ptr("F572", "Montemurlo", "Prato (PO)"), new structType.ptr("F573", "Montemurro", "Potenza (PZ)"), new structType.ptr("F574", "Montenars", "Udine (UD)"), new structType.ptr("F576", "Montenero Di Bisaccia", "Campobasso (CB)"), new structType.ptr("F579", "Montenero Sabino", "Rieti (RI)"), new structType.ptr("F580", "Montenero Val Cocchiara", "Isernia (IS)"), new structType.ptr("F578", "Montenerodomo", "Chieti (CH)"), new structType.ptr("F582", "Monteodorisio", "Chieti (CH)"), new structType.ptr("F586", "Montepaone", "Catanzaro (CZ)"), new structType.ptr("F587", "Monteparano", "Taranto (TA)"), new structType.ptr("F591", "Monteprandone", "Ascoli Piceno (AP)"), new structType.ptr("F592", "Montepulciano", "Siena (SI)"), new structType.ptr("F594", "Monterchi", "Arezzo (AR)"), new structType.ptr("F595", "Montereale", "L'Aquila (AQ)"), new structType.ptr("F596", "Montereale Valcellina", "Pordenone (PN)"), new structType.ptr("F597", "Monterenzio", "Bologna (BO)"), new structType.ptr("F598", "Monteriggioni", "Siena (SI)"), new structType.ptr("F601", "Monteroduni", "Isernia (IS)"), new structType.ptr("F605", "Monteroni D'Arbia", "Siena (SI)"), new structType.ptr("F604", "Monteroni Di Lecce", "Lecce (LE)"), new structType.ptr("F606", "Monterosi", "Viterbo (VT)"), new structType.ptr("F609", "Monterosso Al Mare", "La Spezia (SP)"), new structType.ptr("F610", "Monterosso Almo", "Ragusa (RG)"), new structType.ptr("F607", "Monterosso Calabro", "Vibo Valentia (VV)"), new structType.ptr("F608", "Monterosso Grana", "Cuneo (CN)"), new structType.ptr("F611", "Monterotondo", "Roma (RM)"), new structType.ptr("F612", "Monterotondo Marittimo", "Grosseto (GR)"), new structType.ptr("F614", "Monterubbiano", "Fermo (FM)"), new structType.ptr("F623", "Montesano Salentino", "Lecce (LE)"), new structType.ptr("F625", "Montesano Sulla Marcellana", "Salerno (SA)"), new structType.ptr("F636", "Montesarchio", "Benevento (BN)"), new structType.ptr("F637", "Montescaglioso", "Matera (MT)"), new structType.ptr("F638", "Montescano", "Pavia (PV)"), new structType.ptr("F639", "Montescheno", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("F640", "Montescudaio", "Pisa (PI)"), new structType.ptr("M368", "Montescudo-Monte Colombo", "Rimini (RN)"), new structType.ptr("F642", "Montese", "Modena (MO)"), new structType.ptr("F644", "Montesegale", "Pavia (PV)"), new structType.ptr("F646", "Montesilvano", "Pescara (PE)"), new structType.ptr("F648", "Montespertoli", "Firenze (FI)"), new structType.ptr("F651", "Monteu Da Po", "Torino (TO)"), new structType.ptr("F654", "Monteu Roero", "Cuneo (CN)"), new structType.ptr("F655", "Montevago", "Agrigento (AG)"), new structType.ptr("F656", "Montevarchi", "Arezzo (AR)"), new structType.ptr("F657", "Montevecchia", "Lecco (LC)"), new structType.ptr("F660", "Monteverde", "Avellino (AV)"), new structType.ptr("F661", "Monteverdi Marittimo", "Pisa (PI)"), new structType.ptr("F662", "Monteviale", "Vicenza (VI)"), new structType.ptr("F666", "Montezemolo", "Cuneo (CN)"), new structType.ptr("F667", "Monti", "Olbia-Tempio (OT)"), new structType.ptr("F668", "Montiano", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("F672", "Monticelli Brusati", "Brescia (BS)"), new structType.ptr("F671", "Monticelli D'Ongina", "Piacenza (PC)"), new structType.ptr("F670", "Monticelli Pavese", "Pavia (PV)"), new structType.ptr("F674", "Monticello Brianza", "Lecco (LC)"), new structType.ptr("F675", "Monticello Conte Otto", "Vicenza (VI)"), new structType.ptr("F669", "Monticello D'Alba", "Cuneo (CN)"), new structType.ptr("F471", "Montichiari", "Brescia (BS)"), new structType.ptr("F676", "Monticiano", "Siena (SI)"), new structType.ptr("F677", "Montieri", "Grosseto (GR)"), new structType.ptr("M302", "Montiglio Monferrato", "Asti (AT)"), new structType.ptr("F679", "Montignoso", "Massa-Carrara (MS)"), new structType.ptr("F680", "Montirone", "Brescia (BS)"), new structType.ptr("F367", "Montjovet", "Aosta (AO)"), new structType.ptr("F681", "Montodine", "Cremona (CR)"), new structType.ptr("F682", "Montoggio", "Genova (GE)"), new structType.ptr("F685", "Montone", "Perugia (PG)"), new structType.ptr("F687", "Montopoli Di Sabina", "Rieti (RI)"), new structType.ptr("F686", "Montopoli In Val D'Arno", "Pisa (PI)"), new structType.ptr("F688", "Montorfano", "Como (CO)"), new structType.ptr("F690", "Montorio Al Vomano", "Teramo (TE)"), new structType.ptr("F689", "Montorio Nei Frentani", "Campobasso (CB)"), new structType.ptr("F692", "Montorio Romano", "Roma (RM)"), new structType.ptr("M330", "Montoro", "Avellino (AV)"), new structType.ptr("F696", "Montorso Vicentino", "Vicenza (VI)"), new structType.ptr("F697", "Montottone", "Fermo (FM)"), new structType.ptr("F698", "Montresta", "Oristano (OR)"), new structType.ptr("F701", "Montu' Beccaria", "Pavia (PV)"), new structType.ptr("F703", "Monvalle", "Varese (VA)"), new structType.ptr("F704", "Monza", "Monza e della Brianza (MB)"), new structType.ptr("F705", "Monzambano", "Mantova (MN)"), new structType.ptr("F706", "Monzuno", "Bologna (BO)"), new structType.ptr("F708", "Morano Calabro", "Cosenza (CS)"), new structType.ptr("F707", "Morano Sul Po", "Alessandria (AL)"), new structType.ptr("F709", "Moransengo", "Asti (AT)"), new structType.ptr("F710", "Moraro", "Gorizia (GO)"), new structType.ptr("F711", "Morazzone", "Varese (VA)"), new structType.ptr("F712", "Morbegno", "Sondrio (SO)"), new structType.ptr("F713", "Morbello", "Alessandria (AL)"), new structType.ptr("F716", "Morciano Di Leuca", "Lecce (LE)"), new structType.ptr("F715", "Morciano Di Romagna", "Rimini (RN)"), new structType.ptr("F717", "Morcone", "Benevento (BN)"), new structType.ptr("F718", "Mordano", "Bologna (BO)"), new structType.ptr("F720", "Morengo", "Bergamo (BG)"), new structType.ptr("F721", "Mores", "Sassari (SS)"), new structType.ptr("F722", "Moresco", "Fermo (FM)"), new structType.ptr("F723", "Moretta", "Cuneo (CN)"), new structType.ptr("F724", "Morfasso", "Piacenza (PC)"), new structType.ptr("F725", "Morgano", "Treviso (TV)"), new structType.ptr("F726", "Morgex", "Aosta (AO)"), new structType.ptr("F727", "Morgongiori", "Oristano (OR)"), new structType.ptr("F728", "Mori", "Trento (TN)"), new structType.ptr("F729", "Moriago Della Battaglia", "Treviso (TV)"), new structType.ptr("F730", "Moricone", "Roma (RM)"), new structType.ptr("F731", "Morigerati", "Salerno (SA)"), new structType.ptr("D033", "Morimondo", "Milano (MI)"), new structType.ptr("F732", "Morino", "L'Aquila (AQ)"), new structType.ptr("F733", "Moriondo Torinese", "Torino (TO)"), new structType.ptr("F734", "Morlupo", "Roma (RM)"), new structType.ptr("F735", "Mormanno", "Cosenza (CS)"), new structType.ptr("F736", "Mornago", "Varese (VA)"), new structType.ptr("F737", "Mornese", "Alessandria (AL)"), new structType.ptr("F738", "Mornico Al Serio", "Bergamo (BG)"), new structType.ptr("F739", "Mornico Losana", "Pavia (PV)"), new structType.ptr("F740", "Morolo", "Frosinone (FR)"), new structType.ptr("F743", "Morozzo", "Cuneo (CN)"), new structType.ptr("F744", "Morra De Sanctis", "Avellino (AV)"), new structType.ptr("F745", "Morro D'Alba", "Ancona (AN)"), new structType.ptr("F747", "Morro D'Oro", "Teramo (TE)"), new structType.ptr("F746", "Morro Reatino", "Rieti (RI)"), new structType.ptr("F748", "Morrone Del Sannio", "Campobasso (CB)"), new structType.ptr("F749", "Morrovalle", "Macerata (MC)"), new structType.ptr("F750", "Morsano Al Tagliamento", "Pordenone (PN)"), new structType.ptr("F751", "Morsasco", "Alessandria (AL)"), new structType.ptr("F754", "Mortara", "Pavia (PV)"), new structType.ptr("F756", "Mortegliano", "Udine (UD)"), new structType.ptr("F758", "Morterone", "Lecco (LC)"), new structType.ptr("F760", "Moruzzo", "Udine (UD)"), new structType.ptr("F761", "Moscazzano", "Cremona (CR)"), new structType.ptr("F762", "Moschiano", "Avellino (AV)"), new structType.ptr("F764", "Mosciano Sant'Angelo", "Teramo (TE)"), new structType.ptr("F765", "Moscufo", "Pescara (PE)"), new structType.ptr("F766", "Moso In Passiria .Moos In Passeier.", "Bolzano (BZ)"), new structType.ptr("F767", "Mossa", "Gorizia (GO)"), new structType.ptr("F768", "Mossano", "Vicenza (VI)"), new structType.ptr("M304", "Mosso", "Biella (BI)"), new structType.ptr("F771", "Motta Baluffi", "Cremona (CR)"), new structType.ptr("F772", "Motta Camastra", "Messina (ME)"), new structType.ptr("F773", "Motta D'Affermo", "Messina (ME)"), new structType.ptr("F774", "Motta De' Conti", "Vercelli (VC)"), new structType.ptr("F770", "Motta Di Livenza", "Treviso (TV)"), new structType.ptr("F777", "Motta Montecorvino", "Foggia (FG)"), new structType.ptr("F779", "Motta San Giovanni", "Reggio Calabria (RC)"), new structType.ptr("F780", "Motta Santa Lucia", "Catanzaro (CZ)"), new structType.ptr("F781", "Motta Sant'Anastasia", "Catania (CT)"), new structType.ptr("F783", "Motta Visconti", "Milano (MI)"), new structType.ptr("F775", "Mottafollone", "Cosenza (CS)"), new structType.ptr("F776", "Mottalciata", "Biella (BI)"), new structType.ptr("B012", "Motteggiana", "Mantova (MN)"), new structType.ptr("F784", "Mottola", "Taranto (TA)"), new structType.ptr("F785", "Mozzagrogna", "Chieti (CH)"), new structType.ptr("F786", "Mozzanica", "Bergamo (BG)"), new structType.ptr("F788", "Mozzate", "Como (CO)"), new structType.ptr("F789", "Mozzecane", "Verona (VR)"), new structType.ptr("F791", "Mozzo", "Bergamo (BG)"), new structType.ptr("F793", "Muccia", "Macerata (MC)"), new structType.ptr("F795", "Muggia", "Trieste (TS)"), new structType.ptr("F797", "Muggi\xC3\xB2", "Monza e della Brianza (MB)"), new structType.ptr("F798", "Mugnano Del Cardinale", "Avellino (AV)"), new structType.ptr("F799", "Mugnano Di Napoli", "Napoli (NA)"), new structType.ptr("F801", "Mulazzano", "Lodi (LO)"), new structType.ptr("F802", "Mulazzo", "Massa-Carrara (MS)"), new structType.ptr("F806", "Mura", "Brescia (BS)"), new structType.ptr("F808", "Muravera", "Cagliari (CA)"), new structType.ptr("F809", "Murazzano", "Cuneo (CN)"), new structType.ptr("F811", "Murello", "Cuneo (CN)"), new structType.ptr("F813", "Murialdo", "Savona (SV)"), new structType.ptr("F814", "Murisengo", "Alessandria (AL)"), new structType.ptr("F815", "Murlo", "Siena (SI)"), new structType.ptr("F816", "Muro Leccese", "Lecce (LE)"), new structType.ptr("F817", "Muro Lucano", "Potenza (PZ)"), new structType.ptr("F818", "Muros", "Sassari (SS)"), new structType.ptr("F820", "Muscoline", "Brescia (BS)"), new structType.ptr("F822", "Musei", "Carbonia-Iglesias (CI)"), new structType.ptr("F826", "Musile Di Piave", "Venezia (VE)"), new structType.ptr("F828", "Musso", "Como (CO)"), new structType.ptr("F829", "Mussolente", "Vicenza (VI)"), new structType.ptr("F830", "Mussomeli", "Caltanissetta (CL)"), new structType.ptr("F832", "Muzzana Del Turgnano", "Udine (UD)"), new structType.ptr("F833", "Muzzano", "Biella (BI)"), new structType.ptr("F835", "Nago-Torbole", "Trento (TN)"), new structType.ptr("F836", "Nalles .Nals.", "Bolzano (BZ)"), new structType.ptr("F838", "Nanto", "Vicenza (VI)"), new structType.ptr("F839", "Napoli", "Napoli (NA)"), new structType.ptr("F840", "Narbolia", "Oristano (OR)"), new structType.ptr("F841", "Narcao", "Carbonia-Iglesias (CI)"), new structType.ptr("F842", "Nard\xC3\xB2", "Lecce (LE)"), new structType.ptr("F843", "Nardodipace", "Vibo Valentia (VV)"), new structType.ptr("F844", "Narni", "Terni (TR)"), new structType.ptr("F845", "Naro", "Agrigento (AG)"), new structType.ptr("F846", "Narzole", "Cuneo (CN)"), new structType.ptr("F847", "Nasino", "Savona (SV)"), new structType.ptr("F848", "Naso", "Messina (ME)"), new structType.ptr("F849", "Naturno .Naturns.", "Bolzano (BZ)"), new structType.ptr("F851", "Nave", "Brescia (BS)"), new structType.ptr("F853", "Nave San Rocco", "Trento (TN)"), new structType.ptr("F852", "Navelli", "L'Aquila (AQ)"), new structType.ptr("F856", "Naz Sciaves .Natz Schabs.", "Bolzano (BZ)"), new structType.ptr("F857", "Nazzano", "Roma (RM)"), new structType.ptr("F858", "Ne", "Genova (GE)"), new structType.ptr("F859", "Nebbiuno", "Novara (NO)"), new structType.ptr("F861", "Negrar", "Verona (VR)"), new structType.ptr("F862", "Neirone", "Genova (GE)"), new structType.ptr("F863", "Neive", "Cuneo (CN)"), new structType.ptr("F864", "Nembro", "Bergamo (BG)"), new structType.ptr("F865", "Nemi", "Roma (RM)"), new structType.ptr("F866", "Nemoli", "Potenza (PZ)"), new structType.ptr("F867", "Neoneli", "Oristano (OR)"), new structType.ptr("F868", "Nepi", "Viterbo (VT)"), new structType.ptr("F870", "Nereto", "Teramo (TE)"), new structType.ptr("F871", "Nerola", "Roma (RM)"), new structType.ptr("F872", "Nervesa Della Battaglia", "Treviso (TV)"), new structType.ptr("F874", "Nerviano", "Milano (MI)"), new structType.ptr("F876", "Nespolo", "Rieti (RI)"), new structType.ptr("F877", "Nesso", "Como (CO)"), new structType.ptr("F878", "Netro", "Biella (BI)"), new structType.ptr("F880", "Nettuno", "Roma (RM)"), new structType.ptr("F881", "Neviano", "Lecce (LE)"), new structType.ptr("F882", "Neviano Degli Arduini", "Parma (PR)"), new structType.ptr("F883", "Neviglie", "Cuneo (CN)"), new structType.ptr("F884", "Niardo", "Brescia (BS)"), new structType.ptr("F885", "Nibbiano", "Piacenza (PC)"), new structType.ptr("F886", "Nibbiola", "Novara (NO)"), new structType.ptr("F887", "Nibionno", "Lecco (LC)"), new structType.ptr("F889", "Nichelino", "Torino (TO)"), new structType.ptr("F890", "Nicolosi", "Catania (CT)"), new structType.ptr("F891", "Nicorvo", "Pavia (PV)"), new structType.ptr("F892", "Nicosia", "Enna (EN)"), new structType.ptr("F893", "Nicotera", "Vibo Valentia (VV)"), new structType.ptr("F894", "Niella Belbo", "Cuneo (CN)"), new structType.ptr("F895", "Niella Tanaro", "Cuneo (CN)"), new structType.ptr("F898", "Nimis", "Udine (UD)"), new structType.ptr("F899", "Niscemi", "Caltanissetta (CL)"), new structType.ptr("F900", "Nissoria", "Enna (EN)"), new structType.ptr("F901", "Nizza Di Sicilia", "Messina (ME)"), new structType.ptr("F902", "Nizza Monferrato", "Asti (AT)"), new structType.ptr("F904", "Noale", "Venezia (VE)"), new structType.ptr("F906", "Noasca", "Torino (TO)"), new structType.ptr("F907", "Nocara", "Cosenza (CS)"), new structType.ptr("F908", "Nocciano", "Pescara (PE)"), new structType.ptr("F912", "Nocera Inferiore", "Salerno (SA)"), new structType.ptr("F913", "Nocera Superiore", "Salerno (SA)"), new structType.ptr("F910", "Nocera Terinese", "Catanzaro (CZ)"), new structType.ptr("F911", "Nocera Umbra", "Perugia (PG)"), new structType.ptr("F914", "Noceto", "Parma (PR)"), new structType.ptr("F915", "Noci", "Bari (BA)"), new structType.ptr("F916", "Nociglia", "Lecce (LE)"), new structType.ptr("F917", "Noepoli", "Potenza (PZ)"), new structType.ptr("F918", "Nogara", "Verona (VR)"), new structType.ptr("F920", "Nogaredo", "Trento (TN)"), new structType.ptr("F921", "Nogarole Rocca", "Verona (VR)"), new structType.ptr("F922", "Nogarole Vicentino", "Vicenza (VI)"), new structType.ptr("F923", "Noicattaro", "Bari (BA)"), new structType.ptr("F924", "Nola", "Napoli (NA)"), new structType.ptr("F925", "Nole", "Torino (TO)"), new structType.ptr("F926", "Noli", "Savona (SV)"), new structType.ptr("F927", "Nomaglio", "Torino (TO)"), new structType.ptr("F929", "Nomi", "Trento (TN)"), new structType.ptr("F930", "Nonantola", "Modena (MO)"), new structType.ptr("F931", "None", "Torino (TO)"), new structType.ptr("F932", "Nonio", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("F933", "Noragugume", "Nuoro (NU)"), new structType.ptr("F934", "Norbello", "Oristano (OR)"), new structType.ptr("F935", "Norcia", "Perugia (PG)"), new structType.ptr("F937", "Norma", "Latina (LT)"), new structType.ptr("F939", "Nosate", "Milano (MI)"), new structType.ptr("F942", "Notaresco", "Teramo (TE)"), new structType.ptr("F943", "Noto", "Siracusa (SR)"), new structType.ptr("F949", "Nova Levante .Welschnofen.", "Bolzano (BZ)"), new structType.ptr("F944", "Nova Milanese", "Monza e della Brianza (MB)"), new structType.ptr("F950", "Nova Ponente .Deutschnofen.", "Bolzano (BZ)"), new structType.ptr("A942", "Nova Siri", "Matera (MT)"), new structType.ptr("F137", "Novafeltria", "Rimini (RN)"), new structType.ptr("F947", "Novaledo", "Trento (TN)"), new structType.ptr("F948", "Novalesa", "Torino (TO)"), new structType.ptr("F952", "Novara", "Novara (NO)"), new structType.ptr("F951", "Novara Di Sicilia", "Messina (ME)"), new structType.ptr("F956", "Novate Mezzola", "Sondrio (SO)"), new structType.ptr("F955", "Novate Milanese", "Milano (MI)"), new structType.ptr("F957", "Nove", "Vicenza (VI)"), new structType.ptr("F958", "Novedrate", "Como (CO)"), new structType.ptr("F960", "Novellara", "Reggio Emilia (RE)"), new structType.ptr("F961", "Novello", "Cuneo (CN)"), new structType.ptr("F963", "Noventa Di Piave", "Venezia (VE)"), new structType.ptr("F962", "Noventa Padovana", "Padova (PD)"), new structType.ptr("F964", "Noventa Vicentina", "Vicenza (VI)"), new structType.ptr("F966", "Novi Di Modena", "Modena (MO)"), new structType.ptr("F965", "Novi Ligure", "Alessandria (AL)"), new structType.ptr("F967", "Novi Velia", "Salerno (SA)"), new structType.ptr("F968", "Noviglio", "Milano (MI)"), new structType.ptr("F970", "Novoli", "Lecce (LE)"), new structType.ptr("F972", "Nucetto", "Cuneo (CN)"), new structType.ptr("F975", "Nughedu San Nicol\xC3\xB2", "Sassari (SS)"), new structType.ptr("F974", "Nughedu Santa Vittoria", "Oristano (OR)"), new structType.ptr("F976", "Nule", "Sassari (SS)"), new structType.ptr("F977", "Nulvi", "Sassari (SS)"), new structType.ptr("F978", "Numana", "Ancona (AN)"), new structType.ptr("F979", "Nuoro", "Nuoro (NU)"), new structType.ptr("F980", "Nurachi", "Oristano (OR)"), new structType.ptr("F981", "Nuragus", "Cagliari (CA)"), new structType.ptr("F982", "Nurallao", "Cagliari (CA)"), new structType.ptr("F983", "Nuraminis", "Cagliari (CA)"), new structType.ptr("F985", "Nureci", "Oristano (OR)"), new structType.ptr("F986", "Nurri", "Cagliari (CA)"), new structType.ptr("F987", "Nus", "Aosta (AO)"), new structType.ptr("F988", "Nusco", "Avellino (AV)"), new structType.ptr("F989", "Nuvolento", "Brescia (BS)"), new structType.ptr("F990", "Nuvolera", "Brescia (BS)"), new structType.ptr("F991", "Nuxis", "Carbonia-Iglesias (CI)"), new structType.ptr("F992", "Occhieppo Inferiore", "Biella (BI)"), new structType.ptr("F993", "Occhieppo Superiore", "Biella (BI)"), new structType.ptr("F994", "Occhiobello", "Rovigo (RO)"), new structType.ptr("F995", "Occimiano", "Alessandria (AL)"), new structType.ptr("F996", "Ocre", "L'Aquila (AQ)"), new structType.ptr("F997", "Odalengo Grande", "Alessandria (AL)"), new structType.ptr("F998", "Odalengo Piccolo", "Alessandria (AL)"), new structType.ptr("F999", "Oderzo", "Treviso (TV)"), new structType.ptr("G001", "Odolo", "Brescia (BS)"), new structType.ptr("G002", "Ofena", "L'Aquila (AQ)"), new structType.ptr("G003", "Offagna", "Ancona (AN)"), new structType.ptr("G004", "Offanengo", "Cremona (CR)"), new structType.ptr("G005", "Offida", "Ascoli Piceno (AP)"), new structType.ptr("G006", "Offlaga", "Brescia (BS)"), new structType.ptr("G007", "Oggebbio", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("G008", "Oggiona Con Santo Stefano", "Varese (VA)"), new structType.ptr("G009", "Oggiono", "Lecco (LC)"), new structType.ptr("G010", "Oglianico", "Torino (TO)"), new structType.ptr("G011", "Ogliastro Cilento", "Salerno (SA)"), new structType.ptr("G015", "Olbia", "Olbia-Tempio (OT)"), new structType.ptr("G016", "Olcenengo", "Vercelli (VC)"), new structType.ptr("G018", "Oldenico", "Vercelli (VC)"), new structType.ptr("G019", "Oleggio", "Novara (NO)"), new structType.ptr("G020", "Oleggio Castello", "Novara (NO)"), new structType.ptr("G021", "Olevano Di Lomellina", "Pavia (PV)"), new structType.ptr("G022", "Olevano Romano", "Roma (RM)"), new structType.ptr("G023", "Olevano Sul Tusciano", "Salerno (SA)"), new structType.ptr("G025", "Olgiate Comasco", "Como (CO)"), new structType.ptr("G026", "Olgiate Molgora", "Lecco (LC)"), new structType.ptr("G028", "Olgiate Olona", "Varese (VA)"), new structType.ptr("G030", "Olginate", "Lecco (LC)"), new structType.ptr("G031", "Oliena", "Nuoro (NU)"), new structType.ptr("G032", "Oliva Gessi", "Pavia (PV)"), new structType.ptr("G034", "Olivadi", "Catanzaro (CZ)"), new structType.ptr("G036", "Oliveri", "Messina (ME)"), new structType.ptr("G039", "Oliveto Citra", "Salerno (SA)"), new structType.ptr("G040", "Oliveto Lario", "Lecco (LC)"), new structType.ptr("G037", "Oliveto Lucano", "Matera (MT)"), new structType.ptr("G041", "Olivetta San Michele", "Imperia (IM)"), new structType.ptr("G042", "Olivola", "Alessandria (AL)"), new structType.ptr("G043", "Ollastra", "Oristano (OR)"), new structType.ptr("G044", "Ollolai", "Nuoro (NU)"), new structType.ptr("G045", "Ollomont", "Aosta (AO)"), new structType.ptr("G046", "Olmedo", "Sassari (SS)"), new structType.ptr("G047", "Olmeneta", "Cremona (CR)"), new structType.ptr("G049", "Olmo Al Brembo", "Bergamo (BG)"), new structType.ptr("G048", "Olmo Gentile", "Asti (AT)"), new structType.ptr("G050", "Oltre Il Colle", "Bergamo (BG)"), new structType.ptr("G054", "Oltressenda Alta", "Bergamo (BG)"), new structType.ptr("G056", "Oltrona Di San Mamette", "Como (CO)"), new structType.ptr("G058", "Olzai", "Nuoro (NU)"), new structType.ptr("G061", "Ome", "Brescia (BS)"), new structType.ptr("G062", "Omegna", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("G063", "Omignano", "Salerno (SA)"), new structType.ptr("G064", "Onan\xC3\xAC", "Nuoro (NU)"), new structType.ptr("G065", "Onano", "Viterbo (VT)"), new structType.ptr("G066", "Oncino", "Cuneo (CN)"), new structType.ptr("G068", "Oneta", "Bergamo (BG)"), new structType.ptr("G070", "Onifai", "Nuoro (NU)"), new structType.ptr("G071", "Oniferi", "Nuoro (NU)"), new structType.ptr("G074", "Ono San Pietro", "Brescia (BS)"), new structType.ptr("G075", "Onore", "Bergamo (BG)"), new structType.ptr("G076", "Onzo", "Savona (SV)"), new structType.ptr("G078", "Opera", "Milano (MI)"), new structType.ptr("G079", "Opi", "L'Aquila (AQ)"), new structType.ptr("G080", "Oppeano", "Verona (VR)"), new structType.ptr("G081", "Oppido Lucano", "Potenza (PZ)"), new structType.ptr("G082", "Oppido Mamertina", "Reggio Calabria (RC)"), new structType.ptr("G083", "Ora .Auer.", "Bolzano (BZ)"), new structType.ptr("G084", "Orani", "Nuoro (NU)"), new structType.ptr("G086", "Oratino", "Campobasso (CB)"), new structType.ptr("G087", "Orbassano", "Torino (TO)"), new structType.ptr("G088", "Orbetello", "Grosseto (GR)"), new structType.ptr("G090", "Orciano Pisano", "Pisa (PI)"), new structType.ptr("D522", "Orco Feglino", "Savona (SV)"), new structType.ptr("M266", "Ordona", "Foggia (FG)"), new structType.ptr("G093", "Orero", "Genova (GE)"), new structType.ptr("G095", "Orgiano", "Vicenza (VI)"), new structType.ptr("G097", "Orgosolo", "Nuoro (NU)"), new structType.ptr("G098", "Oria", "Brindisi (BR)"), new structType.ptr("G102", "Oricola", "L'Aquila (AQ)"), new structType.ptr("G103", "Origgio", "Varese (VA)"), new structType.ptr("G105", "Orino", "Varese (VA)"), new structType.ptr("G108", "Orio Al Serio", "Bergamo (BG)"), new structType.ptr("G109", "Orio Canavese", "Torino (TO)"), new structType.ptr("G107", "Orio Litta", "Lodi (LO)"), new structType.ptr("G110", "Oriolo", "Cosenza (CS)"), new structType.ptr("G111", "Oriolo Romano", "Viterbo (VT)"), new structType.ptr("G113", "Oristano", "Oristano (OR)"), new structType.ptr("G114", "Ormea", "Cuneo (CN)"), new structType.ptr("G115", "Ormelle", "Treviso (TV)"), new structType.ptr("G116", "Ornago", "Monza e della Brianza (MB)"), new structType.ptr("G117", "Ornavasso", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("G118", "Ornica", "Bergamo (BG)"), new structType.ptr("G119", "Orosei", "Nuoro (NU)"), new structType.ptr("G120", "Orotelli", "Nuoro (NU)"), new structType.ptr("G121", "Orria", "Salerno (SA)"), new structType.ptr("G122", "Orroli", "Cagliari (CA)"), new structType.ptr("G123", "Orsago", "Treviso (TV)"), new structType.ptr("G124", "Orsara Bormida", "Alessandria (AL)"), new structType.ptr("G125", "Orsara Di Puglia", "Foggia (FG)"), new structType.ptr("G126", "Orsenigo", "Como (CO)"), new structType.ptr("G128", "Orsogna", "Chieti (CH)"), new structType.ptr("G129", "Orsomarso", "Cosenza (CS)"), new structType.ptr("G130", "Orta Di Atella", "Caserta (CE)"), new structType.ptr("G131", "Orta Nova", "Foggia (FG)"), new structType.ptr("G134", "Orta San Giulio", "Novara (NO)"), new structType.ptr("G133", "Ortacesus", "Cagliari (CA)"), new structType.ptr("G135", "Orte", "Viterbo (VT)"), new structType.ptr("G136", "Ortelle", "Lecce (LE)"), new structType.ptr("G137", "Ortezzano", "Fermo (FM)"), new structType.ptr("G139", "Ortignano Raggiolo", "Arezzo (AR)"), new structType.ptr("G140", "Ortisei .St Ulrich.", "Bolzano (BZ)"), new structType.ptr("G141", "Ortona", "Chieti (CH)"), new structType.ptr("G142", "Ortona Dei Marsi", "L'Aquila (AQ)"), new structType.ptr("G143", "Ortonovo", "La Spezia (SP)"), new structType.ptr("G144", "Ortovero", "Savona (SV)"), new structType.ptr("G145", "Ortucchio", "L'Aquila (AQ)"), new structType.ptr("G146", "Ortueri", "Nuoro (NU)"), new structType.ptr("G147", "Orune", "Nuoro (NU)"), new structType.ptr("G148", "Orvieto", "Terni (TR)"), new structType.ptr("B595", "Orvinio", "Rieti (RI)"), new structType.ptr("G149", "Orzinuovi", "Brescia (BS)"), new structType.ptr("G150", "Orzivecchi", "Brescia (BS)"), new structType.ptr("G151", "Osasco", "Torino (TO)"), new structType.ptr("G152", "Osasio", "Torino (TO)"), new structType.ptr("G153", "Oschiri", "Olbia-Tempio (OT)"), new structType.ptr("G154", "Osidda", "Nuoro (NU)"), new structType.ptr("G155", "Osiglia", "Savona (SV)"), new structType.ptr("G156", "Osilo", "Sassari (SS)"), new structType.ptr("G157", "Osimo", "Ancona (AN)"), new structType.ptr("G158", "Osini", "Ogliastra (OG)"), new structType.ptr("G159", "Osio Sopra", "Bergamo (BG)"), new structType.ptr("G160", "Osio Sotto", "Bergamo (BG)"), new structType.ptr("E529", "Osmate", "Varese (VA)"), new structType.ptr("G161", "Osnago", "Lecco (LC)"), new structType.ptr("G163", "Osoppo", "Udine (UD)"), new structType.ptr("G164", "Ospedaletti", "Imperia (IM)"), new structType.ptr("G168", "Ospedaletto", "Trento (TN)"), new structType.ptr("G165", "Ospedaletto D'Alpinolo", "Avellino (AV)"), new structType.ptr("G167", "Ospedaletto Euganeo", "Padova (PD)"), new structType.ptr("G166", "Ospedaletto Lodigiano", "Lodi (LO)"), new structType.ptr("G169", "Ospitale Di Cadore", "Belluno (BL)"), new structType.ptr("G170", "Ospitaletto", "Brescia (BS)"), new structType.ptr("G171", "Ossago Lodigiano", "Lodi (LO)"), new structType.ptr("G173", "Ossana", "Trento (TN)"), new structType.ptr("G178", "Ossi", "Sassari (SS)"), new structType.ptr("G179", "Ossimo", "Brescia (BS)"), new structType.ptr("G181", "Ossona", "Milano (MI)"), new structType.ptr("G183", "Ostana", "Cuneo (CN)"), new structType.ptr("G184", "Ostellato", "Ferrara (FE)"), new structType.ptr("G185", "Ostiano", "Cremona (CR)"), new structType.ptr("G186", "Ostiglia", "Mantova (MN)"), new structType.ptr("F401", "Ostra", "Ancona (AN)"), new structType.ptr("F581", "Ostra Vetere", "Ancona (AN)"), new structType.ptr("G187", "Ostuni", "Brindisi (BR)"), new structType.ptr("G188", "Otranto", "Lecce (LE)"), new structType.ptr("G189", "Otricoli", "Terni (TR)"), new structType.ptr("G191", "Ottana", "Nuoro (NU)"), new structType.ptr("G192", "Ottati", "Salerno (SA)"), new structType.ptr("G190", "Ottaviano", "Napoli (NA)"), new structType.ptr("G193", "Ottiglio", "Alessandria (AL)"), new structType.ptr("G194", "Ottobiano", "Pavia (PV)"), new structType.ptr("G195", "Ottone", "Piacenza (PC)"), new structType.ptr("G196", "Oulx", "Torino (TO)"), new structType.ptr("G197", "Ovada", "Alessandria (AL)"), new structType.ptr("G198", "Ovaro", "Udine (UD)"), new structType.ptr("G199", "Oviglio", "Alessandria (AL)"), new structType.ptr("G200", "Ovindoli", "L'Aquila (AQ)"), new structType.ptr("G201", "Ovodda", "Nuoro (NU)"), new structType.ptr("G012", "Oyace", "Aosta (AO)"), new structType.ptr("G202", "Ozegna", "Torino (TO)"), new structType.ptr("G203", "Ozieri", "Sassari (SS)"), new structType.ptr("G205", "Ozzano Dell'Emilia", "Bologna (BO)"), new structType.ptr("G204", "Ozzano Monferrato", "Alessandria (AL)"), new structType.ptr("G206", "Ozzero", "Milano (MI)"), new structType.ptr("G207", "Pabillonis", "Medio Campidano (VS)"), new structType.ptr("G209", "Pace Del Mela", "Messina (ME)"), new structType.ptr("G208", "Paceco", "Trapani (TP)"), new structType.ptr("G210", "Pacentro", "L'Aquila (AQ)"), new structType.ptr("G211", "Pachino", "Siracusa (SR)"), new structType.ptr("G212", "Paciano", "Perugia (PG)"), new structType.ptr("G213", "Padenghe Sul Garda", "Brescia (BS)"), new structType.ptr("G215", "Paderna", "Alessandria (AL)"), new structType.ptr("G218", "Paderno D'Adda", "Lecco (LC)"), new structType.ptr("G221", "Paderno Del Grappa", "Treviso (TV)"), new structType.ptr("G220", "Paderno Dugnano", "Milano (MI)"), new structType.ptr("G217", "Paderno Franciacorta", "Brescia (BS)"), new structType.ptr("G222", "Paderno Ponchielli", "Cremona (CR)"), new structType.ptr("G224", "Padova", "Padova (PD)"), new structType.ptr("G225", "Padria", "Sassari (SS)"), new structType.ptr("M301", "Padru", "Olbia-Tempio (OT)"), new structType.ptr("G226", "Padula", "Salerno (SA)"), new structType.ptr("G227", "Paduli", "Benevento (BN)"), new structType.ptr("G228", "Paesana", "Cuneo (CN)"), new structType.ptr("G229", "Paese", "Treviso (TV)"), new structType.ptr("G230", "Pagani", "Salerno (SA)"), new structType.ptr("G232", "Paganico Sabino", "Rieti (RI)"), new structType.ptr("G233", "Pagazzano", "Bergamo (BG)"), new structType.ptr("G234", "Pagliara", "Messina (ME)"), new structType.ptr("G237", "Paglieta", "Chieti (CH)"), new structType.ptr("G238", "Pagnacco", "Udine (UD)"), new structType.ptr("G240", "Pagno", "Cuneo (CN)"), new structType.ptr("G241", "Pagnona", "Lecco (LC)"), new structType.ptr("G242", "Pago Del Vallo Di Lauro", "Avellino (AV)"), new structType.ptr("G243", "Pago Veiano", "Benevento (BN)"), new structType.ptr("G247", "Paisco Loveno", "Brescia (BS)"), new structType.ptr("G248", "Paitone", "Brescia (BS)"), new structType.ptr("G249", "Paladina", "Bergamo (BG)"), new structType.ptr("G250", "Palagano", "Modena (MO)"), new structType.ptr("G251", "Palagianello", "Taranto (TA)"), new structType.ptr("G252", "Palagiano", "Taranto (TA)"), new structType.ptr("G253", "Palagonia", "Catania (CT)"), new structType.ptr("G254", "Palaia", "Pisa (PI)"), new structType.ptr("G255", "Palanzano", "Parma (PR)"), new structType.ptr("G257", "Palata", "Campobasso (CB)"), new structType.ptr("G258", "Palau", "Olbia-Tempio (OT)"), new structType.ptr("G259", "Palazzago", "Bergamo (BG)"), new structType.ptr("G263", "Palazzo Adriano", "Palermo (PA)"), new structType.ptr("G262", "Palazzo Canavese", "Torino (TO)"), new structType.ptr("G260", "Palazzo Pignano", "Cremona (CR)"), new structType.ptr("G261", "Palazzo San Gervasio", "Potenza (PZ)"), new structType.ptr("G267", "Palazzolo Acreide", "Siracusa (SR)"), new structType.ptr("G268", "Palazzolo Dello Stella", "Udine (UD)"), new structType.ptr("G264", "Palazzolo Sull'Oglio", "Brescia (BS)"), new structType.ptr("G266", "Palazzolo Vercellese", "Vercelli (VC)"), new structType.ptr("G270", "Palazzuolo Sul Senio", "Firenze (FI)"), new structType.ptr("G271", "Palena", "Chieti (CH)"), new structType.ptr("G272", "Palermiti", "Catanzaro (CZ)"), new structType.ptr("G273", "Palermo", "Palermo (PA)"), new structType.ptr("G274", "Palestrina", "Roma (RM)"), new structType.ptr("G275", "Palestro", "Pavia (PV)"), new structType.ptr("G276", "Paliano", "Frosinone (FR)"), new structType.ptr("G277", "Palizzi", "Reggio Calabria (RC)"), new structType.ptr("G278", "Pallagorio", "Crotone (KR)"), new structType.ptr("G280", "Pallanzeno", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("G281", "Pallare", "Savona (SV)"), new structType.ptr("G283", "Palma Campania", "Napoli (NA)"), new structType.ptr("G282", "Palma Di Montechiaro", "Agrigento (AG)"), new structType.ptr("G284", "Palmanova", "Udine (UD)"), new structType.ptr("G285", "Palmariggi", "Lecce (LE)"), new structType.ptr("G286", "Palmas Arborea", "Oristano (OR)"), new structType.ptr("G288", "Palmi", "Reggio Calabria (RC)"), new structType.ptr("G289", "Palmiano", "Ascoli Piceno (AP)"), new structType.ptr("G290", "Palmoli", "Chieti (CH)"), new structType.ptr("G291", "Palo Del Colle", "Bari (BA)"), new structType.ptr("G293", "Palombara Sabina", "Roma (RM)"), new structType.ptr("G294", "Palombaro", "Chieti (CH)"), new structType.ptr("G292", "Palomonte", "Salerno (SA)"), new structType.ptr("G295", "Palosco", "Bergamo (BG)"), new structType.ptr("G297", "Pal\xC3\xB9", "Verona (VR)"), new structType.ptr("G296", "Palu' Del Fersina", "Trento (TN)"), new structType.ptr("G298", "Paludi", "Cosenza (CS)"), new structType.ptr("G300", "Paluzza", "Udine (UD)"), new structType.ptr("G302", "Pamparato", "Cuneo (CN)"), new structType.ptr("G303", "Pancalieri", "Torino (TO)"), new structType.ptr("G304", "Pancarana", "Pavia (PV)"), new structType.ptr("G305", "Panchi\xC3\xA0", "Trento (TN)"), new structType.ptr("G306", "Pandino", "Cremona (CR)"), new structType.ptr("G307", "Panettieri", "Cosenza (CS)"), new structType.ptr("G308", "Panicale", "Perugia (PG)"), new structType.ptr("G311", "Pannarano", "Benevento (BN)"), new structType.ptr("G312", "Panni", "Foggia (FG)"), new structType.ptr("G315", "Pantelleria", "Trapani (TP)"), new structType.ptr("G316", "Pantigliate", "Milano (MI)"), new structType.ptr("G317", "Paola", "Cosenza (CS)"), new structType.ptr("G318", "Paolisi", "Benevento (BN)"), new structType.ptr("G320", "Papasidero", "Cosenza (CS)"), new structType.ptr("G323", "Papozze", "Rovigo (RO)"), new structType.ptr("G324", "Parabiago", "Milano (MI)"), new structType.ptr("G325", "Parabita", "Lecce (LE)"), new structType.ptr("G327", "Paratico", "Brescia (BS)"), new structType.ptr("G328", "Parcines .Partschins.", "Bolzano (BZ)"), new structType.ptr("G330", "Parella", "Torino (TO)"), new structType.ptr("G331", "Parenti", "Cosenza (CS)"), new structType.ptr("G333", "Parete", "Caserta (CE)"), new structType.ptr("G334", "Pareto", "Alessandria (AL)"), new structType.ptr("G335", "Parghelia", "Vibo Valentia (VV)"), new structType.ptr("G336", "Parlasco", "Lecco (LC)"), new structType.ptr("G337", "Parma", "Parma (PR)"), new structType.ptr("G338", "Parodi Ligure", "Alessandria (AL)"), new structType.ptr("G339", "Paroldo", "Cuneo (CN)"), new structType.ptr("G340", "Parolise", "Avellino (AV)"), new structType.ptr("G342", "Parona", "Pavia (PV)"), new structType.ptr("G344", "Parrano", "Terni (TR)"), new structType.ptr("G346", "Parre", "Bergamo (BG)"), new structType.ptr("G347", "Partanna", "Trapani (TP)"), new structType.ptr("G348", "Partinico", "Palermo (PA)"), new structType.ptr("G349", "Paruzzaro", "Novara (NO)"), new structType.ptr("G350", "Parzanica", "Bergamo (BG)"), new structType.ptr("G352", "Pasian Di Prato", "Udine (UD)"), new structType.ptr("G353", "Pasiano Di Pordenone", "Pordenone (PN)"), new structType.ptr("G354", "Paspardo", "Brescia (BS)"), new structType.ptr("G358", "Passerano Marmorito", "Asti (AT)"), new structType.ptr("G359", "Passignano Sul Trasimeno", "Perugia (PG)"), new structType.ptr("G361", "Passirano", "Brescia (BS)"), new structType.ptr("G362", "Pastena", "Frosinone (FR)"), new structType.ptr("G364", "Pastorano", "Caserta (CE)"), new structType.ptr("G365", "Pastrengo", "Verona (VR)"), new structType.ptr("G367", "Pasturana", "Alessandria (AL)"), new structType.ptr("G368", "Pasturo", "Lecco (LC)"), new structType.ptr("G371", "Patern\xC3\xB2", "Catania (CT)"), new structType.ptr("M269", "Paterno", "Potenza (PZ)"), new structType.ptr("G372", "Paterno Calabro", "Cosenza (CS)"), new structType.ptr("G370", "Paternopoli", "Avellino (AV)"), new structType.ptr("G374", "Patrica", "Frosinone (FR)"), new structType.ptr("G376", "Pattada", "Sassari (SS)"), new structType.ptr("G377", "Patti", "Messina (ME)"), new structType.ptr("G378", "Pat\xC3\xB9", "Lecce (LE)"), new structType.ptr("G379", "Pau", "Oristano (OR)"), new structType.ptr("G381", "Paularo", "Udine (UD)"), new structType.ptr("G382", "Pauli Arbarei", "Medio Campidano (VS)"), new structType.ptr("G384", "Paulilatino", "Oristano (OR)"), new structType.ptr("G385", "Paullo", "Milano (MI)"), new structType.ptr("G386", "Paupisi", "Benevento (BN)"), new structType.ptr("G387", "Pavarolo", "Torino (TO)"), new structType.ptr("G388", "Pavia", "Pavia (PV)"), new structType.ptr("G389", "Pavia Di Udine", "Udine (UD)"), new structType.ptr("G392", "Pavone Canavese", "Torino (TO)"), new structType.ptr("G391", "Pavone Del Mella", "Brescia (BS)"), new structType.ptr("G393", "Pavullo Nel Frignano", "Modena (MO)"), new structType.ptr("G394", "Pazzano", "Reggio Calabria (RC)"), new structType.ptr("G395", "Peccioli", "Pisa (PI)"), new structType.ptr("G396", "Pecco", "Torino (TO)"), new structType.ptr("G397", "Pecetto Di Valenza", "Alessandria (AL)"), new structType.ptr("G398", "Pecetto Torinese", "Torino (TO)"), new structType.ptr("G399", "Pecorara", "Piacenza (PC)"), new structType.ptr("G400", "Pedace", "Cosenza (CS)"), new structType.ptr("G402", "Pedara", "Catania (CT)"), new structType.ptr("G403", "Pedaso", "Fermo (FM)"), new structType.ptr("G404", "Pedavena", "Belluno (BL)"), new structType.ptr("G406", "Pedemonte", "Vicenza (VI)"), new structType.ptr("G408", "Pederobba", "Treviso (TV)"), new structType.ptr("G410", "Pedesina", "Sondrio (SO)"), new structType.ptr("G411", "Pedivigliano", "Cosenza (CS)"), new structType.ptr("G412", "Pedrengo", "Bergamo (BG)"), new structType.ptr("G415", "Peglio", "Como (CO)"), new structType.ptr("G416", "Peglio", "Pesaro e Urbino (PU)"), new structType.ptr("G417", "Pegognaga", "Mantova (MN)"), new structType.ptr("G418", "Peia", "Bergamo (BG)"), new structType.ptr("G419", "Peio", "Trento (TN)"), new structType.ptr("G420", "Pelago", "Firenze (FI)"), new structType.ptr("G421", "Pella", "Novara (NO)"), new structType.ptr("G424", "Pellegrino Parmense", "Parma (PR)"), new structType.ptr("G426", "Pellezzano", "Salerno (SA)"), new structType.ptr("G428", "Pellizzano", "Trento (TN)"), new structType.ptr("G429", "Pelugo", "Trento (TN)"), new structType.ptr("G430", "Penango", "Asti (AT)"), new structType.ptr("G432", "Penna In Teverina", "Terni (TR)"), new structType.ptr("G436", "Penna San Giovanni", "Macerata (MC)"), new structType.ptr("G437", "Penna Sant'Andrea", "Teramo (TE)"), new structType.ptr("G433", "Pennabilli", "Rimini (RN)"), new structType.ptr("G434", "Pennadomo", "Chieti (CH)"), new structType.ptr("G435", "Pennapiedimonte", "Chieti (CH)"), new structType.ptr("G438", "Penne", "Pescara (PE)"), new structType.ptr("G439", "Pentone", "Catanzaro (CZ)"), new structType.ptr("G441", "Perano", "Chieti (CH)"), new structType.ptr("G442", "Perarolo Di Cadore", "Belluno (BL)"), new structType.ptr("G443", "Perca .Percha.", "Bolzano (BZ)"), new structType.ptr("G444", "Percile", "Roma (RM)"), new structType.ptr("G445", "Perdasdefogu", "Ogliastra (OG)"), new structType.ptr("G446", "Perdaxius", "Carbonia-Iglesias (CI)"), new structType.ptr("G447", "Perdifumo", "Salerno (SA)"), new structType.ptr("G449", "Pereto", "L'Aquila (AQ)"), new structType.ptr("G450", "Perfugas", "Sassari (SS)"), new structType.ptr("G451", "Pergine Valdarno", "Arezzo (AR)"), new structType.ptr("G452", "Pergine Valsugana", "Trento (TN)"), new structType.ptr("G453", "Pergola", "Pesaro e Urbino (PU)"), new structType.ptr("G454", "Perinaldo", "Imperia (IM)"), new structType.ptr("G455", "Perito", "Salerno (SA)"), new structType.ptr("G456", "Perledo", "Lecco (LC)"), new structType.ptr("G457", "Perletto", "Cuneo (CN)"), new structType.ptr("G458", "Perlo", "Cuneo (CN)"), new structType.ptr("G459", "Perloz", "Aosta (AO)"), new structType.ptr("G461", "Pernumia", "Padova (PD)"), new structType.ptr("C013", "Pero", "Milano (MI)"), new structType.ptr("G463", "Perosa Argentina", "Torino (TO)"), new structType.ptr("G462", "Perosa Canavese", "Torino (TO)"), new structType.ptr("G465", "Perrero", "Torino (TO)"), new structType.ptr("G469", "Persico Dosimo", "Cremona (CR)"), new structType.ptr("G471", "Pertengo", "Vercelli (VC)"), new structType.ptr("G474", "Pertica Alta", "Brescia (BS)"), new structType.ptr("G475", "Pertica Bassa", "Brescia (BS)"), new structType.ptr("G476", "Pertosa", "Salerno (SA)"), new structType.ptr("G477", "Pertusio", "Torino (TO)"), new structType.ptr("G478", "Perugia", "Perugia (PG)"), new structType.ptr("G479", "Pesaro", "Pesaro e Urbino (PU)"), new structType.ptr("G480", "Pescaglia", "Lucca (LU)"), new structType.ptr("G481", "Pescantina", "Verona (VR)"), new structType.ptr("G482", "Pescara", "Pescara (PE)"), new structType.ptr("G483", "Pescarolo Ed Uniti", "Cremona (CR)"), new structType.ptr("G484", "Pescasseroli", "L'Aquila (AQ)"), new structType.ptr("G485", "Pescate", "Lecco (LC)"), new structType.ptr("G486", "Pesche", "Isernia (IS)"), new structType.ptr("G487", "Peschici", "Foggia (FG)"), new structType.ptr("G488", "Peschiera Borromeo", "Milano (MI)"), new structType.ptr("G489", "Peschiera Del Garda", "Verona (VR)"), new structType.ptr("G491", "Pescia", "Pistoia (PT)"), new structType.ptr("G492", "Pescina", "L'Aquila (AQ)"), new structType.ptr("G494", "Pesco Sannita", "Benevento (BN)"), new structType.ptr("G493", "Pescocostanzo", "L'Aquila (AQ)"), new structType.ptr("G495", "Pescolanciano", "Isernia (IS)"), new structType.ptr("G496", "Pescopagano", "Potenza (PZ)"), new structType.ptr("G497", "Pescopennataro", "Isernia (IS)"), new structType.ptr("G498", "Pescorocchiano", "Rieti (RI)"), new structType.ptr("G499", "Pescosansonesco", "Pescara (PE)"), new structType.ptr("G500", "Pescosolido", "Frosinone (FR)"), new structType.ptr("G502", "Pessano Con Bornago", "Milano (MI)"), new structType.ptr("G504", "Pessina Cremonese", "Cremona (CR)"), new structType.ptr("G505", "Pessinetto", "Torino (TO)"), new structType.ptr("G506", "Petacciato", "Campobasso (CB)"), new structType.ptr("G508", "Petilia Policastro", "Crotone (KR)"), new structType.ptr("G509", "Petina", "Salerno (SA)"), new structType.ptr("G510", "Petralia Soprana", "Palermo (PA)"), new structType.ptr("G511", "Petralia Sottana", "Palermo (PA)"), new structType.ptr("G513", "Petrella Salto", "Rieti (RI)"), new structType.ptr("G512", "Petrella Tifernina", "Campobasso (CB)"), new structType.ptr("G514", "Petriano", "Pesaro e Urbino (PU)"), new structType.ptr("G515", "Petriolo", "Macerata (MC)"), new structType.ptr("G516", "Petritoli", "Fermo (FM)"), new structType.ptr("G517", "Petrizzi", "Catanzaro (CZ)"), new structType.ptr("G518", "Petron\xC3\xA0", "Catanzaro (CZ)"), new structType.ptr("M281", "Petrosino", "Trapani (TP)"), new structType.ptr("G519", "Petruro Irpino", "Avellino (AV)"), new structType.ptr("G520", "Pettenasco", "Novara (NO)"), new structType.ptr("G521", "Pettinengo", "Biella (BI)"), new structType.ptr("G522", "Pettineo", "Messina (ME)"), new structType.ptr("G523", "Pettoranello Del Molise", "Isernia (IS)"), new structType.ptr("G524", "Pettorano Sul Gizio", "L'Aquila (AQ)"), new structType.ptr("G525", "Pettorazza Grimani", "Rovigo (RO)"), new structType.ptr("G526", "Peveragno", "Cuneo (CN)"), new structType.ptr("G528", "Pezzana", "Vercelli (VC)"), new structType.ptr("G529", "Pezzaze", "Brescia (BS)"), new structType.ptr("G532", "Pezzolo Valle Uzzone", "Cuneo (CN)"), new structType.ptr("G535", "Piacenza", "Piacenza (PC)"), new structType.ptr("G534", "Piacenza D'Adige", "Padova (PD)"), new structType.ptr("G536", "Piadena", "Cremona (CR)"), new structType.ptr("G538", "Piaggine", "Salerno (SA)"), new structType.ptr("G546", "Pian Camuno", "Brescia (BS)"), new structType.ptr("G542", "Piana Crixia", "Savona (SV)"), new structType.ptr("G543", "Piana Degli Albanesi", "Palermo (PA)"), new structType.ptr("G541", "Piana Di Monte Verna", "Caserta (CE)"), new structType.ptr("G547", "Piancastagnaio", "Siena (SI)"), new structType.ptr("G549", "Piancogno", "Brescia (BS)"), new structType.ptr("G551", "Piandimeleto", "Pesaro e Urbino (PU)"), new structType.ptr("G553", "Piane Crati", "Cosenza (CS)"), new structType.ptr("G555", "Pianella", "Pescara (PE)"), new structType.ptr("G556", "Pianello Del Lario", "Como (CO)"), new structType.ptr("G557", "Pianello Val Tidone", "Piacenza (PC)"), new structType.ptr("G558", "Pianengo", "Cremona (CR)"), new structType.ptr("G559", "Pianezza", "Torino (TO)"), new structType.ptr("G560", "Pianezze", "Vicenza (VI)"), new structType.ptr("G561", "Pianfei", "Cuneo (CN)"), new structType.ptr("G564", "Pianico", "Bergamo (BG)"), new structType.ptr("G565", "Pianiga", "Venezia (VE)"), new structType.ptr("G568", "Piano Di Sorrento", "Napoli (NA)"), new structType.ptr("D546", "Pianopoli", "Catanzaro (CZ)"), new structType.ptr("G570", "Pianoro", "Bologna (BO)"), new structType.ptr("G571", "Piansano", "Viterbo (VT)"), new structType.ptr("G572", "Piantedo", "Sondrio (SO)"), new structType.ptr("G574", "Piario", "Bergamo (BG)"), new structType.ptr("G575", "Piasco", "Cuneo (CN)"), new structType.ptr("G576", "Piateda", "Sondrio (SO)"), new structType.ptr("G577", "Piatto", "Biella (BI)"), new structType.ptr("G582", "Piazza Al Serchio", "Lucca (LU)"), new structType.ptr("G580", "Piazza Armerina", "Enna (EN)"), new structType.ptr("G579", "Piazza Brembana", "Bergamo (BG)"), new structType.ptr("G583", "Piazzatorre", "Bergamo (BG)"), new structType.ptr("G587", "Piazzola Sul Brenta", "Padova (PD)"), new structType.ptr("G588", "Piazzolo", "Bergamo (BG)"), new structType.ptr("G589", "Picciano", "Pescara (PE)"), new structType.ptr("G590", "Picerno", "Potenza (PZ)"), new structType.ptr("G591", "Picinisco", "Frosinone (FR)"), new structType.ptr("G592", "Pico", "Frosinone (FR)"), new structType.ptr("G593", "Piea", "Asti (AT)"), new structType.ptr("G594", "Piedicavallo", "Biella (BI)"), new structType.ptr("G597", "Piedimonte Etneo", "Catania (CT)"), new structType.ptr("G596", "Piedimonte Matese", "Caserta (CE)"), new structType.ptr("G598", "Piedimonte San Germano", "Frosinone (FR)"), new structType.ptr("G600", "Piedimulera", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("G601", "Piegaro", "Perugia (PG)"), new structType.ptr("G602", "Pienza", "Siena (SI)"), new structType.ptr("G603", "Pieranica", "Cremona (CR)"), new structType.ptr("G612", "Pietra De' Giorgi", "Pavia (PV)"), new structType.ptr("G605", "Pietra Ligure", "Savona (SV)"), new structType.ptr("G619", "Pietra Marazzi", "Alessandria (AL)"), new structType.ptr("G606", "Pietrabbondante", "Isernia (IS)"), new structType.ptr("G607", "Pietrabruna", "Imperia (IM)"), new structType.ptr("G608", "Pietracamela", "Teramo (TE)"), new structType.ptr("G609", "Pietracatella", "Campobasso (CB)"), new structType.ptr("G610", "Pietracupa", "Campobasso (CB)"), new structType.ptr("G611", "Pietradefusi", "Avellino (AV)"), new structType.ptr("G613", "Pietraferrazzana", "Chieti (CH)"), new structType.ptr("G615", "Pietrafitta", "Cosenza (CS)"), new structType.ptr("G616", "Pietragalla", "Potenza (PZ)"), new structType.ptr("G618", "Pietralunga", "Perugia (PG)"), new structType.ptr("G620", "Pietramelara", "Caserta (CE)"), new structType.ptr("G604", "Pietramontecorvino", "Foggia (FG)"), new structType.ptr("G621", "Pietranico", "Pescara (PE)"), new structType.ptr("G622", "Pietrapaola", "Cosenza (CS)"), new structType.ptr("G623", "Pietrapertosa", "Potenza (PZ)"), new structType.ptr("G624", "Pietraperzia", "Enna (EN)"), new structType.ptr("G625", "Pietraporzio", "Cuneo (CN)"), new structType.ptr("G626", "Pietraroja", "Benevento (BN)"), new structType.ptr("G627", "Pietrarubbia", "Pesaro e Urbino (PU)"), new structType.ptr("G628", "Pietrasanta", "Lucca (LU)"), new structType.ptr("G629", "Pietrastornina", "Avellino (AV)"), new structType.ptr("G630", "Pietravairano", "Caserta (CE)"), new structType.ptr("G631", "Pietrelcina", "Benevento (BN)"), new structType.ptr("G636", "Pieve A Nievole", "Pistoia (PT)"), new structType.ptr("G635", "Pieve Albignola", "Pavia (PV)"), new structType.ptr("G639", "Pieve Del Cairo", "Pavia (PV)"), new structType.ptr("M365", "Pieve Di Bono-Prezzo", "Trento (TN)"), new structType.ptr("G642", "Pieve Di Cadore", "Belluno (BL)"), new structType.ptr("G643", "Pieve Di Cento", "Bologna (BO)"), new structType.ptr("G633", "Pieve Di Coriano", "Mantova (MN)"), new structType.ptr("G645", "Pieve Di Soligo", "Treviso (TV)"), new structType.ptr("G632", "Pieve Di Teco", "Imperia (IM)"), new structType.ptr("G647", "Pieve D'Olmi", "Cremona (CR)"), new structType.ptr("G634", "Pieve Emanuele", "Milano (MI)"), new structType.ptr("G096", "Pieve Fissiraga", "Lodi (LO)"), new structType.ptr("G648", "Pieve Fosciana", "Lucca (LU)"), new structType.ptr("G646", "Pieve Ligure", "Genova (GE)"), new structType.ptr("G650", "Pieve Porto Morone", "Pavia (PV)"), new structType.ptr("G651", "Pieve San Giacomo", "Cremona (CR)"), new structType.ptr("G653", "Pieve Santo Stefano", "Arezzo (AR)"), new structType.ptr("G656", "Pieve Tesino", "Trento (TN)"), new structType.ptr("G657", "Pieve Torina", "Macerata (MC)"), new structType.ptr("G658", "Pieve Vergonte", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("G649", "Pievepelago", "Modena (MO)"), new structType.ptr("G659", "Piglio", "Frosinone (FR)"), new structType.ptr("G660", "Pigna", "Imperia (IM)"), new structType.ptr("G662", "Pignataro Interamna", "Frosinone (FR)"), new structType.ptr("G661", "Pignataro Maggiore", "Caserta (CE)"), new structType.ptr("G663", "Pignola", "Potenza (PZ)"), new structType.ptr("G664", "Pignone", "La Spezia (SP)"), new structType.ptr("G665", "Pigra", "Como (CO)"), new structType.ptr("G666", "Pila", "Vercelli (VC)"), new structType.ptr("G669", "Pimentel", "Cagliari (CA)"), new structType.ptr("G670", "Pimonte", "Napoli (NA)"), new structType.ptr("G671", "Pinarolo Po", "Pavia (PV)"), new structType.ptr("G672", "Pinasca", "Torino (TO)"), new structType.ptr("G673", "Pincara", "Rovigo (RO)"), new structType.ptr("G674", "Pinerolo", "Torino (TO)"), new structType.ptr("F831", "Pineto", "Teramo (TE)"), new structType.ptr("G676", "Pino D'Asti", "Asti (AT)"), new structType.ptr("G678", "Pino Torinese", "Torino (TO)"), new structType.ptr("G680", "Pinzano Al Tagliamento", "Pordenone (PN)"), new structType.ptr("G681", "Pinzolo", "Trento (TN)"), new structType.ptr("G682", "Piobbico", "Pesaro e Urbino (PU)"), new structType.ptr("G683", "Piobesi D'Alba", "Cuneo (CN)"), new structType.ptr("G684", "Piobesi Torinese", "Torino (TO)"), new structType.ptr("G685", "Piode", "Vercelli (VC)"), new structType.ptr("G686", "Pioltello", "Milano (MI)"), new structType.ptr("G687", "Piombino", "Livorno (LI)"), new structType.ptr("G688", "Piombino Dese", "Padova (PD)"), new structType.ptr("G690", "Pioraco", "Macerata (MC)"), new structType.ptr("G691", "Piossasco", "Torino (TO)"), new structType.ptr("G692", "Piova' Massaia", "Asti (AT)"), new structType.ptr("G693", "Piove Di Sacco", "Padova (PD)"), new structType.ptr("G694", "Piovene Rocchette", "Vicenza (VI)"), new structType.ptr("G695", "Piovera", "Alessandria (AL)"), new structType.ptr("G696", "Piozzano", "Piacenza (PC)"), new structType.ptr("G697", "Piozzo", "Cuneo (CN)"), new structType.ptr("G699", "Piraino", "Messina (ME)"), new structType.ptr("G702", "Pisa", "Pisa (PI)"), new structType.ptr("G703", "Pisano", "Novara (NO)"), new structType.ptr("G705", "Piscina", "Torino (TO)"), new structType.ptr("M291", "Piscinas", "Carbonia-Iglesias (CI)"), new structType.ptr("G707", "Pisciotta", "Salerno (SA)"), new structType.ptr("G710", "Pisogne", "Brescia (BS)"), new structType.ptr("G704", "Pisoniano", "Roma (RM)"), new structType.ptr("G712", "Pisticci", "Matera (MT)"), new structType.ptr("G713", "Pistoia", "Pistoia (PT)"), new structType.ptr("G716", "Pitigliano", "Grosseto (GR)"), new structType.ptr("G717", "Piubega", "Mantova (MN)"), new structType.ptr("G718", "Piuro", "Sondrio (SO)"), new structType.ptr("G719", "Piverone", "Torino (TO)"), new structType.ptr("G720", "Pizzale", "Pavia (PV)"), new structType.ptr("G721", "Pizzighettone", "Cremona (CR)"), new structType.ptr("G722", "Pizzo", "Vibo Valentia (VV)"), new structType.ptr("G724", "Pizzoferrato", "Chieti (CH)"), new structType.ptr("G726", "Pizzoli", "L'Aquila (AQ)"), new structType.ptr("G727", "Pizzone", "Isernia (IS)"), new structType.ptr("G728", "Pizzoni", "Vibo Valentia (VV)"), new structType.ptr("G729", "Placanica", "Reggio Calabria (RC)"), new structType.ptr("G733", "Plataci", "Cosenza (CS)"), new structType.ptr("G734", "Platania", "Catanzaro (CZ)"), new structType.ptr("G735", "Plat\xC3\xAC", "Reggio Calabria (RC)"), new structType.ptr("G299", "Plaus .Plaus.", "Bolzano (BZ)"), new structType.ptr("G737", "Plesio", "Como (CO)"), new structType.ptr("G740", "Ploaghe", "Sassari (SS)"), new structType.ptr("G741", "Plodio", "Savona (SV)"), new structType.ptr("G742", "Pocapaglia", "Cuneo (CN)"), new structType.ptr("G743", "Pocenia", "Udine (UD)"), new structType.ptr("G746", "Podenzana", "Massa-Carrara (MS)"), new structType.ptr("G747", "Podenzano", "Piacenza (PC)"), new structType.ptr("G749", "Pofi", "Frosinone (FR)"), new structType.ptr("G751", "Poggiardo", "Lecce (LE)"), new structType.ptr("G752", "Poggibonsi", "Siena (SI)"), new structType.ptr("G754", "Poggio A Caiano", "Prato (PO)"), new structType.ptr("G756", "Poggio Bustone", "Rieti (RI)"), new structType.ptr("G757", "Poggio Catino", "Rieti (RI)"), new structType.ptr("G761", "Poggio Imperiale", "Foggia (FG)"), new structType.ptr("G763", "Poggio Mirteto", "Rieti (RI)"), new structType.ptr("G764", "Poggio Moiano", "Rieti (RI)"), new structType.ptr("G765", "Poggio Nativo", "Rieti (RI)"), new structType.ptr("G766", "Poggio Picenze", "L'Aquila (AQ)"), new structType.ptr("G768", "Poggio Renatico", "Ferrara (FE)"), new structType.ptr("G753", "Poggio Rusco", "Mantova (MN)"), new structType.ptr("G770", "Poggio San Lorenzo", "Rieti (RI)"), new structType.ptr("G771", "Poggio San Marcello", "Ancona (AN)"), new structType.ptr("D566", "Poggio San Vicino", "Macerata (MC)"), new structType.ptr("B317", "Poggio Sannita", "Isernia (IS)"), new structType.ptr("M324", "Poggio Torriana", "Rimini (RN)"), new structType.ptr("G758", "Poggiodomo", "Perugia (PG)"), new structType.ptr("G760", "Poggiofiorito", "Chieti (CH)"), new structType.ptr("G762", "Poggiomarino", "Napoli (NA)"), new structType.ptr("G767", "Poggioreale", "Trapani (TP)"), new structType.ptr("G769", "Poggiorsini", "Bari (BA)"), new structType.ptr("G431", "Poggiridenti", "Sondrio (SO)"), new structType.ptr("G772", "Pogliano Milanese", "Milano (MI)"), new structType.ptr("G773", "Pognana Lario", "Como (CO)"), new structType.ptr("G774", "Pognano", "Bergamo (BG)"), new structType.ptr("G775", "Pogno", "Novara (NO)"), new structType.ptr("G777", "Poirino", "Torino (TO)"), new structType.ptr("G776", "Pojana Maggiore", "Vicenza (VI)"), new structType.ptr("G779", "Polaveno", "Brescia (BS)"), new structType.ptr("G780", "Polcenigo", "Pordenone (PN)"), new structType.ptr("G782", "Polesella", "Rovigo (RO)"), new structType.ptr("M367", "Polesine Zibello", "Parma (PR)"), new structType.ptr("G784", "Poli", "Roma (RM)"), new structType.ptr("G785", "Polia", "Vibo Valentia (VV)"), new structType.ptr("G786", "Policoro", "Matera (MT)"), new structType.ptr("G787", "Polignano A Mare", "Bari (BA)"), new structType.ptr("G789", "Polinago", "Modena (MO)"), new structType.ptr("G790", "Polino", "Terni (TR)"), new structType.ptr("G791", "Polistena", "Reggio Calabria (RC)"), new structType.ptr("G792", "Polizzi Generosa", "Palermo (PA)"), new structType.ptr("G793", "Polla", "Salerno (SA)"), new structType.ptr("G794", "Pollein", "Aosta (AO)"), new structType.ptr("G795", "Pollena Trocchia", "Napoli (NA)"), new structType.ptr("F567", "Pollenza", "Macerata (MC)"), new structType.ptr("G796", "Pollica", "Salerno (SA)"), new structType.ptr("G797", "Pollina", "Palermo (PA)"), new structType.ptr("G798", "Pollone", "Biella (BI)"), new structType.ptr("G799", "Pollutri", "Chieti (CH)"), new structType.ptr("G800", "Polonghera", "Cuneo (CN)"), new structType.ptr("G801", "Polpenazze Del Garda", "Brescia (BS)"), new structType.ptr("G802", "Polverara", "Padova (PD)"), new structType.ptr("G803", "Polverigi", "Ancona (AN)"), new structType.ptr("G804", "Pomarance", "Pisa (PI)"), new structType.ptr("G805", "Pomaretto", "Torino (TO)"), new structType.ptr("G806", "Pomarico", "Matera (MT)"), new structType.ptr("G807", "Pomaro Monferrato", "Alessandria (AL)"), new structType.ptr("G808", "Pomarolo", "Trento (TN)"), new structType.ptr("G809", "Pombia", "Novara (NO)"), new structType.ptr("G811", "Pomezia", "Roma (RM)"), new structType.ptr("G812", "Pomigliano D'Arco", "Napoli (NA)"), new structType.ptr("G813", "Pompei", "Napoli (NA)"), new structType.ptr("G814", "Pompeiana", "Imperia (IM)"), new structType.ptr("G815", "Pompiano", "Brescia (BS)"), new structType.ptr("G816", "Pomponesco", "Mantova (MN)"), new structType.ptr("G817", "Pompu", "Oristano (OR)"), new structType.ptr("G818", "Poncarale", "Brescia (BS)"), new structType.ptr("G820", "Ponderano", "Biella (BI)"), new structType.ptr("G821", "Ponna", "Como (CO)"), new structType.ptr("G822", "Ponsacco", "Pisa (PI)"), new structType.ptr("G823", "Ponso", "Padova (PD)"), new structType.ptr("G826", "Pont Canavese", "Torino (TO)"), new structType.ptr("G825", "Pontassieve", "Firenze (FI)"), new structType.ptr("G545", "Pontboset", "Aosta (AO)"), new structType.ptr("G827", "Ponte", "Benevento (BN)"), new structType.ptr("G833", "Ponte Buggianese", "Pistoia (PT)"), new structType.ptr("G842", "Ponte Dell'Olio", "Piacenza (PC)"), new structType.ptr("G844", "Ponte Di Legno", "Brescia (BS)"), new structType.ptr("G846", "Ponte Di Piave", "Treviso (TV)"), new structType.ptr("G830", "Ponte Gardena .Waidbruck.", "Bolzano (BZ)"), new structType.ptr("G829", "Ponte In Valtellina", "Sondrio (SO)"), new structType.ptr("G847", "Ponte Lambro", "Como (CO)"), new structType.ptr("B662", "Ponte Nelle Alpi", "Belluno (BL)"), new structType.ptr("G851", "Ponte Nizza", "Pavia (PV)"), new structType.ptr("F941", "Ponte Nossa", "Bergamo (BG)"), new structType.ptr("G855", "Ponte San Nicol\xC3\xB2", "Padova (PD)"), new structType.ptr("G856", "Ponte San Pietro", "Bergamo (BG)"), new structType.ptr("G831", "Pontebba", "Udine (UD)"), new structType.ptr("G834", "Pontecagnano Faiano", "Salerno (SA)"), new structType.ptr("G836", "Pontecchio Polesine", "Rovigo (RO)"), new structType.ptr("G837", "Pontechianale", "Cuneo (CN)"), new structType.ptr("G838", "Pontecorvo", "Frosinone (FR)"), new structType.ptr("G839", "Pontecurone", "Alessandria (AL)"), new structType.ptr("G840", "Pontedassio", "Imperia (IM)"), new structType.ptr("G843", "Pontedera", "Pisa (PI)"), new structType.ptr("G848", "Pontelandolfo", "Benevento (BN)"), new structType.ptr("G849", "Pontelatone", "Caserta (CE)"), new structType.ptr("G850", "Pontelongo", "Padova (PD)"), new structType.ptr("G852", "Pontenure", "Piacenza (PC)"), new structType.ptr("G853", "Ponteranica", "Bergamo (BG)"), new structType.ptr("G858", "Pontestura", "Alessandria (AL)"), new structType.ptr("G859", "Pontevico", "Brescia (BS)"), new structType.ptr("G860", "Pontey", "Aosta (AO)"), new structType.ptr("G861", "Ponti", "Alessandria (AL)"), new structType.ptr("G862", "Ponti Sul Mincio", "Mantova (MN)"), new structType.ptr("G864", "Pontida", "Bergamo (BG)"), new structType.ptr("G865", "Pontinia", "Latina (LT)"), new structType.ptr("G866", "Pontinvrea", "Savona (SV)"), new structType.ptr("G867", "Pontirolo Nuovo", "Bergamo (BG)"), new structType.ptr("G869", "Pontoglio", "Brescia (BS)"), new structType.ptr("G870", "Pontremoli", "Massa-Carrara (MS)"), new structType.ptr("G854", "Pont-Saint-Martin", "Aosta (AO)"), new structType.ptr("G871", "Ponza", "Latina (LT)"), new structType.ptr("G873", "Ponzano Di Fermo", "Fermo (FM)"), new structType.ptr("G872", "Ponzano Monferrato", "Alessandria (AL)"), new structType.ptr("G874", "Ponzano Romano", "Roma (RM)"), new structType.ptr("G875", "Ponzano Veneto", "Treviso (TV)"), new structType.ptr("G877", "Ponzone", "Alessandria (AL)"), new structType.ptr("G878", "Popoli", "Pescara (PE)"), new structType.ptr("G879", "Poppi", "Arezzo (AR)"), new structType.ptr("G881", "Porano", "Terni (TR)"), new structType.ptr("G882", "Porcari", "Lucca (LU)"), new structType.ptr("G886", "Porcia", "Pordenone (PN)"), new structType.ptr("G888", "Pordenone", "Pordenone (PN)"), new structType.ptr("G889", "Porlezza", "Como (CO)"), new structType.ptr("G890", "Pornassio", "Imperia (IM)"), new structType.ptr("G891", "Porpetto", "Udine (UD)"), new structType.ptr("G894", "Portacomaro", "Asti (AT)"), new structType.ptr("G895", "Portalbera", "Pavia (PV)"), new structType.ptr("G900", "Porte", "Torino (TO)"), new structType.ptr("M358", "Porte Di Rendena", "Trento (TN)"), new structType.ptr("G902", "Portici", "Napoli (NA)"), new structType.ptr("G903", "Portico Di Caserta", "Caserta (CE)"), new structType.ptr("G904", "Portico E San Benedetto", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("G905", "Portigliola", "Reggio Calabria (RC)"), new structType.ptr("E680", "Porto Azzurro", "Livorno (LI)"), new structType.ptr("G906", "Porto Ceresio", "Varese (VA)"), new structType.ptr("M263", "Porto Cesareo", "Lecce (LE)"), new structType.ptr("F299", "Porto Empedocle", "Agrigento (AG)"), new structType.ptr("G917", "Porto Mantovano", "Mantova (MN)"), new structType.ptr("G919", "Porto Recanati", "Macerata (MC)"), new structType.ptr("G920", "Porto San Giorgio", "Fermo (FM)"), new structType.ptr("G921", "Porto Sant'Elpidio", "Fermo (FM)"), new structType.ptr("G923", "Porto Tolle", "Rovigo (RO)"), new structType.ptr("G924", "Porto Torres", "Sassari (SS)"), new structType.ptr("G907", "Porto Valtravaglia", "Varese (VA)"), new structType.ptr("G926", "Porto Viro", "Rovigo (RO)"), new structType.ptr("G909", "Portobuffol\xC3\xA8", "Treviso (TV)"), new structType.ptr("G910", "Portocannone", "Campobasso (CB)"), new structType.ptr("G912", "Portoferraio", "Livorno (LI)"), new structType.ptr("G913", "Portofino", "Genova (GE)"), new structType.ptr("G914", "Portogruaro", "Venezia (VE)"), new structType.ptr("G916", "Portomaggiore", "Ferrara (FE)"), new structType.ptr("M257", "Portopalo Di Capo Passero", "Siracusa (SR)"), new structType.ptr("G922", "Portoscuso", "Carbonia-Iglesias (CI)"), new structType.ptr("G925", "Portovenere", "La Spezia (SP)"), new structType.ptr("G927", "Portula", "Biella (BI)"), new structType.ptr("G929", "Posada", "Nuoro (NU)"), new structType.ptr("G931", "Posina", "Vicenza (VI)"), new structType.ptr("G932", "Positano", "Salerno (SA)"), new structType.ptr("G933", "Possagno", "Treviso (TV)"), new structType.ptr("G934", "Posta", "Rieti (RI)"), new structType.ptr("G935", "Posta Fibreno", "Frosinone (FR)"), new structType.ptr("G936", "Postal .Burgstall.", "Bolzano (BZ)"), new structType.ptr("G937", "Postalesio", "Sondrio (SO)"), new structType.ptr("G939", "Postiglione", "Salerno (SA)"), new structType.ptr("G940", "Postua", "Vercelli (VC)"), new structType.ptr("G942", "Potenza", "Potenza (PZ)"), new structType.ptr("F632", "Potenza Picena", "Macerata (MC)"), new structType.ptr("G943", "Pove Del Grappa", "Vicenza (VI)"), new structType.ptr("G944", "Povegliano", "Treviso (TV)"), new structType.ptr("G945", "Povegliano Veronese", "Verona (VR)"), new structType.ptr("G947", "Poviglio", "Reggio Emilia (RE)"), new structType.ptr("G949", "Povoletto", "Udine (UD)"), new structType.ptr("G950", "Pozza Di Fassa", "Trento (TN)"), new structType.ptr("G951", "Pozzaglia Sabina", "Rieti (RI)"), new structType.ptr("B914", "Pozzaglio Ed Uniti", "Cremona (CR)"), new structType.ptr("G953", "Pozzallo", "Ragusa (RG)"), new structType.ptr("G954", "Pozzilli", "Isernia (IS)"), new structType.ptr("G955", "Pozzo D'Adda", "Milano (MI)"), new structType.ptr("G960", "Pozzol Groppo", "Alessandria (AL)"), new structType.ptr("G959", "Pozzolengo", "Brescia (BS)"), new structType.ptr("G957", "Pozzoleone", "Vicenza (VI)"), new structType.ptr("G961", "Pozzolo Formigaro", "Alessandria (AL)"), new structType.ptr("G962", "Pozzomaggiore", "Sassari (SS)"), new structType.ptr("G963", "Pozzonovo", "Padova (PD)"), new structType.ptr("G964", "Pozzuoli", "Napoli (NA)"), new structType.ptr("G966", "Pozzuolo Del Friuli", "Udine (UD)"), new structType.ptr("G965", "Pozzuolo Martesana", "Milano (MI)"), new structType.ptr("G968", "Pradalunga", "Bergamo (BG)"), new structType.ptr("G969", "Pradamano", "Udine (UD)"), new structType.ptr("G970", "Pradleves", "Cuneo (CN)"), new structType.ptr("G973", "Pragelato", "Torino (TO)"), new structType.ptr("G975", "Praia A Mare", "Cosenza (CS)"), new structType.ptr("G976", "Praiano", "Salerno (SA)"), new structType.ptr("G977", "Pralboino", "Brescia (BS)"), new structType.ptr("G978", "Prali", "Torino (TO)"), new structType.ptr("G979", "Pralormo", "Torino (TO)"), new structType.ptr("G980", "Pralungo", "Biella (BI)"), new structType.ptr("G981", "Pramaggiore", "Venezia (VE)"), new structType.ptr("G982", "Pramollo", "Torino (TO)"), new structType.ptr("G985", "Prarolo", "Vercelli (VC)"), new structType.ptr("G986", "Prarostino", "Torino (TO)"), new structType.ptr("G987", "Prasco", "Alessandria (AL)"), new structType.ptr("G988", "Prascorsano", "Torino (TO)"), new structType.ptr("G993", "Prata Camportaccio", "Sondrio (SO)"), new structType.ptr("G992", "Prata D'Ansidonia", "L'Aquila (AQ)"), new structType.ptr("G994", "Prata Di Pordenone", "Pordenone (PN)"), new structType.ptr("G990", "Prata Di Principato Ultra", "Avellino (AV)"), new structType.ptr("G991", "Prata Sannita", "Caserta (CE)"), new structType.ptr("G995", "Pratella", "Caserta (CE)"), new structType.ptr("G997", "Pratiglione", "Torino (TO)"), new structType.ptr("G999", "Prato", "Prato (PO)"), new structType.ptr("H004", "Prato Allo Stelvio .Prad Am Stilfserjoch.", "Bolzano (BZ)"), new structType.ptr("H002", "Prato Carnico", "Udine (UD)"), new structType.ptr("H001", "Prato Sesia", "Novara (NO)"), new structType.ptr("H007", "Pratola Peligna", "L'Aquila (AQ)"), new structType.ptr("H006", "Pratola Serra", "Avellino (AV)"), new structType.ptr("M329", "Pratovecchio Stia", "Arezzo (AR)"), new structType.ptr("H010", "Pravisdomini", "Pordenone (PN)"), new structType.ptr("G974", "Pray", "Biella (BI)"), new structType.ptr("H011", "Prazzo", "Cuneo (CN)"), new structType.ptr("H014", "Precenicco", "Udine (UD)"), new structType.ptr("H015", "Preci", "Perugia (PG)"), new structType.ptr("M344", "Predaia", "Trento (TN)"), new structType.ptr("H017", "Predappio", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("H018", "Predazzo", "Trento (TN)"), new structType.ptr("H019", "Predoi .Prettau.", "Bolzano (BZ)"), new structType.ptr("H020", "Predore", "Bergamo (BG)"), new structType.ptr("H021", "Predosa", "Alessandria (AL)"), new structType.ptr("H022", "Preganziol", "Treviso (TV)"), new structType.ptr("H026", "Pregnana Milanese", "Milano (MI)"), new structType.ptr("H027", "Prel\xC3\xA0", "Imperia (IM)"), new structType.ptr("H028", "Premana", "Lecco (LC)"), new structType.ptr("H029", "Premariacco", "Udine (UD)"), new structType.ptr("H030", "Premeno", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("H033", "Premia", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("H034", "Premilcuore", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("H036", "Premolo", "Bergamo (BG)"), new structType.ptr("H037", "Premosello-Chiovenda", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("H038", "Preone", "Udine (UD)"), new structType.ptr("H040", "Prepotto", "Udine (UD)"), new structType.ptr("H042", "Pre'-Saint-Didier", "Aosta (AO)"), new structType.ptr("H043", "Preseglie", "Brescia (BS)"), new structType.ptr("H045", "Presenzano", "Caserta (CE)"), new structType.ptr("H046", "Presezzo", "Bergamo (BG)"), new structType.ptr("H047", "Presicce", "Lecce (LE)"), new structType.ptr("H048", "Pressana", "Verona (VR)"), new structType.ptr("H052", "Pretoro", "Chieti (CH)"), new structType.ptr("H055", "Prevalle", "Brescia (BS)"), new structType.ptr("H056", "Prezza", "L'Aquila (AQ)"), new structType.ptr("H059", "Priero", "Cuneo (CN)"), new structType.ptr("H062", "Prignano Cilento", "Salerno (SA)"), new structType.ptr("H061", "Prignano Sulla Secchia", "Modena (MO)"), new structType.ptr("H063", "Primaluna", "Lecco (LC)"), new structType.ptr("M359", "Primiero San Martino Di Castrozza", "Trento (TN)"), new structType.ptr("H068", "Priocca", "Cuneo (CN)"), new structType.ptr("H069", "Priola", "Cuneo (CN)"), new structType.ptr("M279", "Priolo Gargallo", "Siracusa (SR)"), new structType.ptr("G698", "Priverno", "Latina (LT)"), new structType.ptr("H070", "Prizzi", "Palermo (PA)"), new structType.ptr("H071", "Proceno", "Viterbo (VT)"), new structType.ptr("H072", "Procida", "Napoli (NA)"), new structType.ptr("H073", "Propata", "Genova (GE)"), new structType.ptr("H074", "Proserpio", "Como (CO)"), new structType.ptr("H076", "Prossedi", "Latina (LT)"), new structType.ptr("H078", "Provaglio D'Iseo", "Brescia (BS)"), new structType.ptr("H077", "Provaglio Val Sabbia", "Brescia (BS)"), new structType.ptr("H081", "Proves .Proveis.", "Bolzano (BZ)"), new structType.ptr("H083", "Provvidenti", "Campobasso (CB)"), new structType.ptr("H085", "Prunetto", "Cuneo (CN)"), new structType.ptr("H086", "Puegnago Del Garda", "Brescia (BS)"), new structType.ptr("H087", "Puglianello", "Benevento (BN)"), new structType.ptr("H088", "Pula", "Cagliari (CA)"), new structType.ptr("H089", "Pulfero", "Udine (UD)"), new structType.ptr("H090", "Pulsano", "Taranto (TA)"), new structType.ptr("H091", "Pumenengo", "Bergamo (BG)"), new structType.ptr("H094", "Pusiano", "Como (CO)"), new structType.ptr("H095", "Putifigari", "Sassari (SS)"), new structType.ptr("H096", "Putignano", "Bari (BA)"), new structType.ptr("H097", "Quadrelle", "Avellino (AV)"), new structType.ptr("H098", "Quadri", "Chieti (CH)"), new structType.ptr("H100", "Quagliuzzo", "Torino (TO)"), new structType.ptr("H101", "Qualiano", "Napoli (NA)"), new structType.ptr("H102", "Quaranti", "Asti (AT)"), new structType.ptr("H103", "Quaregna", "Biella (BI)"), new structType.ptr("H104", "Quargnento", "Alessandria (AL)"), new structType.ptr("H106", "Quarna Sopra", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("H107", "Quarna Sotto", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("H108", "Quarona", "Vercelli (VC)"), new structType.ptr("H109", "Quarrata", "Pistoia (PT)"), new structType.ptr("H110", "Quart", "Aosta (AO)"), new structType.ptr("H114", "Quarto", "Napoli (NA)"), new structType.ptr("H117", "Quarto D'Altino", "Venezia (VE)"), new structType.ptr("H118", "Quartu Sant'Elena", "Cagliari (CA)"), new structType.ptr("H119", "Quartucciu", "Cagliari (CA)"), new structType.ptr("H120", "Quassolo", "Torino (TO)"), new structType.ptr("H121", "Quattordio", "Alessandria (AL)"), new structType.ptr("H122", "Quattro Castella", "Reggio Emilia (RE)"), new structType.ptr("M332", "Quero Vas", "Belluno (BL)"), new structType.ptr("H126", "Quiliano", "Savona (SV)"), new structType.ptr("H127", "Quincinetto", "Torino (TO)"), new structType.ptr("H128", "Quindici", "Avellino (AV)"), new structType.ptr("H129", "Quingentole", "Mantova (MN)"), new structType.ptr("H130", "Quintano", "Cremona (CR)"), new structType.ptr("H131", "Quinto Di Treviso", "Treviso (TV)"), new structType.ptr("H132", "Quinto Vercellese", "Vercelli (VC)"), new structType.ptr("H134", "Quinto Vicentino", "Vicenza (VI)"), new structType.ptr("H140", "Quinzano D'Oglio", "Brescia (BS)"), new structType.ptr("H143", "Quistello", "Mantova (MN)"), new structType.ptr("H146", "Rabbi", "Trento (TN)"), new structType.ptr("H147", "Racale", "Lecce (LE)"), new structType.ptr("H148", "Racalmuto", "Agrigento (AG)"), new structType.ptr("H150", "Racconigi", "Cuneo (CN)"), new structType.ptr("H151", "Raccuja", "Messina (ME)"), new structType.ptr("H152", "Racines .Ratschings.", "Bolzano (BZ)"), new structType.ptr("H153", "Radda In Chianti", "Siena (SI)"), new structType.ptr("H154", "Raddusa", "Catania (CT)"), new structType.ptr("H156", "Radicofani", "Siena (SI)"), new structType.ptr("H157", "Radicondoli", "Siena (SI)"), new structType.ptr("H159", "Raffadali", "Agrigento (AG)"), new structType.ptr("M287", "Ragalna", "Catania (CT)"), new structType.ptr("H161", "Ragogna", "Udine (UD)"), new structType.ptr("H163", "Ragusa", "Ragusa (RG)"), new structType.ptr("H166", "Raiano", "L'Aquila (AQ)"), new structType.ptr("H168", "Ramacca", "Catania (CT)"), new structType.ptr("H173", "Rancio Valcuvia", "Varese (VA)"), new structType.ptr("H174", "Ranco", "Varese (VA)"), new structType.ptr("H175", "Randazzo", "Catania (CT)"), new structType.ptr("H176", "Ranica", "Bergamo (BG)"), new structType.ptr("H177", "Ranzanico", "Bergamo (BG)"), new structType.ptr("H180", "Ranzo", "Imperia (IM)"), new structType.ptr("H182", "Rapagnano", "Fermo (FM)"), new structType.ptr("H183", "Rapallo", "Genova (GE)"), new structType.ptr("H184", "Rapino", "Chieti (CH)"), new structType.ptr("H185", "Rapolano Terme", "Siena (SI)"), new structType.ptr("H186", "Rapolla", "Potenza (PZ)"), new structType.ptr("H187", "Rapone", "Potenza (PZ)"), new structType.ptr("H188", "Rassa", "Vercelli (VC)"), new structType.ptr("H189", "Rasun Anterselva .Rasen Antholz.", "Bolzano (BZ)"), new structType.ptr("H192", "Rasura", "Sondrio (SO)"), new structType.ptr("H194", "Ravanusa", "Agrigento (AG)"), new structType.ptr("H195", "Ravarino", "Modena (MO)"), new structType.ptr("H196", "Ravascletto", "Udine (UD)"), new structType.ptr("H198", "Ravello", "Salerno (SA)"), new structType.ptr("H199", "Ravenna", "Ravenna (RA)"), new structType.ptr("H200", "Raveo", "Udine (UD)"), new structType.ptr("H202", "Raviscanina", "Caserta (CE)"), new structType.ptr("H203", "Re", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("H204", "Rea", "Pavia (PV)"), new structType.ptr("H205", "Realmonte", "Agrigento (AG)"), new structType.ptr("H206", "Reana Del Rojale", "Udine (UD)"), new structType.ptr("H207", "Reano", "Torino (TO)"), new structType.ptr("H210", "Recale", "Caserta (CE)"), new structType.ptr("H211", "Recanati", "Macerata (MC)"), new structType.ptr("H212", "Recco", "Genova (GE)"), new structType.ptr("H213", "Recetto", "Novara (NO)"), new structType.ptr("H214", "Recoaro Terme", "Vicenza (VI)"), new structType.ptr("H216", "Redavalle", "Pavia (PV)"), new structType.ptr("H218", "Redondesco", "Mantova (MN)"), new structType.ptr("H219", "Refrancore", "Asti (AT)"), new structType.ptr("H220", "Refrontolo", "Treviso (TV)"), new structType.ptr("H221", "Regalbuto", "Enna (EN)"), new structType.ptr("H222", "Reggello", "Firenze (FI)"), new structType.ptr("H224", "Reggio Di Calabria", "Reggio Calabria (RC)"), new structType.ptr("H223", "Reggio Nell'Emilia", "Reggio Emilia (RE)"), new structType.ptr("H225", "Reggiolo", "Reggio Emilia (RE)"), new structType.ptr("H227", "Reino", "Benevento (BN)"), new structType.ptr("H228", "Reitano", "Messina (ME)"), new structType.ptr("H229", "Remanzacco", "Udine (UD)"), new structType.ptr("H230", "Remedello", "Brescia (BS)"), new structType.ptr("H233", "Renate", "Monza e della Brianza (MB)"), new structType.ptr("H235", "Rende", "Cosenza (CS)"), new structType.ptr("H236", "Renon .Ritten.", "Bolzano (BZ)"), new structType.ptr("H238", "Resana", "Treviso (TV)"), new structType.ptr("H240", "Rescaldina", "Milano (MI)"), new structType.ptr("H242", "Resia", "Udine (UD)"), new structType.ptr("H244", "Resiutta", "Udine (UD)"), new structType.ptr("H245", "Resuttano", "Caltanissetta (CL)"), new structType.ptr("H246", "Retorbido", "Pavia (PV)"), new structType.ptr("H247", "Revello", "Cuneo (CN)"), new structType.ptr("H248", "Revere", "Mantova (MN)"), new structType.ptr("H250", "Revigliasco D'Asti", "Asti (AT)"), new structType.ptr("H253", "Revine Lago", "Treviso (TV)"), new structType.ptr("H254", "Rev\xC3\xB2", "Trento (TN)"), new structType.ptr("H255", "Rezzago", "Como (CO)"), new structType.ptr("H256", "Rezzato", "Brescia (BS)"), new structType.ptr("H257", "Rezzo", "Imperia (IM)"), new structType.ptr("H258", "Rezzoaglio", "Genova (GE)"), new structType.ptr("H262", "Rhemes-Notre-Dame", "Aosta (AO)"), new structType.ptr("H263", "Rhemes-Saint-Georges", "Aosta (AO)"), new structType.ptr("H264", "Rho", "Milano (MI)"), new structType.ptr("H265", "Riace", "Reggio Calabria (RC)"), new structType.ptr("H266", "Rialto", "Savona (SV)"), new structType.ptr("H267", "Riano", "Roma (RM)"), new structType.ptr("H268", "Riardo", "Caserta (CE)"), new structType.ptr("H269", "Ribera", "Agrigento (AG)"), new structType.ptr("H270", "Ribordone", "Torino (TO)"), new structType.ptr("H271", "Ricadi", "Vibo Valentia (VV)"), new structType.ptr("H272", "Ricaldone", "Alessandria (AL)"), new structType.ptr("H273", "Riccia", "Campobasso (CB)"), new structType.ptr("H274", "Riccione", "Rimini (RN)"), new structType.ptr("H275", "Ricco' Del Golfo Di Spezia", "La Spezia (SP)"), new structType.ptr("H276", "Ricengo", "Cremona (CR)"), new structType.ptr("H277", "Ricigliano", "Salerno (SA)"), new structType.ptr("H280", "Riese Pio X", "Treviso (TV)"), new structType.ptr("H281", "Riesi", "Caltanissetta (CL)"), new structType.ptr("H282", "Rieti", "Rieti (RI)"), new structType.ptr("H284", "Rifiano .Riffian.", "Bolzano (BZ)"), new structType.ptr("H285", "Rifreddo", "Cuneo (CN)"), new structType.ptr("H288", "Rignano Flaminio", "Roma (RM)"), new structType.ptr("H287", "Rignano Garganico", "Foggia (FG)"), new structType.ptr("H286", "Rignano Sull'Arno", "Firenze (FI)"), new structType.ptr("H289", "Rigolato", "Udine (UD)"), new structType.ptr("H291", "Rima San Giuseppe", "Vercelli (VC)"), new structType.ptr("H292", "Rimasco", "Vercelli (VC)"), new structType.ptr("H293", "Rimella", "Vercelli (VC)"), new structType.ptr("H294", "Rimini", "Rimini (RN)"), new structType.ptr("H299", "Rio Di Pusteria .Muehlbach.", "Bolzano (BZ)"), new structType.ptr("H305", "Rio Marina", "Livorno (LI)"), new structType.ptr("H297", "Rio Nell'Elba", "Livorno (LI)"), new structType.ptr("H298", "Rio Saliceto", "Reggio Emilia (RE)"), new structType.ptr("H300", "Riofreddo", "Roma (RM)"), new structType.ptr("H301", "Riola Sardo", "Oristano (OR)"), new structType.ptr("H302", "Riolo Terme", "Ravenna (RA)"), new structType.ptr("H303", "Riolunato", "Modena (MO)"), new structType.ptr("H304", "Riomaggiore", "La Spezia (SP)"), new structType.ptr("H307", "Rionero In Vulture", "Potenza (PZ)"), new structType.ptr("H308", "Rionero Sannitico", "Isernia (IS)"), new structType.ptr("H320", "Ripa Teatina", "Chieti (CH)"), new structType.ptr("H311", "Ripabottoni", "Campobasso (CB)"), new structType.ptr("H312", "Ripacandida", "Potenza (PZ)"), new structType.ptr("H313", "Ripalimosani", "Campobasso (CB)"), new structType.ptr("H314", "Ripalta Arpina", "Cremona (CR)"), new structType.ptr("H315", "Ripalta Cremasca", "Cremona (CR)"), new structType.ptr("H316", "Ripalta Guerina", "Cremona (CR)"), new structType.ptr("H319", "Riparbella", "Pisa (PI)"), new structType.ptr("H321", "Ripatransone", "Ascoli Piceno (AP)"), new structType.ptr("H323", "Ripe San Ginesio", "Macerata (MC)"), new structType.ptr("H324", "Ripi", "Frosinone (FR)"), new structType.ptr("H325", "Riposto", "Catania (CT)"), new structType.ptr("H326", "Rittana", "Cuneo (CN)"), new structType.ptr("H330", "Riva Del Garda", "Trento (TN)"), new structType.ptr("H331", "Riva Di Solto", "Bergamo (BG)"), new structType.ptr("H328", "Riva Ligure", "Imperia (IM)"), new structType.ptr("H337", "Riva Presso Chieri", "Torino (TO)"), new structType.ptr("H329", "Riva Valdobbia", "Vercelli (VC)"), new structType.ptr("H333", "Rivalba", "Torino (TO)"), new structType.ptr("H334", "Rivalta Bormida", "Alessandria (AL)"), new structType.ptr("H335", "Rivalta Di Torino", "Torino (TO)"), new structType.ptr("H327", "Rivamonte Agordino", "Belluno (BL)"), new structType.ptr("H336", "Rivanazzano Terme", "Pavia (PV)"), new structType.ptr("H338", "Rivara", "Torino (TO)"), new structType.ptr("H340", "Rivarolo Canavese", "Torino (TO)"), new structType.ptr("H341", "Rivarolo Del Re Ed Uniti", "Cremona (CR)"), new structType.ptr("H342", "Rivarolo Mantovano", "Mantova (MN)"), new structType.ptr("H343", "Rivarone", "Alessandria (AL)"), new structType.ptr("H344", "Rivarossa", "Torino (TO)"), new structType.ptr("H346", "Rive", "Vercelli (VC)"), new structType.ptr("H347", "Rive D'Arcano", "Udine (UD)"), new structType.ptr("H348", "Rivello", "Potenza (PZ)"), new structType.ptr("H350", "Rivergaro", "Piacenza (PC)"), new structType.ptr("M317", "Rivignano Teor", "Udine (UD)"), new structType.ptr("H353", "Rivisondoli", "L'Aquila (AQ)"), new structType.ptr("H354", "Rivodutri", "Rieti (RI)"), new structType.ptr("H355", "Rivoli", "Torino (TO)"), new structType.ptr("H356", "Rivoli Veronese", "Verona (VR)"), new structType.ptr("H357", "Rivolta D'Adda", "Cremona (CR)"), new structType.ptr("H359", "Rizziconi", "Reggio Calabria (RC)"), new structType.ptr("H360", "Ro", "Ferrara (FE)"), new structType.ptr("H361", "Roana", "Vicenza (VI)"), new structType.ptr("H362", "Roaschia", "Cuneo (CN)"), new structType.ptr("H363", "Roascio", "Cuneo (CN)"), new structType.ptr("H365", "Roasio", "Vercelli (VC)"), new structType.ptr("H366", "Roatto", "Asti (AT)"), new structType.ptr("H367", "Robassomero", "Torino (TO)"), new structType.ptr("G223", "Robbiate", "Lecco (LC)"), new structType.ptr("H369", "Robbio", "Pavia (PV)"), new structType.ptr("H371", "Robecchetto Con Induno", "Milano (MI)"), new structType.ptr("H372", "Robecco D'Oglio", "Cremona (CR)"), new structType.ptr("H375", "Robecco Pavese", "Pavia (PV)"), new structType.ptr("H373", "Robecco Sul Naviglio", "Milano (MI)"), new structType.ptr("H376", "Robella", "Asti (AT)"), new structType.ptr("H377", "Robilante", "Cuneo (CN)"), new structType.ptr("H378", "Roburent", "Cuneo (CN)"), new structType.ptr("H386", "Rocca Canavese", "Torino (TO)"), new structType.ptr("H387", "Rocca Canterano", "Roma (RM)"), new structType.ptr("H391", "Rocca Cigli\xC3\xA8", "Cuneo (CN)"), new structType.ptr("H392", "Rocca D'Arazzo", "Asti (AT)"), new structType.ptr("H395", "Rocca De' Baldi", "Cuneo (CN)"), new structType.ptr("H396", "Rocca De' Giorgi", "Pavia (PV)"), new structType.ptr("H398", "Rocca D'Evandro", "Caserta (CE)"), new structType.ptr("H399", "Rocca Di Botte", "L'Aquila (AQ)"), new structType.ptr("H400", "Rocca Di Cambio", "L'Aquila (AQ)"), new structType.ptr("H401", "Rocca Di Cave", "Roma (RM)"), new structType.ptr("H402", "Rocca Di Mezzo", "L'Aquila (AQ)"), new structType.ptr("H403", "Rocca Di Neto", "Crotone (KR)"), new structType.ptr("H404", "Rocca Di Papa", "Roma (RM)"), new structType.ptr("H414", "Rocca Grimalda", "Alessandria (AL)"), new structType.ptr("H416", "Rocca Imperiale", "Cosenza (CS)"), new structType.ptr("H421", "Rocca Massima", "Latina (LT)"), new structType.ptr("H429", "Rocca Pia", "L'Aquila (AQ)"), new structType.ptr("H379", "Rocca Pietore", "Belluno (BL)"), new structType.ptr("H432", "Rocca Priora", "Roma (RM)"), new structType.ptr("H437", "Rocca San Casciano", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("H438", "Rocca San Felice", "Avellino (AV)"), new structType.ptr("H439", "Rocca San Giovanni", "Chieti (CH)"), new structType.ptr("H440", "Rocca Santa Maria", "Teramo (TE)"), new structType.ptr("H441", "Rocca Santo Stefano", "Roma (RM)"), new structType.ptr("H446", "Rocca Sinibalda", "Rieti (RI)"), new structType.ptr("H450", "Rocca Susella", "Pavia (PV)"), new structType.ptr("H382", "Roccabascerana", "Avellino (AV)"), new structType.ptr("H383", "Roccabernarda", "Crotone (KR)"), new structType.ptr("H384", "Roccabianca", "Parma (PR)"), new structType.ptr("H385", "Roccabruna", "Cuneo (CN)"), new structType.ptr("H389", "Roccacasale", "L'Aquila (AQ)"), new structType.ptr("H393", "Roccadarce", "Frosinone (FR)"), new structType.ptr("H394", "Roccadaspide", "Salerno (SA)"), new structType.ptr("H405", "Roccafiorita", "Messina (ME)"), new structType.ptr("H390", "Roccafluvione", "Ascoli Piceno (AP)"), new structType.ptr("H408", "Roccaforte Del Greco", "Reggio Calabria (RC)"), new structType.ptr("H406", "Roccaforte Ligure", "Alessandria (AL)"), new structType.ptr("H407", "Roccaforte Mondov\xC3\xAC", "Cuneo (CN)"), new structType.ptr("H409", "Roccaforzata", "Taranto (TA)"), new structType.ptr("H410", "Roccafranca", "Brescia (BS)"), new structType.ptr("H411", "Roccagiovine", "Roma (RM)"), new structType.ptr("H412", "Roccagloriosa", "Salerno (SA)"), new structType.ptr("H413", "Roccagorga", "Latina (LT)"), new structType.ptr("H417", "Roccalbegna", "Grosseto (GR)"), new structType.ptr("H418", "Roccalumera", "Messina (ME)"), new structType.ptr("H420", "Roccamandolfi", "Isernia (IS)"), new structType.ptr("H422", "Roccamena", "Palermo (PA)"), new structType.ptr("H423", "Roccamonfina", "Caserta (CE)"), new structType.ptr("H424", "Roccamontepiano", "Chieti (CH)"), new structType.ptr("H425", "Roccamorice", "Pescara (PE)"), new structType.ptr("H426", "Roccanova", "Potenza (PZ)"), new structType.ptr("H427", "Roccantica", "Rieti (RI)"), new structType.ptr("H428", "Roccapalumba", "Palermo (PA)"), new structType.ptr("H431", "Roccapiemonte", "Salerno (SA)"), new structType.ptr("H433", "Roccarainola", "Napoli (NA)"), new structType.ptr("H434", "Roccaraso", "L'Aquila (AQ)"), new structType.ptr("H436", "Roccaromana", "Caserta (CE)"), new structType.ptr("H442", "Roccascalegna", "Chieti (CH)"), new structType.ptr("H443", "Roccasecca", "Frosinone (FR)"), new structType.ptr("H444", "Roccasecca Dei Volsci", "Latina (LT)"), new structType.ptr("H445", "Roccasicura", "Isernia (IS)"), new structType.ptr("H447", "Roccasparvera", "Cuneo (CN)"), new structType.ptr("H448", "Roccaspinalveti", "Chieti (CH)"), new structType.ptr("H449", "Roccastrada", "Grosseto (GR)"), new structType.ptr("H380", "Roccavaldina", "Messina (ME)"), new structType.ptr("H451", "Roccaverano", "Asti (AT)"), new structType.ptr("H452", "Roccavignale", "Savona (SV)"), new structType.ptr("H453", "Roccavione", "Cuneo (CN)"), new structType.ptr("H454", "Roccavivara", "Campobasso (CB)"), new structType.ptr("H456", "Roccella Ionica", "Reggio Calabria (RC)"), new structType.ptr("H455", "Roccella Valdemone", "Messina (ME)"), new structType.ptr("H458", "Rocchetta A Volturno", "Isernia (IS)"), new structType.ptr("H462", "Rocchetta Belbo", "Cuneo (CN)"), new structType.ptr("H461", "Rocchetta Di Vara", "La Spezia (SP)"), new structType.ptr("H459", "Rocchetta E Croce", "Caserta (CE)"), new structType.ptr("H465", "Rocchetta Ligure", "Alessandria (AL)"), new structType.ptr("H460", "Rocchetta Nervina", "Imperia (IM)"), new structType.ptr("H466", "Rocchetta Palafea", "Asti (AT)"), new structType.ptr("H467", "Rocchetta Sant'Antonio", "Foggia (FG)"), new structType.ptr("H468", "Rocchetta Tanaro", "Asti (AT)"), new structType.ptr("H470", "Rodano", "Milano (MI)"), new structType.ptr("H472", "Roddi", "Cuneo (CN)"), new structType.ptr("H473", "Roddino", "Cuneo (CN)"), new structType.ptr("H474", "Rodello", "Cuneo (CN)"), new structType.ptr("H475", "Rodengo .Rodeneck.", "Bolzano (BZ)"), new structType.ptr("H477", "Rodengo Saiano", "Brescia (BS)"), new structType.ptr("H478", "Rodero", "Como (CO)"), new structType.ptr("H480", "Rodi Garganico", "Foggia (FG)"), new structType.ptr("H479", "Rodi' Milici", "Messina (ME)"), new structType.ptr("H481", "Rodigo", "Mantova (MN)"), new structType.ptr("H484", "Roe' Volciano", "Brescia (BS)"), new structType.ptr("H485", "Rofrano", "Salerno (SA)"), new structType.ptr("H486", "Rogeno", "Lecco (LC)"), new structType.ptr("H488", "Roggiano Gravina", "Cosenza (CS)"), new structType.ptr("H489", "Roghudi", "Reggio Calabria (RC)"), new structType.ptr("H490", "Rogliano", "Cosenza (CS)"), new structType.ptr("H491", "Rognano", "Pavia (PV)"), new structType.ptr("H492", "Rogno", "Bergamo (BG)"), new structType.ptr("H493", "Rogolo", "Sondrio (SO)"), new structType.ptr("H494", "Roiate", "Roma (RM)"), new structType.ptr("H495", "Roio Del Sangro", "Chieti (CH)"), new structType.ptr("H497", "Roisan", "Aosta (AO)"), new structType.ptr("H498", "Roletto", "Torino (TO)"), new structType.ptr("H500", "Rolo", "Reggio Emilia (RE)"), new structType.ptr("H501", "Roma", "Roma (RM)"), new structType.ptr("H503", "Romagnano Al Monte", "Salerno (SA)"), new structType.ptr("H502", "Romagnano Sesia", "Novara (NO)"), new structType.ptr("H505", "Romagnese", "Pavia (PV)"), new structType.ptr("H506", "Romallo", "Trento (TN)"), new structType.ptr("H507", "Romana", "Sassari (SS)"), new structType.ptr("H508", "Romanengo", "Cremona (CR)"), new structType.ptr("H511", "Romano Canavese", "Torino (TO)"), new structType.ptr("H512", "Romano D'Ezzelino", "Vicenza (VI)"), new structType.ptr("H509", "Romano Di Lombardia", "Bergamo (BG)"), new structType.ptr("H514", "Romans D'Isonzo", "Gorizia (GO)"), new structType.ptr("H516", "Rombiolo", "Vibo Valentia (VV)"), new structType.ptr("H517", "Romeno", "Trento (TN)"), new structType.ptr("H518", "Romentino", "Novara (NO)"), new structType.ptr("H519", "Rometta", "Messina (ME)"), new structType.ptr("H521", "Ronago", "Como (CO)"), new structType.ptr("H522", "Ronc\xC3\xA0", "Verona (VR)"), new structType.ptr("H523", "Roncade", "Treviso (TV)"), new structType.ptr("H525", "Roncadelle", "Brescia (BS)"), new structType.ptr("H527", "Roncaro", "Pavia (PV)"), new structType.ptr("H528", "Roncegno Terme", "Trento (TN)"), new structType.ptr("H529", "Roncello", "Monza e della Brianza (MB)"), new structType.ptr("H531", "Ronchi Dei Legionari", "Gorizia (GO)"), new structType.ptr("H532", "Ronchi Valsugana", "Trento (TN)"), new structType.ptr("H533", "Ronchis", "Udine (UD)"), new structType.ptr("H534", "Ronciglione", "Viterbo (VT)"), new structType.ptr("H540", "Ronco All'Adige", "Verona (VR)"), new structType.ptr("H538", "Ronco Biellese", "Biella (BI)"), new structType.ptr("H537", "Ronco Briantino", "Monza e della Brianza (MB)"), new structType.ptr("H539", "Ronco Canavese", "Torino (TO)"), new structType.ptr("H536", "Ronco Scrivia", "Genova (GE)"), new structType.ptr("H535", "Roncobello", "Bergamo (BG)"), new structType.ptr("H541", "Roncoferraro", "Mantova (MN)"), new structType.ptr("H542", "Roncofreddo", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("H544", "Roncola", "Bergamo (BG)"), new structType.ptr("H546", "Rondanina", "Genova (GE)"), new structType.ptr("H547", "Rondissone", "Torino (TO)"), new structType.ptr("H549", "Ronsecco", "Vercelli (VC)"), new structType.ptr("M303", "Ronzo-Chienis", "Trento (TN)"), new structType.ptr("H552", "Ronzone", "Trento (TN)"), new structType.ptr("H553", "Roppolo", "Biella (BI)"), new structType.ptr("H554", "Ror\xC3\xA0", "Torino (TO)"), new structType.ptr("H556", "Ros\xC3\xA0", "Vicenza (VI)"), new structType.ptr("H558", "Rosarno", "Reggio Calabria (RC)"), new structType.ptr("H559", "Rosasco", "Pavia (PV)"), new structType.ptr("H560", "Rosate", "Milano (MI)"), new structType.ptr("H561", "Rosazza", "Biella (BI)"), new structType.ptr("H562", "Rosciano", "Pescara (PE)"), new structType.ptr("H564", "Roscigno", "Salerno (SA)"), new structType.ptr("H565", "Rose", "Cosenza (CS)"), new structType.ptr("H566", "Rosello", "Chieti (CH)"), new structType.ptr("H572", "Roseto Capo Spulico", "Cosenza (CS)"), new structType.ptr("F585", "Roseto Degli Abruzzi", "Teramo (TE)"), new structType.ptr("H568", "Roseto Valfortore", "Foggia (FG)"), new structType.ptr("H570", "Rosignano Marittimo", "Livorno (LI)"), new structType.ptr("H569", "Rosignano Monferrato", "Alessandria (AL)"), new structType.ptr("H573", "Rosolina", "Rovigo (RO)"), new structType.ptr("H574", "Rosolini", "Siracusa (SR)"), new structType.ptr("H575", "Rosora", "Ancona (AN)"), new structType.ptr("H577", "Rossa", "Vercelli (VC)"), new structType.ptr("H578", "Rossana", "Cuneo (CN)"), new structType.ptr("H579", "Rossano", "Cosenza (CS)"), new structType.ptr("H580", "Rossano Veneto", "Vicenza (VI)"), new structType.ptr("H581", "Rossiglione", "Genova (GE)"), new structType.ptr("H583", "Rosta", "Torino (TO)"), new structType.ptr("H584", "Rota D'Imagna", "Bergamo (BG)"), new structType.ptr("H585", "Rota Greca", "Cosenza (CS)"), new structType.ptr("H588", "Rotella", "Ascoli Piceno (AP)"), new structType.ptr("H589", "Rotello", "Campobasso (CB)"), new structType.ptr("H590", "Rotonda", "Potenza (PZ)"), new structType.ptr("H591", "Rotondella", "Matera (MT)"), new structType.ptr("H592", "Rotondi", "Avellino (AV)"), new structType.ptr("H593", "Rottofreno", "Piacenza (PC)"), new structType.ptr("H594", "Rotzo", "Vicenza (VI)"), new structType.ptr("H555", "Roure", "Torino (TO)"), new structType.ptr("H364", "Rovasenda", "Vercelli (VC)"), new structType.ptr("H598", "Rovato", "Brescia (BS)"), new structType.ptr("H599", "Rovegno", "Genova (GE)"), new structType.ptr("H601", "Rovellasca", "Como (CO)"), new structType.ptr("H602", "Rovello Porro", "Como (CO)"), new structType.ptr("H604", "Roverbella", "Mantova (MN)"), new structType.ptr("H606", "Roverchiara", "Verona (VR)"), new structType.ptr("H607", "Rovere' Della Luna", "Trento (TN)"), new structType.ptr("H608", "Rovere' Veronese", "Verona (VR)"), new structType.ptr("H610", "Roveredo Di Gu\xC3\xA0", "Verona (VR)"), new structType.ptr("H609", "Roveredo In Piano", "Pordenone (PN)"), new structType.ptr("H612", "Rovereto", "Trento (TN)"), new structType.ptr("H614", "Rovescala", "Pavia (PV)"), new structType.ptr("H615", "Rovetta", "Bergamo (BG)"), new structType.ptr("H618", "Roviano", "Roma (RM)"), new structType.ptr("H620", "Rovigo", "Rovigo (RO)"), new structType.ptr("H621", "Rovito", "Cosenza (CS)"), new structType.ptr("H622", "Rovolon", "Padova (PD)"), new structType.ptr("H623", "Rozzano", "Milano (MI)"), new structType.ptr("H625", "Rubano", "Padova (PD)"), new structType.ptr("H627", "Rubiana", "Torino (TO)"), new structType.ptr("H628", "Rubiera", "Reggio Emilia (RE)"), new structType.ptr("H629", "Ruda", "Udine (UD)"), new structType.ptr("H630", "Rudiano", "Brescia (BS)"), new structType.ptr("H631", "Rueglio", "Torino (TO)"), new structType.ptr("H632", "Ruffano", "Lecce (LE)"), new structType.ptr("H633", "Ruffia", "Cuneo (CN)"), new structType.ptr("H634", "Ruffre'-Mendola", "Trento (TN)"), new structType.ptr("H635", "Rufina", "Firenze (FI)"), new structType.ptr("F271", "Ruinas", "Oristano (OR)"), new structType.ptr("H637", "Ruino", "Pavia (PV)"), new structType.ptr("H639", "Rumo", "Trento (TN)"), new structType.ptr("H641", "Ruoti", "Potenza (PZ)"), new structType.ptr("H642", "Russi", "Ravenna (RA)"), new structType.ptr("H643", "Rutigliano", "Bari (BA)"), new structType.ptr("H644", "Rutino", "Salerno (SA)"), new structType.ptr("H165", "Ruviano", "Caserta (CE)"), new structType.ptr("H646", "Ruvo Del Monte", "Potenza (PZ)"), new structType.ptr("H645", "Ruvo Di Puglia", "Bari (BA)"), new structType.ptr("H647", "Sabaudia", "Latina (LT)"), new structType.ptr("H648", "Sabbia", "Vercelli (VC)"), new structType.ptr("H650", "Sabbio Chiese", "Brescia (BS)"), new structType.ptr("H652", "Sabbioneta", "Mantova (MN)"), new structType.ptr("H654", "Sacco", "Salerno (SA)"), new structType.ptr("H655", "Saccolongo", "Padova (PD)"), new structType.ptr("H657", "Sacile", "Pordenone (PN)"), new structType.ptr("H658", "Sacrofano", "Roma (RM)"), new structType.ptr("H659", "Sadali", "Cagliari (CA)"), new structType.ptr("H661", "Sagama", "Oristano (OR)"), new structType.ptr("H662", "Sagliano Micca", "Biella (BI)"), new structType.ptr("H665", "Sagrado", "Gorizia (GO)"), new structType.ptr("H666", "Sagron Mis", "Trento (TN)"), new structType.ptr("H669", "Saint-Christophe", "Aosta (AO)"), new structType.ptr("H670", "Saint-Denis", "Aosta (AO)"), new structType.ptr("H671", "Saint-Marcel", "Aosta (AO)"), new structType.ptr("H672", "Saint-Nicolas", "Aosta (AO)"), new structType.ptr("H673", "Saint-Oyen", "Aosta (AO)"), new structType.ptr("H674", "Saint-Pierre", "Aosta (AO)"), new structType.ptr("H675", "Saint-Rhemy-En-Bosses", "Aosta (AO)"), new structType.ptr("H676", "Saint-Vincent", "Aosta (AO)"), new structType.ptr("H682", "Sala Baganza", "Parma (PR)"), new structType.ptr("H681", "Sala Biellese", "Biella (BI)"), new structType.ptr("H678", "Sala Bolognese", "Bologna (BO)"), new structType.ptr("H679", "Sala Comacina", "Como (CO)"), new structType.ptr("H683", "Sala Consilina", "Salerno (SA)"), new structType.ptr("H677", "Sala Monferrato", "Alessandria (AL)"), new structType.ptr("H687", "Salandra", "Matera (MT)"), new structType.ptr("H688", "Salaparuta", "Trapani (TP)"), new structType.ptr("H689", "Salara", "Rovigo (RO)"), new structType.ptr("H690", "Salasco", "Vercelli (VC)"), new structType.ptr("H691", "Salassa", "Torino (TO)"), new structType.ptr("H684", "Salbertrand", "Torino (TO)"), new structType.ptr("F810", "Salcedo", "Vicenza (VI)"), new structType.ptr("H693", "Salcito", "Campobasso (CB)"), new structType.ptr("H694", "Sale", "Alessandria (AL)"), new structType.ptr("H695", "Sale Delle Langhe", "Cuneo (CN)"), new structType.ptr("H699", "Sale Marasino", "Brescia (BS)"), new structType.ptr("H704", "Sale San Giovanni", "Cuneo (CN)"), new structType.ptr("H700", "Salemi", "Trapani (TP)"), new structType.ptr("H686", "Salento", "Salerno (SA)"), new structType.ptr("H702", "Salerano Canavese", "Torino (TO)"), new structType.ptr("H701", "Salerano Sul Lambro", "Lodi (LO)"), new structType.ptr("H703", "Salerno", "Salerno (SA)"), new structType.ptr("H705", "Saletto", "Padova (PD)"), new structType.ptr("H706", "Salgareda", "Treviso (TV)"), new structType.ptr("H707", "Sali Vercellese", "Vercelli (VC)"), new structType.ptr("H708", "Salice Salentino", "Lecce (LE)"), new structType.ptr("H710", "Saliceto", "Cuneo (CN)"), new structType.ptr("H713", "Salisano", "Rieti (RI)"), new structType.ptr("H714", "Salizzole", "Verona (VR)"), new structType.ptr("H715", "Salle", "Pescara (PE)"), new structType.ptr("H716", "Salmour", "Cuneo (CN)"), new structType.ptr("H717", "Sal\xC3\xB2", "Brescia (BS)"), new structType.ptr("H719", "Salorno .Salurn.", "Bolzano (BZ)"), new structType.ptr("H720", "Salsomaggiore Terme", "Parma (PR)"), new structType.ptr("H723", "Saltrio", "Varese (VA)"), new structType.ptr("H724", "Saludecio", "Rimini (RN)"), new structType.ptr("H725", "Saluggia", "Vercelli (VC)"), new structType.ptr("H726", "Salussola", "Biella (BI)"), new structType.ptr("H727", "Saluzzo", "Cuneo (CN)"), new structType.ptr("H729", "Salve", "Lecce (LE)"), new structType.ptr("H731", "Salvirola", "Cremona (CR)"), new structType.ptr("H732", "Salvitelle", "Salerno (SA)"), new structType.ptr("H734", "Salza Di Pinerolo", "Torino (TO)"), new structType.ptr("H733", "Salza Irpina", "Avellino (AV)"), new structType.ptr("H735", "Salzano", "Venezia (VE)"), new structType.ptr("H736", "Samarate", "Varese (VA)"), new structType.ptr("H738", "Samassi", "Medio Campidano (VS)"), new structType.ptr("H739", "Samatzai", "Cagliari (CA)"), new structType.ptr("H743", "Sambuca Di Sicilia", "Agrigento (AG)"), new structType.ptr("H744", "Sambuca Pistoiese", "Pistoia (PT)"), new structType.ptr("H745", "Sambuci", "Roma (RM)"), new structType.ptr("H746", "Sambuco", "Cuneo (CN)"), new structType.ptr("H749", "Sammichele Di Bari", "Bari (BA)"), new structType.ptr("H013", "Samo", "Reggio Calabria (RC)"), new structType.ptr("H752", "Samolaco", "Sondrio (SO)"), new structType.ptr("H754", "Samone", "Trento (TN)"), new structType.ptr("H753", "Samone", "Torino (TO)"), new structType.ptr("H755", "Sampeyre", "Cuneo (CN)"), new structType.ptr("H756", "Samugheo", "Oristano (OR)"), new structType.ptr("H763", "San Bartolomeo Al Mare", "Imperia (IM)"), new structType.ptr("H764", "San Bartolomeo In Galdo", "Benevento (BN)"), new structType.ptr("H760", "San Bartolomeo Val Cavargna", "Como (CO)"), new structType.ptr("H765", "San Basile", "Cosenza (CS)"), new structType.ptr("H766", "San Basilio", "Cagliari (CA)"), new structType.ptr("H767", "San Bassano", "Cremona (CR)"), new structType.ptr("H768", "San Bellino", "Rovigo (RO)"), new structType.ptr("H770", "San Benedetto Belbo", "Cuneo (CN)"), new structType.ptr("H772", "San Benedetto Dei Marsi", "L'Aquila (AQ)"), new structType.ptr("H769", "San Benedetto Del Tronto", "Ascoli Piceno (AP)"), new structType.ptr("H773", "San Benedetto In Perillis", "L'Aquila (AQ)"), new structType.ptr("H771", "San Benedetto Po", "Mantova (MN)"), new structType.ptr("H774", "San Benedetto Ullano", "Cosenza (CS)"), new structType.ptr("G566", "San Benedetto Val Di Sambro", "Bologna (BO)"), new structType.ptr("H775", "San Benigno Canavese", "Torino (TO)"), new structType.ptr("H777", "San Bernardino Verbano", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("H780", "San Biagio Della Cima", "Imperia (IM)"), new structType.ptr("H781", "San Biagio Di Callalta", "Treviso (TV)"), new structType.ptr("H778", "San Biagio Platani", "Agrigento (AG)"), new structType.ptr("H779", "San Biagio Saracinisco", "Frosinone (FR)"), new structType.ptr("H782", "San Biase", "Campobasso (CB)"), new structType.ptr("H783", "San Bonifacio", "Verona (VR)"), new structType.ptr("H784", "San Buono", "Chieti (CH)"), new structType.ptr("H785", "San Calogero", "Vibo Valentia (VV)"), new structType.ptr("H786", "San Candido .Innichen.", "Bolzano (BZ)"), new structType.ptr("H787", "San Canzian D'Isonzo", "Gorizia (GO)"), new structType.ptr("H789", "San Carlo Canavese", "Torino (TO)"), new structType.ptr("H790", "San Casciano Dei Bagni", "Siena (SI)"), new structType.ptr("H791", "San Casciano In Val Di Pesa", "Firenze (FI)"), new structType.ptr("M264", "San Cassiano", "Lecce (LE)"), new structType.ptr("H792", "San Cataldo", "Caltanissetta (CL)"), new structType.ptr("M295", "San Cesareo", "Roma (RM)"), new structType.ptr("H793", "San Cesario Di Lecce", "Lecce (LE)"), new structType.ptr("H794", "San Cesario Sul Panaro", "Modena (MO)"), new structType.ptr("H795", "San Chirico Nuovo", "Potenza (PZ)"), new structType.ptr("H796", "San Chirico Raparo", "Potenza (PZ)"), new structType.ptr("H797", "San Cipirello", "Palermo (PA)"), new structType.ptr("H798", "San Cipriano D'Aversa", "Caserta (CE)"), new structType.ptr("H800", "San Cipriano Picentino", "Salerno (SA)"), new structType.ptr("H799", "San Cipriano Po", "Pavia (PV)"), new structType.ptr("H801", "San Clemente", "Rimini (RN)"), new structType.ptr("H803", "San Colombano Al Lambro", "Milano (MI)"), new structType.ptr("H804", "San Colombano Belmonte", "Torino (TO)"), new structType.ptr("H802", "San Colombano Certenoli", "Genova (GE)"), new structType.ptr("H805", "San Cono", "Catania (CT)"), new structType.ptr("H806", "San Cosmo Albanese", "Cosenza (CS)"), new structType.ptr("H808", "San Costantino Albanese", "Potenza (PZ)"), new structType.ptr("H807", "San Costantino Calabro", "Vibo Valentia (VV)"), new structType.ptr("H809", "San Costanzo", "Pesaro e Urbino (PU)"), new structType.ptr("H810", "San Cristoforo", "Alessandria (AL)"), new structType.ptr("H814", "San Damiano Al Colle", "Pavia (PV)"), new structType.ptr("H811", "San Damiano D'Asti", "Asti (AT)"), new structType.ptr("H812", "San Damiano Macra", "Cuneo (CN)"), new structType.ptr("H816", "San Daniele Del Friuli", "Udine (UD)"), new structType.ptr("H815", "San Daniele Po", "Cremona (CR)"), new structType.ptr("H818", "San Demetrio Corone", "Cosenza (CS)"), new structType.ptr("H819", "San Demetrio Ne' Vestini", "L'Aquila (AQ)"), new structType.ptr("H820", "San Didero", "Torino (TO)"), new structType.ptr("H823", "San Dona' Di Piave", "Venezia (VE)"), new structType.ptr("H822", "San Donaci", "Brindisi (BR)"), new structType.ptr("H826", "San Donato Di Lecce", "Lecce (LE)"), new structType.ptr("H825", "San Donato Di Ninea", "Cosenza (CS)"), new structType.ptr("H827", "San Donato Milanese", "Milano (MI)"), new structType.ptr("H824", "San Donato Val Di Comino", "Frosinone (FR)"), new structType.ptr("D324", "San Dorligo Della Valle", "Trieste (TS)"), new structType.ptr("H830", "San Fedele Intelvi", "Como (CO)"), new structType.ptr("H831", "San Fele", "Potenza (PZ)"), new structType.ptr("H834", "San Felice A Cancello", "Caserta (CE)"), new structType.ptr("H836", "San Felice Circeo", "Latina (LT)"), new structType.ptr("H838", "San Felice Del Benaco", "Brescia (BS)"), new structType.ptr("H833", "San Felice Del Molise", "Campobasso (CB)"), new structType.ptr("H835", "San Felice Sul Panaro", "Modena (MO)"), new structType.ptr("M277", "San Ferdinando", "Reggio Calabria (RC)"), new structType.ptr("H839", "San Ferdinando Di Puglia", "Barletta-Andria-Trani (BT)"), new structType.ptr("H840", "San Fermo Della Battaglia", "Como (CO)"), new structType.ptr("H841", "San Fili", "Cosenza (CS)"), new structType.ptr("H842", "San Filippo Del Mela", "Messina (ME)"), new structType.ptr("H843", "San Fior", "Treviso (TV)"), new structType.ptr("H844", "San Fiorano", "Lodi (LO)"), new structType.ptr("H845", "San Floriano Del Collio", "Gorizia (GO)"), new structType.ptr("H846", "San Floro", "Catanzaro (CZ)"), new structType.ptr("H847", "San Francesco Al Campo", "Torino (TO)"), new structType.ptr("H850", "San Fratello", "Messina (ME)"), new structType.ptr("H856", "San Gavino Monreale", "Medio Campidano (VS)"), new structType.ptr("H857", "San Gemini", "Terni (TR)"), new structType.ptr("H858", "San Genesio Atesino .Jenesien.", "Bolzano (BZ)"), new structType.ptr("H859", "San Genesio Ed Uniti", "Pavia (PV)"), new structType.ptr("H860", "San Gennaro Vesuviano", "Napoli (NA)"), new structType.ptr("H862", "San Germano Chisone", "Torino (TO)"), new structType.ptr("H863", "San Germano Dei Berici", "Vicenza (VI)"), new structType.ptr("H861", "San Germano Vercellese", "Vercelli (VC)"), new structType.ptr("H865", "San Gervasio Bresciano", "Brescia (BS)"), new structType.ptr("H867", "San Giacomo Degli Schiavoni", "Campobasso (CB)"), new structType.ptr("H870", "San Giacomo Delle Segnate", "Mantova (MN)"), new structType.ptr("H868", "San Giacomo Filippo", "Sondrio (SO)"), new structType.ptr("B952", "San Giacomo Vercellese", "Vercelli (VC)"), new structType.ptr("H873", "San Gillio", "Torino (TO)"), new structType.ptr("H875", "San Gimignano", "Siena (SI)"), new structType.ptr("H876", "San Ginesio", "Macerata (MC)"), new structType.ptr("H892", "San Giorgio A Cremano", "Napoli (NA)"), new structType.ptr("H880", "San Giorgio A Liri", "Frosinone (FR)"), new structType.ptr("H881", "San Giorgio Albanese", "Cosenza (CS)"), new structType.ptr("H890", "San Giorgio Canavese", "Torino (TO)"), new structType.ptr("H894", "San Giorgio Del Sannio", "Benevento (BN)"), new structType.ptr("H891", "San Giorgio Della Richinvelda", "Pordenone (PN)"), new structType.ptr("H893", "San Giorgio Delle Pertiche", "Padova (PD)"), new structType.ptr("H885", "San Giorgio Di Lomellina", "Pavia (PV)"), new structType.ptr("H883", "San Giorgio Di Mantova", "Mantova (MN)"), new structType.ptr("H895", "San Giorgio Di Nogaro", "Udine (UD)"), new structType.ptr("H896", "San Giorgio Di Piano", "Bologna (BO)"), new structType.ptr("H897", "San Giorgio In Bosco", "Padova (PD)"), new structType.ptr("H882", "San Giorgio Ionico", "Taranto (TA)"), new structType.ptr("H898", "San Giorgio La Molara", "Benevento (BN)"), new structType.ptr("H888", "San Giorgio Lucano", "Matera (MT)"), new structType.ptr("H878", "San Giorgio Monferrato", "Alessandria (AL)"), new structType.ptr("H889", "San Giorgio Morgeto", "Reggio Calabria (RC)"), new structType.ptr("H887", "San Giorgio Piacentino", "Piacenza (PC)"), new structType.ptr("H899", "San Giorgio Scarampi", "Asti (AT)"), new structType.ptr("H884", "San Giorgio Su Legnano", "Milano (MI)"), new structType.ptr("H900", "San Giorio Di Susa", "Torino (TO)"), new structType.ptr("H907", "San Giovanni A Piro", "Salerno (SA)"), new structType.ptr("H906", "San Giovanni Al Natisone", "Udine (UD)"), new structType.ptr("H910", "San Giovanni Bianco", "Bergamo (BG)"), new structType.ptr("H912", "San Giovanni Del Dosso", "Mantova (MN)"), new structType.ptr("H903", "San Giovanni Di Gerace", "Reggio Calabria (RC)"), new structType.ptr("H914", "San Giovanni Gemini", "Agrigento (AG)"), new structType.ptr("H916", "San Giovanni Ilarione", "Verona (VR)"), new structType.ptr("H918", "San Giovanni In Croce", "Cremona (CR)"), new structType.ptr("H919", "San Giovanni In Fiore", "Cosenza (CS)"), new structType.ptr("H920", "San Giovanni In Galdo", "Campobasso (CB)"), new structType.ptr("H921", "San Giovanni In Marignano", "Rimini (RN)"), new structType.ptr("G467", "San Giovanni In Persiceto", "Bologna (BO)"), new structType.ptr("H917", "San Giovanni Incarico", "Frosinone (FR)"), new structType.ptr("H922", "San Giovanni La Punta", "Catania (CT)"), new structType.ptr("H923", "San Giovanni Lipioni", "Chieti (CH)"), new structType.ptr("H924", "San Giovanni Lupatoto", "Verona (VR)"), new structType.ptr("H926", "San Giovanni Rotondo", "Foggia (FG)"), new structType.ptr("G287", "San Giovanni Suergiu", "Carbonia-Iglesias (CI)"), new structType.ptr("D690", "San Giovanni Teatino", "Chieti (CH)"), new structType.ptr("H901", "San Giovanni Valdarno", "Arezzo (AR)"), new structType.ptr("H928", "San Giuliano Del Sannio", "Campobasso (CB)"), new structType.ptr("H929", "San Giuliano Di Puglia", "Campobasso (CB)"), new structType.ptr("H930", "San Giuliano Milanese", "Milano (MI)"), new structType.ptr("A562", "San Giuliano Terme", "Pisa (PI)"), new structType.ptr("H933", "San Giuseppe Jato", "Palermo (PA)"), new structType.ptr("H931", "San Giuseppe Vesuviano", "Napoli (NA)"), new structType.ptr("H935", "San Giustino", "Perugia (PG)"), new structType.ptr("H936", "San Giusto Canavese", "Torino (TO)"), new structType.ptr("H937", "San Godenzo", "Firenze (FI)"), new structType.ptr("H942", "San Gregorio Da Sassola", "Roma (RM)"), new structType.ptr("H940", "San Gregorio Di Catania", "Catania (CT)"), new structType.ptr("H941", "San Gregorio D'Ippona", "Vibo Valentia (VV)"), new structType.ptr("H943", "San Gregorio Magno", "Salerno (SA)"), new structType.ptr("H939", "San Gregorio Matese", "Caserta (CE)"), new structType.ptr("H938", "San Gregorio Nelle Alpi", "Belluno (BL)"), new structType.ptr("H945", "San Lazzaro Di Savena", "Bologna (BO)"), new structType.ptr("H949", "San Leo", "Rimini (RN)"), new structType.ptr("H951", "San Leonardo", "Udine (UD)"), new structType.ptr("H952", "San Leonardo In Passiria .St Leonhard In Pas.", "Bolzano (BZ)"), new structType.ptr("H953", "San Leucio Del Sannio", "Benevento (BN)"), new structType.ptr("H955", "San Lorenzello", "Benevento (BN)"), new structType.ptr("H959", "San Lorenzo", "Reggio Calabria (RC)"), new structType.ptr("H957", "San Lorenzo Al Mare", "Imperia (IM)"), new structType.ptr("H961", "San Lorenzo Bellizzi", "Cosenza (CS)"), new structType.ptr("H962", "San Lorenzo Del Vallo", "Cosenza (CS)"), new structType.ptr("H956", "San Lorenzo Di Sebato .St Lorenzen.", "Bolzano (BZ)"), new structType.ptr("M345", "San Lorenzo Dorsino", "Trento (TN)"), new structType.ptr("H958", "San Lorenzo In Campo", "Pesaro e Urbino (PU)"), new structType.ptr("H964", "San Lorenzo Isontino", "Gorizia (GO)"), new structType.ptr("H967", "San Lorenzo Maggiore", "Benevento (BN)"), new structType.ptr("H969", "San Lorenzo Nuovo", "Viterbo (VT)"), new structType.ptr("H970", "San Luca", "Reggio Calabria (RC)"), new structType.ptr("H971", "San Lucido", "Cosenza (CS)"), new structType.ptr("H973", "San Lupo", "Benevento (BN)"), new structType.ptr("H976", "San Mango D'Aquino", "Catanzaro (CZ)"), new structType.ptr("H977", "San Mango Piemonte", "Salerno (SA)"), new structType.ptr("H975", "San Mango Sul Calore", "Avellino (AV)"), new structType.ptr("H978", "San Marcellino", "Caserta (CE)"), new structType.ptr("H979", "San Marcello", "Ancona (AN)"), new structType.ptr("M377", "San Marcello Piteglio", "Pistoia (PT)"), new structType.ptr("H981", "San Marco Argentano", "Cosenza (CS)"), new structType.ptr("H982", "San Marco D'Alunzio", "Messina (ME)"), new structType.ptr("H984", "San Marco Dei Cavoti", "Benevento (BN)"), new structType.ptr("F043", "San Marco Evangelista", "Caserta (CE)"), new structType.ptr("H985", "San Marco In Lamis", "Foggia (FG)"), new structType.ptr("H986", "San Marco La Catola", "Foggia (FG)"), new structType.ptr("H999", "San Martino Al Tagliamento", "Pordenone (PN)"), new structType.ptr("H987", "San Martino Alfieri", "Asti (AT)"), new structType.ptr("I003", "San Martino Buon Albergo", "Verona (VR)"), new structType.ptr("H997", "San Martino Canavese", "Torino (TO)"), new structType.ptr("H994", "San Martino D'Agri", "Potenza (PZ)"), new structType.ptr("I005", "San Martino Dall'Argine", "Mantova (MN)"), new structType.ptr("I007", "San Martino Del Lago", "Cremona (CR)"), new structType.ptr("H992", "San Martino Di Finita", "Cosenza (CS)"), new structType.ptr("I008", "San Martino Di Lupari", "Padova (PD)"), new structType.ptr("H996", "San Martino Di Venezze", "Rovigo (RO)"), new structType.ptr("H988", "San Martino In Badia .St Martin In Thurn.", "Bolzano (BZ)"), new structType.ptr("H989", "San Martino In Passiria .St Martin In Passei.", "Bolzano (BZ)"), new structType.ptr("H990", "San Martino In Pensilis", "Campobasso (CB)"), new structType.ptr("I011", "San Martino In Rio", "Reggio Emilia (RE)"), new structType.ptr("I012", "San Martino In Strada", "Lodi (LO)"), new structType.ptr("I002", "San Martino Sannita", "Benevento (BN)"), new structType.ptr("I014", "San Martino Siccomario", "Pavia (PV)"), new structType.ptr("H991", "San Martino Sulla Marrucina", "Chieti (CH)"), new structType.ptr("I016", "San Martino Valle Caudina", "Avellino (AV)"), new structType.ptr("I018", "San Marzano Di San Giuseppe", "Taranto (TA)"), new structType.ptr("I017", "San Marzano Oliveto", "Asti (AT)"), new structType.ptr("I019", "San Marzano Sul Sarno", "Salerno (SA)"), new structType.ptr("I023", "San Massimo", "Campobasso (CB)"), new structType.ptr("I024", "San Maurizio Canavese", "Torino (TO)"), new structType.ptr("I025", "San Maurizio D'Opaglio", "Novara (NO)"), new structType.ptr("I028", "San Mauro Castelverde", "Palermo (PA)"), new structType.ptr("I031", "San Mauro Cilento", "Salerno (SA)"), new structType.ptr("H712", "San Mauro Di Saline", "Verona (VR)"), new structType.ptr("I029", "San Mauro Forte", "Matera (MT)"), new structType.ptr("I032", "San Mauro La Bruca", "Salerno (SA)"), new structType.ptr("I026", "San Mauro Marchesato", "Crotone (KR)"), new structType.ptr("I027", "San Mauro Pascoli", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("I030", "San Mauro Torinese", "Torino (TO)"), new structType.ptr("I040", "San Michele Al Tagliamento", "Venezia (VE)"), new structType.ptr("I042", "San Michele All'Adige", "Trento (TN)"), new structType.ptr("I035", "San Michele Di Ganzaria", "Catania (CT)"), new structType.ptr("I034", "San Michele Di Serino", "Avellino (AV)"), new structType.ptr("I037", "San Michele Mondov\xC3\xAC", "Cuneo (CN)"), new structType.ptr("I045", "San Michele Salentino", "Brindisi (BR)"), new structType.ptr("I046", "San Miniato", "Pisa (PI)"), new structType.ptr("I047", "San Nazario", "Vicenza (VI)"), new structType.ptr("I049", "San Nazzaro", "Benevento (BN)"), new structType.ptr("I052", "San Nazzaro Sesia", "Novara (NO)"), new structType.ptr("I051", "San Nazzaro Val Cavargna", "Como (CO)"), new structType.ptr("I054", "San Nicandro Garganico", "Foggia (FG)"), new structType.ptr("I060", "San Nicola Arcella", "Cosenza (CS)"), new structType.ptr("I061", "San Nicola Baronia", "Avellino (AV)"), new structType.ptr("I058", "San Nicola Da Crissa", "Vibo Valentia (VV)"), new structType.ptr("I057", "San Nicola Dell'Alto", "Crotone (KR)"), new structType.ptr("I056", "San Nicola La Strada", "Caserta (CE)"), new structType.ptr("I062", "San Nicola Manfredi", "Benevento (BN)"), new structType.ptr("A368", "San Nicolo' D'Arcidano", "Oristano (OR)"), new structType.ptr("I063", "San Nicolo' Di Comelico", "Belluno (BL)"), new structType.ptr("G383", "San Nicolo' Gerrei", "Cagliari (CA)"), new structType.ptr("I065", "San Pancrazio .St Pankraz.", "Bolzano (BZ)"), new structType.ptr("I066", "San Pancrazio Salentino", "Brindisi (BR)"), new structType.ptr("G407", "San Paolo", "Brescia (BS)"), new structType.ptr("B906", "San Paolo Albanese", "Potenza (PZ)"), new structType.ptr("I073", "San Paolo Bel Sito", "Napoli (NA)"), new structType.ptr("B310", "San Paolo D'Argon", "Bergamo (BG)"), new structType.ptr("I072", "San Paolo Di Civitate", "Foggia (FG)"), new structType.ptr("I071", "San Paolo Di Jesi", "Ancona (AN)"), new structType.ptr("I076", "San Paolo Solbrito", "Asti (AT)"), new structType.ptr("I079", "San Pellegrino Terme", "Bergamo (BG)"), new structType.ptr("I082", "San Pier D'Isonzo", "Gorizia (GO)"), new structType.ptr("I084", "San Pier Niceto", "Messina (ME)"), new structType.ptr("I086", "San Piero Patti", "Messina (ME)"), new structType.ptr("I093", "San Pietro A Maida", "Catanzaro (CZ)"), new structType.ptr("I092", "San Pietro Al Natisone", "Udine (UD)"), new structType.ptr("I089", "San Pietro Al Tanagro", "Salerno (SA)"), new structType.ptr("I095", "San Pietro Apostolo", "Catanzaro (CZ)"), new structType.ptr("I096", "San Pietro Avellana", "Isernia (IS)"), new structType.ptr("I098", "San Pietro Clarenza", "Catania (CT)"), new structType.ptr("I088", "San Pietro Di Cadore", "Belluno (BL)"), new structType.ptr("I102", "San Pietro Di Carid\xC3\xA0", "Reggio Calabria (RC)"), new structType.ptr("I103", "San Pietro Di Feletto", "Treviso (TV)"), new structType.ptr("I105", "San Pietro Di Morubio", "Verona (VR)"), new structType.ptr("I108", "San Pietro In Amantea", "Cosenza (CS)"), new structType.ptr("I109", "San Pietro In Cariano", "Verona (VR)"), new structType.ptr("I110", "San Pietro In Casale", "Bologna (BO)"), new structType.ptr("G788", "San Pietro In Cerro", "Piacenza (PC)"), new structType.ptr("I107", "San Pietro In Gu", "Padova (PD)"), new structType.ptr("I114", "San Pietro In Guarano", "Cosenza (CS)"), new structType.ptr("I115", "San Pietro In Lama", "Lecce (LE)"), new structType.ptr("I113", "San Pietro Infine", "Caserta (CE)"), new structType.ptr("I116", "San Pietro Mosezzo", "Novara (NO)"), new structType.ptr("I117", "San Pietro Mussolino", "Vicenza (VI)"), new structType.ptr("I090", "San Pietro Val Lemina", "Torino (TO)"), new structType.ptr("I119", "San Pietro Vernotico", "Brindisi (BR)"), new structType.ptr("I120", "San Pietro Viminario", "Padova (PD)"), new structType.ptr("I121", "San Pio Delle Camere", "L'Aquila (AQ)"), new structType.ptr("I125", "San Polo Dei Cavalieri", "Roma (RM)"), new structType.ptr("I123", "San Polo D'Enza", "Reggio Emilia (RE)"), new structType.ptr("I124", "San Polo Di Piave", "Treviso (TV)"), new structType.ptr("I122", "San Polo Matese", "Campobasso (CB)"), new structType.ptr("I126", "San Ponso", "Torino (TO)"), new structType.ptr("I128", "San Possidonio", "Modena (MO)"), new structType.ptr("I130", "San Potito Sannitico", "Caserta (CE)"), new structType.ptr("I129", "San Potito Ultra", "Avellino (AV)"), new structType.ptr("I131", "San Prisco", "Caserta (CE)"), new structType.ptr("I132", "San Procopio", "Reggio Calabria (RC)"), new structType.ptr("I133", "San Prospero", "Modena (MO)"), new structType.ptr("I135", "San Quirico D'Orcia", "Siena (SI)"), new structType.ptr("I136", "San Quirino", "Pordenone (PN)"), new structType.ptr("I137", "San Raffaele Cimena", "Torino (TO)"), new structType.ptr("I139", "San Roberto", "Reggio Calabria (RC)"), new structType.ptr("I140", "San Rocco Al Porto", "Lodi (LO)"), new structType.ptr("I142", "San Romano In Garfagnana", "Lucca (LU)"), new structType.ptr("I143", "San Rufo", "Salerno (SA)"), new structType.ptr("I147", "San Salvatore Di Fitalia", "Messina (ME)"), new structType.ptr("I144", "San Salvatore Monferrato", "Alessandria (AL)"), new structType.ptr("I145", "San Salvatore Telesino", "Benevento (BN)"), new structType.ptr("I148", "San Salvo", "Chieti (CH)"), new structType.ptr("I151", "San Sebastiano Al Vesuvio", "Napoli (NA)"), new structType.ptr("I150", "San Sebastiano Curone", "Alessandria (AL)"), new structType.ptr("I152", "San Sebastiano Da Po", "Torino (TO)"), new structType.ptr("I154", "San Secondo Di Pinerolo", "Torino (TO)"), new structType.ptr("I153", "San Secondo Parmense", "Parma (PR)"), new structType.ptr("I157", "San Severino Lucano", "Potenza (PZ)"), new structType.ptr("I156", "San Severino Marche", "Macerata (MC)"), new structType.ptr("I158", "San Severo", "Foggia (FG)"), new structType.ptr("I162", "San Siro", "Como (CO)"), new structType.ptr("I163", "San Sossio Baronia", "Avellino (AV)"), new structType.ptr("I164", "San Sostene", "Catanzaro (CZ)"), new structType.ptr("I165", "San Sosti", "Cosenza (CS)"), new structType.ptr("I166", "San Sperate", "Cagliari (CA)"), new structType.ptr("I373", "San Stino Di Livenza", "Venezia (VE)"), new structType.ptr("I261", "San Tammaro", "Caserta (CE)"), new structType.ptr("I328", "San Teodoro", "Messina (ME)"), new structType.ptr("I329", "San Teodoro", "Olbia-Tempio (OT)"), new structType.ptr("I347", "San Tomaso Agordino", "Belluno (BL)"), new structType.ptr("I376", "San Valentino In Abruzzo Citeriore", "Pescara (PE)"), new structType.ptr("I377", "San Valentino Torio", "Salerno (SA)"), new structType.ptr("I381", "San Venanzo", "Terni (TR)"), new structType.ptr("I382", "San Vendemiano", "Treviso (TV)"), new structType.ptr("I384", "San Vero Milis", "Oristano (OR)"), new structType.ptr("I390", "San Vincenzo", "Livorno (LI)"), new structType.ptr("I388", "San Vincenzo La Costa", "Cosenza (CS)"), new structType.ptr("I389", "San Vincenzo Valle Roveto", "L'Aquila (AQ)"), new structType.ptr("I391", "San Vitaliano", "Napoli (NA)"), new structType.ptr("I402", "San Vito", "Cagliari (CA)"), new structType.ptr("I403", "San Vito Al Tagliamento", "Pordenone (PN)"), new structType.ptr("I404", "San Vito Al Torre", "Udine (UD)"), new structType.ptr("I394", "San Vito Chietino", "Chieti (CH)"), new structType.ptr("I396", "San Vito Dei Normanni", "Brindisi (BR)"), new structType.ptr("I392", "San Vito Di Cadore", "Belluno (BL)"), new structType.ptr("I405", "San Vito Di Fagagna", "Udine (UD)"), new structType.ptr("I401", "San Vito Di Leguzzano", "Vicenza (VI)"), new structType.ptr("I407", "San Vito Lo Capo", "Trapani (TP)"), new structType.ptr("I400", "San Vito Romano", "Roma (RM)"), new structType.ptr("I393", "San Vito Sullo Ionio", "Catanzaro (CZ)"), new structType.ptr("I408", "San Vittore Del Lazio", "Frosinone (FR)"), new structType.ptr("I409", "San Vittore Olona", "Milano (MI)"), new structType.ptr("I414", "San Zeno Di Montagna", "Verona (VR)"), new structType.ptr("I412", "San Zeno Naviglio", "Brescia (BS)"), new structType.ptr("I415", "San Zenone Al Lambro", "Milano (MI)"), new structType.ptr("I416", "San Zenone Al Po", "Pavia (PV)"), new structType.ptr("I417", "San Zenone Degli Ezzelini", "Treviso (TV)"), new structType.ptr("H757", "Sanarica", "Lecce (LE)"), new structType.ptr("H821", "Sandigliano", "Biella (BI)"), new structType.ptr("H829", "Sandrigo", "Vicenza (VI)"), new structType.ptr("H851", "Sanfr\xC3\xA8", "Cuneo (CN)"), new structType.ptr("H852", "Sanfront", "Cuneo (CN)"), new structType.ptr("H855", "Sangano", "Torino (TO)"), new structType.ptr("H872", "Sangiano", "Varese (VA)"), new structType.ptr("H877", "Sangineto", "Cosenza (CS)"), new structType.ptr("H944", "Sanguinetto", "Verona (VR)"), new structType.ptr("H974", "Sanluri", "Medio Campidano (VS)"), new structType.ptr("I048", "Sannazzaro De' Burgondi", "Pavia (PV)"), new structType.ptr("I053", "Sannicandro Di Bari", "Bari (BA)"), new structType.ptr("I059", "Sannicola", "Lecce (LE)"), new structType.ptr("I138", "Sanremo", "Imperia (IM)"), new structType.ptr("I155", "Sansepolcro", "Arezzo (AR)"), new structType.ptr("I168", "Santa Brigida", "Bergamo (BG)"), new structType.ptr("I171", "Santa Caterina Albanese", "Cosenza (CS)"), new structType.ptr("I170", "Santa Caterina Dello Ionio", "Catanzaro (CZ)"), new structType.ptr("I169", "Santa Caterina Villarmosa", "Caltanissetta (CL)"), new structType.ptr("I172", "Santa Cesarea Terme", "Lecce (LE)"), new structType.ptr("I176", "Santa Cristina D'Aspromonte", "Reggio Calabria (RC)"), new structType.ptr("I175", "Santa Cristina E Bissone", "Pavia (PV)"), new structType.ptr("I174", "Santa Cristina Gela", "Palermo (PA)"), new structType.ptr("I173", "Santa Cristina Valgardena .St Christina In", "Bolzano (BZ)"), new structType.ptr("I178", "Santa Croce Camerina", "Ragusa (RG)"), new structType.ptr("I179", "Santa Croce Del Sannio", "Benevento (BN)"), new structType.ptr("I181", "Santa Croce Di Magliano", "Campobasso (CB)"), new structType.ptr("I177", "Santa Croce Sull'Arno", "Pisa (PI)"), new structType.ptr("I183", "Santa Domenica Talao", "Cosenza (CS)"), new structType.ptr("I184", "Santa Domenica Vittoria", "Messina (ME)"), new structType.ptr("I185", "Santa Elisabetta", "Agrigento (AG)"), new structType.ptr("I187", "Santa Fiora", "Grosseto (GR)"), new structType.ptr("I188", "Santa Flavia", "Palermo (PA)"), new structType.ptr("I203", "Santa Giuletta", "Pavia (PV)"), new structType.ptr("I205", "Santa Giusta", "Oristano (OR)"), new structType.ptr("I206", "Santa Giustina", "Belluno (BL)"), new structType.ptr("I207", "Santa Giustina In Colle", "Padova (PD)"), new structType.ptr("I217", "Santa Luce", "Pisa (PI)"), new structType.ptr("I220", "Santa Lucia Del Mela", "Messina (ME)"), new structType.ptr("I221", "Santa Lucia Di Piave", "Treviso (TV)"), new structType.ptr("I219", "Santa Lucia Di Serino", "Avellino (AV)"), new structType.ptr("I226", "Santa Margherita D'Adige", "Padova (PD)"), new structType.ptr("I224", "Santa Margherita Di Belice", "Agrigento (AG)"), new structType.ptr("I230", "Santa Margherita Di Staffora", "Pavia (PV)"), new structType.ptr("I225", "Santa Margherita Ligure", "Genova (GE)"), new structType.ptr("I232", "Santa Maria A Monte", "Pisa (PI)"), new structType.ptr("I233", "Santa Maria A Vico", "Caserta (CE)"), new structType.ptr("I234", "Santa Maria Capua Vetere", "Caserta (CE)"), new structType.ptr("M284", "Santa Maria Coghinas", "Sassari (SS)"), new structType.ptr("C717", "Santa Maria Del Cedro", "Cosenza (CS)"), new structType.ptr("I238", "Santa Maria Del Molise", "Isernia (IS)"), new structType.ptr("I237", "Santa Maria Della Versa", "Pavia (PV)"), new structType.ptr("I240", "Santa Maria Di Licodia", "Catania (CT)"), new structType.ptr("I242", "Santa Maria Di Sala", "Venezia (VE)"), new structType.ptr("I243", "Santa Maria Ho\xC3\xA8", "Lecco (LC)"), new structType.ptr("I244", "Santa Maria Imbaro", "Chieti (CH)"), new structType.ptr("M273", "Santa Maria La Carit\xC3\xA0", "Napoli (NA)"), new structType.ptr("I247", "Santa Maria La Fossa", "Caserta (CE)"), new structType.ptr("I248", "Santa Maria La Longa", "Udine (UD)"), new structType.ptr("I249", "Santa Maria Maggiore", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("I251", "Santa Maria Nuova", "Ancona (AN)"), new structType.ptr("I253", "Santa Marina", "Salerno (SA)"), new structType.ptr("I254", "Santa Marina Salina", "Messina (ME)"), new structType.ptr("I255", "Santa Marinella", "Roma (RM)"), new structType.ptr("I291", "Santa Ninfa", "Trapani (TP)"), new structType.ptr("I301", "Santa Paolina", "Avellino (AV)"), new structType.ptr("I308", "Santa Severina", "Crotone (KR)"), new structType.ptr("I310", "Santa Sofia", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("I309", "Santa Sofia D'Epiro", "Cosenza (CS)"), new structType.ptr("I311", "Santa Teresa Di Riva", "Messina (ME)"), new structType.ptr("I312", "Santa Teresa Gallura", "Olbia-Tempio (OT)"), new structType.ptr("I314", "Santa Venerina", "Catania (CT)"), new structType.ptr("I316", "Santa Vittoria D'Alba", "Cuneo (CN)"), new structType.ptr("I315", "Santa Vittoria In Matenano", "Fermo (FM)"), new structType.ptr("I182", "Santadi", "Carbonia-Iglesias (CI)"), new structType.ptr("I189", "Sant'Agapito", "Isernia (IS)"), new structType.ptr("I191", "Sant'Agata Bolognese", "Bologna (BO)"), new structType.ptr("I197", "Sant'Agata De' Goti", "Benevento (BN)"), new structType.ptr("I198", "Sant'Agata Del Bianco", "Reggio Calabria (RC)"), new structType.ptr("I192", "Sant'Agata Di Esaro", "Cosenza (CS)"), new structType.ptr("I199", "Sant'Agata Di Militello", "Messina (ME)"), new structType.ptr("I193", "Sant'Agata Di Puglia", "Foggia (FG)"), new structType.ptr("I201", "Sant'Agata Feltria", "Rimini (RN)"), new structType.ptr("I190", "Sant'Agata Fossili", "Alessandria (AL)"), new structType.ptr("I202", "Sant'Agata Li Battiati", "Catania (CT)"), new structType.ptr("I196", "Sant'Agata Sul Santerno", "Ravenna (RA)"), new structType.ptr("I208", "Sant'Agnello", "Napoli (NA)"), new structType.ptr("I210", "Sant'Albano Stura", "Cuneo (CN)"), new structType.ptr("I213", "Sant'Alessio Con Vialone", "Pavia (PV)"), new structType.ptr("I214", "Sant'Alessio In Aspromonte", "Reggio Calabria (RC)"), new structType.ptr("I215", "Sant'Alessio Siculo", "Messina (ME)"), new structType.ptr("I216", "Sant'Alfio", "Catania (CT)"), new structType.ptr("I258", "Sant'Ambrogio Di Torino", "Torino (TO)"), new structType.ptr("I259", "Sant'Ambrogio Di Valpolicella", "Verona (VR)"), new structType.ptr("I256", "Sant'Ambrogio Sul Garigliano", "Frosinone (FR)"), new structType.ptr("I262", "Sant'Anastasia", "Napoli (NA)"), new structType.ptr("I263", "Sant'Anatolia Di Narco", "Perugia (PG)"), new structType.ptr("I266", "Sant'Andrea Apostolo Dello Ionio", "Catanzaro (CZ)"), new structType.ptr("I265", "Sant'Andrea Del Garigliano", "Frosinone (FR)"), new structType.ptr("I264", "Sant'Andrea Di Conza", "Avellino (AV)"), new structType.ptr("I271", "Sant'Andrea Frius", "Cagliari (CA)"), new structType.ptr("I277", "Sant'Angelo A Cupolo", "Benevento (BN)"), new structType.ptr("I278", "Sant'Angelo A Fasanella", "Salerno (SA)"), new structType.ptr("I280", "Sant'Angelo A Scala", "Avellino (AV)"), new structType.ptr("I279", "Sant'Angelo All'Esca", "Avellino (AV)"), new structType.ptr("I273", "Sant'Angelo D'Alife", "Caserta (CE)"), new structType.ptr("I281", "Sant'Angelo Dei Lombardi", "Avellino (AV)"), new structType.ptr("I282", "Sant'Angelo Del Pesco", "Isernia (IS)"), new structType.ptr("I283", "Sant'Angelo Di Brolo", "Messina (ME)"), new structType.ptr("I275", "Sant'Angelo Di Piove Di Sacco", "Padova (PD)"), new structType.ptr("I286", "Sant'Angelo In Pontano", "Macerata (MC)"), new structType.ptr("I287", "Sant'Angelo In Vado", "Pesaro e Urbino (PU)"), new structType.ptr("I288", "Sant'Angelo Le Fratte", "Potenza (PZ)"), new structType.ptr("I289", "Sant'Angelo Limosano", "Campobasso (CB)"), new structType.ptr("I274", "Sant'Angelo Lodigiano", "Lodi (LO)"), new structType.ptr("I276", "Sant'Angelo Lomellina", "Pavia (PV)"), new structType.ptr("I290", "Sant'Angelo Muxaro", "Agrigento (AG)"), new structType.ptr("I284", "Sant'Angelo Romano", "Roma (RM)"), new structType.ptr("M209", "Sant'Anna Arresi", "Carbonia-Iglesias (CI)"), new structType.ptr("I292", "Sant'Anna D'Alfaedo", "Verona (VR)"), new structType.ptr("I293", "Sant'Antimo", "Napoli (NA)"), new structType.ptr("I294", "Sant'Antioco", "Carbonia-Iglesias (CI)"), new structType.ptr("I296", "Sant'Antonino Di Susa", "Torino (TO)"), new structType.ptr("I300", "Sant'Antonio Abate", "Napoli (NA)"), new structType.ptr("M276", "Sant'Antonio Di Gallura", "Olbia-Tempio (OT)"), new structType.ptr("I302", "Sant'Apollinare", "Frosinone (FR)"), new structType.ptr("I305", "Sant'Arcangelo", "Potenza (PZ)"), new structType.ptr("I304", "Santarcangelo Di Romagna", "Rimini (RN)"), new structType.ptr("F557", "Sant'Arcangelo Trimonte", "Benevento (BN)"), new structType.ptr("I306", "Sant'Arpino", "Caserta (CE)"), new structType.ptr("I307", "Sant'Arsenio", "Salerno (SA)"), new structType.ptr("I326", "Sante Marie", "L'Aquila (AQ)"), new structType.ptr("I318", "Sant'Egidio Alla Vibrata", "Teramo (TE)"), new structType.ptr("I317", "Sant'Egidio Del Monte Albino", "Salerno (SA)"), new structType.ptr("I319", "Sant'Elena", "Padova (PD)"), new structType.ptr("B466", "Sant'Elena Sannita", "Isernia (IS)"), new structType.ptr("I320", "Sant'Elia A Pianisi", "Campobasso (CB)"), new structType.ptr("I321", "Sant'Elia Fiumerapido", "Frosinone (FR)"), new structType.ptr("I324", "Sant'Elpidio A Mare", "Fermo (FM)"), new structType.ptr("I327", "Santena", "Torino (TO)"), new structType.ptr("I330", "Santeramo In Colle", "Bari (BA)"), new structType.ptr("I332", "Sant'Eufemia A Maiella", "Pescara (PE)"), new structType.ptr("I333", "Sant'Eufemia D'Aspromonte", "Reggio Calabria (RC)"), new structType.ptr("I335", "Sant'Eusanio Del Sangro", "Chieti (CH)"), new structType.ptr("I336", "Sant'Eusanio Forconese", "L'Aquila (AQ)"), new structType.ptr("I337", "Santhi\xC3\xA0", "Vercelli (VC)"), new structType.ptr("I339", "Santi Cosma E Damiano", "Latina (LT)"), new structType.ptr("I341", "Sant'Ilario Dello Ionio", "Reggio Calabria (RC)"), new structType.ptr("I342", "Sant'Ilario D'Enza", "Reggio Emilia (RE)"), new structType.ptr("I344", "Sant'Ippolito", "Pesaro e Urbino (PU)"), new structType.ptr("I365", "Santo Stefano Al Mare", "Imperia (IM)"), new structType.ptr("I367", "Santo Stefano Belbo", "Cuneo (CN)"), new structType.ptr("I368", "Santo Stefano D'Aveto", "Genova (GE)"), new structType.ptr("I357", "Santo Stefano Del Sole", "Avellino (AV)"), new structType.ptr("C919", "Santo Stefano Di Cadore", "Belluno (BL)"), new structType.ptr("I370", "Santo Stefano Di Camastra", "Messina (ME)"), new structType.ptr("I363", "Santo Stefano Di Magra", "La Spezia (SP)"), new structType.ptr("I359", "Santo Stefano Di Rogliano", "Cosenza (CS)"), new structType.ptr("I360", "Santo Stefano Di Sessanio", "L'Aquila (AQ)"), new structType.ptr("I371", "Santo Stefano In Aspromonte", "Reggio Calabria (RC)"), new structType.ptr("I362", "Santo Stefano Lodigiano", "Lodi (LO)"), new structType.ptr("I356", "Santo Stefano Quisquina", "Agrigento (AG)"), new structType.ptr("I372", "Santo Stefano Roero", "Cuneo (CN)"), new structType.ptr("I361", "Santo Stefano Ticino", "Milano (MI)"), new structType.ptr("I346", "Sant'Olcese", "Genova (GE)"), new structType.ptr("I260", "Santomenna", "Salerno (SA)"), new structType.ptr("I348", "Sant'Omero", "Teramo (TE)"), new structType.ptr("M333", "Sant'Omobono Terme", "Bergamo (BG)"), new structType.ptr("I350", "Sant'Onofrio", "Vibo Valentia (VV)"), new structType.ptr("I351", "Santopadre", "Frosinone (FR)"), new structType.ptr("I352", "Sant'Oreste", "Roma (RM)"), new structType.ptr("I353", "Santorso", "Vicenza (VI)"), new structType.ptr("I354", "Sant'Orsola Terme", "Trento (TN)"), new structType.ptr("I374", "Santu Lussurgiu", "Oristano (OR)"), new structType.ptr("I375", "Sant'Urbano", "Padova (PD)"), new structType.ptr("I410", "Sanza", "Salerno (SA)"), new structType.ptr("I411", "Sanzeno", "Trento (TN)"), new structType.ptr("I418", "Saonara", "Padova (PD)"), new structType.ptr("I420", "Saponara", "Messina (ME)"), new structType.ptr("I421", "Sappada", "Belluno (BL)"), new structType.ptr("I422", "Sapri", "Salerno (SA)"), new structType.ptr("I423", "Saracena", "Cosenza (CS)"), new structType.ptr("I424", "Saracinesco", "Roma (RM)"), new structType.ptr("I425", "Sarcedo", "Vicenza (VI)"), new structType.ptr("I426", "Sarconi", "Potenza (PZ)"), new structType.ptr("I428", "Sardara", "Medio Campidano (VS)"), new structType.ptr("I429", "Sardigliano", "Alessandria (AL)"), new structType.ptr("I430", "Sarego", "Vicenza (VI)"), new structType.ptr("I431", "Sarentino .Sarntal.", "Bolzano (BZ)"), new structType.ptr("I432", "Sarezzano", "Alessandria (AL)"), new structType.ptr("I433", "Sarezzo", "Brescia (BS)"), new structType.ptr("I434", "Sarmato", "Piacenza (PC)"), new structType.ptr("I435", "Sarmede", "Treviso (TV)"), new structType.ptr("I436", "Sarnano", "Macerata (MC)"), new structType.ptr("I437", "Sarnico", "Bergamo (BG)"), new structType.ptr("I438", "Sarno", "Salerno (SA)"), new structType.ptr("I439", "Sarnonico", "Trento (TN)"), new structType.ptr("I441", "Saronno", "Varese (VA)"), new structType.ptr("I442", "Sarre", "Aosta (AO)"), new structType.ptr("I443", "Sarroch", "Cagliari (CA)"), new structType.ptr("I444", "Sarsina", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("I445", "Sarteano", "Siena (SI)"), new structType.ptr("I447", "Sartirana Lomellina", "Pavia (PV)"), new structType.ptr("I448", "Sarule", "Nuoro (NU)"), new structType.ptr("I449", "Sarzana", "La Spezia (SP)"), new structType.ptr("I451", "Sassano", "Salerno (SA)"), new structType.ptr("I452", "Sassari", "Sassari (SS)"), new structType.ptr("I453", "Sassello", "Savona (SV)"), new structType.ptr("I454", "Sassetta", "Livorno (LI)"), new structType.ptr("I455", "Sassinoro", "Benevento (BN)"), new structType.ptr("I457", "Sasso Di Castalda", "Potenza (PZ)"), new structType.ptr("G972", "Sasso Marconi", "Bologna (BO)"), new structType.ptr("I459", "Sassocorvaro", "Pesaro e Urbino (PU)"), new structType.ptr("I460", "Sassofeltrio", "Pesaro e Urbino (PU)"), new structType.ptr("I461", "Sassoferrato", "Ancona (AN)"), new structType.ptr("I462", "Sassuolo", "Modena (MO)"), new structType.ptr("I463", "Satriano", "Catanzaro (CZ)"), new structType.ptr("G614", "Satriano Di Lucania", "Potenza (PZ)"), new structType.ptr("I464", "Sauris", "Udine (UD)"), new structType.ptr("I465", "Sauze Di Cesana", "Torino (TO)"), new structType.ptr("I466", "Sauze D'Oulx", "Torino (TO)"), new structType.ptr("I467", "Sava", "Taranto (TA)"), new structType.ptr("I468", "Savelli", "Crotone (KR)"), new structType.ptr("I469", "Saviano", "Napoli (NA)"), new structType.ptr("I470", "Savigliano", "Cuneo (CN)"), new structType.ptr("I471", "Savignano Irpino", "Avellino (AV)"), new structType.ptr("I473", "Savignano Sul Panaro", "Modena (MO)"), new structType.ptr("I472", "Savignano Sul Rubicone", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("I475", "Savignone", "Genova (GE)"), new structType.ptr("I476", "Saviore Dell'Adamello", "Brescia (BS)"), new structType.ptr("I477", "Savoca", "Messina (ME)"), new structType.ptr("I478", "Savogna", "Udine (UD)"), new structType.ptr("I479", "Savogna D'Isonzo", "Gorizia (GO)"), new structType.ptr("H730", "Savoia Di Lucania", "Potenza (PZ)"), new structType.ptr("I480", "Savona", "Savona (SV)"), new structType.ptr("I482", "Scafa", "Pescara (PE)"), new structType.ptr("I483", "Scafati", "Salerno (SA)"), new structType.ptr("I484", "Scagnello", "Cuneo (CN)"), new structType.ptr("I486", "Scala", "Salerno (SA)"), new structType.ptr("I485", "Scala Coeli", "Cosenza (CS)"), new structType.ptr("I487", "Scaldasole", "Pavia (PV)"), new structType.ptr("I489", "Scalea", "Cosenza (CS)"), new structType.ptr("I490", "Scalenghe", "Torino (TO)"), new structType.ptr("I492", "Scaletta Zanclea", "Messina (ME)"), new structType.ptr("I493", "Scampitella", "Avellino (AV)"), new structType.ptr("I494", "Scandale", "Crotone (KR)"), new structType.ptr("I496", "Scandiano", "Reggio Emilia (RE)"), new structType.ptr("B962", "Scandicci", "Firenze (FI)"), new structType.ptr("I497", "Scandolara Ravara", "Cremona (CR)"), new structType.ptr("I498", "Scandolara Ripa D'Oglio", "Cremona (CR)"), new structType.ptr("I499", "Scandriglia", "Rieti (RI)"), new structType.ptr("I501", "Scanno", "L'Aquila (AQ)"), new structType.ptr("I503", "Scano Di Montiferro", "Oristano (OR)"), new structType.ptr("I504", "Scansano", "Grosseto (GR)"), new structType.ptr("M256", "Scanzano Jonico", "Matera (MT)"), new structType.ptr("I506", "Scanzorosciate", "Bergamo (BG)"), new structType.ptr("I507", "Scapoli", "Isernia (IS)"), new structType.ptr("I510", "Scarlino", "Grosseto (GR)"), new structType.ptr("I511", "Scarmagno", "Torino (TO)"), new structType.ptr("I512", "Scarnafigi", "Cuneo (CN)"), new structType.ptr("M326", "Scarperia E San Piero", "Firenze (FI)"), new structType.ptr("I519", "Scena .Schenna.", "Bolzano (BZ)"), new structType.ptr("I520", "Scerni", "Chieti (CH)"), new structType.ptr("I522", "Scheggia E Pascelupo", "Perugia (PG)"), new structType.ptr("I523", "Scheggino", "Perugia (PG)"), new structType.ptr("I526", "Schiavi Di Abruzzo", "Chieti (CH)"), new structType.ptr("I527", "Schiavon", "Vicenza (VI)"), new structType.ptr("I529", "Schignano", "Como (CO)"), new structType.ptr("I530", "Schilpario", "Bergamo (BG)"), new structType.ptr("I531", "Schio", "Vicenza (VI)"), new structType.ptr("I532", "Schivenoglia", "Mantova (MN)"), new structType.ptr("I533", "Sciacca", "Agrigento (AG)"), new structType.ptr("I534", "Sciara", "Palermo (PA)"), new structType.ptr("I535", "Scicli", "Ragusa (RG)"), new structType.ptr("I536", "Scido", "Reggio Calabria (RC)"), new structType.ptr("D290", "Scigliano", "Cosenza (CS)"), new structType.ptr("I537", "Scilla", "Reggio Calabria (RC)"), new structType.ptr("I538", "Scillato", "Palermo (PA)"), new structType.ptr("I539", "Sciolze", "Torino (TO)"), new structType.ptr("I540", "Scisciano", "Napoli (NA)"), new structType.ptr("I541", "Sclafani Bagni", "Palermo (PA)"), new structType.ptr("I543", "Scontrone", "L'Aquila (AQ)"), new structType.ptr("I544", "Scopa", "Vercelli (VC)"), new structType.ptr("I545", "Scopello", "Vercelli (VC)"), new structType.ptr("I546", "Scoppito", "L'Aquila (AQ)"), new structType.ptr("I548", "Scordia", "Catania (CT)"), new structType.ptr("I549", "Scorrano", "Lecce (LE)"), new structType.ptr("I551", "Scorz\xC3\xA8", "Venezia (VE)"), new structType.ptr("I553", "Scurcola Marsicana", "L'Aquila (AQ)"), new structType.ptr("I554", "Scurelle", "Trento (TN)"), new structType.ptr("I555", "Scurzolengo", "Asti (AT)"), new structType.ptr("I556", "Seborga", "Imperia (IM)"), new structType.ptr("I558", "Secinaro", "L'Aquila (AQ)"), new structType.ptr("I559", "Secl\xC3\xAC", "Lecce (LE)"), new structType.ptr("I561", "Secugnago", "Lodi (LO)"), new structType.ptr("I562", "Sedegliano", "Udine (UD)"), new structType.ptr("I563", "Sedico", "Belluno (BL)"), new structType.ptr("I564", "Sedilo", "Oristano (OR)"), new structType.ptr("I565", "Sedini", "Sassari (SS)"), new structType.ptr("I566", "Sedriano", "Milano (MI)"), new structType.ptr("I567", "Sedrina", "Bergamo (BG)"), new structType.ptr("I569", "Sefro", "Macerata (MC)"), new structType.ptr("I570", "Segariu", "Medio Campidano (VS)"), new structType.ptr("I571", "Seggiano", "Grosseto (GR)"), new structType.ptr("I573", "Segni", "Roma (RM)"), new structType.ptr("I576", "Segonzano", "Trento (TN)"), new structType.ptr("I577", "Segrate", "Milano (MI)"), new structType.ptr("I578", "Segusino", "Treviso (TV)"), new structType.ptr("I580", "Selargius", "Cagliari (CA)"), new structType.ptr("I581", "Selci", "Rieti (RI)"), new structType.ptr("I582", "Selegas", "Cagliari (CA)"), new structType.ptr("M360", "Sella Giudicarie", "Trento (TN)"), new structType.ptr("I585", "Sellano", "Perugia (PG)"), new structType.ptr("I588", "Sellero", "Brescia (BS)"), new structType.ptr("I589", "Sellia", "Catanzaro (CZ)"), new structType.ptr("I590", "Sellia Marina", "Catanzaro (CZ)"), new structType.ptr("I593", "Selva Dei Molini .Muehlwald.", "Bolzano (BZ)"), new structType.ptr("I592", "Selva Di Cadore", "Belluno (BL)"), new structType.ptr("I594", "Selva Di Progno", "Verona (VR)"), new structType.ptr("I591", "Selva Di Val Gardena .Wolkenstein In Groeden.", "Bolzano (BZ)"), new structType.ptr("I595", "Selvazzano Dentro", "Padova (PD)"), new structType.ptr("I597", "Selvino", "Bergamo (BG)"), new structType.ptr("I598", "Semestene", "Sassari (SS)"), new structType.ptr("I599", "Semiana", "Pavia (PV)"), new structType.ptr("I600", "Seminara", "Reggio Calabria (RC)"), new structType.ptr("I601", "Semproniano", "Grosseto (GR)"), new structType.ptr("I602", "Senago", "Milano (MI)"), new structType.ptr("I604", "Senales .Schnals.", "Bolzano (BZ)"), new structType.ptr("I603", "Senale-San Felice .Unsere Liebe Frau Im Wald.", "Bolzano (BZ)"), new structType.ptr("I605", "Seneghe", "Oristano (OR)"), new structType.ptr("I606", "Senerchia", "Avellino (AV)"), new structType.ptr("I607", "Seniga", "Brescia (BS)"), new structType.ptr("I608", "Senigallia", "Ancona (AN)"), new structType.ptr("I609", "Senis", "Oristano (OR)"), new structType.ptr("I610", "Senise", "Potenza (PZ)"), new structType.ptr("I611", "Senna Comasco", "Como (CO)"), new structType.ptr("I612", "Senna Lodigiana", "Lodi (LO)"), new structType.ptr("I613", "Sennariolo", "Oristano (OR)"), new structType.ptr("I614", "Sennori", "Sassari (SS)"), new structType.ptr("I615", "Senorb\xC3\xAC", "Cagliari (CA)"), new structType.ptr("I618", "Sepino", "Campobasso (CB)"), new structType.ptr("I621", "Sequals", "Pordenone (PN)"), new structType.ptr("I622", "Seravezza", "Lucca (LU)"), new structType.ptr("I624", "Serdiana", "Cagliari (CA)"), new structType.ptr("I625", "Seregno", "Monza e della Brianza (MB)"), new structType.ptr("I626", "Seren Del Grappa", "Belluno (BL)"), new structType.ptr("I627", "Sergnano", "Cremona (CR)"), new structType.ptr("I628", "Seriate", "Bergamo (BG)"), new structType.ptr("I629", "Serina", "Bergamo (BG)"), new structType.ptr("I630", "Serino", "Avellino (AV)"), new structType.ptr("I631", "Serle", "Brescia (BS)"), new structType.ptr("I632", "Sermide", "Mantova (MN)"), new structType.ptr("I634", "Sermoneta", "Latina (LT)"), new structType.ptr("I635", "Sernaglia Della Battaglia", "Treviso (TV)"), new structType.ptr("I636", "Sernio", "Sondrio (SO)"), new structType.ptr("I637", "Serole", "Asti (AT)"), new structType.ptr("I642", "Serra D'Aiello", "Cosenza (CS)"), new structType.ptr("I643", "Serra De' Conti", "Ancona (AN)"), new structType.ptr("I650", "Serra Pedace", "Cosenza (CS)"), new structType.ptr("I640", "Serra Ricc\xC3\xB2", "Genova (GE)"), new structType.ptr("I639", "Serra San Bruno", "Vibo Valentia (VV)"), new structType.ptr("I653", "Serra San Quirico", "Ancona (AN)"), new structType.ptr("I654", "Serra Sant'Abbondio", "Pesaro e Urbino (PU)"), new structType.ptr("I641", "Serracapriola", "Foggia (FG)"), new structType.ptr("I644", "Serradifalco", "Caltanissetta (CL)"), new structType.ptr("I646", "Serralunga D'Alba", "Cuneo (CN)"), new structType.ptr("I645", "Serralunga Di Crea", "Alessandria (AL)"), new structType.ptr("I647", "Serramanna", "Medio Campidano (VS)"), new structType.ptr("F357", "Serramazzoni", "Modena (MO)"), new structType.ptr("I648", "Serramezzana", "Salerno (SA)"), new structType.ptr("I649", "Serramonacesca", "Pescara (PE)"), new structType.ptr("I651", "Serrapetrona", "Macerata (MC)"), new structType.ptr("I652", "Serrara Fontana", "Napoli (NA)"), new structType.ptr("I655", "Serrastretta", "Catanzaro (CZ)"), new structType.ptr("I656", "Serrata", "Reggio Calabria (RC)"), new structType.ptr("I662", "Serravalle A Po", "Mantova (MN)"), new structType.ptr("I661", "Serravalle Di Chienti", "Macerata (MC)"), new structType.ptr("I659", "Serravalle Langhe", "Cuneo (CN)"), new structType.ptr("I660", "Serravalle Pistoiese", "Pistoia (PT)"), new structType.ptr("I657", "Serravalle Scrivia", "Alessandria (AL)"), new structType.ptr("I663", "Serravalle Sesia", "Vercelli (VC)"), new structType.ptr("I666", "Serre", "Salerno (SA)"), new structType.ptr("I667", "Serrenti", "Medio Campidano (VS)"), new structType.ptr("I668", "Serri", "Cagliari (CA)"), new structType.ptr("I669", "Serrone", "Frosinone (FR)"), new structType.ptr("I671", "Sersale", "Catanzaro (CZ)"), new structType.ptr("C070", "Servigliano", "Fermo (FM)"), new structType.ptr("I676", "Sessa Aurunca", "Caserta (CE)"), new structType.ptr("I677", "Sessa Cilento", "Salerno (SA)"), new structType.ptr("I678", "Sessame", "Asti (AT)"), new structType.ptr("I679", "Sessano Del Molise", "Isernia (IS)"), new structType.ptr("E070", "Sesta Godano", "La Spezia (SP)"), new structType.ptr("I681", "Sestino", "Arezzo (AR)"), new structType.ptr("I687", "Sesto .Sexten.", "Bolzano (BZ)"), new structType.ptr("I686", "Sesto Al Reghena", "Pordenone (PN)"), new structType.ptr("I688", "Sesto Calende", "Varese (VA)"), new structType.ptr("I682", "Sesto Campano", "Isernia (IS)"), new structType.ptr("I683", "Sesto Ed Uniti", "Cremona (CR)"), new structType.ptr("I684", "Sesto Fiorentino", "Firenze (FI)"), new structType.ptr("I690", "Sesto San Giovanni", "Milano (MI)"), new structType.ptr("I689", "Sestola", "Modena (MO)"), new structType.ptr("I693", "Sestri Levante", "Genova (GE)"), new structType.ptr("I692", "Sestriere", "Torino (TO)"), new structType.ptr("I695", "Sestu", "Cagliari (CA)"), new structType.ptr("I696", "Settala", "Milano (MI)"), new structType.ptr("I697", "Settefrati", "Frosinone (FR)"), new structType.ptr("I698", "Settime", "Asti (AT)"), new structType.ptr("I700", "Settimo Milanese", "Milano (MI)"), new structType.ptr("I701", "Settimo Rottaro", "Torino (TO)"), new structType.ptr("I699", "Settimo San Pietro", "Cagliari (CA)"), new structType.ptr("I703", "Settimo Torinese", "Torino (TO)"), new structType.ptr("I702", "Settimo Vittone", "Torino (TO)"), new structType.ptr("I704", "Settingiano", "Catanzaro (CZ)"), new structType.ptr("I705", "Setzu", "Medio Campidano (VS)"), new structType.ptr("I706", "Seui", "Ogliastra (OG)"), new structType.ptr("I707", "Seulo", "Cagliari (CA)"), new structType.ptr("I709", "Seveso", "Monza e della Brianza (MB)"), new structType.ptr("I711", "Sezzadio", "Alessandria (AL)"), new structType.ptr("I712", "Sezze", "Latina (LT)"), new structType.ptr("I714", "Sfruz", "Trento (TN)"), new structType.ptr("I715", "Sgonico", "Trieste (TS)"), new structType.ptr("I716", "Sgurgola", "Frosinone (FR)"), new structType.ptr("I717", "Siamaggiore", "Oristano (OR)"), new structType.ptr("I718", "Siamanna", "Oristano (OR)"), new structType.ptr("I720", "Siano", "Salerno (SA)"), new structType.ptr("I721", "Siapiccia", "Oristano (OR)"), new structType.ptr("M253", "Sicignano Degli Alburni", "Salerno (SA)"), new structType.ptr("I723", "Siculiana", "Agrigento (AG)"), new structType.ptr("I724", "Siddi", "Medio Campidano (VS)"), new structType.ptr("I725", "Siderno", "Reggio Calabria (RC)"), new structType.ptr("I726", "Siena", "Siena (SI)"), new structType.ptr("I727", "Sigillo", "Perugia (PG)"), new structType.ptr("I728", "Signa", "Firenze (FI)"), new structType.ptr("I729", "Silandro .Schlanders.", "Bolzano (BZ)"), new structType.ptr("I730", "Silanus", "Nuoro (NU)"), new structType.ptr("F116", "Silea", "Treviso (TV)"), new structType.ptr("I732", "Siligo", "Sassari (SS)"), new structType.ptr("I734", "Siliqua", "Cagliari (CA)"), new structType.ptr("I735", "Silius", "Cagliari (CA)"), new structType.ptr("M347", "Sillano Giuncugnano", "Lucca (LU)"), new structType.ptr("I736", "Sillavengo", "Novara (NO)"), new structType.ptr("I738", "Silvano D'Orba", "Alessandria (AL)"), new structType.ptr("I739", "Silvano Pietra", "Pavia (PV)"), new structType.ptr("I741", "Silvi", "Teramo (TE)"), new structType.ptr("I742", "Simala", "Oristano (OR)"), new structType.ptr("I743", "Simaxis", "Oristano (OR)"), new structType.ptr("I744", "Simbario", "Vibo Valentia (VV)"), new structType.ptr("I745", "Simeri Crichi", "Catanzaro (CZ)"), new structType.ptr("I747", "Sinagra", "Messina (ME)"), new structType.ptr("A468", "Sinalunga", "Siena (SI)"), new structType.ptr("I748", "Sindia", "Nuoro (NU)"), new structType.ptr("I749", "Sini", "Oristano (OR)"), new structType.ptr("I750", "Sinio", "Cuneo (CN)"), new structType.ptr("I751", "Siniscola", "Nuoro (NU)"), new structType.ptr("I752", "Sinnai", "Cagliari (CA)"), new structType.ptr("I753", "Sinopoli", "Reggio Calabria (RC)"), new structType.ptr("I754", "Siracusa", "Siracusa (SR)"), new structType.ptr("I756", "Sirignano", "Avellino (AV)"), new structType.ptr("I757", "Siris", "Oristano (OR)"), new structType.ptr("I633", "Sirmione", "Brescia (BS)"), new structType.ptr("I758", "Sirolo", "Ancona (AN)"), new structType.ptr("I759", "Sirone", "Lecco (LC)"), new structType.ptr("I761", "Sirtori", "Lecco (LC)"), new structType.ptr("M325", "Sissa Trecasali", "Parma (PR)"), new structType.ptr("I765", "Siurgus Donigala", "Cagliari (CA)"), new structType.ptr("E265", "Siziano", "Pavia (PV)"), new structType.ptr("I767", "Sizzano", "Novara (NO)"), new structType.ptr("I771", "Sluderno .Schluderns.", "Bolzano (BZ)"), new structType.ptr("I774", "Smerillo", "Fermo (FM)"), new structType.ptr("I775", "Soave", "Verona (VR)"), new structType.ptr("I777", "Socchieve", "Udine (UD)"), new structType.ptr("I778", "Sodd\xC3\xAC", "Oristano (OR)"), new structType.ptr("I779", "Sogliano Al Rubicone", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("I780", "Sogliano Cavour", "Lecce (LE)"), new structType.ptr("I781", "Soglio", "Asti (AT)"), new structType.ptr("I782", "Soiano Del Lago", "Brescia (BS)"), new structType.ptr("I783", "Solagna", "Vicenza (VI)"), new structType.ptr("I785", "Solarino", "Siracusa (SR)"), new structType.ptr("I786", "Solaro", "Milano (MI)"), new structType.ptr("I787", "Solarolo", "Ravenna (RA)"), new structType.ptr("I790", "Solarolo Rainerio", "Cremona (CR)"), new structType.ptr("I791", "Solarussa", "Oristano (OR)"), new structType.ptr("I792", "Solbiate", "Como (CO)"), new structType.ptr("I793", "Solbiate Arno", "Varese (VA)"), new structType.ptr("I794", "Solbiate Olona", "Varese (VA)"), new structType.ptr("I796", "Soldano", "Imperia (IM)"), new structType.ptr("I797", "Soleminis", "Cagliari (CA)"), new structType.ptr("I798", "Solero", "Alessandria (AL)"), new structType.ptr("I799", "Solesino", "Padova (PD)"), new structType.ptr("I800", "Soleto", "Lecce (LE)"), new structType.ptr("I801", "Solferino", "Mantova (MN)"), new structType.ptr("I802", "Soliera", "Modena (MO)"), new structType.ptr("I803", "Solignano", "Parma (PR)"), new structType.ptr("I805", "Solofra", "Avellino (AV)"), new structType.ptr("I808", "Solonghello", "Alessandria (AL)"), new structType.ptr("I809", "Solopaca", "Benevento (BN)"), new structType.ptr("I812", "Solto Collina", "Bergamo (BG)"), new structType.ptr("I813", "Solza", "Bergamo (BG)"), new structType.ptr("I815", "Somaglia", "Lodi (LO)"), new structType.ptr("I817", "Somano", "Cuneo (CN)"), new structType.ptr("I819", "Somma Lombardo", "Varese (VA)"), new structType.ptr("I820", "Somma Vesuviana", "Napoli (NA)"), new structType.ptr("I821", "Sommacampagna", "Verona (VR)"), new structType.ptr("I822", "Sommariva Del Bosco", "Cuneo (CN)"), new structType.ptr("I823", "Sommariva Perno", "Cuneo (CN)"), new structType.ptr("I824", "Sommatino", "Caltanissetta (CL)"), new structType.ptr("I825", "Sommo", "Pavia (PV)"), new structType.ptr("I826", "Sona", "Verona (VR)"), new structType.ptr("I827", "Soncino", "Cremona (CR)"), new structType.ptr("I828", "Sondalo", "Sondrio (SO)"), new structType.ptr("I829", "Sondrio", "Sondrio (SO)"), new structType.ptr("I830", "Songavazzo", "Bergamo (BG)"), new structType.ptr("I831", "Sonico", "Brescia (BS)"), new structType.ptr("I832", "Sonnino", "Latina (LT)"), new structType.ptr("I835", "Soprana", "Biella (BI)"), new structType.ptr("I838", "Sora", "Frosinone (FR)"), new structType.ptr("I839", "Soraga", "Trento (TN)"), new structType.ptr("I840", "Soragna", "Parma (PR)"), new structType.ptr("I841", "Sorano", "Grosseto (GR)"), new structType.ptr("I844", "Sorbo San Basile", "Catanzaro (CZ)"), new structType.ptr("I843", "Sorbo Serpico", "Avellino (AV)"), new structType.ptr("I845", "Sorbolo", "Parma (PR)"), new structType.ptr("I847", "Sordevolo", "Biella (BI)"), new structType.ptr("I848", "Sordio", "Lodi (LO)"), new structType.ptr("I849", "Soresina", "Cremona (CR)"), new structType.ptr("I850", "Sorg\xC3\xA0", "Verona (VR)"), new structType.ptr("I851", "Sorgono", "Nuoro (NU)"), new structType.ptr("I852", "Sori", "Genova (GE)"), new structType.ptr("I853", "Sorianello", "Vibo Valentia (VV)"), new structType.ptr("I854", "Soriano Calabro", "Vibo Valentia (VV)"), new structType.ptr("I855", "Soriano Nel Cimino", "Viterbo (VT)"), new structType.ptr("I856", "Sorico", "Como (CO)"), new structType.ptr("I857", "Soriso", "Novara (NO)"), new structType.ptr("I858", "Sorisole", "Bergamo (BG)"), new structType.ptr("I860", "Sormano", "Como (CO)"), new structType.ptr("I861", "Sorradile", "Oristano (OR)"), new structType.ptr("I862", "Sorrento", "Napoli (NA)"), new structType.ptr("I863", "Sorso", "Sassari (SS)"), new structType.ptr("I864", "Sortino", "Siracusa (SR)"), new structType.ptr("I865", "Sospiro", "Cremona (CR)"), new structType.ptr("I866", "Sospirolo", "Belluno (BL)"), new structType.ptr("I867", "Sossano", "Vicenza (VI)"), new structType.ptr("I868", "Sostegno", "Biella (BI)"), new structType.ptr("I869", "Sotto Il Monte Giovanni Xxiii", "Bergamo (BG)"), new structType.ptr("I871", "Sover", "Trento (TN)"), new structType.ptr("I872", "Soverato", "Catanzaro (CZ)"), new structType.ptr("I873", "Sovere", "Bergamo (BG)"), new structType.ptr("I874", "Soveria Mannelli", "Catanzaro (CZ)"), new structType.ptr("I875", "Soveria Simeri", "Catanzaro (CZ)"), new structType.ptr("I876", "Soverzene", "Belluno (BL)"), new structType.ptr("I877", "Sovicille", "Siena (SI)"), new structType.ptr("I878", "Sovico", "Monza e della Brianza (MB)"), new structType.ptr("I879", "Sovizzo", "Vicenza (VI)"), new structType.ptr("I673", "Sovramonte", "Belluno (BL)"), new structType.ptr("I880", "Sozzago", "Novara (NO)"), new structType.ptr("I881", "Spadafora", "Messina (ME)"), new structType.ptr("I884", "Spadola", "Vibo Valentia (VV)"), new structType.ptr("I885", "Sparanise", "Caserta (CE)"), new structType.ptr("I886", "Sparone", "Torino (TO)"), new structType.ptr("I887", "Specchia", "Lecce (LE)"), new structType.ptr("I888", "Spello", "Perugia (PG)"), new structType.ptr("I891", "Sperlinga", "Enna (EN)"), new structType.ptr("I892", "Sperlonga", "Latina (LT)"), new structType.ptr("I893", "Sperone", "Avellino (AV)"), new structType.ptr("I894", "Spessa", "Pavia (PV)"), new structType.ptr("I895", "Spezzano Albanese", "Cosenza (CS)"), new structType.ptr("I896", "Spezzano Della Sila", "Cosenza (CS)"), new structType.ptr("I898", "Spezzano Piccolo", "Cosenza (CS)"), new structType.ptr("I899", "Spiazzo", "Trento (TN)"), new structType.ptr("I901", "Spigno Monferrato", "Alessandria (AL)"), new structType.ptr("I902", "Spigno Saturnia", "Latina (LT)"), new structType.ptr("I903", "Spilamberto", "Modena (MO)"), new structType.ptr("I904", "Spilimbergo", "Pordenone (PN)"), new structType.ptr("I905", "Spilinga", "Vibo Valentia (VV)"), new structType.ptr("I906", "Spinadesco", "Cremona (CR)"), new structType.ptr("I907", "Spinazzola", "Barletta-Andria-Trani (BT)"), new structType.ptr("I908", "Spinea", "Venezia (VE)"), new structType.ptr("I909", "Spineda", "Cremona (CR)"), new structType.ptr("I910", "Spinete", "Campobasso (CB)"), new structType.ptr("I911", "Spineto Scrivia", "Alessandria (AL)"), new structType.ptr("I912", "Spinetoli", "Ascoli Piceno (AP)"), new structType.ptr("I914", "Spino D'Adda", "Cremona (CR)"), new structType.ptr("I916", "Spinone Al Lago", "Bergamo (BG)"), new structType.ptr("I917", "Spinoso", "Potenza (PZ)"), new structType.ptr("I919", "Spirano", "Bergamo (BG)"), new structType.ptr("I921", "Spoleto", "Perugia (PG)"), new structType.ptr("I922", "Spoltore", "Pescara (PE)"), new structType.ptr("I923", "Spongano", "Lecce (LE)"), new structType.ptr("I924", "Spormaggiore", "Trento (TN)"), new structType.ptr("I925", "Sporminore", "Trento (TN)"), new structType.ptr("I926", "Spotorno", "Savona (SV)"), new structType.ptr("I927", "Spresiano", "Treviso (TV)"), new structType.ptr("I928", "Spriana", "Sondrio (SO)"), new structType.ptr("I929", "Squillace", "Catanzaro (CZ)"), new structType.ptr("I930", "Squinzano", "Lecce (LE)"), new structType.ptr("I932", "Staffolo", "Ancona (AN)"), new structType.ptr("I935", "Stagno Lombardo", "Cremona (CR)"), new structType.ptr("I936", "Staiti", "Reggio Calabria (RC)"), new structType.ptr("I937", "Stalett\xC3\xAC", "Catanzaro (CZ)"), new structType.ptr("I938", "Stanghella", "Padova (PD)"), new structType.ptr("I939", "Staranzano", "Gorizia (GO)"), new structType.ptr("M298", "Statte", "Taranto (TA)"), new structType.ptr("I941", "Stazzano", "Alessandria (AL)"), new structType.ptr("I942", "Stazzema", "Lucca (LU)"), new structType.ptr("I943", "Stazzona", "Como (CO)"), new structType.ptr("I945", "Stefanaconi", "Vibo Valentia (VV)"), new structType.ptr("I946", "Stella", "Savona (SV)"), new structType.ptr("G887", "Stella Cilento", "Salerno (SA)"), new structType.ptr("I947", "Stellanello", "Savona (SV)"), new structType.ptr("I948", "Stelvio .Stilfs.", "Bolzano (BZ)"), new structType.ptr("I949", "Stenico", "Trento (TN)"), new structType.ptr("I950", "Sternatia", "Lecce (LE)"), new structType.ptr("I951", "Stezzano", "Bergamo (BG)"), new structType.ptr("I953", "Stienta", "Rovigo (RO)"), new structType.ptr("I954", "Stigliano", "Matera (MT)"), new structType.ptr("I955", "Stignano", "Reggio Calabria (RC)"), new structType.ptr("I956", "Stilo", "Reggio Calabria (RC)"), new structType.ptr("I959", "Stimigliano", "Rieti (RI)"), new structType.ptr("M290", "Stintino", "Sassari (SS)"), new structType.ptr("I960", "Stio", "Salerno (SA)"), new structType.ptr("I962", "Stornara", "Foggia (FG)"), new structType.ptr("I963", "Stornarella", "Foggia (FG)"), new structType.ptr("I964", "Storo", "Trento (TN)"), new structType.ptr("I965", "Stra", "Venezia (VE)"), new structType.ptr("I968", "Stradella", "Pavia (PV)"), new structType.ptr("I969", "Strambinello", "Torino (TO)"), new structType.ptr("I970", "Strambino", "Torino (TO)"), new structType.ptr("I973", "Strangolagalli", "Frosinone (FR)"), new structType.ptr("I974", "Stregna", "Udine (UD)"), new structType.ptr("I975", "Strembo", "Trento (TN)"), new structType.ptr("I976", "Stresa", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("I977", "Strevi", "Alessandria (AL)"), new structType.ptr("I978", "Striano", "Napoli (NA)"), new structType.ptr("I980", "Strona", "Biella (BI)"), new structType.ptr("I981", "Stroncone", "Terni (TR)"), new structType.ptr("I982", "Strongoli", "Crotone (KR)"), new structType.ptr("I984", "Stroppiana", "Vercelli (VC)"), new structType.ptr("I985", "Stroppo", "Cuneo (CN)"), new structType.ptr("I986", "Strozza", "Bergamo (BG)"), new structType.ptr("I990", "Sturno", "Avellino (AV)"), new structType.ptr("B014", "Suardi", "Pavia (PV)"), new structType.ptr("I991", "Subbiano", "Arezzo (AR)"), new structType.ptr("I992", "Subiaco", "Roma (RM)"), new structType.ptr("I993", "Succivo", "Caserta (CE)"), new structType.ptr("I994", "Sueglio", "Lecco (LC)"), new structType.ptr("I995", "Suelli", "Cagliari (CA)"), new structType.ptr("I996", "Suello", "Lecco (LC)"), new structType.ptr("I997", "Suisio", "Bergamo (BG)"), new structType.ptr("I998", "Sulbiate", "Monza e della Brianza (MB)"), new structType.ptr("I804", "Sulmona", "L'Aquila (AQ)"), new structType.ptr("L002", "Sulzano", "Brescia (BS)"), new structType.ptr("L003", "Sumirago", "Varese (VA)"), new structType.ptr("L004", "Summonte", "Avellino (AV)"), new structType.ptr("L006", "Suni", "Oristano (OR)"), new structType.ptr("L007", "Suno", "Novara (NO)"), new structType.ptr("L008", "Supersano", "Lecce (LE)"), new structType.ptr("L009", "Supino", "Frosinone (FR)"), new structType.ptr("L010", "Surano", "Lecce (LE)"), new structType.ptr("L011", "Surbo", "Lecce (LE)"), new structType.ptr("L013", "Susa", "Torino (TO)"), new structType.ptr("L014", "Susegana", "Treviso (TV)"), new structType.ptr("L015", "Sustinente", "Mantova (MN)"), new structType.ptr("L016", "Sutera", "Caltanissetta (CL)"), new structType.ptr("L017", "Sutri", "Viterbo (VT)"), new structType.ptr("L018", "Sutrio", "Udine (UD)"), new structType.ptr("L019", "Suvereto", "Livorno (LI)"), new structType.ptr("L020", "Suzzara", "Mantova (MN)"), new structType.ptr("L022", "Taceno", "Lecco (LC)"), new structType.ptr("L023", "Tadasuni", "Oristano (OR)"), new structType.ptr("L024", "Taggia", "Imperia (IM)"), new structType.ptr("L025", "Tagliacozzo", "L'Aquila (AQ)"), new structType.ptr("L026", "Taglio Di Po", "Rovigo (RO)"), new structType.ptr("L027", "Tagliolo Monferrato", "Alessandria (AL)"), new structType.ptr("L030", "Taibon Agordino", "Belluno (BL)"), new structType.ptr("L032", "Taino", "Varese (VA)"), new structType.ptr("G736", "Taipana", "Udine (UD)"), new structType.ptr("L034", "Talamello", "Rimini (RN)"), new structType.ptr("L035", "Talamona", "Sondrio (SO)"), new structType.ptr("L036", "Talana", "Ogliastra (OG)"), new structType.ptr("L037", "Taleggio", "Bergamo (BG)"), new structType.ptr("L038", "Talla", "Arezzo (AR)"), new structType.ptr("L039", "Talmassons", "Udine (UD)"), new structType.ptr("L040", "Tambre", "Belluno (BL)"), new structType.ptr("L042", "Taormina", "Messina (ME)"), new structType.ptr("L046", "Tarano", "Rieti (RI)"), new structType.ptr("L047", "Taranta Peligna", "Chieti (CH)"), new structType.ptr("L048", "Tarantasca", "Cuneo (CN)"), new structType.ptr("L049", "Taranto", "Taranto (TA)"), new structType.ptr("L050", "Tarcento", "Udine (UD)"), new structType.ptr("D024", "Tarquinia", "Viterbo (VT)"), new structType.ptr("L055", "Tarsia", "Cosenza (CS)"), new structType.ptr("L056", "Tartano", "Sondrio (SO)"), new structType.ptr("L057", "Tarvisio", "Udine (UD)"), new structType.ptr("L058", "Tarzo", "Treviso (TV)"), new structType.ptr("L059", "Tassarolo", "Alessandria (AL)"), new structType.ptr("L061", "Taurano", "Avellino (AV)"), new structType.ptr("L062", "Taurasi", "Avellino (AV)"), new structType.ptr("L063", "Taurianova", "Reggio Calabria (RC)"), new structType.ptr("L064", "Taurisano", "Lecce (LE)"), new structType.ptr("L065", "Tavagnacco", "Udine (UD)"), new structType.ptr("L066", "Tavagnasco", "Torino (TO)"), new structType.ptr("L067", "Tavarnelle Val Di Pesa", "Firenze (FI)"), new structType.ptr("F260", "Tavazzano Con Villavesco", "Lodi (LO)"), new structType.ptr("L069", "Tavenna", "Campobasso (CB)"), new structType.ptr("L070", "Taverna", "Catanzaro (CZ)"), new structType.ptr("L071", "Tavernerio", "Como (CO)"), new structType.ptr("L073", "Tavernola Bergamasca", "Bergamo (BG)"), new structType.ptr("C698", "Tavernole Sul Mella", "Brescia (BS)"), new structType.ptr("L074", "Taviano", "Lecce (LE)"), new structType.ptr("L075", "Tavigliano", "Biella (BI)"), new structType.ptr("L078", "Tavoleto", "Pesaro e Urbino (PU)"), new structType.ptr("L081", "Tavullia", "Pesaro e Urbino (PU)"), new structType.ptr("L082", "Teana", "Potenza (PZ)"), new structType.ptr("L083", "Teano", "Caserta (CE)"), new structType.ptr("D292", "Teggiano", "Salerno (SA)"), new structType.ptr("L084", "Teglio", "Sondrio (SO)"), new structType.ptr("L085", "Teglio Veneto", "Venezia (VE)"), new structType.ptr("L086", "Telese Terme", "Benevento (BN)"), new structType.ptr("L087", "Telgate", "Bergamo (BG)"), new structType.ptr("L088", "Telti", "Olbia-Tempio (OT)"), new structType.ptr("L089", "Telve", "Trento (TN)"), new structType.ptr("L090", "Telve Di Sopra", "Trento (TN)"), new structType.ptr("L093", "Tempio Pausania", "Olbia-Tempio (OT)"), new structType.ptr("L094", "Tem\xC3\xB9", "Brescia (BS)"), new structType.ptr("L096", "Tenna", "Trento (TN)"), new structType.ptr("L097", "Tenno", "Trento (TN)"), new structType.ptr("L100", "Teolo", "Padova (PD)"), new structType.ptr("L102", "Teora", "Avellino (AV)"), new structType.ptr("L103", "Teramo", "Teramo (TE)"), new structType.ptr("L104", "Terdobbiate", "Novara (NO)"), new structType.ptr("L105", "Terelle", "Frosinone (FR)"), new structType.ptr("L106", "Terento .Terenten.", "Bolzano (BZ)"), new structType.ptr("E548", "Terenzo", "Parma (PR)"), new structType.ptr("M282", "Tergu", "Sassari (SS)"), new structType.ptr("L108", "Terlano .Terlan.", "Bolzano (BZ)"), new structType.ptr("L109", "Terlizzi", "Bari (BA)"), new structType.ptr("M210", "Terme Vigliatore", "Messina (ME)"), new structType.ptr("L111", "Termeno Sulla Strada Del Vino .Tramin An Der.", "Bolzano (BZ)"), new structType.ptr("L112", "Termini Imerese", "Palermo (PA)"), new structType.ptr("L113", "Termoli", "Campobasso (CB)"), new structType.ptr("L115", "Ternate", "Varese (VA)"), new structType.ptr("L116", "Ternengo", "Biella (BI)"), new structType.ptr("L117", "Terni", "Terni (TR)"), new structType.ptr("L118", "Terno D'Isola", "Bergamo (BG)"), new structType.ptr("L120", "Terracina", "Latina (LT)"), new structType.ptr("L121", "Terragnolo", "Trento (TN)"), new structType.ptr("L122", "Terralba", "Oristano (OR)"), new structType.ptr("L124", "Terranova Da Sibari", "Cosenza (CS)"), new structType.ptr("L125", "Terranova Dei Passerini", "Lodi (LO)"), new structType.ptr("L126", "Terranova Di Pollino", "Potenza (PZ)"), new structType.ptr("L127", "Terranova Sappo Minulio", "Reggio Calabria (RC)"), new structType.ptr("L123", "Terranuova Bracciolini", "Arezzo (AR)"), new structType.ptr("L131", "Terrasini", "Palermo (PA)"), new structType.ptr("L132", "Terrassa Padovana", "Padova (PD)"), new structType.ptr("L134", "Terravecchia", "Cosenza (CS)"), new structType.ptr("L136", "Terrazzo", "Verona (VR)"), new structType.ptr("M381", "Terre Del Reno", "Ferrara (FE)"), new structType.ptr("M379", "Terre Roveresche", "Pesaro e Urbino (PU)"), new structType.ptr("L138", "Terricciola", "Pisa (PI)"), new structType.ptr("L139", "Terruggia", "Alessandria (AL)"), new structType.ptr("L140", "Tertenia", "Ogliastra (OG)"), new structType.ptr("L142", "Terzigno", "Napoli (NA)"), new structType.ptr("L143", "Terzo", "Alessandria (AL)"), new structType.ptr("L144", "Terzo Di Aquileia", "Udine (UD)"), new structType.ptr("L145", "Terzolas", "Trento (TN)"), new structType.ptr("L146", "Terzorio", "Imperia (IM)"), new structType.ptr("L147", "Tesero", "Trento (TN)"), new structType.ptr("L149", "Tesimo .Tisens.", "Bolzano (BZ)"), new structType.ptr("L150", "Tessennano", "Viterbo (VT)"), new structType.ptr("L152", "Testico", "Savona (SV)"), new structType.ptr("L153", "Teti", "Nuoro (NU)"), new structType.ptr("L154", "Teulada", "Cagliari (CA)"), new structType.ptr("L155", "Teverola", "Caserta (CE)"), new structType.ptr("L156", "Tezze Sul Brenta", "Vicenza (VI)"), new structType.ptr("L157", "Thiene", "Vicenza (VI)"), new structType.ptr("L158", "Thiesi", "Sassari (SS)"), new structType.ptr("L160", "Tiana", "Nuoro (NU)"), new structType.ptr("L164", "Ticengo", "Cremona (CR)"), new structType.ptr("L165", "Ticineto", "Alessandria (AL)"), new structType.ptr("L166", "Tiggiano", "Lecce (LE)"), new structType.ptr("L167", "Tiglieto", "Genova (GE)"), new structType.ptr("L168", "Tigliole", "Asti (AT)"), new structType.ptr("L169", "Tignale", "Brescia (BS)"), new structType.ptr("L172", "Tinnura", "Oristano (OR)"), new structType.ptr("L173", "Tione Degli Abruzzi", "L'Aquila (AQ)"), new structType.ptr("L174", "Tione Di Trento", "Trento (TN)"), new structType.ptr("L175", "Tirano", "Sondrio (SO)"), new structType.ptr("L176", "Tires .Tiers.", "Bolzano (BZ)"), new structType.ptr("L177", "Tiriolo", "Catanzaro (CZ)"), new structType.ptr("L178", "Tirolo .Tirol.", "Bolzano (BZ)"), new structType.ptr("L180", "Tissi", "Sassari (SS)"), new structType.ptr("L181", "Tito", "Potenza (PZ)"), new structType.ptr("L182", "Tivoli", "Roma (RM)"), new structType.ptr("L183", "Tizzano Val Parma", "Parma (PR)"), new structType.ptr("L184", "Toano", "Reggio Emilia (RE)"), new structType.ptr("L185", "Tocco Caudio", "Benevento (BN)"), new structType.ptr("L186", "Tocco Da Casauria", "Pescara (PE)"), new structType.ptr("L187", "Toceno", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("L188", "Todi", "Perugia (PG)"), new structType.ptr("L189", "Toffia", "Rieti (RI)"), new structType.ptr("L190", "Toirano", "Savona (SV)"), new structType.ptr("L191", "Tolentino", "Macerata (MC)"), new structType.ptr("L192", "Tolfa", "Roma (RM)"), new structType.ptr("L193", "Tollegno", "Biella (BI)"), new structType.ptr("L194", "Tollo", "Chieti (CH)"), new structType.ptr("L195", "Tolmezzo", "Udine (UD)"), new structType.ptr("L197", "Tolve", "Potenza (PZ)"), new structType.ptr("L199", "Tombolo", "Padova (PD)"), new structType.ptr("L200", "Ton", "Trento (TN)"), new structType.ptr("L202", "Tonara", "Nuoro (NU)"), new structType.ptr("L203", "Tonco", "Asti (AT)"), new structType.ptr("L204", "Tonengo", "Asti (AT)"), new structType.ptr("D717", "Tonezza Del Cimone", "Vicenza (VI)"), new structType.ptr("L205", "Tora E Piccilli", "Caserta (CE)"), new structType.ptr("L206", "Torano Castello", "Cosenza (CS)"), new structType.ptr("L207", "Torano Nuovo", "Teramo (TE)"), new structType.ptr("L210", "Torbole Casaglia", "Brescia (BS)"), new structType.ptr("L211", "Torcegno", "Trento (TN)"), new structType.ptr("L212", "Torchiara", "Salerno (SA)"), new structType.ptr("L213", "Torchiarolo", "Brindisi (BR)"), new structType.ptr("L214", "Torella Dei Lombardi", "Avellino (AV)"), new structType.ptr("L215", "Torella Del Sannio", "Campobasso (CB)"), new structType.ptr("L216", "Torgiano", "Perugia (PG)"), new structType.ptr("L217", "Torgnon", "Aosta (AO)"), new structType.ptr("L219", "Torino", "Torino (TO)"), new structType.ptr("L218", "Torino Di Sangro", "Chieti (CH)"), new structType.ptr("L220", "Toritto", "Bari (BA)"), new structType.ptr("L221", "Torlino Vimercati", "Cremona (CR)"), new structType.ptr("L223", "Tornaco", "Novara (NO)"), new structType.ptr("L224", "Tornareccio", "Chieti (CH)"), new structType.ptr("L225", "Tornata", "Cremona (CR)"), new structType.ptr("L227", "Tornimparte", "L'Aquila (AQ)"), new structType.ptr("L228", "Torno", "Como (CO)"), new structType.ptr("L229", "Tornolo", "Parma (PR)"), new structType.ptr("L230", "Toro", "Campobasso (CB)"), new structType.ptr("L231", "Torp\xC3\xA8", "Nuoro (NU)"), new structType.ptr("L233", "Torraca", "Salerno (SA)"), new structType.ptr("L235", "Torralba", "Sassari (SS)"), new structType.ptr("L237", "Torrazza Coste", "Pavia (PV)"), new structType.ptr("L238", "Torrazza Piemonte", "Torino (TO)"), new structType.ptr("L239", "Torrazzo", "Biella (BI)"), new structType.ptr("L245", "Torre Annunziata", "Napoli (NA)"), new structType.ptr("L250", "Torre Beretti E Castellaro", "Pavia (PV)"), new structType.ptr("L251", "Torre Boldone", "Bergamo (BG)"), new structType.ptr("L252", "Torre Bormida", "Cuneo (CN)"), new structType.ptr("L243", "Torre Cajetani", "Frosinone (FR)"), new structType.ptr("L247", "Torre Canavese", "Torino (TO)"), new structType.ptr("L256", "Torre D'Arese", "Pavia (PV)"), new structType.ptr("L257", "Torre De' Busi", "Lecco (LC)"), new structType.ptr("L262", "Torre De' Negri", "Pavia (PV)"), new structType.ptr("L263", "Torre De' Passeri", "Pescara (PE)"), new structType.ptr("L258", "Torre De' Picenardi", "Cremona (CR)"), new structType.ptr("L265", "Torre De' Roveri", "Bergamo (BG)"), new structType.ptr("L259", "Torre Del Greco", "Napoli (NA)"), new structType.ptr("L267", "Torre Di Mosto", "Venezia (VE)"), new structType.ptr("L240", "Torre Di Ruggiero", "Catanzaro (CZ)"), new structType.ptr("L244", "Torre Di Santa Maria", "Sondrio (SO)"), new structType.ptr("L269", "Torre D'Isola", "Pavia (PV)"), new structType.ptr("L272", "Torre Le Nocelle", "Avellino (AV)"), new structType.ptr("L241", "Torre Mondov\xC3\xAC", "Cuneo (CN)"), new structType.ptr("L274", "Torre Orsaia", "Salerno (SA)"), new structType.ptr("L276", "Torre Pallavicina", "Bergamo (BG)"), new structType.ptr("L277", "Torre Pellice", "Torino (TO)"), new structType.ptr("L278", "Torre San Giorgio", "Cuneo (CN)"), new structType.ptr("L279", "Torre San Patrizio", "Fermo (FM)"), new structType.ptr("L280", "Torre Santa Susanna", "Brindisi (BR)"), new structType.ptr("L246", "Torreano", "Udine (UD)"), new structType.ptr("L248", "Torrebelvicino", "Vicenza (VI)"), new structType.ptr("L253", "Torrebruna", "Chieti (CH)"), new structType.ptr("L254", "Torrecuso", "Benevento (BN)"), new structType.ptr("L270", "Torreglia", "Padova (PD)"), new structType.ptr("L271", "Torregrotta", "Messina (ME)"), new structType.ptr("L273", "Torremaggiore", "Foggia (FG)"), new structType.ptr("M286", "Torrenova", "Messina (ME)"), new structType.ptr("L281", "Torresina", "Cuneo (CN)"), new structType.ptr("L282", "Torretta", "Palermo (PA)"), new structType.ptr("L285", "Torrevecchia Pia", "Pavia (PV)"), new structType.ptr("L284", "Torrevecchia Teatina", "Chieti (CH)"), new structType.ptr("L287", "Torri Del Benaco", "Verona (VR)"), new structType.ptr("L297", "Torri Di Quartesolo", "Vicenza (VI)"), new structType.ptr("L286", "Torri In Sabina", "Rieti (RI)"), new structType.ptr("L290", "Torrice", "Frosinone (FR)"), new structType.ptr("L294", "Torricella", "Taranto (TA)"), new structType.ptr("L296", "Torricella Del Pizzo", "Cremona (CR)"), new structType.ptr("L293", "Torricella In Sabina", "Rieti (RI)"), new structType.ptr("L291", "Torricella Peligna", "Chieti (CH)"), new structType.ptr("L295", "Torricella Sicura", "Teramo (TE)"), new structType.ptr("L292", "Torricella Verzate", "Pavia (PV)"), new structType.ptr("L298", "Torriglia", "Genova (GE)"), new structType.ptr("L299", "Torrile", "Parma (PR)"), new structType.ptr("L301", "Torrioni", "Avellino (AV)"), new structType.ptr("L303", "Torrita Di Siena", "Siena (SI)"), new structType.ptr("L302", "Torrita Tiberina", "Roma (RM)"), new structType.ptr("A355", "Tortol\xC3\xAC", "Ogliastra (OG)"), new structType.ptr("L304", "Tortona", "Alessandria (AL)"), new structType.ptr("L305", "Tortora", "Cosenza (CS)"), new structType.ptr("L306", "Tortorella", "Salerno (SA)"), new structType.ptr("L307", "Tortoreto", "Teramo (TE)"), new structType.ptr("L308", "Tortorici", "Messina (ME)"), new structType.ptr("L309", "Torviscosa", "Udine (UD)"), new structType.ptr("L312", "Toscolano Maderno", "Brescia (BS)"), new structType.ptr("L314", "Tossicia", "Teramo (TE)"), new structType.ptr("L316", "Tovo Di Sant'Agata", "Sondrio (SO)"), new structType.ptr("L315", "Tovo San Giacomo", "Savona (SV)"), new structType.ptr("L317", "Trabia", "Palermo (PA)"), new structType.ptr("L319", "Tradate", "Varese (VA)"), new structType.ptr("L321", "Tramatza", "Oristano (OR)"), new structType.ptr("L322", "Trambileno", "Trento (TN)"), new structType.ptr("L323", "Tramonti", "Salerno (SA)"), new structType.ptr("L324", "Tramonti Di Sopra", "Pordenone (PN)"), new structType.ptr("L325", "Tramonti Di Sotto", "Pordenone (PN)"), new structType.ptr("L326", "Tramutola", "Potenza (PZ)"), new structType.ptr("L327", "Trana", "Torino (TO)"), new structType.ptr("L328", "Trani", "Barletta-Andria-Trani (BT)"), new structType.ptr("L330", "Traona", "Sondrio (SO)"), new structType.ptr("L331", "Trapani", "Trapani (TP)"), new structType.ptr("L332", "Trappeto", "Palermo (PA)"), new structType.ptr("L333", "Trarego Viggiona", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("L334", "Trasacco", "L'Aquila (AQ)"), new structType.ptr("L335", "Trasaghis", "Udine (UD)"), new structType.ptr("L336", "Trasquera", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("L337", "Tratalias", "Carbonia-Iglesias (CI)"), new structType.ptr("L338", "Trausella", "Torino (TO)"), new structType.ptr("I236", "Travaco' Siccomario", "Pavia (PV)"), new structType.ptr("L339", "Travagliato", "Brescia (BS)"), new structType.ptr("L342", "Travedona-Monate", "Varese (VA)"), new structType.ptr("L345", "Traversella", "Torino (TO)"), new structType.ptr("L346", "Traversetolo", "Parma (PR)"), new structType.ptr("L340", "Traves", "Torino (TO)"), new structType.ptr("L347", "Travesio", "Pordenone (PN)"), new structType.ptr("L348", "Travo", "Piacenza (PC)"), new structType.ptr("M361", "Tre Ville", "Trento (TN)"), new structType.ptr("L349", "Trebaseleghe", "Padova (PD)"), new structType.ptr("L353", "Trebisacce", "Cosenza (CS)"), new structType.ptr("M280", "Trecase", "Napoli (NA)"), new structType.ptr("L355", "Trecastagni", "Catania (CT)"), new structType.ptr("M318", "Trecastelli", "Ancona (AN)"), new structType.ptr("L356", "Trecate", "Novara (NO)"), new structType.ptr("L357", "Trecchina", "Potenza (PZ)"), new structType.ptr("L359", "Trecenta", "Rovigo (RO)"), new structType.ptr("L361", "Tredozio", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("L363", "Treglio", "Chieti (CH)"), new structType.ptr("L364", "Tregnago", "Verona (VR)"), new structType.ptr("L366", "Treia", "Macerata (MC)"), new structType.ptr("L367", "Treiso", "Cuneo (CN)"), new structType.ptr("L368", "Tremenico", "Lecco (LC)"), new structType.ptr("L369", "Tremestieri Etneo", "Catania (CT)"), new structType.ptr("M341", "Tremezzina", "Como (CO)"), new structType.ptr("L372", "Tremosine", "Brescia (BS)"), new structType.ptr("L375", "Trenta", "Cosenza (CS)"), new structType.ptr("L377", "Trentinara", "Salerno (SA)"), new structType.ptr("L378", "Trento", "Trento (TN)"), new structType.ptr("L379", "Trentola Ducenta", "Caserta (CE)"), new structType.ptr("L380", "Trenzano", "Brescia (BS)"), new structType.ptr("L381", "Treppo Carnico", "Udine (UD)"), new structType.ptr("L382", "Treppo Grande", "Udine (UD)"), new structType.ptr("L383", "Trepuzzi", "Lecce (LE)"), new structType.ptr("L384", "Trequanda", "Siena (SI)"), new structType.ptr("L386", "Tresana", "Massa-Carrara (MS)"), new structType.ptr("L388", "Trescore Balneario", "Bergamo (BG)"), new structType.ptr("L389", "Trescore Cremasco", "Cremona (CR)"), new structType.ptr("L390", "Tresigallo", "Ferrara (FE)"), new structType.ptr("L392", "Tresivio", "Sondrio (SO)"), new structType.ptr("L393", "Tresnuraghes", "Oristano (OR)"), new structType.ptr("L396", "Trevenzuolo", "Verona (VR)"), new structType.ptr("L397", "Trevi", "Perugia (PG)"), new structType.ptr("L398", "Trevi Nel Lazio", "Frosinone (FR)"), new structType.ptr("L399", "Trevico", "Avellino (AV)"), new structType.ptr("L400", "Treviglio", "Bergamo (BG)"), new structType.ptr("L402", "Trevignano", "Treviso (TV)"), new structType.ptr("L401", "Trevignano Romano", "Roma (RM)"), new structType.ptr("L403", "Treville", "Alessandria (AL)"), new structType.ptr("L404", "Treviolo", "Bergamo (BG)"), new structType.ptr("L407", "Treviso", "Treviso (TV)"), new structType.ptr("L406", "Treviso Bresciano", "Brescia (BS)"), new structType.ptr("L408", "Trezzano Rosa", "Milano (MI)"), new structType.ptr("L409", "Trezzano Sul Naviglio", "Milano (MI)"), new structType.ptr("L411", "Trezzo Sull'Adda", "Milano (MI)"), new structType.ptr("L410", "Trezzo Tinella", "Cuneo (CN)"), new structType.ptr("L413", "Trezzone", "Como (CO)"), new structType.ptr("L414", "Tribano", "Padova (PD)"), new structType.ptr("L415", "Tribiano", "Milano (MI)"), new structType.ptr("L416", "Tribogna", "Genova (GE)"), new structType.ptr("L418", "Tricarico", "Matera (MT)"), new structType.ptr("L419", "Tricase", "Lecce (LE)"), new structType.ptr("L420", "Tricerro", "Vercelli (VC)"), new structType.ptr("L421", "Tricesimo", "Udine (UD)"), new structType.ptr("L422", "Trichiana", "Belluno (BL)"), new structType.ptr("L423", "Triei", "Ogliastra (OG)"), new structType.ptr("L424", "Trieste", "Trieste (TS)"), new structType.ptr("L425", "Triggiano", "Bari (BA)"), new structType.ptr("L426", "Trigolo", "Cremona (CR)"), new structType.ptr("L427", "Trinit\xC3\xA0", "Cuneo (CN)"), new structType.ptr("L428", "Trinita' D'Agultu E Vignola", "Olbia-Tempio (OT)"), new structType.ptr("B915", "Trinitapoli", "Barletta-Andria-Trani (BT)"), new structType.ptr("L429", "Trino", "Vercelli (VC)"), new structType.ptr("L430", "Triora", "Imperia (IM)"), new structType.ptr("L431", "Tripi", "Messina (ME)"), new structType.ptr("L432", "Trisobbio", "Alessandria (AL)"), new structType.ptr("L433", "Trissino", "Vicenza (VI)"), new structType.ptr("L434", "Triuggio", "Monza e della Brianza (MB)"), new structType.ptr("L435", "Trivento", "Campobasso (CB)"), new structType.ptr("L436", "Trivero", "Biella (BI)"), new structType.ptr("L437", "Trivigliano", "Frosinone (FR)"), new structType.ptr("L438", "Trivignano Udinese", "Udine (UD)"), new structType.ptr("L439", "Trivigno", "Potenza (PZ)"), new structType.ptr("L440", "Trivolzio", "Pavia (PV)"), new structType.ptr("L444", "Trodena Nel Parco Naturale .Truden Im Naturpa", "Bolzano (BZ)"), new structType.ptr("L445", "Trofarello", "Torino (TO)"), new structType.ptr("L447", "Troia", "Foggia (FG)"), new structType.ptr("L448", "Troina", "Enna (EN)"), new structType.ptr("L449", "Tromello", "Pavia (PV)"), new structType.ptr("L450", "Trontano", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A705", "Tronzano Lago Maggiore", "Varese (VA)"), new structType.ptr("L451", "Tronzano Vercellese", "Vercelli (VC)"), new structType.ptr("L452", "Tropea", "Vibo Valentia (VV)"), new structType.ptr("L453", "Trovo", "Pavia (PV)"), new structType.ptr("L454", "Truccazzano", "Milano (MI)"), new structType.ptr("L455", "Tubre .Taufers Im Muenstertal.", "Bolzano (BZ)"), new structType.ptr("L458", "Tufara", "Campobasso (CB)"), new structType.ptr("L459", "Tufillo", "Chieti (CH)"), new structType.ptr("L460", "Tufino", "Napoli (NA)"), new structType.ptr("L461", "Tufo", "Avellino (AV)"), new structType.ptr("L462", "Tuglie", "Lecce (LE)"), new structType.ptr("L463", "Tuili", "Medio Campidano (VS)"), new structType.ptr("L464", "Tula", "Sassari (SS)"), new structType.ptr("L466", "Tuoro Sul Trasimeno", "Perugia (PG)"), new structType.ptr("G507", "Turania", "Rieti (RI)"), new structType.ptr("L469", "Turano Lodigiano", "Lodi (LO)"), new structType.ptr("L470", "Turate", "Como (CO)"), new structType.ptr("L471", "Turbigo", "Milano (MI)"), new structType.ptr("L472", "Turi", "Bari (BA)"), new structType.ptr("L473", "Turri", "Medio Campidano (VS)"), new structType.ptr("L474", "Turriaco", "Gorizia (GO)"), new structType.ptr("L475", "Turrivalignani", "Pescara (PE)"), new structType.ptr("L477", "Tursi", "Matera (MT)"), new structType.ptr("L478", "Tusa", "Messina (ME)"), new structType.ptr("L310", "Tuscania", "Viterbo (VT)"), new structType.ptr("C789", "Ubiale Clanezzo", "Bergamo (BG)"), new structType.ptr("L480", "Uboldo", "Varese (VA)"), new structType.ptr("L482", "Ucria", "Messina (ME)"), new structType.ptr("L483", "Udine", "Udine (UD)"), new structType.ptr("L484", "Ugento", "Lecce (LE)"), new structType.ptr("L485", "Uggiano La Chiesa", "Lecce (LE)"), new structType.ptr("L487", "Uggiate-Trevano", "Como (CO)"), new structType.ptr("L488", "Ula' Tirso", "Oristano (OR)"), new structType.ptr("L489", "Ulassai", "Ogliastra (OG)"), new structType.ptr("L490", "Ultimo .Ulten.", "Bolzano (BZ)"), new structType.ptr("D786", "Umbertide", "Perugia (PG)"), new structType.ptr("L492", "Umbriatico", "Crotone (KR)"), new structType.ptr("L494", "Urago D'Oglio", "Brescia (BS)"), new structType.ptr("L496", "Uras", "Oristano (OR)"), new structType.ptr("L497", "Urbana", "Padova (PD)"), new structType.ptr("L498", "Urbania", "Pesaro e Urbino (PU)"), new structType.ptr("L499", "Urbe", "Savona (SV)"), new structType.ptr("L500", "Urbino", "Pesaro e Urbino (PU)"), new structType.ptr("L501", "Urbisaglia", "Macerata (MC)"), new structType.ptr("L502", "Urgnano", "Bergamo (BG)"), new structType.ptr("L503", "Uri", "Sassari (SS)"), new structType.ptr("L505", "Ururi", "Campobasso (CB)"), new structType.ptr("L506", "Urzulei", "Ogliastra (OG)"), new structType.ptr("L507", "Uscio", "Genova (GE)"), new structType.ptr("L508", "Usellus", "Oristano (OR)"), new structType.ptr("L509", "Usini", "Sassari (SS)"), new structType.ptr("L511", "Usmate Velate", "Monza e della Brianza (MB)"), new structType.ptr("L512", "Ussana", "Cagliari (CA)"), new structType.ptr("L513", "Ussaramanna", "Medio Campidano (VS)"), new structType.ptr("L514", "Ussassai", "Ogliastra (OG)"), new structType.ptr("L515", "Usseaux", "Torino (TO)"), new structType.ptr("L516", "Usseglio", "Torino (TO)"), new structType.ptr("L517", "Ussita", "Macerata (MC)"), new structType.ptr("L519", "Ustica", "Palermo (PA)"), new structType.ptr("L521", "Uta", "Cagliari (CA)"), new structType.ptr("L522", "Uzzano", "Pistoia (PT)"), new structType.ptr("L524", "Vaccarizzo Albanese", "Cosenza (CS)"), new structType.ptr("L525", "Vacone", "Rieti (RI)"), new structType.ptr("L526", "Vacri", "Chieti (CH)"), new structType.ptr("L527", "Vadena .Pfatten.", "Bolzano (BZ)"), new structType.ptr("L528", "Vado Ligure", "Savona (SV)"), new structType.ptr("L533", "Vagli Sotto", "Lucca (LU)"), new structType.ptr("L529", "Vaglia", "Firenze (FI)"), new structType.ptr("L532", "Vaglio Basilicata", "Potenza (PZ)"), new structType.ptr("L531", "Vaglio Serra", "Asti (AT)"), new structType.ptr("L537", "Vaiano", "Prato (PO)"), new structType.ptr("L535", "Vaiano Cremasco", "Cremona (CR)"), new structType.ptr("L538", "Vaie", "Torino (TO)"), new structType.ptr("L539", "Vailate", "Cremona (CR)"), new structType.ptr("L540", "Vairano Patenora", "Caserta (CE)"), new structType.ptr("M265", "Vajont", "Pordenone (PN)"), new structType.ptr("M334", "Val Brembilla", "Bergamo (BG)"), new structType.ptr("L555", "Val Della Torre", "Torino (TO)"), new structType.ptr("L562", "Val Di Nizza", "Pavia (PV)"), new structType.ptr("L564", "Val Di Vizze .Pfitsch.", "Bolzano (BZ)"), new structType.ptr("M374", "Val Di Zoldo", "Belluno (BL)"), new structType.ptr("L638", "Val Masino", "Sondrio (SO)"), new structType.ptr("H259", "Val Rezzo", "Como (CO)"), new structType.ptr("L544", "Valbondione", "Bergamo (BG)"), new structType.ptr("L545", "Valbrembo", "Bergamo (BG)"), new structType.ptr("L546", "Valbrevenna", "Genova (GE)"), new structType.ptr("L547", "Valbrona", "Como (CO)"), new structType.ptr("L551", "Valdagno", "Vicenza (VI)"), new structType.ptr("M343", "Valdaone", "Trento (TN)"), new structType.ptr("L552", "Valdaora .Olang.", "Bolzano (BZ)"), new structType.ptr("L554", "Valdastico", "Vicenza (VI)"), new structType.ptr("L556", "Valdengo", "Biella (BI)"), new structType.ptr("G319", "Valderice", "Trapani (TP)"), new structType.ptr("L557", "Valdidentro", "Sondrio (SO)"), new structType.ptr("L558", "Valdieri", "Cuneo (CN)"), new structType.ptr("L561", "Valdina", "Messina (ME)"), new structType.ptr("L563", "Valdisotto", "Sondrio (SO)"), new structType.ptr("L565", "Valdobbiadene", "Treviso (TV)"), new structType.ptr("L566", "Valduggia", "Vercelli (VC)"), new structType.ptr("L568", "Valeggio", "Pavia (PV)"), new structType.ptr("L567", "Valeggio Sul Mincio", "Verona (VR)"), new structType.ptr("L569", "Valentano", "Viterbo (VT)"), new structType.ptr("L570", "Valenza", "Alessandria (AL)"), new structType.ptr("L571", "Valenzano", "Bari (BA)"), new structType.ptr("L572", "Valera Fratta", "Lodi (LO)"), new structType.ptr("L573", "Valfabbrica", "Perugia (PG)"), new structType.ptr("L574", "Valfenera", "Asti (AT)"), new structType.ptr("L575", "Valfloriana", "Trento (TN)"), new structType.ptr("M382", "Valfornace", "Macerata (MC)"), new structType.ptr("L576", "Valfurva", "Sondrio (SO)"), new structType.ptr("L577", "Valganna", "Varese (VA)"), new structType.ptr("L578", "Valgioie", "Torino (TO)"), new structType.ptr("L579", "Valgoglio", "Bergamo (BG)"), new structType.ptr("L580", "Valgrana", "Cuneo (CN)"), new structType.ptr("L581", "Valgreghentino", "Lecco (LC)"), new structType.ptr("L582", "Valgrisenche", "Aosta (AO)"), new structType.ptr("L583", "Valguarnera Caropepe", "Enna (EN)"), new structType.ptr("L584", "Vallada Agordina", "Belluno (BL)"), new structType.ptr("L586", "Vallanzengo", "Biella (BI)"), new structType.ptr("L588", "Vallarsa", "Trento (TN)"), new structType.ptr("L589", "Vallata", "Avellino (AV)"), new structType.ptr("L594", "Valle Agricola", "Caserta (CE)"), new structType.ptr("L595", "Valle Aurina .Ahrntal.", "Bolzano (BZ)"), new structType.ptr("L597", "Valle Castellana", "Teramo (TE)"), new structType.ptr("G540", "Valle Dell'Angelo", "Salerno (SA)"), new structType.ptr("L590", "Valle Di Cadore", "Belluno (BL)"), new structType.ptr("L601", "Valle Di Casies .Gsies.", "Bolzano (BZ)"), new structType.ptr("L591", "Valle Di Maddaloni", "Caserta (CE)"), new structType.ptr("M362", "Valle Laghi", "Trento (TN)"), new structType.ptr("L593", "Valle Lomellina", "Pavia (PV)"), new structType.ptr("L606", "Valle Mosso", "Biella (BI)"), new structType.ptr("L617", "Valle Salimbene", "Pavia (PV)"), new structType.ptr("L620", "Valle San Nicolao", "Biella (BI)"), new structType.ptr("L596", "Vallebona", "Imperia (IM)"), new structType.ptr("L598", "Vallecorsa", "Frosinone (FR)"), new structType.ptr("L599", "Vallecrosia", "Imperia (IM)"), new structType.ptr("L603", "Valledolmo", "Palermo (PA)"), new structType.ptr("L604", "Valledoria", "Sassari (SS)"), new structType.ptr("I322", "Vallefiorita", "Catanzaro (CZ)"), new structType.ptr("M331", "Vallefoglia", "Pesaro e Urbino (PU)"), new structType.ptr("L607", "Vallelonga", "Vibo Valentia (VV)"), new structType.ptr("L609", "Vallelunga Pratameno", "Caltanissetta (CL)"), new structType.ptr("L605", "Vallemaio", "Frosinone (FR)"), new structType.ptr("L611", "Vallepietra", "Roma (RM)"), new structType.ptr("L612", "Vallerano", "Viterbo (VT)"), new structType.ptr("L613", "Vallermosa", "Cagliari (CA)"), new structType.ptr("L614", "Vallerotonda", "Frosinone (FR)"), new structType.ptr("L616", "Vallesaccarda", "Avellino (AV)"), new structType.ptr("L623", "Valleve", "Bergamo (BG)"), new structType.ptr("L624", "Valli Del Pasubio", "Vicenza (VI)"), new structType.ptr("L625", "Vallinfreda", "Roma (RM)"), new structType.ptr("L626", "Vallio Terme", "Brescia (BS)"), new structType.ptr("L628", "Vallo Della Lucania", "Salerno (SA)"), new structType.ptr("L627", "Vallo Di Nera", "Perugia (PG)"), new structType.ptr("L629", "Vallo Torinese", "Torino (TO)"), new structType.ptr("L631", "Valloriate", "Cuneo (CN)"), new structType.ptr("L633", "Valmacca", "Alessandria (AL)"), new structType.ptr("L634", "Valmadrera", "Lecco (LC)"), new structType.ptr("L636", "Valmala", "Cuneo (CN)"), new structType.ptr("L639", "Valmontone", "Roma (RM)"), new structType.ptr("L640", "Valmorea", "Como (CO)"), new structType.ptr("L641", "Valmozzola", "Parma (PR)"), new structType.ptr("L642", "Valnegra", "Bergamo (BG)"), new structType.ptr("L643", "Valpelline", "Aosta (AO)"), new structType.ptr("L644", "Valperga", "Torino (TO)"), new structType.ptr("B510", "Valprato Soana", "Torino (TO)"), new structType.ptr("M320", "Valsamoggia", "Bologna (BO)"), new structType.ptr("L647", "Valsavarenche", "Aosta (AO)"), new structType.ptr("D513", "Valsinni", "Matera (MT)"), new structType.ptr("C936", "Valsolda", "Como (CO)"), new structType.ptr("L650", "Valstagna", "Vicenza (VI)"), new structType.ptr("L651", "Valstrona", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("L653", "Valtopina", "Perugia (PG)"), new structType.ptr("L655", "Valtorta", "Bergamo (BG)"), new structType.ptr("L654", "Valtournenche", "Aosta (AO)"), new structType.ptr("L656", "Valva", "Salerno (SA)"), new structType.ptr("M346", "Valvasone \xC3\xA0rzene", "Pordenone (PN)"), new structType.ptr("L658", "Valverde", "Catania (CT)"), new structType.ptr("L659", "Valverde", "Pavia (PV)"), new structType.ptr("L468", "Valvestino", "Brescia (BS)"), new structType.ptr("L660", "Vandoies .Vintl.", "Bolzano (BZ)"), new structType.ptr("L664", "Vanzaghello", "Milano (MI)"), new structType.ptr("L665", "Vanzago", "Milano (MI)"), new structType.ptr("L666", "Vanzone Con San Carlo", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("L667", "Vaprio D'Adda", "Milano (MI)"), new structType.ptr("L668", "Vaprio D'Agogna", "Novara (NO)"), new structType.ptr("L669", "Varallo", "Vercelli (VC)"), new structType.ptr("L670", "Varallo Pombia", "Novara (NO)"), new structType.ptr("L671", "Varano Borghi", "Varese (VA)"), new structType.ptr("L672", "Varano De' Melegari", "Parma (PR)"), new structType.ptr("L673", "Varapodio", "Reggio Calabria (RC)"), new structType.ptr("L675", "Varazze", "Savona (SV)"), new structType.ptr("L676", "Varco Sabino", "Rieti (RI)"), new structType.ptr("L677", "Varedo", "Monza e della Brianza (MB)"), new structType.ptr("L678", "Varena", "Trento (TN)"), new structType.ptr("L680", "Varenna", "Lecco (LC)"), new structType.ptr("L682", "Varese", "Varese (VA)"), new structType.ptr("L681", "Varese Ligure", "La Spezia (SP)"), new structType.ptr("L685", "Varisella", "Torino (TO)"), new structType.ptr("L686", "Varmo", "Udine (UD)"), new structType.ptr("L687", "Varna .Vahrn.", "Bolzano (BZ)"), new structType.ptr("L689", "Varsi", "Parma (PR)"), new structType.ptr("L690", "Varzi", "Pavia (PV)"), new structType.ptr("L691", "Varzo", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("A701", "Vasanello", "Viterbo (VT)"), new structType.ptr("L693", "Vasia", "Imperia (IM)"), new structType.ptr("E372", "Vasto", "Chieti (CH)"), new structType.ptr("L696", "Vastogirardi", "Isernia (IS)"), new structType.ptr("L698", "Vauda Canavese", "Torino (TO)"), new structType.ptr("L699", "Vazzano", "Vibo Valentia (VV)"), new structType.ptr("L700", "Vazzola", "Treviso (TV)"), new structType.ptr("L702", "Vecchiano", "Pisa (PI)"), new structType.ptr("L704", "Vedano Al Lambro", "Monza e della Brianza (MB)"), new structType.ptr("L703", "Vedano Olona", "Varese (VA)"), new structType.ptr("L706", "Vedelago", "Treviso (TV)"), new structType.ptr("L707", "Vedeseta", "Bergamo (BG)"), new structType.ptr("L709", "Veduggio Con Colzano", "Monza e della Brianza (MB)"), new structType.ptr("L710", "Veggiano", "Padova (PD)"), new structType.ptr("L711", "Veglie", "Lecce (LE)"), new structType.ptr("L712", "Veglio", "Biella (BI)"), new structType.ptr("L713", "Vejano", "Viterbo (VT)"), new structType.ptr("L715", "Veleso", "Como (CO)"), new structType.ptr("L716", "Velezzo Lomellina", "Pavia (PV)"), new structType.ptr("L719", "Velletri", "Roma (RM)"), new structType.ptr("L720", "Vellezzo Bellini", "Pavia (PV)"), new structType.ptr("L723", "Velo D'Astico", "Vicenza (VI)"), new structType.ptr("L722", "Velo Veronese", "Verona (VR)"), new structType.ptr("L724", "Velturno .Feldthurns.", "Bolzano (BZ)"), new structType.ptr("L725", "Venafro", "Isernia (IS)"), new structType.ptr("L727", "Venaria Reale", "Torino (TO)"), new structType.ptr("L728", "Venarotta", "Ascoli Piceno (AP)"), new structType.ptr("L729", "Venasca", "Cuneo (CN)"), new structType.ptr("L726", "Venaus", "Torino (TO)"), new structType.ptr("L730", "Vendone", "Savona (SV)"), new structType.ptr("L731", "Vendrogno", "Lecco (LC)"), new structType.ptr("L733", "Venegono Inferiore", "Varese (VA)"), new structType.ptr("L734", "Venegono Superiore", "Varese (VA)"), new structType.ptr("L735", "Venetico", "Messina (ME)"), new structType.ptr("L736", "Venezia", "Venezia (VE)"), new structType.ptr("L737", "Veniano", "Como (CO)"), new structType.ptr("L738", "Venosa", "Potenza (PZ)"), new structType.ptr("M364", "Ventasso", "Reggio Emilia (RE)"), new structType.ptr("L739", "Venticano", "Avellino (AV)"), new structType.ptr("L741", "Ventimiglia", "Imperia (IM)"), new structType.ptr("L740", "Ventimiglia Di Sicilia", "Palermo (PA)"), new structType.ptr("L742", "Ventotene", "Latina (LT)"), new structType.ptr("L743", "Venzone", "Udine (UD)"), new structType.ptr("L745", "Verano .Voeran.", "Bolzano (BZ)"), new structType.ptr("L744", "Verano Brianza", "Monza e della Brianza (MB)"), new structType.ptr("L746", "Verbania", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("L747", "Verbicaro", "Cosenza (CS)"), new structType.ptr("L748", "Vercana", "Como (CO)"), new structType.ptr("L749", "Verceia", "Sondrio (SO)"), new structType.ptr("L750", "Vercelli", "Vercelli (VC)"), new structType.ptr("L751", "Vercurago", "Lecco (LC)"), new structType.ptr("L752", "Verdellino", "Bergamo (BG)"), new structType.ptr("L753", "Verdello", "Bergamo (BG)"), new structType.ptr("M337", "Verderio", "Lecco (LC)"), new structType.ptr("L758", "Verduno", "Cuneo (CN)"), new structType.ptr("L762", "Vergato", "Bologna (BO)"), new structType.ptr("L764", "Verghereto", "Forl\xC3\xAC-Cesena (FC)"), new structType.ptr("L765", "Vergiate", "Varese (VA)"), new structType.ptr("L768", "Vermezzo", "Milano (MI)"), new structType.ptr("L769", "Vermiglio", "Trento (TN)"), new structType.ptr("L771", "Vernante", "Cuneo (CN)"), new structType.ptr("L772", "Vernasca", "Piacenza (PC)"), new structType.ptr("L773", "Vernate", "Milano (MI)"), new structType.ptr("L774", "Vernazza", "La Spezia (SP)"), new structType.ptr("L775", "Vernio", "Prato (PO)"), new structType.ptr("L776", "Vernole", "Lecce (LE)"), new structType.ptr("L777", "Verolanuova", "Brescia (BS)"), new structType.ptr("L778", "Verolavecchia", "Brescia (BS)"), new structType.ptr("L779", "Verolengo", "Torino (TO)"), new structType.ptr("L780", "Veroli", "Frosinone (FR)"), new structType.ptr("L781", "Verona", "Verona (VR)"), new structType.ptr("D193", "Veronella", "Verona (VR)"), new structType.ptr("L783", "Verrayes", "Aosta (AO)"), new structType.ptr("C282", "Verres", "Aosta (AO)"), new structType.ptr("L784", "Verretto", "Pavia (PV)"), new structType.ptr("L785", "Verrone", "Biella (BI)"), new structType.ptr("L788", "Verrua Po", "Pavia (PV)"), new structType.ptr("L787", "Verrua Savoia", "Torino (TO)"), new structType.ptr("L792", "Vertemate Con Minoprio", "Como (CO)"), new structType.ptr("L795", "Vertova", "Bergamo (BG)"), new structType.ptr("L797", "Verucchio", "Rimini (RN)"), new structType.ptr("L798", "Veruno", "Novara (NO)"), new structType.ptr("L799", "Vervio", "Sondrio (SO)"), new structType.ptr("L801", "Verzegnis", "Udine (UD)"), new structType.ptr("L802", "Verzino", "Crotone (KR)"), new structType.ptr("L804", "Verzuolo", "Cuneo (CN)"), new structType.ptr("L805", "Vescovana", "Padova (PD)"), new structType.ptr("L806", "Vescovato", "Cremona (CR)"), new structType.ptr("L807", "Vesime", "Asti (AT)"), new structType.ptr("L808", "Vespolate", "Novara (NO)"), new structType.ptr("L809", "Vessalico", "Imperia (IM)"), new structType.ptr("L810", "Vestenanova", "Verona (VR)"), new structType.ptr("L811", "Vestign\xC3\xA8", "Torino (TO)"), new structType.ptr("L812", "Vestone", "Brescia (BS)"), new structType.ptr("L813", "Vestreno", "Lecco (LC)"), new structType.ptr("L814", "Vetralla", "Viterbo (VT)"), new structType.ptr("L815", "Vetto", "Reggio Emilia (RE)"), new structType.ptr("L817", "Vezza D'Alba", "Cuneo (CN)"), new structType.ptr("L816", "Vezza D'Oglio", "Brescia (BS)"), new structType.ptr("L819", "Vezzano Ligure", "La Spezia (SP)"), new structType.ptr("L820", "Vezzano Sul Crostolo", "Reggio Emilia (RE)"), new structType.ptr("L823", "Vezzi Portio", "Savona (SV)"), new structType.ptr("L826", "Viadana", "Mantova (MN)"), new structType.ptr("L827", "Viadanica", "Bergamo (BG)"), new structType.ptr("L828", "Viagrande", "Catania (CT)"), new structType.ptr("L829", "Viale", "Asti (AT)"), new structType.ptr("L830", "Vialfr\xC3\xA8", "Torino (TO)"), new structType.ptr("L831", "Viano", "Reggio Emilia (RE)"), new structType.ptr("L833", "Viareggio", "Lucca (LU)"), new structType.ptr("L834", "Viarigi", "Asti (AT)"), new structType.ptr("F537", "Vibo Valentia", "Vibo Valentia (VV)"), new structType.ptr("L835", "Vibonati", "Salerno (SA)"), new structType.ptr("L836", "Vicalvi", "Frosinone (FR)"), new structType.ptr("L837", "Vicari", "Palermo (PA)"), new structType.ptr("L838", "Vicchio", "Firenze (FI)"), new structType.ptr("L840", "Vicenza", "Vicenza (VI)"), new structType.ptr("L548", "Vico Canavese", "Torino (TO)"), new structType.ptr("L842", "Vico Del Gargano", "Foggia (FG)"), new structType.ptr("L845", "Vico Equense", "Napoli (NA)"), new structType.ptr("L843", "Vico Nel Lazio", "Frosinone (FR)"), new structType.ptr("L841", "Vicoforte", "Cuneo (CN)"), new structType.ptr("L846", "Vicoli", "Pescara (PE)"), new structType.ptr("L847", "Vicolungo", "Novara (NO)"), new structType.ptr("L850", "Vicopisano", "Pisa (PI)"), new structType.ptr("L851", "Vicovaro", "Roma (RM)"), new structType.ptr("M259", "Viddalba", "Sassari (SS)"), new structType.ptr("L854", "Vidigulfo", "Pavia (PV)"), new structType.ptr("L856", "Vidor", "Treviso (TV)"), new structType.ptr("L857", "Vidracco", "Torino (TO)"), new structType.ptr("L858", "Vieste", "Foggia (FG)"), new structType.ptr("L859", "Vietri Di Potenza", "Potenza (PZ)"), new structType.ptr("L860", "Vietri Sul Mare", "Salerno (SA)"), new structType.ptr("L866", "Vigan\xC3\xB2", "Lecco (LC)"), new structType.ptr("L865", "Vigano San Martino", "Bergamo (BG)"), new structType.ptr("L868", "Vigarano Mainarda", "Ferrara (FE)"), new structType.ptr("L869", "Vigasio", "Verona (VR)"), new structType.ptr("L872", "Vigevano", "Pavia (PV)"), new structType.ptr("L873", "Viggianello", "Potenza (PZ)"), new structType.ptr("L874", "Viggiano", "Potenza (PZ)"), new structType.ptr("L876", "Viggi\xC3\xB9", "Varese (VA)"), new structType.ptr("L878", "Vighizzolo D'Este", "Padova (PD)"), new structType.ptr("L880", "Vigliano Biellese", "Biella (BI)"), new structType.ptr("L879", "Vigliano D'Asti", "Asti (AT)"), new structType.ptr("L881", "Vignale Monferrato", "Alessandria (AL)"), new structType.ptr("L882", "Vignanello", "Viterbo (VT)"), new structType.ptr("L883", "Vignate", "Milano (MI)"), new structType.ptr("L885", "Vignola", "Modena (MO)"), new structType.ptr("L886", "Vignola Falesina", "Trento (TN)"), new structType.ptr("L887", "Vignole Borbera", "Alessandria (AL)"), new structType.ptr("L888", "Vignolo", "Cuneo (CN)"), new structType.ptr("L889", "Vignone", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("L890", "Vigo Di Cadore", "Belluno (BL)"), new structType.ptr("L893", "Vigo Di Fassa", "Trento (TN)"), new structType.ptr("L892", "Vigodarzere", "Padova (PD)"), new structType.ptr("L894", "Vigolo", "Bergamo (BG)"), new structType.ptr("L897", "Vigolzone", "Piacenza (PC)"), new structType.ptr("L898", "Vigone", "Torino (TO)"), new structType.ptr("L899", "Vigonovo", "Venezia (VE)"), new structType.ptr("L900", "Vigonza", "Padova (PD)"), new structType.ptr("L904", "Viguzzolo", "Alessandria (AL)"), new structType.ptr("L912", "Villa Bartolomea", "Verona (VR)"), new structType.ptr("L913", "Villa Basilica", "Lucca (LU)"), new structType.ptr("L917", "Villa Biscossi", "Pavia (PV)"), new structType.ptr("L919", "Villa Carcina", "Brescia (BS)"), new structType.ptr("L920", "Villa Castelli", "Brindisi (BR)"), new structType.ptr("L922", "Villa Celiera", "Pescara (PE)"), new structType.ptr("L926", "Villa Collemandina", "Lucca (LU)"), new structType.ptr("L928", "Villa Cortese", "Milano (MI)"), new structType.ptr("L929", "Villa D'Adda", "Bergamo (BG)"), new structType.ptr("A215", "Villa D'Alm\xC3\xA8", "Bergamo (BG)"), new structType.ptr("L933", "Villa Del Bosco", "Biella (BI)"), new structType.ptr("L934", "Villa Del Conte", "Padova (PD)"), new structType.ptr("D801", "Villa Di Briano", "Caserta (CE)"), new structType.ptr("L907", "Villa Di Chiavenna", "Sondrio (SO)"), new structType.ptr("L936", "Villa Di Serio", "Bergamo (BG)"), new structType.ptr("L908", "Villa Di Tirano", "Sondrio (SO)"), new structType.ptr("L938", "Villa D'Ogna", "Bergamo (BG)"), new structType.ptr("L937", "Villa Estense", "Padova (PD)"), new structType.ptr("L943", "Villa Faraldi", "Imperia (IM)"), new structType.ptr("L956", "Villa Guardia", "Como (CO)"), new structType.ptr("L957", "Villa Lagarina", "Trento (TN)"), new structType.ptr("A081", "Villa Latina", "Frosinone (FR)"), new structType.ptr("L844", "Villa Literno", "Caserta (CE)"), new structType.ptr("L969", "Villa Minozzo", "Reggio Emilia (RE)"), new structType.ptr("F804", "Villa Poma", "Mantova (MN)"), new structType.ptr("M018", "Villa San Giovanni", "Reggio Calabria (RC)"), new structType.ptr("H913", "Villa San Giovanni In Tuscia", "Viterbo (VT)"), new structType.ptr("I118", "Villa San Pietro", "Cagliari (CA)"), new structType.ptr("M019", "Villa San Secondo", "Asti (AT)"), new structType.ptr("L905", "Villa Santa Lucia", "Frosinone (FR)"), new structType.ptr("M021", "Villa Santa Lucia Degli Abruzzi", "L'Aquila (AQ)"), new structType.ptr("M022", "Villa Santa Maria", "Chieti (CH)"), new structType.ptr("M023", "Villa Sant'Angelo", "L'Aquila (AQ)"), new structType.ptr("I298", "Villa Sant'Antonio", "Oristano (OR)"), new structType.ptr("L909", "Villa Santina", "Udine (UD)"), new structType.ptr("I364", "Villa Santo Stefano", "Frosinone (FR)"), new structType.ptr("A609", "Villa Verde", "Oristano (OR)"), new structType.ptr("M034", "Villa Vicentina", "Udine (UD)"), new structType.ptr("L915", "Villabassa .Niederdorf.", "Bolzano (BZ)"), new structType.ptr("L916", "Villabate", "Palermo (PA)"), new structType.ptr("L923", "Villachiara", "Brescia (BS)"), new structType.ptr("L924", "Villacidro", "Medio Campidano (VS)"), new structType.ptr("L931", "Villadeati", "Alessandria (AL)"), new structType.ptr("L939", "Villadose", "Rovigo (RO)"), new structType.ptr("L906", "Villadossola", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("L942", "Villafalletto", "Cuneo (CN)"), new structType.ptr("L945", "Villafranca D'Asti", "Asti (AT)"), new structType.ptr("L949", "Villafranca Di Verona", "Verona (VR)"), new structType.ptr("L946", "Villafranca In Lunigiana", "Massa-Carrara (MS)"), new structType.ptr("L947", "Villafranca Padovana", "Padova (PD)"), new structType.ptr("L948", "Villafranca Piemonte", "Torino (TO)"), new structType.ptr("L944", "Villafranca Sicula", "Agrigento (AG)"), new structType.ptr("L950", "Villafranca Tirrena", "Messina (ME)"), new structType.ptr("L951", "Villafrati", "Palermo (PA)"), new structType.ptr("L952", "Villaga", "Vicenza (VI)"), new structType.ptr("L953", "Villagrande Strisaili", "Ogliastra (OG)"), new structType.ptr("L958", "Villalago", "L'Aquila (AQ)"), new structType.ptr("L959", "Villalba", "Caltanissetta (CL)"), new structType.ptr("L961", "Villalfonsina", "Chieti (CH)"), new structType.ptr("L963", "Villalvernia", "Alessandria (AL)"), new structType.ptr("L964", "Villamagna", "Chieti (CH)"), new structType.ptr("L965", "Villamaina", "Avellino (AV)"), new structType.ptr("L966", "Villamar", "Medio Campidano (VS)"), new structType.ptr("L967", "Villamarzana", "Rovigo (RO)"), new structType.ptr("L968", "Villamassargia", "Carbonia-Iglesias (CI)"), new structType.ptr("L970", "Villamiroglio", "Alessandria (AL)"), new structType.ptr("L971", "Villandro .Villanders.", "Bolzano (BZ)"), new structType.ptr("L978", "Villanova Biellese", "Biella (BI)"), new structType.ptr("L982", "Villanova Canavese", "Torino (TO)"), new structType.ptr("L975", "Villanova D'Albenga", "Savona (SV)"), new structType.ptr("L983", "Villanova D'Ardenghi", "Pavia (PV)"), new structType.ptr("L984", "Villanova D'Asti", "Asti (AT)"), new structType.ptr("L973", "Villanova Del Battista", "Avellino (AV)"), new structType.ptr("L985", "Villanova Del Ghebbo", "Rovigo (RO)"), new structType.ptr("L977", "Villanova Del Sillaro", "Lodi (LO)"), new structType.ptr("L979", "Villanova Di Camposampiero", "Padova (PD)"), new structType.ptr("L988", "Villanova Marchesana", "Rovigo (RO)"), new structType.ptr("L974", "Villanova Mondov\xC3\xAC", "Cuneo (CN)"), new structType.ptr("L972", "Villanova Monferrato", "Alessandria (AL)"), new structType.ptr("L989", "Villanova Monteleone", "Sassari (SS)"), new structType.ptr("L990", "Villanova Solaro", "Cuneo (CN)"), new structType.ptr("L980", "Villanova Sull'Arda", "Piacenza (PC)"), new structType.ptr("L991", "Villanova Truschedu", "Oristano (OR)"), new structType.ptr("L992", "Villanova Tulo", "Cagliari (CA)"), new structType.ptr("L986", "Villanovaforru", "Medio Campidano (VS)"), new structType.ptr("L987", "Villanovafranca", "Medio Campidano (VS)"), new structType.ptr("L994", "Villanterio", "Pavia (PV)"), new structType.ptr("L995", "Villanuova Sul Clisi", "Brescia (BS)"), new structType.ptr("M278", "Villaperuccio", "Carbonia-Iglesias (CI)"), new structType.ptr("B903", "Villapiana", "Cosenza (CS)"), new structType.ptr("L998", "Villaputzu", "Cagliari (CA)"), new structType.ptr("L999", "Villar Dora", "Torino (TO)"), new structType.ptr("M007", "Villar Focchiardo", "Torino (TO)"), new structType.ptr("M013", "Villar Pellice", "Torino (TO)"), new structType.ptr("M014", "Villar Perosa", "Torino (TO)"), new structType.ptr("M015", "Villar San Costanzo", "Cuneo (CN)"), new structType.ptr("M002", "Villarbasse", "Torino (TO)"), new structType.ptr("M003", "Villarboit", "Vercelli (VC)"), new structType.ptr("M004", "Villareggia", "Torino (TO)"), new structType.ptr("G309", "Villaricca", "Napoli (NA)"), new structType.ptr("M009", "Villaromagnano", "Alessandria (AL)"), new structType.ptr("M011", "Villarosa", "Enna (EN)"), new structType.ptr("M016", "Villasalto", "Cagliari (CA)"), new structType.ptr("M017", "Villasanta", "Monza e della Brianza (MB)"), new structType.ptr("B738", "Villasimius", "Cagliari (CA)"), new structType.ptr("M025", "Villasor", "Cagliari (CA)"), new structType.ptr("M026", "Villaspeciosa", "Cagliari (CA)"), new structType.ptr("M027", "Villastellone", "Torino (TO)"), new structType.ptr("M028", "Villata", "Vercelli (VC)"), new structType.ptr("M030", "Villaurbana", "Oristano (OR)"), new structType.ptr("M031", "Villavallelonga", "L'Aquila (AQ)"), new structType.ptr("M032", "Villaverla", "Vicenza (VI)"), new structType.ptr("M363", "Ville D'Anaunia", "Trento (TN)"), new structType.ptr("L981", "Villeneuve", "Aosta (AO)"), new structType.ptr("M043", "Villesse", "Gorizia (GO)"), new structType.ptr("M041", "Villetta Barrea", "L'Aquila (AQ)"), new structType.ptr("M042", "Villette", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("M044", "Villimpenta", "Mantova (MN)"), new structType.ptr("M045", "Villongo", "Bergamo (BG)"), new structType.ptr("M048", "Villorba", "Treviso (TV)"), new structType.ptr("M050", "Vilminore Di Scalve", "Bergamo (BG)"), new structType.ptr("M052", "Vimercate", "Monza e della Brianza (MB)"), new structType.ptr("M053", "Vimodrone", "Milano (MI)"), new structType.ptr("M055", "Vinadio", "Cuneo (CN)"), new structType.ptr("M057", "Vinchiaturo", "Campobasso (CB)"), new structType.ptr("M058", "Vinchio", "Asti (AT)"), new structType.ptr("M059", "Vinci", "Firenze (FI)"), new structType.ptr("M060", "Vinovo", "Torino (TO)"), new structType.ptr("M062", "Vinzaglio", "Novara (NO)"), new structType.ptr("M063", "Viola", "Cuneo (CN)"), new structType.ptr("M065", "Vione", "Brescia (BS)"), new structType.ptr("M067", "Vipiteno .Sterzing.", "Bolzano (BZ)"), new structType.ptr("M069", "Virle Piemonte", "Torino (TO)"), new structType.ptr("M070", "Visano", "Brescia (BS)"), new structType.ptr("M071", "Vische", "Torino (TO)"), new structType.ptr("M072", "Visciano", "Napoli (NA)"), new structType.ptr("M073", "Visco", "Udine (UD)"), new structType.ptr("M077", "Visone", "Alessandria (AL)"), new structType.ptr("M078", "Visso", "Macerata (MC)"), new structType.ptr("M079", "Vistarino", "Pavia (PV)"), new structType.ptr("M080", "Vistrorio", "Torino (TO)"), new structType.ptr("M081", "Vita", "Trapani (TP)"), new structType.ptr("M082", "Viterbo", "Viterbo (VT)"), new structType.ptr("M083", "Viticuso", "Frosinone (FR)"), new structType.ptr("M085", "Vito D'Asio", "Pordenone (PN)"), new structType.ptr("M086", "Vitorchiano", "Viterbo (VT)"), new structType.ptr("M088", "Vittoria", "Ragusa (RG)"), new structType.ptr("M089", "Vittorio Veneto", "Treviso (TV)"), new structType.ptr("M090", "Vittorito", "L'Aquila (AQ)"), new structType.ptr("M091", "Vittuone", "Milano (MI)"), new structType.ptr("M093", "Vitulano", "Benevento (BN)"), new structType.ptr("M092", "Vitulazio", "Caserta (CE)"), new structType.ptr("M094", "Vi\xC3\xB9", "Torino (TO)"), new structType.ptr("M096", "Vivaro", "Pordenone (PN)"), new structType.ptr("M095", "Vivaro Romano", "Roma (RM)"), new structType.ptr("M098", "Viverone", "Biella (BI)"), new structType.ptr("M100", "Vizzini", "Catania (CT)"), new structType.ptr("M101", "Vizzola Ticino", "Varese (VA)"), new structType.ptr("M102", "Vizzolo Predabissi", "Milano (MI)"), new structType.ptr("M103", "V\xC3\xB2", "Padova (PD)"), new structType.ptr("M104", "Vobarno", "Brescia (BS)"), new structType.ptr("M105", "Vobbia", "Genova (GE)"), new structType.ptr("M106", "Vocca", "Vercelli (VC)"), new structType.ptr("M108", "Vodo Cadore", "Belluno (BL)"), new structType.ptr("M109", "Voghera", "Pavia (PV)"), new structType.ptr("M110", "Voghiera", "Ferrara (FE)"), new structType.ptr("M111", "Vogogna", "Verbano-Cusio-Ossola (VB)"), new structType.ptr("M113", "Volano", "Trento (TN)"), new structType.ptr("M115", "Volla", "Napoli (NA)"), new structType.ptr("M116", "Volongo", "Cremona (CR)"), new structType.ptr("M118", "Volpago Del Montello", "Treviso (TV)"), new structType.ptr("M119", "Volpara", "Pavia (PV)"), new structType.ptr("M120", "Volpedo", "Alessandria (AL)"), new structType.ptr("M121", "Volpeglino", "Alessandria (AL)"), new structType.ptr("M122", "Volpiano", "Torino (TO)"), new structType.ptr("M125", "Volta Mantovana", "Mantova (MN)"), new structType.ptr("M123", "Voltaggio", "Alessandria (AL)"), new structType.ptr("M124", "Voltago Agordino", "Belluno (BL)"), new structType.ptr("M126", "Volterra", "Pisa (PI)"), new structType.ptr("M127", "Voltido", "Cremona (CR)"), new structType.ptr("M131", "Volturara Appula", "Foggia (FG)"), new structType.ptr("M130", "Volturara Irpina", "Avellino (AV)"), new structType.ptr("M132", "Volturino", "Foggia (FG)"), new structType.ptr("M133", "Volvera", "Torino (TO)"), new structType.ptr("M136", "Vottignasco", "Cuneo (CN)"), new structType.ptr("M138", "Zaccanopoli", "Vibo Valentia (VV)"), new structType.ptr("M139", "Zafferana Etnea", "Catania (CT)"), new structType.ptr("M140", "Zagarise", "Catanzaro (CZ)"), new structType.ptr("M141", "Zagarolo", "Roma (RM)"), new structType.ptr("M142", "Zambana", "Trento (TN)"), new structType.ptr("M143", "Zambrone", "Vibo Valentia (VV)"), new structType.ptr("M144", "Zandobbio", "Bergamo (BG)"), new structType.ptr("M145", "Zan\xC3\xA8", "Vicenza (VI)"), new structType.ptr("M147", "Zanica", "Bergamo (BG)"), new structType.ptr("M267", "Zapponeta", "Foggia (FG)"), new structType.ptr("M150", "Zavattarello", "Pavia (PV)"), new structType.ptr("M152", "Zeccone", "Pavia (PV)"), new structType.ptr("M153", "Zeddiani", "Oristano (OR)"), new structType.ptr("M156", "Zelbio", "Como (CO)"), new structType.ptr("M158", "Zelo Buon Persico", "Lodi (LO)"), new structType.ptr("M160", "Zelo Surrigone", "Milano (MI)"), new structType.ptr("M161", "Zeme", "Pavia (PV)"), new structType.ptr("M162", "Zenevredo", "Pavia (PV)"), new structType.ptr("M163", "Zenson Di Piave", "Treviso (TV)"), new structType.ptr("M165", "Zerba", "Piacenza (PC)"), new structType.ptr("M166", "Zerbo", "Pavia (PV)"), new structType.ptr("M167", "Zerbol\xC3\xB2", "Pavia (PV)"), new structType.ptr("M168", "Zerfaliu", "Oristano (OR)"), new structType.ptr("M169", "Zeri", "Massa-Carrara (MS)"), new structType.ptr("M170", "Zermeghedo", "Vicenza (VI)"), new structType.ptr("M171", "Zero Branco", "Treviso (TV)"), new structType.ptr("M172", "Zevio", "Verona (VR)"), new structType.ptr("M173", "Ziano Di Fiemme", "Trento (TN)"), new structType.ptr("L848", "Ziano Piacentino", "Piacenza (PC)"), new structType.ptr("M176", "Zibido San Giacomo", "Milano (MI)"), new structType.ptr("M177", "Zignago", "La Spezia (SP)"), new structType.ptr("M178", "Zimella", "Verona (VR)"), new structType.ptr("M179", "Zimone", "Biella (BI)"), new structType.ptr("M180", "Zinasco", "Pavia (PV)"), new structType.ptr("M182", "Zoagli", "Genova (GE)"), new structType.ptr("M183", "Zocca", "Modena (MO)"), new structType.ptr("M184", "Zogno", "Bergamo (BG)"), new structType.ptr("M185", "Zola Predosa", "Bologna (BO)"), new structType.ptr("M187", "Zollino", "Lecce (LE)"), new structType.ptr("M188", "Zone", "Brescia (BS)"), new structType.ptr("M189", "Zoppe' Di Cadore", "Belluno (BL)"), new structType.ptr("M190", "Zoppola", "Pordenone (PN)"), new structType.ptr("M194", "Zovencedo", "Vicenza (VI)"), new structType.ptr("M196", "Zubiena", "Biella (BI)"), new structType.ptr("M197", "Zuccarello", "Savona (SV)"), new structType.ptr("M199", "Zugliano", "Vicenza (VI)"), new structType.ptr("M200", "Zuglio", "Udine (UD)"), new structType.ptr("M201", "Zumaglia", "Biella (BI)"), new structType.ptr("M202", "Zumpano", "Cosenza (CS)"), new structType.ptr("M203", "Zungoli", "Avellino (AV)"), new structType.ptr("M204", "Zungri", "Vibo Valentia (VV)")]);
		$pkg.ItalianFemaleNames = new sliceType$2(["Abbondanza", "Ada", "Addolorata", "Adelaide", "Adelasia", "Adele", "Adelina", "Adina", "Adria", "Adriana", "Agata", "Agnese", "Agostina", "Aida", "Alba", "Alberta", "Albina", "Alda", "Alessandra", "Alessia", "Alfonsa", "Alfreda", "Alice", "Alida", "Alina", "Allegra", "Alma", "Altea", "Amalia", "Amanda", "Amata", "Ambra", "Amelia", "Amina", "Anastasia", "Andromeda", "Angela", "Angelica", "Anita", "Anna", "Annabella", "Annagrazia", "Annamaria", "Annunziata", "Antea", "Antonella", "Antonia", "Arianna", "Armida", "Artemisa", "Asella", "Asia", "Assunta", "Astrid", "Atanasia", "Aurelia", "Aurora", "Ausilia", "Ave", "Aza", "Azelia", "Azzurra", "Babila", "Barbara", "Bartolomea", "Basilia", "Bassilla", "Batilda", "Beata", "Beatrice", "Belina", "Benedetta", "Beniamina", "Bernadetta", "Betta", "Bianca", "Bibiana", "Bice", "Brigida", "Bruna", "Camelia", "Camilla", "Candida", "Carina", "Carla", "Carlotta", "Carmela", "Carmen", "Carola", "Carolina", "Cassandra", "Catena", "Caterina", "Cecilia", "Celeste", "Chiara", "Cinzia", "Clara", "Claudia", "Clelia", "Clemenzia", "Cleo", "Cleopatra", "Cloe", "Colomba", "Concetta", "Consolata", "Cora", "Cordelia", "Corinna", "Cornelia", "Cosima", "Costanza", "Crescenzia", "Cristiana", "Cristina", "Crocefissa", "Dafne", "Damiana", "Daniela", "Daria", "Deanna", "Debora", "Delia", "Delinda", "Delizia", "Diana", "Dianora", "Diletta", "Dina", "Diodata", "Dionisia", "Doda", "Dolores", "Domenica", "Donata", "Donatella", "Donna", "Dora", "Dorotea", "Ebe", "Edda", "Editta", "Egizia", "Elaide", "Elda", "Elena", "Eleonora", "Elettra", "Eliana", "Elide", "Elimena", "Elisa", "Elisabetta", "Elisea", "Eloisa", "Elsa", "Elvia", "Elvira", "Emanuela", "Emilia", "Emiliana", "Emma", "Enrica", "Esmeralda", "Estella", "Ester", "Esterina", "Eufemia", "Eugenia", "Euridice", "Eusebia", "Eutalia", "Eva", "Evangelina", "Evelina", "Fabiana", "Fabiola", "Fatima", "Fausta", "Federica", "Fedora", "Felicia", "Fernanda", "Fiammetta", "Filippa", "Fiordaliso", "Fiore", "Fiorella", "Fiorenza", "Flaminia", "Flavia", "Flaviana", "Flora", "Floriana", "Fortunata", "Fosca", "Franca", "Francesca", "Fulvia", "Gabriella", "Gaia", "Galatea", "Gelsomina", "Gemma", "Genesia", "Genoveffa", "Germana", "Giacinta", "Giada", "Gilda", "Ginevra", "Gioia", "Giorgia", "Giovanna", "Gisella", "Giuditta", "Giulia", "Giuliana", "Giulitta", "Giuseppa", "Giuseppina", "Giusta", "Gloria", "Grazia", "Graziana", "Graziella", "Greta", "Guendalina", "Ida", "Idea", "Iginia", "Ilaria", "Ilda", "Ilenia", "Ilia", "Immacolata", "Ines", "Innocenza", "Iolanda", "Irene", "Iride", "Iris", "Irma", "Irmina", "Isa", "Isabella", "Isidora", "Lara", "Laura", "Lavinia", "Lea", "Lelia", "Lena", "Leonia", "Leonilda", "Letizia", "Lia", "Liana", "Licia", "Lidia", "Liliana", "Linda", "Lisa", "Livia", "Liviana", "Lodovica", "Loredana", "Lorena", "Lorenza", "Loretta", "Loriana", "Luana", "Luce", "Lucia", "Luciana", "Lucilla", "Lucrezia", "Ludovica", "Luigia", "Luisa", "Luna", "Macaria", "Maddalena", "Mafalda", "Magda", "Maida", "Manuela", "Mara", "Marana", "Marcella", "Mareta", "Margherita", "Maria", "Marianna", "Marica", "Mariella", "Marilena", "Marina", "Marinella", "Marinetta", "Marisa", "Marita", "Marta", "Martina", "Maruta", "Marzia", "Massima", "Matilde", "Maura", "Melania", "Melissa", "Mia", "Michela", "Milena", "Mimma", "Mina", "Minerva", "Miranda", "Mirella", "Miriam", "Mirta", "Monica", "Morena", "Morgana", "Nadia", "Natalia", "Natalina", "Neiva", "Nicoletta", "Nina", "Ninfa", "Noemi", "Norina", "Norma", "Nunziata", "Odetta", "Odilia", "Ofelia", "Olga", "Olimpia", "Olinda", "Olivia", "Ombretta", "Ondina", "Onesta", "Onorata", "Onorina", "Orchidea", "Oriana", "Orietta", "Ornella", "Orsola", "Orsolina", "Ortensia", "Osanna", "Otilia", "Palladia", "Palmira", "Pamela", "Paola", "Patrizia", "Penelope", "Perla", "Petronilla", "Pia", "Piera", "Placida", "Priscilla", "Quieta", "Rachele", "Raffaella", "Rebecca", "Regina", "Renata", "Riccarda", "Rina", "Rita", "Roberta", "Romana", "Rosa", "Rosalia", "Rosalinda", "Rosamunda", "Rosanna", "Rosita", "Rosmunda", "Rossana", "Rossella", "Saba", "Sabina", "Sabrina", "Samanta", "Sandra", "Santina", "Sara", "Savina", "Sebastiana", "Sefora", "Selene", "Selvaggia", "Serafina", "Serena", "Severa", "Sibilla", "Silvana", "Silvia", "Simona", "Simonetta", "Sofia", "Sonia", "Stefania", "Stella", "Susanna", "Sveva", "Tabita", "Tamara", "Taziana", "Tea", "Tecla", "Teresa", "Teudosia", "Tina", "Tiziana", "Tullia", "Uliva", "Valentina", "Valeria", "Valeriana", "Vanda", "Vanessa", "Vanna", "Venere", "Vera", "Verdiana", "Verena", "Veriana", "Veridiana", "Veronica", "Viliana", "Vilma", "Vincenza", "Viola", "Virginia", "Vissia", "Vittoria", "Viviana", "Wanda", "Zaira", "Zelinda", "Zita", "Zoe"]);
		$pkg.ItalianMaleNames = new sliceType$2(["Abelardo", "Abele", "Abenzio", "Abramio", "Abramo", "Acacio", "Acario", "Achille", "Adalberto", "Adalfredo", "Adalgiso", "Adalrico", "Adamo", "Addo", "Adelardo", "Adelberto", "Adone", "Adriano", "Agabio", "Agape", "Agostino", "Aladino", "Alamanno", "Alano", "Albano", "Alberico", "Alberto", "Albino", "Aleandro", "Aleardo", "Aleramo", "Alessandro", "Alessio", "Alfio", "Alfonso", "Alfredo", "Algiso", "Alighiero", "Almerigo", "Aloisio", "Alvaro", "Alviero", "Alvise", "Amadeo", "Amando", "Amanzio", "Amauri", "Ambrogio", "Ambrosiano", "Amedeo", "Amilcare", "Amleto", "Amos", "Ampelio", "Anacleto", "Andrea", "Angelo", "Aniceto", "Aniello", "Annibale", "Ansaldo", "Anselmo", "Ansovino", "Antelmo", "Antonello", "Antonio", "Arcadio", "Aresio", "Aris", "Aristarco", "Aristofane", "Aristotele", "Armando", "Arminio", "Arnaldo", "Aronne", "Arrigo", "Arturo", "Ascanio", "Astianatte", "Ataleo", "Atanasio", "Athos", "Attila", "Auberto", "Augusto", "Aureliano", "Aurelio", "Ausilio", "Averardo", "Azeglio", "Azelio", "Bacco", "Baldassarre", "Baldo", "Baldomero", "Baldovino", "Barbarigo", "Barnaba", "Barsaba", "Barsimeo", "Bartolo", "Bartolomeo", "Basileo", "Basilio", "Bassiano", "Bastiano", "Battista", "Beltramo", "Benedetto", "Beniamino", "Benigno", "Benito", "Benvenuto", "Bertoldo", "Biagio", "Bibiano", "Bindo", "Bino", "Bonaldo", "Bonaventura", "Bonavita", "Bonifacio", "Bonito", "Boris", "Bortolo", "Brancaleone", "Brando", "Bruno", "Bruto", "Caino", "Caio", "Calogero", "Camillo", "Candido", "Cantidio", "Canziano", "Carlo", "Carmelo", "Carmine", "Cassiano", "Cassio", "Casto", "Cataldo", "Catullo", "Cecco", "Cecilio", "Celso", "Cesare", "Cesario", "Cherubino", "Chiaffredo", "Cino", "Ciro", "Clarenzio", "Claudio", "Cleandro", "Clemente", "Clinio", "Clodomiro", "Clodoveo", "Colmanno", "Colmazio", "Colombano", "Colombo", "Concetto", "Concordio", "Corbiniano", "Coreno", "Coriolano", "Cornelio", "Coronato", "Corrado", "Cosimo", "Cosma", "Costante", "Costantino", "Costanzo", "Crispino", "Cristiano", "Cristoforo", "Crocefisso", "Cuniberto", "Daciano", "Dacio", "Damaso", "Damiano", "Daniele", "Danilo", "Danio", "Dante", "Dario", "Davide", "Davino", "Decimo", "Demetrio", "Democrito", "Didimo", "Diego", "Dino", "Dionigi", "Dionisio", "Dodato", "Domenico", "Domezio", "Donatello", "Donato", "Duilio", "Eberardo", "Edoardo", "Efisio", "Efrem", "Egeo", "Egidio", "Egisto", "Elia", "Eliano", "Elifio", "Eligio", "Elio", "Eliodoro", "Eliseo", "Elita", "Elmo", "Elogio", "Elpidio", "Elvezio", "Elvino", "Emanuele", "Emidio", "Emiliano", "Emilio", "Emmerico", "Empirio", "Endrigo", "Enea", "Enecone", "Ennio", "Enrico", "Enzo", "Eraclide", "Eraldo", "Erardo", "Erasmo", "Erberto", "Ercolano", "Ercole", "Erenia", "Eriberto", "Erico", "Ermanno", "Ermenegildo", "Ermes", "Ermete", "Ermilo", "Erminio", "Ernesto", "Eros", "Esuperio", "Eterie", "Ettore", "Euclide", "Eufebio", "Eufemio", "Eufronio", "Eugenio", "Eusebio", "Euseo", "Eustorgio", "Eustosio", "Eutalio", "Evaldo", "Evandro", "Evaristo", "Evasio", "Everardo", "Evidio", "Evodio", "Evremondo", "Ezechiele", "Ezio", "Fabiano", "Fabio", "Fabrizio", "Famiano", "Fausto", "Fazio", "Fedele", "Federico", "Fedro", "Felice", "Feliciano", "Ferdinando", "Fermiano", "Fermo", "Fernando", "Ferruccio", "Festo", "Fidenziano", "Fidenzio", "Filiberto", "Filippo", "Filomeno", "Fiorenziano", "Fiorenzo", "Flaviano", "Flavio", "Fleano", "Floriano", "Folco", "Fortunato", "Fosco", "Francesco", "Franco", "Frido", "Frontiniano", "Fulberto", "Fulgenzio", "Fulvio", "Furio", "Furseo", "Fuscolo", "Gabino", "Gabriele", "Gaetano", "Gaglioffo", "Gaio", "Galdino", "Galeazzo", "Galileo", "Gallicano", "Gandolfo", "Garimberto", "Gaspare", "Gastone", "Gaudenzio", "Gaudino", "Gautiero", "Gavino", "Gedeone", "Geminiano", "Generoso", "Genesio", "Gennaro", "Gentile", "Genziano", "Gerardo", "Gerasimo", "Geremia", "Gerino", "Germano", "Gerolamo", "Geronimo", "Geronzio", "Gervasio", "Gesualdo", "Gherardo", "Giacinto", "Giacobbe", "Giacomo", "Giadero", "Giambattista", "Gianbattista", "Giancarlo", "Giandomenico", "Gianfranco", "Gianluca", "Gianluigi", "Gianmarco", "Gianmaria", "Gianmario", "Gianni", "Gianpaolo", "Gianpiero", "Gianpietro", "Gianuario", "Giasone", "Gilberto", "Gildo", "Gillo", "Gineto", "Gino", "Gioacchino", "Giobbe", "Gioberto", "Giocondo", "Gioele", "Giona", "Gionata", "Giordano", "Giorgio", "Giosuele", "Giosu\xC3\xA8", "Giotto", "Giovanni", "Giove", "Gioventino", "Giovenzio", "Girardo", "Girolamo", "Giuda", "Giuliano", "Giulio", "Giuseppe", "Giustiniano", "Giusto", "Glauco", "Goffredo", "Golia", "Gomberto", "Gondulfo", "Gonerio", "Gonzaga", "Gordiano", "Gosto", "Gottardo", "Graciliano", "Grato", "Graziano", "Gregorio", "Grimaldo", "Gualberto", "Gualtiero", "Guelfo", "Guerrino", "Guglielmo", "Guiberto", "Guido", "Guiscardo", "Gumesindo", "Gustavo", "Iacopo", "Iacopone", "Icaro", "Icilio", "Ido", "Iginio", "Igino", "Ignazio", "Igor", "Ilario", "Ildebrando", "Ildefonso", "Illidio", "Illuminato", "Immacolato", "Indro", "Innocente", "Innocenzo", "Ippocrate", "Ippolito", "Ireneo", "Isacco", "Isaia", "Ischirione", "Isidoro", "Ismaele", "Italo", "Ivan", "Ivano", "Ivanoe", "Ivo", "Ivone", "Ladislao", "Lamberto", "Lancilotto", "Landolfo", "Lanfranco", "Lapo", "Laurentino", "Lauriano", "Lautone", "Lavinio", "Lazzaro", "Leandro", "Leo", "Leonardo", "Leone", "Leonida", "Leonio", "Leonzio", "Leopardo", "Leopoldo", "Letterio", "Liberato", "Liberatore", "Liberio", "Libero", "Liberto", "Liborio", "Lidio", "Lieto", "Lino", "Lisandro", "Livino", "Livio", "Lodovico", "Loreno", "Lorenzo", "Loris", "Luca", "Luciano", "Lucio", "Ludano", "Ludovico", "Luigi", "Macario", "Maccabeo", "Maffeo", "Maggiorino", "Magno", "Maiorico", "Malco", "Mamante", "Mancio", "Manetto", "Manfredo", "Manilio", "Manlio", "Mansueto", "Manuele", "Marcello", "Marciano", "Marco", "Mariano", "Marino", "Mario", "Marolo", "Martino", "Marzio", "Massimiliano", "Massimo", "Matroniano", "Matteo", "Mattia", "Maurilio", "Maurizio", "Mauro", "Medardo", "Medoro", "Melanio", "Melchiade", "Melchiorre", "Melezio", "Menardo", "Menelao", "Meneo", "Mennone", "Mercurio", "Metello", "Metrofane", "Michelangelo", "Michele", "Milo", "Minervino", "Mirco", "Mirko", "Mirocleto", "Misaele", "Modesto", "Monaldo", "Monitore", "Moreno", "Mos\xC3\xA8", "Muziano", "Namazio", "Napoleone", "Narciso", "Narseo", "Narsete", "Natale", "Nazario", "Nazzareno", "Nazzaro", "Neopolo", "Neoterio", "Nereo", "Neri", "Nestore", "Nicarete", "Nicea", "Niceforo", "Niceto", "Nicezio", "Nico", "Nicodemo", "Nicola", "Nicol\xC3\xB2", "Niniano", "Nino", "Norberto", "Nostriano", "No\xC3\xA8", "Nunzio", "Oddone", "Oderico", "Odidone", "Odorico", "Olimpio", "Olindo", "Oliviero", "Omar", "Omero", "Onesto", "Onofrio", "Onorino", "Onorio", "Orazio", "Orenzio", "Oreste", "Orfeo", "Orio", "Orlando", "Oronzo", "Orsino", "Orso", "Ortensio", "Oscar", "Osmondo", "Osvaldo", "Otello", "Ottaviano", "Ottavio", "Ottone", "Ovidio", "Paciano", "Pacifico", "Pacomio", "Palatino", "Palladio", "Pammachio", "Pancario", "Pancrazio", "Panfilo", "Pantaleo", "Pantaleone", "Paolo", "Pardo", "Paride", "Parmenio", "Pasquale", "Paterniano", "Patrizio", "Patroclo", "Pauside", "Peleo", "Pellegrino", "Pericle", "Perseo", "Petronio", "Pierangelo", "Piergiorgio", "Pierluigi", "Piermarco", "Piero", "Piersilvio", "Pietro", "Pio", "Pippo", "Placido", "Platone", "Plinio", "Plutarco", "Polidoro", "Polifemo", "Pollione", "Pompeo", "Pomponio", "Ponziano", "Ponzio", "Porfirio", "Porziano", "Postumio", "Prassede", "Priamo", "Primo", "Prisco", "Privato", "Procopio", "Prospero", "Protasio", "Proteo", "Prudenzio", "Publio", "Pupolo", "Pusicio", "Quarto", "Quasimodo", "Querano", "Quintiliano", "Quintilio", "Quintino", "Quinziano", "Quinzio", "Quirino", "Radolfo", "Raffaele", "Raide", "Raimondo", "Rainaldo", "Ramiro", "Raniero", "Ranolfo", "Reginaldo", "Regolo", "Remigio", "Remo", "Remondo", "Renato", "Renzo", "Respicio", "Ricario", "Riccardo", "Richelmo", "Rinaldo", "Rino", "Robaldo", "Roberto", "Rocco", "Rodiano", "Rodolfo", "Rodrigo", "Rolando", "Rolfo", "Romano", "Romeo", "Romero", "Romoaldo", "Romolo", "Romualdo", "Rosario", "Rubiano", "Rufino", "Rufo", "Ruggero", "Ruperto", "Rutilo", "Sabato", "Sabazio", "Sabele", "Sabino", "Saffiro", "Saffo", "Saladino", "Salomone", "Salom\xC3\xA8", "Salustio", "Salvatore", "Salvo", "Samuele", "Sandro", "Sansone", "Sante", "Santo", "Sapiente", "Sarbello", "Saturniano", "Saturnino", "Saul", "Saverio", "Savino", "Sebastiano", "Secondiano", "Secondo", "Semiramide", "Semplicio", "Sempronio", "Senesio", "Senofonte", "Serafino", "Serapione", "Sergio", "Servidio", "Serviliano", "Sesto", "Settimio", "Settimo", "Severiano", "Severino", "Severo", "Sico", "Sicuro", "Sidonio", "Sigfrido", "Sigismondo", "Silvano", "Silverio", "Silvestro", "Silvio", "Simeone", "Simone", "Sinesio", "Sinfronio", "Sireno", "Siriano", "Siricio", "Siro", "Sisto", "Soccorso", "Socrate", "Solocone", "Sostene", "Sosteneo", "Sostrato", "Spano", "Spartaco", "Speranzio", "Stanislao", "Stefano", "Stiliano", "Stiriaco", "Surano", "Sviturno", "Taddeo", "Taide", "Tammaro", "Tancredi", "Tarcisio", "Tarso", "Taziano", "Tazio", "Telchide", "Telemaco", "Temistocle", "Teobaldo", "Teodoro", "Teodosio", "Teodoto", "Teogene", "Terenzio", "Terzo", "Tesauro", "Tesifonte", "Tibaldo", "Tiberio", "Tiburzio", "Ticone", "Timoteo", "Tirone", "Tito", "Tiziano", "Tizio", "Tobia", "Tolomeo", "Tommaso", "Torquato", "Tosco", "Tranquillo", "Tristano", "Tulliano", "Tullio", "Turi", "Turibio", "Tussio", "Ubaldo", "Ubertino", "Uberto", "Ugo", "Ugolino", "Uguccione", "Ulberto", "Ulderico", "Ulfo", "Ulisse", "Ulpiano", "Ulrico", "Ulstano", "Ultimo", "Umberto", "Umile", "Uranio", "Urbano", "Urdino", "Uriele", "Ursicio", "Ursino", "Ursmaro", "Valente", "Valentino", "Valeriano", "Valerico", "Valerio", "Valfredo", "Valfrido", "Valtena", "Valter", "Varo", "Vasco", "Vedasto", "Velio", "Venanzio", "Venceslao", "Venerando", "Venerio", "Ventura", "Venustiano", "Venusto", "Verano", "Verecondo", "Verenzio", "Verulo", "Vespasiano", "Vezio", "Vidiano", "Vidone", "Vilfredo", "Viliberto", "Vincenzo", "Vindonio", "Vinebaldo", "Vinfrido", "Vinicio", "Virgilio", "Virginio", "Virone", "Viscardo", "Vitale", "Vitalico", "Vito", "Vittore", "Vittoriano", "Vittorio", "Vivaldo", "Viviano", "Vladimiro", "Vodingo", "Volfango", "Vulmaro", "Vulpiano", "Walter", "Zabedeo", "Zaccaria", "Zaccheo", "Zanobi", "Zefiro", "Zena", "Zenaide", "Zenebio", "Zeno", "Zenobio", "Zenone", "Zetico", "Zoilo", "Zosimo"]);
		$pkg.Cities = new sliceType$4([new City.ptr(1, "Torino"), new City.ptr(2, "Vercelli-Biella"), new City.ptr(3, "Novara-Verbania"), new City.ptr(4, "Cuneo"), new City.ptr(5, "Asti"), new City.ptr(6, "Alessandria"), new City.ptr(7, "Aosta"), new City.ptr(8, "Imperia"), new City.ptr(9, "Savona"), new City.ptr(10, "Genova"), new City.ptr(11, "La Spezia"), new City.ptr(12, "Varese"), new City.ptr(13, "Como-Lecco"), new City.ptr(14, "Sondrio"), new City.ptr(15, "Milano-Lodi"), new City.ptr(16, "Bergamo"), new City.ptr(17, "Brescia"), new City.ptr(18, "Pavia"), new City.ptr(19, "Cremona"), new City.ptr(20, "Mantova"), new City.ptr(21, "Bolzano"), new City.ptr(22, "Trento"), new City.ptr(23, "Verona"), new City.ptr(24, "Vicenza"), new City.ptr(25, "Belluno"), new City.ptr(26, "Treviso"), new City.ptr(27, "Venezia"), new City.ptr(28, "Padova"), new City.ptr(29, "Rovigo"), new City.ptr(30, "Udine"), new City.ptr(31, "Gorizia"), new City.ptr(32, "Trieste"), new City.ptr(33, "Piacenza"), new City.ptr(34, "Parma"), new City.ptr(35, "Reggio Emilia"), new City.ptr(36, "Modena"), new City.ptr(37, "Bologna"), new City.ptr(38, "Ferrara"), new City.ptr(39, "Ravenna"), new City.ptr(40, "Forl\xC3\xAC-Rimini"), new City.ptr(41, "Pesaro"), new City.ptr(42, "Ancona"), new City.ptr(43, "Macerata"), new City.ptr(44, "Ascoli Piceno"), new City.ptr(45, "Massa Carrara"), new City.ptr(46, "Lucca"), new City.ptr(47, "Pistoia"), new City.ptr(48, "Firenze"), new City.ptr(49, "Livorno"), new City.ptr(50, "Pisa"), new City.ptr(51, "Arezzo"), new City.ptr(52, "Siena"), new City.ptr(53, "Grosseto"), new City.ptr(54, "Perugia"), new City.ptr(55, "Terni"), new City.ptr(56, "Viterbo"), new City.ptr(57, "Rieti"), new City.ptr(58, "Roma"), new City.ptr(59, "Latina"), new City.ptr(60, "Frosinone"), new City.ptr(61, "Caserta"), new City.ptr(62, "Benevento"), new City.ptr(63, "Napoli"), new City.ptr(64, "Avellino"), new City.ptr(65, "Salerno"), new City.ptr(66, "L'Aquila"), new City.ptr(67, "Teramo"), new City.ptr(68, "Pescara"), new City.ptr(69, "Chieti"), new City.ptr(70, "Campobasso"), new City.ptr(71, "Foggia"), new City.ptr(72, "Bari"), new City.ptr(73, "Taranto"), new City.ptr(74, "Brindisi"), new City.ptr(75, "Lecce"), new City.ptr(76, "Potenza"), new City.ptr(77, "Matera"), new City.ptr(78, "Cosenza"), new City.ptr(79, "Catanzaro-Crotone-ViboValentia"), new City.ptr(80, "Reggio Calabria"), new City.ptr(81, "Trapani"), new City.ptr(82, "Palermo"), new City.ptr(83, "Messina"), new City.ptr(84, "Agrigento"), new City.ptr(85, "Caltanissetta"), new City.ptr(86, "Enna"), new City.ptr(87, "Catania"), new City.ptr(88, "Ragusa"), new City.ptr(89, "Siracusa"), new City.ptr(90, "Sassari"), new City.ptr(91, "Nuoro"), new City.ptr(92, "Cagliari"), new City.ptr(93, "Pordenone"), new City.ptr(94, "Isernia"), new City.ptr(95, "Oristano"), new City.ptr(96, "Milano 2 (Monza)"), new City.ptr(97, "Firenze 2 (Prato)"), new City.ptr(98, "Brescia 2"), new City.ptr(99, "Genova 2"), new City.ptr(100, "Roma 2"), new City.ptr(120, "Bologna 2"), new City.ptr(121, "Napoli 2")]);
		$pkg.ItalianSurnames = new sliceType$2(["Abatangelo", "Abatantuono", "Abate", "Abatecola", "Abategiovanni", "Abati", "Abaticola", "Abb\xC3\xA0", "Abbadelli", "Abbascia", "Abbatangelo", "Abbatantuono", "Abbate", "Abbatecola", "Abbatelli", "Abbaticola", "Abbiati", "Abbiento", "Abbondanzieri", "Abbondi", "Abbondio", "Abbruscato", "Abelli", "Abello", "Abis", "Abram", "Abrami", "Abramo", "Abrioni", "Abruscato", "Abutzu", "Acardi", "Acca", "Accardi", "Accardo", "Accareddu", "Accettola", "Acciai", "Acciaio", "Acciaioli", "Acciari", "Acciaro", "Acciarri", "Accorsi", "Accorso", "Accursi", "Accursio", "Accurso", "Acerbi", "Acerbis", "Acerbo", "Acerboni", "Acerra", "Acerrano", "Acocella", "Acone", "Aconi", "Acqua", "Acquafredda", "Acquarone", "Acquaroni", "Acquati", "Acquaviva", "Acquistapace", "Acquisti", "Acquisto", "Acri", "Actis", "Adami", "Adamic", "Adamo", "Adamoli", "Adda", "Addari", "Addario", "Adessi", "Adesso", "Adimari", "Adinolfi", "Affini", "Africani", "Africano", "Agani", "Agassi", "Agassini", "Agasso", "Agate", "Agati", "Agazzi", "Agazzini", "Agazzino", "Agazzone", "Agazzoni", "Aggi", "Aggio", "Agirmo", "Agli", "Aglieri", "Aglietti", "Aglio", "Agnelli", "Agnello", "Agnelluti", "Agnellutti", "Agnusdei", "Agonigi", "Agosta", "Agosti", "Agostinelli", "Agostinello", "Agostini", "Agostinielli", "Agostinis", "Agosto", "Agrati", "Agresta", "Agreste", "Agresti", "Agrioli", "Agrippa", "Aguniano", "Agus", "Agusti", "Agusto", "Aguzzi", "Aiala", "Aiana", "Aicardi", "Aicardo", "Aielli", "Aiello", "Aimo", "Aimone", "Aimoni", "Aini", "Aiolfi", "Airaldi", "Air\xC3\xB2", "Airola", "Airoldi", "Airoldo", "Aita", "Aiuti", "Aiuto", "Ajala", "Ajelli", "Ajello", "Ajmo", "Ajmone", "Ajolfi", "Ajuti", "Alagona", "Alaimo", "Alamanni", "Alamanno", "Alampi", "Alampo", "Alarico", "Alasia", "Alasio", "Albanese", "Albanesi", "Albani", "Albanis", "Albano", "Alberani", "Alberghini", "Alberi", "Alberici", "Alberighi", "Albero", "Alberoni", "Alberta", "Albertario", "Albertazzi", "Alberti", "Albertini", "Albertis", "Alberto", "Albertosi", "Albini", "Albino", "Albinoni", "Albis", "Alboini", "Alboino", "Alboni", "Albonici", "Albonico", "Albricci", "Albrici", "Albrisio", "Albrizi", "Albrizio", "Albrizzi", "Alcaini", "Alcaino", "Aldebrandi", "Alderici", "Alderighi", "Alderisi", "Alderisio", "Aldinucci", "Aldobrando", "Aldovrando", "Alduina", "Alduini", "Alduino", "Alemagna", "Alemani", "Alemanni", "Alemanno", "Alemano", "Aleppi", "Aleppo", "Alepri", "Alesci", "Alescio", "Alesi", "Alesina", "Alesini", "Alesio", "Alessandrella", "Alessandrelli", "Alessandrello", "Alessandri", "Alessandria", "Alessandrin", "Alessandrina", "Alessandrini", "Alessandrino", "Alessandro", "Alessandroni", "Alessandrucci", "Alessi", "Alessio", "Alesso", "Alfani", "Alfano", "Alfero", "Alfiere", "Alfieri", "Alfini", "Alfino", "Alfonsetti", "Alfonsi", "Alfonso", "Alfonzetti", "Alfonzi", "Alghisi", "Alghisio", "Algisi", "Al\xC3\xAC", "Aliberti", "Aliberto", "Alieri", "Alighieri", "Alighiero", "Alimena", "Alimonda", "Alinari", "Alinei", "Alineri", "Alioti", "Alioto", "Aliotta", "Aliprandi", "Alisio", "Allamani", "Allamano", "Allasia", "Allasio", "Allegra", "Allegranza", "Allegretti", "Allegri", "Allegrini", "Allegro", "Allevi", "Alliata", "Alliati", "Allieri", "Alliero", "Allievi", "Allighi", "Allighieri", "Almanno", "Al\xC3\xB2", "Aloe", "Aloi", "Aloia", "Aloise", "Aloisi", "Aloisio", "Aloja", "Alpini", "Alpino", "Alster", "Altamura", "Altana", "Altavilla", "Altebrandi", "Altebrando", "Altiner", "Altinier", "Altobelli", "Altobello", "Altobrandi", "Altoviti", "Al\xC3\xB9", "Alunni", "Alunno", "Alvise", "Alvisio", "Amadei", "Amadeo", "Amadini", "Amadore", "Amadori", "Amalberti", "Amalberto", "Amalfi", "Amalfitani", "Amalfitano", "Amantea", "Amantia", "Amati", "Amato", "Amatore", "Amatori", "Amatruda", "Amatrude", "Amatrudi", "Amatrudo", "Ambrogetti", "Ambroggio", "Ambrogi", "Ambrogio", "Ambrosetti", "Ambrosi", "Ambrosin", "Ambrosino", "Ambrosio", "Amedali", "Amedei", "Ameglio", "Ameli", "Amelio", "Amella", "Amelli", "Amellio", "Amello", "Amendola", "Amendolea", "Amendolia", "Ameri", "Amerini", "Amerio", "Amici", "Amico", "Amiranda", "Amistadi", "Ammazzalorso", "Amodeo", "Amodio", "Amone", "Amoni", "Amoretti", "Amoretto", "Amorini", "Amorino", "Amorosi", "Amoroso", "Amorusi", "Amoruso", "Ampola", "Anastasi", "Anastasia", "Anastasio", "Ancarani", "Andideri", "Andidero", "Andolfi", "Andolfo", "Andolina", "Andrade", "Andrea", "Andreani", "Andreano", "Andreasi", "Andreassi", "Andreazza", "Andreazzi", "Andreazzini", "Andreazzo", "Andreetta", "Andreetti", "Andrei", "Andreis", "Andrenacci", "Andreoli", "Andreotti", "Andretti", "Andrusiani", "Anedda", "Anelli", "Anello", "Anesin", "Anesini", "Anfora", "Anforti", "Anfossi", "Anfosso", "Angari", "Angarone", "Angaroni", "Angela", "Angelelli", "Angeleri", "Angeletti", "Angeli", "Angelilli", "Angelillis", "Angelillo", "Angelini", "Angelino", "Angelo", "Angeloni", "Angelotti", "Angelucci", "Angioli", "Angiolini", "Anglesio", "Angonova", "Anicito", "Aniello", "Annibaldi", "Annibale", "Annibali", "Anniballo", "Annis", "Annone", "Annoni", "Annovazzi", "Annunzi", "Annunziata", "Annunziato", "Annunzio", "Ansaldi", "Ansaldo", "Ansalone", "Ansaloni", "Anselmi", "Anselmo", "Ansevini", "Ansione", "Ansolini", "Ansovini", "Ansuinelli", "Ansuini", "Antacido", "Antenucci", "Antimi", "Antimo", "Antina", "Antini", "Antino", "Antinori", "Antioco", "Antoci", "Antola", "Antolini", "Antolino", "Antona", "Antonaci", "Antonelli", "Antonello", "Antoni", "Antoniazzi", "Antoniazzo", "Antonicelli", "Antonicello", "Antoniel", "Antonina", "Antonini", "Antonino", "Antonio", "Antoniol", "Antonioli", "Antoniolo", "Antonione", "Antonioni", "Antoniotti", "Antoniotto", "Antoniozzi", "Antonucci", "Antuzzi", "Anzalone", "Anzaloni", "Anzelmi", "Anzelmo", "Anzil", "Anzile", "Anzilutti", "Anzini", "Anzivino", "Anzolin", "Anzolini", "Anzovini", "Anzovino", "Anzuinelli", "Anzuini", "Anzuino", "Apice", "Apicella", "Apolloni", "Apollonio", "Aporti", "Apostoli", "Apostolo", "Appello", "Appiani", "Appiano", "Appierto", "Appino", "Appolloni", "Aquarone", "Aquila", "Aquilante", "Aquilanti", "Aquino", "Aradori", "Araldi", "Araldo", "Arbizzani", "Arbizzi", "Arbizzoni", "Arbore", "Arboreto", "Arbucci", "Arcaini", "Arcangeli", "Arcangelo", "Arcari", "Arcaro", "Arcelli", "Arcellone", "Arcelloni", "Archetti", "Archi", "Archieri", "Archinti", "Arcidiaco", "Arcidiacono", "Arconati", "Arcudi", "Arcuri", "Ardemagni", "Ardemani", "Ardemanni", "Ardenghi", "Ardengo", "Ardesi", "Ardigo\xE2\x80\x99", "Ardini", "Ardino", "Ardissino", "Ardizio", "Ardizzi", "Ardizzon", "Ardizzone", "Ardizzoni", "Ardovini", "Ardovino", "Arduini", "Arduino", "Arena", "Arenella", "Areni", "Arenzi", "Aresti", "Arezzini", "Argazzi", "Argentero", "Argenti", "Argentieri", "Argentiero", "Argento", "Argeri", "Argerio", "Argiolas", "Argir\xC3\xB2", "Argurio", "Ariani", "Ariatti", "Arici", "Arico", "Aric\xC3\xB2", "Arienti", "Arioldi", "Arioldo", "Arioli", "Ariolo", "Ariotti", "Arisci", "Arixi", "Arlati", "Arlotta", "Arlotti", "Arlotto", "Armagni", "Armani", "Armanini", "Armanni", "Armanno", "Armano", "Armelli", "Armellin", "Armellini", "Armellon", "Armelloni", "Armeni", "Arnaldi", "Arnaldo", "Arnao", "Arnau", "Arnaudi", "Arnaudo", "Arnosti", "Aroffu", "Aromando", "Aronica", "Arosio", "Arpini", "Arpino", "Arrighetta", "Arrighetti", "Arrighi", "Arrigone", "Arrigoni", "Artico", "Artino", "Artisti", "Arus", "Arzaghi", "Arzani", "Arzente", "Arzenti", "Arzu", "Asaro", "Ascani", "Ascanio", "Ascari", "Ascente", "Ascenti", "Ascheri", "Ascherio", "Aschero", "Aschieri", "Aschiero", "Ascioti", "Asero", "Asfinio", "Asinari", "Asinaro", "Asnaghi", "Asnago", "Asnicar", "Aspesi", "Asquini", "Assi", "Asso", "Assogna", "Aste", "Asti", "Astillero", "Astolfi", "Astolfo", "Astore", "Astori", "Astorini", "Astorino", "Atanasi", "Atanasio", "Ateniese", "Ateniesi", "Attaguile", "Attanasi", "Attanasio", "Attolini", "Attolino", "Atzei", "Atzeni", "Atzenis", "Atzori", "Aucella", "Aucelli", "Aucello", "Audissino", "Auferio", "Augelli", "Augello", "Auletta", "Auria", "Auricchio", "Aurora", "Austoni", "Auteri", "Auterio", "Autero", "Autieri", "Autiero", "Autuori", "Avaldi", "Avalli", "Avallone", "Avancini", "Avantaggiato", "Avanti", "Avanzati", "Avanzi", "Avanzini", "Avanzino", "Avanzo", "Avella", "Avellone", "Aveni", "Avenia", "Aventino", "Aversa", "Aversana", "Aversano", "Avesani", "Avesano", "Avigliano", "Avogadri", "Avogadro", "Avogari", "Avogaro", "Avola", "Aymerich", "Azara", "Azeglio", "Azzali", "Azzalin", "Azzalini", "Azzara", "Azzari", "Azzario", "Azzaro", "Azzi", "Azzini", "Azzino", "Azzo", "Azzopardi", "Babare", "Babbaro", "Babusci", "Babuscio", "Baccarani", "Baccari", "Baccaro", "Bacceliere", "Baccelieri", "Bacci", "Baccigalupi", "Baccigaluppi", "Baccini", "Baccino", "Baceliere", "Bacelieri", "Bacigalupi", "Bacigalupo", "Bacigaluppi", "Bacigaluppo", "Badalamenti", "Badalati", "Badalato", "Badalucchi", "Badalucco", "Badanai", "Badessa", "Badessi", "Badesso", "Badia", "Badiale", "Badiali", "Badolati", "Badolato", "Baduena", "Baffo", "Bagaglia", "Bagardi", "Bagat", "Bagatini", "Bagato", "Bagatto", "Baggi", "Baggini", "Baggio", "Bagiacchi", "Bagiacci", "Bagini", "Bagli", "Baglietti", "Baglini", "Baglio", "Baglione", "Baglioni", "Bagnaschi", "Bagnasco", "Bagnatica", "Bagneschi", "Bagni", "Bagno", "Bagnoli", "Bai", "Baiamonte", "Baiamonti", "Baiardi", "Baiardo", "Baio", "Baiocchi", "Baiocchini", "Baiocchino", "Baiocco", "Bait", "Bajamonte", "Bajardi", "Bajardo", "Bajetta", "Bajetti", "Bajo", "Bajocchi", "Bajocco", "Bajt", "Balanzino", "Balbi", "Balbini", "Balbo", "Balboni", "Baldan", "Baldani", "Baldas", "Baldassano", "Baldassarre", "Baldassarri", "Baldazzi", "Baldelli", "Baldesari", "Baldeschi", "Baldessare", "Baldessari", "Baldessarre", "Baldessarri", "Baldi", "Baldin", "Baldini", "Baldino", "Baldinu", "Baldinucci", "Baldiraghi", "Baldisser", "Baldisseri", "Baldissero", "Baldisserotto", "Baldo", "Baldoli", "Baldolini", "Baldone", "Baldoni", "Baldrighi", "Balducchi", "Balducci", "Balduccio", "Balestra", "Balestri", "Balestrieri", "Balestrini", "Balestrino", "Balestro", "Balistreri", "Balivo", "Balla", "Ballabio", "Balladore", "Balladori", "Ballarin", "Ballarini", "Ballarino", "Ballatore", "Ballatori", "Ballerini", "Ballerino", "Ballotti", "Balocco", "Balossi", "Balotti", "Balsamello", "Balsamini", "Balsamo", "Balsari", "Baltolu", "Balzaretti", "Balzarini", "Balzarotti", "Bamberghi", "Bampa", "Bampi", "Banchio", "Banderali", "Bandi", "Bandini", "Bandino", "Bandirali", "Banducci", "Banella", "Banelli", "Banello", "Banfi", "Baracca", "Baracchi", "Baracco", "Baragatti", "Baral", "Baraldi", "Baraldo", "Barale", "Baratta", "Baratti", "Barattieri", "Baratto", "Barazzutti", "Barba", "Barbagalli", "Barbagallo", "Barbagli", "Barbanera", "Barbareschi", "Barbaresco", "Barbari", "Barbarini", "Barbarino", "Barbaro", "Barbarossa", "Barbato", "Barb\xC3\xA8", "Barbera", "Barberi", "Barberini", "Barberis", "Barbero", "Barbetta", "Barbetti", "Barbi", "Barbierato", "Barbieri", "Barbiero", "Barbin", "Barbini", "Barbino", "Barbisotti", "Barbo", "Barbolini", "Barbon", "Barbone", "Barbonetti", "Barboni", "Barbosa", "Barbosi", "Barboso", "Bardella", "Bardelli", "Bardelloni", "Bardi", "Bardino", "Bardo", "Bardone", "Bardoni", "Barei", "Barel", "Barell", "Barelli", "Barello", "Baresi", "Baretta", "Baretti", "Baretto", "Bargelli", "Bargellini", "Bargiacchi", "Barichello", "Barigozzi", "Barilari", "Barilaro", "Barile", "Barili", "Barilla", "Barillari", "Barillaro", "Barilli", "Barill\xC3\xA0", "Baril\xC3\xA0", "Barison", "Barisonzi", "Barlassina", "Barnaba", "Barnab\xC3\xA8", "Barnabei", "Barnab\xC3\xB2", "Barni", "Baro", "Baroli", "Barolo", "Baron", "Baroncelli", "Baroncini", "Barone", "Baroni", "Baronti", "Barracco", "Barraco", "Barral", "Barreca", "Barrese", "Barresi", "Barri", "Barrichello", "Barruffi", "Barruffo", "Barsotti", "Bartali", "Bartalini", "Bartalotta", "Bartezaghi", "Bartezzaghi", "Bartolazzi", "Bartoletti", "Bartoli", "Bartolini", "Bartolotta", "Bartolotti", "Bartolozzi", "Bartolucci", "Baruffi", "Baruffini", "Baruffino", "Baruffo", "Barzaghi", "Barzi", "Barzizza", "Basana", "Basani", "Bascap\xC3\xA8", "Baschenis", "Baschiazzorre", "Basciano", "Bascio", "Baseggio", "Basez", "Basezzi", "Basile", "Basili", "Basilico", "Basilic\xC3\xB2", "Basilio", "Basilone", "Basini", "Bassan", "Bassani", "Bassanini", "Bassano", "Bassetti", "Bassetto", "Bassi", "Bassich", "Bassini", "Bassino", "Basso", "Bassoli", "Bassolini", "Bassolino", "Bassotti", "Bastanza", "Bastanzio", "Bastia", "Bastiani", "Bastone", "Bastoni", "Batelli", "Battaggia", "Battaglia", "Battaglieri", "Battaglierin", "Battagliero", "Battagliese", "Battaglin", "Battaglini", "Battaglino", "Battaglioni", "Battaia", "Battaini", "Battecca", "Battelli", "Battello", "Battezzati", "Battezzato", "Battiata", "Battiati", "Battiato", "Battini", "Battino", "Battipaglia", "Battista", "Battistella", "Battistelli", "Battisti", "Battistini", "Batto", "Battolu", "Bau", "Ba\xC3\xB9", "Bauda", "Baudi", "Baudini", "Baudino", "Baudo", "Baudone", "Baudoni", "Bavastrello", "Bavastro", "Bavestrello", "Bavila", "Bazza", "Bazzan", "Bazzanella", "Bazzanelli", "Bazzara", "Bazzarin", "Bazzaro", "Bazzo", "Bazzoni", "Bealli", "Bearzi", "Bearzot", "Bebbo", "Becalossi", "Beccalossi", "Beccaria", "Beccarini", "Becchere", "Beccheri", "Becchero", "Becchio", "Becci", "Bechere", "Bechi", "Beco", "Bedin", "Bedini", "Bedino", "Bedoni", "Begarelli", "Beghi", "Belardetti", "Belardi", "Belardinetti", "Belardo", "Belcastro", "Belfiore", "Belfiori", "Belgiovane", "Belgiovine", "Bella", "Bellafronte", "Bellanda", "Bellandi", "Bellando", "Bellani", "Bellaria", "Bellasi", "Bellato", "Bellavite", "Bellaviti", "Belleboni", "Bellebono", "Bellen", "Belleri", "Bellesi", "Belletti", "Belletto", "Belli", "Bellia", "Belliboni", "Bellincioni", "Bellini", "Bellinzoni", "Bellitto", "Bello", "Bellocchio", "Bellodi", "Bellomi", "Bellomo", "Belloni", "Belloti", "Bellotti", "Bellucci", "Belluccio", "Belluomini", "Belluti", "Belluto", "Belluzzi", "Belluzzo", "Belmessieri", "Belmonte", "Belotti", "Belperio", "Beltrama", "Beltrame", "Beltrami", "Beltramini", "Beltramino", "Belvedere", "Benati", "Benato", "Benavoli", "Bencivegna", "Bencivenga", "Bencivenni", "Benedet", "Benedetta", "Benedettelli", "Benedetti", "Benedetto", "Benedusi", "Benelli", "Benetti", "Benevelli", "Benevello", "Beneventi", "Benevento", "Benfatti", "Benfatto", "Benigno", "Benincasa", "Benivento", "Benizi", "Benizzi", "Bennato", "Benni", "Bentivegna", "Bentivegni", "Bentivenga", "Bentivogli", "Bentivoglio", "Benucci", "Benussi", "Benvenuti", "Benvenuto", "Benzi", "Benzo", "Benzon", "Benzone", "Benzoni", "Beo", "Beolchi", "Beozzi", "Beozzo", "Beraldi", "Beraldini", "Beraldo", "Berard", "Berardelli", "Berardi", "Berardini", "Berardino", "Berardo", "Bercellesi", "Beretta", "Bergalla", "Bergalli", "Bergallo", "Bergamaschi", "Bergamasco", "Bergami", "Bergamin", "Bergamini", "Bergamino", "Bergamo", "Bergia", "Bergnach", "Bergnesi", "Bergo", "Bergoli", "Bergolo", "Bergomi", "Bergonzi", "Berini", "Berino", "Berisso", "Berlangeri", "Berlangieri", "Berlingeri", "Berlingero", "Berlinghieri", "Berlingiere", "Berlingieri", "Berlinguer", "Berlusconi", "Bernab\xC3\xA8", "Bernabei", "Bernab\xC3\xB3", "Bernard", "Bernardelli", "Bernardi", "Bernardini", "Bernardino", "Bernardo", "Bernasca", "Bernascone", "Bernasconi", "Bernazzani", "Bernazzi", "Berni", "Bernich", "Bernieri", "Bernini", "Bernizzoni", "Bernocchi", "Bernuzzi", "Bernuzzo", "Berri", "Berro", "Berruti", "Berruto", "Bersan", "Bersani", "Bersano", "Berselli", "Bersellini", "Bersellino", "Bersezio", "Bert", "Bertacchi", "Bertacchini", "Bertagna", "Bertagni", "Bertagnin", "Bertagnini", "Bertagnoli", "Bertagnon", "Bertagnoni", "Bertaina", "Bertanza", "Bertanzetti", "Bertanzi", "Bertarelli", "Bertarini", "Bertatini", "Berte", "Bert\xC3\xA8", "Bertea", "Bertelli", "Berti", "Bertin", "Bertina", "Bertinelli", "Bertinetti", "Bertinetto", "Bertini", "Bertino", "Bertinotti", "Berto", "Bertocchi", "Bertocchini", "Bertocchio", "Bertocco", "Bertola", "Bertolaia", "Bertolazzi", "Bertoldi", "Bertoldo", "Bertoletti", "Bertoli", "Bertolini", "Bertolino", "Bertolli", "Bertollini", "Bertollo", "Bertolo", "Bertolotti", "Bertomoro", "Berton", "Bertona", "Bertoncini", "Bertone", "Bertoni", "Bertossi", "Bertossio", "Bertosso", "Bertotti", "Bertotto", "Bertucci", "Bertuccio", "Bertugli", "Bertuglia", "Bertulli", "Bertullo", "Bertuzzi", "Bertuzzo", "Bert\xC3\xB2s", "Berutti", "Berutto", "Berzi", "Besalduch", "Besana", "Besani", "Bescap\xC3\xA8", "Beschi", "Besco", "Besozzi", "Besseghini", "Besson", "Bessone", "Betta", "Bettazza", "Bettazzi", "Bettazzo", "Bett\xC3\xA8", "Bettega", "Betti", "Bettiga", "Bettin", "Bettinelli", "Bettini", "Bettio", "Bettiol", "Bettiolo", "Bettoni", "Beuzer", "Bevacqua", "Beverina", "Bevilacqua", "Bezzi", "Bezzo", "Bezzola", "Bezzoli", "Bia", "Biadego", "Biadico", "Biadigo", "Biagetti", "Biaggi", "Biaggio", "Biagi", "Biagini", "Biagione", "Biagioni", "Biagiotti", "Biamonte", "Biamonti", "Bianca", "Biancacci", "Biancardi", "Biancarelli", "Biancat", "Bianchedi", "Bianchella", "Bianchessi", "Bianchetta", "Bianchetto", "Bianchi", "Bianchin", "Bianchini", "Bianchino", "Bianco", "Biancotto", "Biancu", "Biancucci", "Biasi", "Biasibetti", "Biasini", "Biasio", "Biasuz", "Biava", "Biavaschi", "Biavati", "Bibb\xC3\xB2", "Bicego", "Bicocchi", "Biella", "Bielli", "Biello", "Biffi", "Bigatti", "Biggiogero", "Biggioggero", "Bigiogero", "Bigioli", "Bigiolli", "Biglia", "Biglino", "Bignami", "Bignamini", "Bignotti", "Bignotto", "Bigolotti", "Bill\xC3\xA9", "Bilotti", "Bilotto", "Bina", "Binasco", "Binda", "Bindi", "Binetti", "Binetto", "Bini", "Bino", "Binotti", "Binotto", "Bionaz", "Bionda", "Biondi", "Biondo", "Biosa", "Biraghi", "Biral", "Birardi", "Birolini", "Birtig", "Bisacco", "Bisante", "Bisanti", "Bisaro", "Biscegli", "Bisceglia", "Bisceglie", "Bisconti", "Bisetti", "Bisi", "Bisiach", "Bisini", "Bisinotto", "Bisio", "Biso", "Bison", "Bissacco", "Bissaco", "Bissacot", "Bissaro", "Bisso", "Bissolo", "Bitetto", "Biti", "Bittarelli", "Bivacqua", "Bixio", "Bizarri", "Bizarro", "Bizozzero", "Bizzarri", "Bizzarro", "Bizzeti", "Bizzetti", "Bizzoca", "Bizzozero", "Bizzozzero", "Blaiotta", "Blasi", "Blasinger", "Blasio", "Blaso", "Bledig", "Bleve", "Bloise", "Bobbiese", "Bobbiesi", "Boca", "Bocaletti", "Bocaletto", "Bocca", "Boccaccio", "Boccadoro", "Boccalari", "Boccaletti", "Boccaletto", "Boccalini", "Boccanegra", "Boccanera", "Boccardi", "Boccardo", "Boccato", "Bocchi", "Bocchiola", "Bocchioli", "Bocciarelli", "Boccotti", "Bochicchio", "Bocola", "Bodini", "Boer", "Boerchi", "Boerchio", "Boeri", "Boerio", "Boero", "Bogani", "Boggi", "Boggioni", "Boglia", "Boglio", "Bogoni", "Boi", "Boiocchi", "Bolatti", "Bolatto", "Boldrin", "Boldrini", "Boletti", "Bolia", "Bolignani", "Bolignano", "Bolis", "Bollati", "Bollina", "Bolmida", "Bologna", "Bolognani", "Bolognese", "Bolognesi", "Bolognini", "Bolzan", "Bolzonaro", "Bolzoni", "Bombardi", "Bombardiere", "Bombardieri", "Bombelli", "Bombini", "Bombonato", "Bon", "Bona", "Bonacchi", "Bonacci", "Bonaccio", "Bonaccorsi", "Bonaccorso", "Bonacina", "Bonacolsi", "Bonacorsi", "Bonacorso", "Bonaddio", "Bonadduce", "Bonadei", "Bonadeo", "Bonadio", "Bonadonna", "Bonaduce", "Bonaita", "Bonaiuti", "Bonaiuto", "Bonajuto", "Bonalda", "Bonaluce", "Bonalume", "Bonalumi", "Bonanni", "Bonanno", "Bonapace", "Bonardi", "Bonarota", "Bonaroti", "Bonarrota", "Bonarroti", "Bonati", "Bonato", "Bonaventura", "Bonaventuri", "Bonavera", "Bonazza", "Bonazzi", "Bonci", "Boncio", "Boncompagni", "Bondanza", "Bondavalli", "Bondi", "Bondioli", "Bonelli", "Boneschi", "Bonetti", "Bonetto", "Bonfadini", "Bonfant", "Bonfante", "Bonfanti", "Bonfantini", "Bonfigli", "Bonfiglio", "Bonfiglioli", "Bonforte", "Bonforti", "Bongioanni", "Bongiorni", "Bongiorno", "Bongiovanni", "Boni", "Bonicelli", "Bonifaci", "Bonifacio", "Bonifazi", "Bonifazio", "Boniforte", "Boniforti", "Bonin", "Bonini", "Bonino", "Boninsegna", "Boniperti", "Bonisoli", "Bonitatibus", "Bonizzi", "Bonizzone", "Bonizzoni", "Bonoli", "Bonolis", "Bonolo", "Bonomi", "Bonomini", "Bonomo", "Bononcini", "Bonora", "Bonsignore", "Bonsignori", "Bontempi", "Bontempo", "Bonvegna", "Bonvicini", "Bonvini", "Bonzi", "Bonzo", "Boragni", "Boragno", "Bordignon", "Bordignoni", "Bordoni", "Borelli", "Borello", "Borghero", "Borghese", "Borghetti", "Borghetto", "Borghezio", "Borghi", "Borghini", "Borgia", "Borgiani", "Boriani", "Borio", "Boriotti", "Borlini", "Bormetti", "Bormida", "Bormolini", "Borotto", "Borracci", "Borraccio", "Borrassa", "Borrasso", "Borrelli", "Borrello", "Borri", "Borriello", "Borriero", "Borromeo", "Borromini", "Borsani", "Borsari", "Borsaro", "Borsellini", "Borsellino", "Borsi", "Borso", "Borsoi", "Borsotti", "Bortini", "Bortolazzi", "Bortoli", "Bortolotti", "Borzelli", "Borzi", "Borz\xC3\xAC", "Borzilli", "Borzillo", "Borzini", "Bosca", "Boscardelli", "Boscardi", "Boscarelli", "Boscarello", "Boscariol", "Boscariolo", "Boschetti", "Boschetto", "Boschi", "Boschini", "Boschiroli", "Bosco", "Boscolo", "Boselli", "Bosello", "Bosetti", "Bosetto", "Bosi", "Bosio", "Bosoni", "Bossetti", "Bossetto", "Bossi", "Bossola", "Bossoletti", "Bossoli", "Bossolo", "Botero", "Botta", "Bott\xC3\xA0", "Bottai", "Bottani", "Bottarin", "Bottarini", "Bottaro", "Bottega", "Bottero", "Botti", "Botticella", "Botticelli", "Bottigli", "Bottiglio", "Bottin", "Bottina", "Bottinelli", "Bottineri", "Bottini", "Bottinneri", "Bottino", "Botto", "Bottonaro", "Bottone", "Bottoni", "Bottura", "Botturi", "Bova", "Bove", "Boveri", "Bovina", "Bovini", "Bovino", "Bovolenta", "Boz", "Bozza", "Bozzi", "Bozzini", "Bozzo", "Bozzoli", "Bozzolo", "Bracaccia", "Bracaglia", "Bracalenti", "Bracchi", "Bracchitta", "Bracci", "Braccio", "Bracco", "Braceschi", "Bracone", "Braconi", "Braga", "Bragaglia", "Bragalini", "Bragato", "Braghieri", "Braguglia", "Braida", "Braj", "Bramati", "Bramato", "Brambati", "Brambilla", "Brancaleone", "Brancalion", "Brancati", "Brancatisano", "Brancato", "Brandelli", "Brandello", "Brandi", "Brandimarte", "Brandini", "Brandino", "Brando", "Brandoardi", "Brandolese", "Brandolesio", "Brandolini", "Brandolisi", "Brandolisio", "Brandovardi", "Branduardi", "Brasca", "Brasi", "Brasola", "Bratta", "Bratti", "Bratto", "Bratus", "Brau", "Bravetti", "Bravi", "Bray", "Brayda", "Brayde", "Breda", "Bregalini", "Bregallini", "Brembati", "Brembi", "Brembilla", "Brenci", "Brencio", "Brendolini", "Brentazzoli", "Brera", "Brero", "Brescia", "Bresciani", "Bresolin", "Bressan", "Bressanelli", "Briano", "Brianta", "Briante", "Brianza", "Brianzoli", "Bricca", "Brigatti", "Brignole", "Brina", "Brindisi", "Brini", "Brino", "Brintazzoli", "Brione", "Brioni", "Brioschi", "Briotti", "Briozzi", "Briozzo", "Brisca", "Briscas", "Briscioli", "Brivio", "Brizio", "Brizzi", "Brizzolara", "Brizzolari", "Brocca", "Brocchetta", "Brocchieri", "Brochetta", "Broda", "Brodi", "Brodo", "Broggi", "Broggian", "Broggin", "Broggini", "Broggio", "Brogi", "Brogin", "Brogini", "Brogio", "Brogioni", "Brogli", "Broglia", "Broglio", "Brognara", "Brogni", "Broi", "Broili", "Broilo", "Broseghini", "Brovedan", "Brugnaro", "Brugnera", "Brugnetti", "Brugnola", "Brugnoli", "Brun", "Bruna", "Brunacci", "Brunati", "Brunato", "Brunatti", "Brunatto", "Brundu", "Brunella", "Brunelli", "Brunello", "Brunetta", "Brunetti", "Brunetto", "Bruni", "Brunini", "Brunino", "Brunitto", "Brunone", "Brunoni", "Brunotti", "Brunozzi", "Brunu", "Brusaschetto", "Brusaschi", "Brusasco", "Brusca", "Bruschetti", "Bruschi", "Bruseghin", "Bruseghini", "Bruson", "Brusone", "Brusoni", "Bruzone", "Bruzzese", "Bruzzi", "Bruzzo", "Bruzzone", "Bua", "Buccetti", "Bucci", "Buccigrossi", "Bucetti", "Buchiniz", "Buda", "Bufalini", "Bufalino", "Buffa", "Buffi", "Buffini", "Buffino", "Buffo", "Bugatti", "Bugatto", "Buglia", "Bugliani", "Bugna", "Bugni", "Bugno", "Bugoni", "Buldreghini", "Buldrighini", "Bulf", "Bulfone", "Bulgarelli", "Bulgarello", "Bulgari", "Bulgarini", "Bulgarino", "Buluggiu", "Bulzi", "Buo", "Buonadonna", "Buonanno", "Buonarota", "Buonaroti", "Buonarrota", "Buonarroti", "Buoncompagni", "Buonfiglio", "Buongiorno", "Buoni", "Buono", "Buonocore", "Buonomini", "Buontempo", "Burana", "Buranelli", "Buranello", "Burani", "Buratti", "Burattini", "Buratto", "Burdo", "Burgazzi", "Burgnich", "Burla", "Buro", "Burzi", "Burzio", "Bus", "Busa", "Busan", "Busana", "Busca", "Buscaglia", "Buscaglione", "Buscaglioni", "Buscema", "Buscemi", "Buschettu", "Busi", "Busiol", "Busn\xC3\xA8", "Buso", "Busone", "Busoni", "Bussemi", "Busso", "Bussola", "Bussoli", "Bussolo", "Bussolotti", "Bussolotto", "Busti", "Busurgi", "Butt\xC3\xA0", "Butti", "Butto", "Buttu", "Buttura", "Butturi", "Buzio", "Buziol", "Buzzi", "Buzzolino", "Buzzone", "Buzzoni", "Cabassi", "Cabella", "Cabello", "Cabizzosu", "Cabona", "Caboni", "Cabras", "Cabrele", "Cabrini", "Cacavale", "Caccamo", "Caccavale", "Caccavella", "Caccavelli", "Caccavello", "Caccaviello", "Caccia", "Caccialanza", "Caccianiga", "Cacciapuoti", "Cacciari", "Cacciatore", "Caccini", "Cacciopini", "Caccioppini", "Cacco", "Caciopini", "Cacioppini", "Cadamagnani", "Cadau", "Caddeo", "Caddeu", "Cadeddu", "Cadelli", "Cadenazzi", "Cadenazzo", "Cadeo", "Cadoni", "Cadore", "Cadori", "Cadorin", "Cadorini", "Cadringher", "Caem", "Caenazzo", "Caffarel", "Caffari", "Caffaro", "Cafieri", "Cafiero", "Cageci", "Cageggi", "Cagegi", "Caggeci", "Caggeggi", "Caggegi", "Caggiano", "Caglia", "Cagliero", "Cagnazzi", "Cagnazzo", "Cagni", "Cagnola", "Cagnoli", "Cagnolo", "Cagnoni", "Cagol", "Caia", "Caiafa", "Caiati", "Caiato", "Caiazzo", "Caicco", "Caico", "Caifano", "Caiffa", "Caim", "Caimi", "Caimmi", "Caiola", "Caioli", "Caiolo", "Caiozzo", "Caira", "Cairo", "Calabrese", "Calabresi", "Calabretta", "Calabretti", "Calabria", "Calabro", "Calabr\xC3\xB2", "Calaciura", "Calafa", "Calaf\xC3\xA0", "Calafiore", "Calamai", "Calamari", "Calamaro", "Calami", "Calamia", "Calamida", "Calamo", "Calandra", "Calandrella", "Calandrelli", "Calandrello", "Calandri", "Calandria", "Calandriello", "Calandrini", "Calandrino", "Calandro", "Calatabiano", "Calatro", "Calatrone", "Calatroni", "Calcagni", "Calcagnini", "Calcagnino", "Calcagno", "Calcaterra", "Calchera", "Calchi", "Caldara", "Caldarola", "Caldato", "Caldera", "Calderara", "Calderari", "Calderaro", "Calderon", "Calderone", "Calderoni", "Caldi", "Caldonazzo", "Calgaro", "Cali", "Cal\xC3\xAC", "Calian", "Caliandro", "Caliani", "Caliano", "Calicchia", "Calicchio", "Caliciuri", "Caliendi", "Caliendo", "Caliendro", "Califani", "Califano", "Caligiuri", "Calignano", "Caliman", "Calimani", "Calimano", "Calini", "Calino", "Calise", "Calisi", "Calizzi", "Callari", "Calledda", "Callegari", "Callegaro", "Calligari", "Calligaro", "Calliman", "Callocchia", "Cal\xC3\xB2", "Calogeri", "Calogero", "Calogiuri", "Calonaci", "Calopresti", "Caltabellotta", "Caltabiano", "Calvanese", "Calvanesi", "Calvanise", "Calvelli", "Calvello", "Calvesi", "Calvi", "Calvise", "Calvosa", "Calzavacca", "Calzetta", "Calzolai", "Calzolaio", "Calzolare", "Calzolari", "Calzolaro", "Cal\xC3\xA0", "Camagna", "Camagni", "Camana", "Camanini", "Camarda", "Camardi", "Camardo", "Camarra", "Cambedda", "Cambi", "Cambi\xC3\xA8", "Cambielli", "Cambieri", "Cambio", "Cambria", "Cambriani", "Camera", "Cameran", "Camerani", "Camerini", "Camerino", "Caminada", "Caminati", "Caminoli", "Camisasca", "Camisoni", "Cammarata", "Cammarota", "Camnasio", "Camogliano", "Camoni", "Camoranesi", "Camossi", "Camosso", "Campagna", "Campagnola", "Campagnoli", "Campagnolo", "Campana", "Campanale", "Campanaro", "Campanella", "Campanelli", "Campanile", "Campanili", "Campanini", "Campati", "Campi", "Campironi", "Campisano", "Campise", "Campisi", "Campitelli", "Campo", "Campolunghi", "Campolungo", "Campomaggiore", "Campomizzi", "Camporese", "Camporesi", "Campus", "Camurani", "Canalaz", "Canale", "Canali", "Canalis", "Cancellieri", "Cancemi", "Cancian", "Canciani", "Candela", "Candelori", "Candeloro", "Candeo", "Candia", "Candiani", "Candiano", "Candore", "Candotti", "Candotto", "Candussi", "Candussio", "Cand\xC3\xACla", "Cane", "Canegalli", "Canegallo", "Canepa", "Caneva", "Canevari", "Canevisio", "Cangemi", "Cangi", "Cangini", "Cangio", "Cani", "Caniati", "Caniato", "Canizzaro", "Cannas", "Cannavaro", "Cannav\xC3\xB2", "Cannizzaro", "Canonica", "Canonici", "Canonico", "Canosa", "Canova", "Cantacessi", "Cantafio", "Cantalena", "Cantalupi", "Cantalupo", "Cantarella", "Cantarelli", "Cantarini", "Cantarino", "Cantilena", "Cantina", "Cantini", "Canton", "Cantoni", "Cant\xC3\xB9", "Canu", "Canzanella", "Canzi", "Canzian", "Canziani", "Canzonieri", "Capaci", "Caparrotti", "Capasso", "Capecci", "Capece", "Capecelatro", "Capelletti", "Capelli", "Capellini", "Capello", "Caperdoni", "Capezzera", "Capilungo", "Capitani", "Capitanio", "Capizzi", "Capo", "Capoani", "Capobianco", "Capocci", "Capoccia", "Capodanno", "Capoferri", "Capolungo", "Capone", "Caponio", "Caponnetto", "Caporale", "Caporali", "Caporaloni", "Capotorto", "Capotosti", "Capovilla", "Capozzoli", "Capozzolo", "Cappella", "Cappelletti", "Cappelletto", "Cappelli", "Cappellini", "Cappellino", "Cappello", "Capponi", "Cappuccini", "Cappuzzo", "Capra", "Caprara", "Caprari", "Capraro", "Capriotti", "Capuana", "Capuani", "Capuano", "Capuozzo", "Capurro", "Caputi", "Caputo", "Capuzzo", "Capuzzoni", "Carabelli", "Carabot", "Carabott", "Caraccioli", "Caracciolo", "Caracciuolo", "Caracoi", "Caracristi", "Caradonna", "Carafa", "Caraffa", "Carafoli", "Carai", "Caramaschi", "Caramelli", "Caramello", "Caramiello", "Carani", "Carannante", "Carano", "Carapelli", "Carassai", "Caratti", "Caratto", "Carau", "Caravati", "Carbi", "Carbo", "Carbone", "Carbonella", "Carbonelli", "Carbonello", "Carbonetti", "Carbonetto", "Carboni", "Carbonin", "Carbonini", "Carcano", "Carciofali", "Carciofalo", "Carciofoli", "Carciofolo", "Cardamone", "Cardamoni", "Cardarella", "Cardarelli", "Cardarello", "Cardea", "Cardia", "Cardillo", "Cardin", "Cardinale", "Cardinali", "Cardini", "Cardino", "Cardona", "Cardone", "Cardoni", "Carducci", "Carella", "Carelli", "Carello", "Caremoli", "Carenzi", "Carere", "Careri", "Caresta", "Caretta", "Caretti", "Caretto", "Carfagna", "Carfagni", "Carfi", "Carf\xC3\xAC", "Carfora", "Cargnel", "Cargnelli", "Cargnello", "Cargneluti", "Cargnelutti", "Caria", "Cariddi", "Caridi", "Carimati", "Carina", "Carinelli", "Carini", "Carino", "Carioni", "Carle", "Carlentini", "Carlessi", "Carlesso", "Carletto", "Carli", "Carlin", "Carlini", "Carlino", "Carloni", "Carlucci", "Carmela", "Carmeli", "Carmelo", "Carminati", "Carmine", "Carnabuci", "Carnelli", "Carnello", "Carnesecca", "Carnesecchi", "Carnevale", "Carnevali", "Carniel", "Carnielli", "Carniello", "Carnovale", "Carnovali", "Caro", "Carobbi", "Carobbio", "Carolei", "Caroleo", "Carolfi", "Caronia", "Caroselli", "Carosello", "Carosi", "Carosio", "Caroso", "Carosone", "Carotenuto", "Carpi", "Carpita", "Carpitella", "Carra", "Carr\xC3\xA0", "Carradori", "Carrai", "Carrano", "Carrara", "Carrarini", "Carraro", "Carrau", "Carrera", "Carriero", "Carrobbio", "Carrogu", "Carrozzo", "Carruba", "Carrubba", "Carta", "Carti", "Carucci", "Caruccio", "Carugati", "Caruggi", "Carusi", "Carusillo", "Carusio", "Caruso", "Carusone", "Casa", "Casabianca", "Casablanca", "Casabona", "Casaccia", "Casaccio", "Casadei", "Casadio", "Casagranda", "Casagrande", "Casale", "Casalecchi", "Casalegno", "Casali", "Casalini", "Casaloldi", "Casaloldo", "Casamassa", "Casamassima", "Casano", "Casanova", "Casari", "Casarini", "Casarotti", "Casarotto", "Casasola", "Casasole", "Casasoli", "Casati", "Casavola", "Caschili", "Casciani", "Casciano", "Casciello", "Cascino", "Cascio", "Cascionale", "Casciotti", "Casella", "Caselli", "Casertani", "Casertano", "Casina", "Casini", "Casino", "Casiraghi", "Casirago", "Caspani", "Cassai", "Cassanego", "Cassanelli", "Cassanello", "Cassani", "Cassanmagnago", "Cassano", "Cassara", "Cassarini", "Cassarino", "Cassaro", "Cassarotto", "Cassera", "Cassetta", "Cassetti", "Cassetto", "Cassia", "Cassibba", "Cassina", "Cassinaia", "Cassinari", "Cassisa", "Cassisi", "Cassitto", "Castagna", "Castagnari", "Castagnaro", "Castagner", "Castagneri", "Castagnero", "Castagnetti", "Castagnini", "Castagnoli", "Castaldi", "Castaldo", "Castano", "Castegnini", "Castellani", "Castellano", "Castellari", "Castellaro", "Castellazzi", "Castelletti", "Castelli", "Castellini", "Castello", "Castellotti", "Castelluzzo", "Castelnuovo", "Castelvecchi", "Castelvecchio", "Castiglioni", "Castoldi", "Castracane", "Castracanei", "Castro", "Casu", "Catacchio", "Catagini", "Catalani", "Catalano", "Cataldi", "Cataldo", "Catale", "Catalini", "Catania", "Catanzarita", "Catanzariti", "Catanzaro", "Catarame", "Catelan", "Catelani", "Catelli", "Caterina", "Catini", "Catino", "Catone", "Catoni", "Catrame", "Cattabriga", "Cattalani", "Cattalano", "Cattalini", "Cattaneo", "Cattani", "Cattelan", "Catterina", "Catti", "Cattina", "Catto", "Cattonar", "Cattonaro", "Cattunar", "Cau", "Causio", "Causo", "Cauzo", "Cavacciuti", "Cavagli\xC3\xA0", "Cavagna", "Cavagnari", "Cavagnaro", "Cavagnola", "Cavagnoli", "Cavagnolo", "Cavalcab\xC3\xB2", "Cavalcante", "Cavalcanti", "Cavalera", "Cavaliere", "Cavalieri", "Cavallara", "Cavallari", "Cavallaro", "Cavalleri", "Cavallero", "Cavalli", "Cavallini", "Cavallino", "Cavallo", "Cavalloni", "Cavallotti", "Cavanna", "Cavasin", "Cavasini", "Cavasino", "Cavazza", "Cavazzi", "Cavazzini", "Cavazzuti", "Cavenaghi", "Caverzaghi", "Cavezzini", "Caviglione", "Caviglioni", "Cavioni", "Cavoti", "Cavoto", "Cavuoti", "Cavuoto", "Cazzaniga", "Cazzato", "Cazzini", "Cazzulani", "Cebba", "Cecato", "Ceccardi", "Ceccardini", "Ceccarelli", "Ceccarello", "Ceccato", "Ceccherelli", "Ceccherini", "Cecchetti", "Cecchetto", "Cecchi", "Cecchin", "Cecchinelli", "Cecchinello", "Cecchini", "Ceccon", "Cecconello", "Cecconi", "Cecere", "Cecon", "Ceconi", "Cederna", "Cedolin", "Cedolini", "Cefarelli", "Cefariello", "Cefaro", "Ceglia", "Ceglie", "Cei", "Celani", "Celentani", "Celentano", "Celenza", "Celestini", "Celestino", "Celi", "Celia", "Cella", "Celli", "Celotti", "Celotto", "Cenci", "Censo", "Censoni", "Centa", "Centamori", "Centanni", "Centelles", "Centenari", "Centinaio", "Centonze", "Ceol", "Ceola", "Ceolan", "Ceolin", "Ceramelli", "Cerasa", "Cerati", "Cerca", "Cercato", "Cerello", "Ceremeletti", "Ceresa", "Ceretta", "Ceretti", "Ceriani", "Cerini", "Cerino", "Cerioli", "Cerioni", "Cernuschi", "Cerone", "Cerqueti", "Cerqueto", "Cerquetti", "Cerrati", "Cerrato", "Cerri", "Cerrini", "Cerrino", "Cerro", "Cerrone", "Cerroni", "Cerruti", "Cersosimo", "Cerulli", "Cerullo", "Ceruti", "Cerutti", "Cervellera", "Cervelleri", "Cervellero", "Cervera", "Cervero", "Cervi", "Cervini", "Cervo", "Cervone", "Cervoni", "Cerza", "Cerzosimo", "Cerzoso", "Cesana", "Cesano", "Cesaratti", "Cesaratto", "Cesaretto", "Cesari", "Cesarini", "Cesaris", "Cesarotto", "Cescato", "Cescatti", "Ceschi", "Ceschin", "Ceschina", "Ceschinelli", "Ceschini", "Ceschino", "Cesco", "Cesconi", "Cescotti", "Cesi", "Cestara", "Cestari", "Cestaro", "Chapel", "Checchi", "Cheli", "Cherchi", "Cherchia", "Cherici", "Cherico", "Cherini", "Cherubini", "Chessa", "Chiabra", "Chiabrando", "Chiacchio", "Chiaffarata", "Chiai", "Chiaini", "Chiaino", "Chianale", "Chianca", "Chiancone", "Chiani", "Chianini", "Chiapella", "Chiappa", "Chiappella", "Chiappellini", "Chiappuzzi", "Chiappuzzo", "Chiapuzzi", "Chiapuzzo", "Chiara", "Chiaramonte", "Chiarella", "Chiarelli", "Chiarello", "Chiaretti", "Chiaretto", "Chiari", "Chiariello", "Chiarini", "Chiarion", "Chiaron", "Chiarotto", "Chiavari", "Chiaveri", "Chicoli", "Chieppi", "Chiera", "Chierchia", "Chierchio", "Chiereghini", "Chieri", "Chierichetti", "Chierichini", "Chierici", "Chierico", "Chiesa", "Chigi", "Chilelli", "Chil\xC3\xB2", "Chin", "China", "Chinati", "Chinelli", "Chinello", "Chini", "Chinnati", "Chinni", "Chinno", "Chino", "Chiochia", "Chioda", "Chiodaroli", "Chiodi", "Chiodo", "Chiogna", "Chiola", "Chionchio", "Chirico", "Chiricosta", "Chirigu", "Chirizzi", "Chivu", "Ciabattoni", "Ciacci", "Ciaccio", "Ciampi", "Ciampo", "Ciampoli", "Cianci", "Cianciarini", "Ciancio", "Cianciulli", "Cianciullo", "Cianferra", "Ciani", "Ciano", "Ciaralli", "Ciarallo", "Ciaramella", "Ciaramelli", "Ciarcia", "Ciardi", "Ciardo", "Ciavaglia", "Ciavaglioli", "Ciavarella", "Ciavarelli", "Ciavarello", "Ciavarrella", "Cibra", "Cibrario", "Ciccardi", "Ciccardini", "Ciccarella", "Ciccarelli", "Ciccarello", "Ciccia", "Ciccio", "Ciccone", "Cicconi", "Ciceri", "Cicero", "Cicogna", "Cicognini", "Ciconi", "Cieno", "Cifarelli", "Cifariello", "Cifone", "Cigognini", "Cigoli", "Cigolini", "Cilano", "Cilea", "Cilenti", "Cilento", "Cilfone", "Cilfoni", "Cilli", "Cillo", "Cima", "Cimaduomo", "Ciman", "Cimarosti", "Cimarosto", "Cimarrusti", "Cimarrusto", "Cimarusti", "Cimatti", "Cimbarle", "Cimberla", "Cimberle", "Cimbri", "Cimini", "Cimino", "Cimmarrusti", "Cimmarusti", "Cimmini", "Cimmino", "Cinaglia", "Cingolani", "Cingoli", "Cinieri", "Ciniselli", "Cino", "Cinquanta", "Cinquegrana", "Cinquetti", "Cinti", "Cioce", "Ciofetti", "Cioffi", "Ciommi", "Ciona", "Cione", "Cioni", "Cionini", "Cionna", "Cionni", "Ciotta", "Ciotti", "Ciotto", "Cipitelli", "Cipolla", "Cipolletta", "Cipollini", "Cipollone", "Ciprian", "Cipriani", "Cipriano", "Circello", "Circensi", "Circenzi", "Circi", "Circio", "Cireddu", "Cirelli", "Ciresa", "Ciresi", "Ciriaci", "Ciriaco", "Cirigliano", "Cirignano", "Cirigni", "Cirignotta", "Cirilla", "Cirilli", "Cirillo", "Cirincione", "Cirincioni", "Ciro", "Cirone", "Cironi", "Cirrincione", "Cirrottola", "Ciserani", "Cislaghi", "Citeri", "Citerio", "Citroni", "Citteri", "Citterio", "Ciuccio", "Ciuffi", "Ciuffini", "Ciuffo", "Ciulla", "Ciuni", "Ciusani", "Ciussani", "Ciuti", "Ciutti", "Civardi", "Civaschi", "Civenni", "Civiello", "Civilla", "Civillo", "Clapis", "Clarice", "Clarich", "Clarici", "Claricini", "Claudini", "Claudino", "Claveri", "Claverio", "Clemeno", "Clemente", "Clementi", "Clementoni", "Clerici", "Clerico", "Clotir", "Clun", "C\xC3\xB2", "Coana", "Cocchi", "Cocco", "Cocconcelli", "Cocconi", "Cocozza", "Cocuzza", "Codari", "Codazza", "Codazzi", "Codec\xC3\xA0", "Codecasa", "Codega", "Codeghini", "Codeleoncini", "Codeluppi", "Coderoni", "Coeli", "Coen", "Cofferati", "Coffetti", "Coglianese", "Cogliati", "Cognetti", "Cognetto", "Cogni", "Cogorno", "Cohen", "Coin", "Cola", "Colace", "Colaci", "Colacresi", "Colaianni", "Colamartino", "Colangeli", "Colangelo", "Colantuoni", "Colantuono", "Colasanti", "Colasanto", "Colavita", "Colavito", "Colavolpe", "Coldani", "Colella", "Colelli", "Colello", "Coletta", "Colibretti", "Colicchia", "Colla", "Collasius", "Colleoni", "Colletta", "Colletti", "Colletto", "Colli", "Colnaghi", "Col\xC3\xB2", "Colocresi", "Cologna", "Colognese", "Colognesi", "Cologni", "Cologno", "Colombari", "Colombarini", "Colombera", "Colombi", "Colombini", "Colombo", "Colonna", "Colosetti", "Colosi", "Coloso", "Coltraro", "Colucci", "Coluccia", "Coluccio", "Colugnatti", "Columbro", "Colussi", "Colusso", "Comand", "Comandi", "Comand\xC3\xB9", "Comaro", "Comaroli", "Comasni", "Comberiati", "Comberiato", "Combi", "Comelli", "Comer", "Comerlati", "Cominelli", "Comiran", "Comizzoli", "Como", "Compagnoni", "Comparin", "Comparini", "Comuzzi", "Comuzzo", "Conca", "Concas", "Concu", "Condr\xC3\xB2", "Confalone", "Confalonieri", "Confettura", "Conforti", "Conforto", "Confuorto", "Congera", "Congiu", "Consensi", "Consiglio", "Console", "Consoli", "Consolini", "Consolino", "Consolo", "Consonni", "Cont", "Contaldi", "Contaldo", "Contardi", "Contardo", "Conte", "Conterno", "Conti", "Contin", "Contini", "Continisio", "Contino", "Contri", "Contrisciani", "Conversi", "Converso", "Conzi", "Conzo", "Copat", "Copelli", "Copertino", "Coppari", "Coppi", "Coppini", "Coppo", "Coppola", "Coppolina", "Coppolino", "Coppolone", "Coppotelli", "Corai", "Corain", "Corapi", "Coratelli", "Corazza", "Corbani", "Corbari", "Corbella", "Corbellini", "Corbellino", "Corbetta", "Corda", "Cordani", "Cordari", "Cordaro", "Cordella", "Cordini", "Cordioli", "Cordone", "Cordoni", "Corgnati", "Cori", "Corna", "Cornacchia", "Cornaghi", "Cornalba", "Cornali", "Cornara", "Cornari", "Cornaro", "Corner", "Cornero", "Cornetti", "Corni", "Corno", "Corona", "Coronato", "Coronei", "Coroneo", "Corongiu", "Corpi", "Corpo", "Corpus", "Corrada", "Corradengo", "Corradi", "Corradini", "Corrado", "Correddu", "Corsa", "Corsi", "Corsini", "Corso", "Cortellini", "Cortenova", "Cortese", "Cortesi", "Corti", "Cortinovi", "Cortinovis", "Corvini", "Coscarella", "Coscarelli", "Coscarello", "Cosco", "Cosentini", "Cosentino", "Cosini", "Cosmacini", "Cosmi", "Cosmo", "Cosoleto", "Cossa", "Cossalter", "Cossu", "Cossutta", "Cossutti", "Costa", "Costabile", "Costacurta", "Costamagna", "Costantini", "Costantino", "Costanza", "Costanzi", "Costanzo", "Costarella", "Costarelli", "Costenaro", "Costucci", "Coszach", "Cotignola", "Cotronei", "Cotroneo", "Cotta", "Cotti", "Cotza", "Coutandin", "Cover", "Coveri", "Covioli", "Covoni", "Covre", "Cozzi", "Cozzo", "Cozzolino", "Cozzula", "Craba", "Craighero", "Cravera", "Craveri", "Cravero", "Crea", "Creda", "Credi", "Credo", "Crema", "Cremagnani", "Cremascoli", "Cremona", "Cremonese", "Cremonesi", "Cremonin", "Cremonini", "Cremonino", "Crenna", "Crescenzi", "Crescenzio", "Crescenzo", "Cresci", "Crescimbene", "Crescimbeni", "Crescitelli", "Crespi", "Crespiatico", "Crevani", "Cria", "Crialesi", "Cribio", "Crippa", "Crisafi", "Crisafulli", "Crisaldi", "Crisanti", "Crisanto", "Crisci", "Criscione", "Criscuolo", "Crisostomi", "Crisostomo", "Crispi", "Crispini", "Crispino", "Crispo", "Cristaldi", "Cristallo", "Cristiani", "Cristiano", "Cristofalo", "Cristofani", "Cristofano", "Cristofari", "Cristofaro", "Cristoferi", "Cristofero", "Cristofoli", "Cristofolo", "Cristoforetti", "Cristofori", "Cristoforo", "Cristoforoni", "Crivellari", "Crivellaro", "Crivelli", "Croattini", "Crobu", "Croce", "Crocetta", "Crocetti", "Crocetto", "Croci", "Crocicchia", "Crocini", "Crocioni", "Crognale", "Cropelli", "Crossignani", "Crott", "Crotti", "Cruccas", "Cruciani", "Cruciano", "Cubeddu", "Cuboni", "Cucca", "Cucchetti", "Cucchi", "Cucchiani", "Cucco", "Cuccu", "Cuccus", "Cucinato", "Cuciniello", "Cucinotta", "Cucovaz", "Cucugliata", "Cuggia", "Cugnone", "Cugnoni", "Culos", "Culosi", "Culoso", "Cultraro", "Cumer", "Cumerlato", "Cumerle", "Cumerlotti", "Cumero", "Cuminetti", "Cuminetto", "Cumini", "Cumino", "Cuna", "Cundari", "Cunegati", "Cunegato", "Cunegatti", "Cunego", "Cunegonda", "Cunegondi", "Cuneo", "Cunial", "Cunietti", "Cuoco", "Cuomo", "Cuordifede", "Curatola", "Curatolo", "Curci", "Curcio", "Curi", "Curiale", "Curio", "Curione", "Curioni", "Curotti", "Curotto", "Curreli", "Curr\xC3\xB2", "Cursietti", "Cursio", "Curti", "Cusani", "Cusano", "Cusimano", "Cusin", "Cusinati", "Cusinato", "Cusini", "Cusmano", "Cusumano", "Cuzzi", "Cuzzocrea", "D'abrosca", "D'acquisto", "D'acunto", "D'adda", "D'addario", "D'afflitto", "D'agaro", "D'agostini", "D'agostino", "D'aiello", "D'ajello", "D'alba", "D'alberti", "D'alena", "D'alessandro", "D'alfonso", "D'alise", "D'aloia", "D'aloja", "D'al\xC3\xB9", "D'amato", "D'ambrosi", "D'ambrosio", "D'ambruosi", "D'ambruoso", "D'amici", "D'amicis", "D'amico", "D'amone", "D'andrade", "D'andrea", "D'andria", "D'angelis", "D'angelo", "D'annunzio", "D'antonio", "D'aqu\xC3\xAC", "D'aquino", "D'arena", "D'arpizio", "D'arrigo", "D'attanasio", "D'audino", "D'auria", "D'avanzo", "D'aversa", "D'azeglio", "D'elia", "D'episcopo", "D'errico", "D'onofrio", "D'orazio", "D'orlandi", "D'orlando", "D'ospina", "D'ursi", "D'urso", "D'uva", "Dabellani", "Dacc\xC3\xB2", "Dadda", "Daelli", "Daffonchio", "Daggiano", "Dagostini", "Dagostino", "Daielli", "Dainese", "Dainesi", "Dajelli", "Dal Monte", "Dalbon", "Dalcin", "Dalena", "Dalfovo", "Dall'agnol", "Dall'ara", "Dall'ava", "Dall'era", "Dall'ora", "Dalla Costa", "Dalla Monica", "Dallabora", "Dallara", "Dallera", "Dalmasi", "Dalmasio", "Dalmaso", "Dalmasso", "Dalmonte", "Dameno", "Dametti", "Damiani", "Damiano", "Dandria", "Danelli", "Daneri", "Danero", "Danese", "Danesi", "Daniel", "Daniele", "Danieli", "Daniotti", "Danova", "Danovaro", "Dantile", "Danzi", "Dapiaggi", "Dardano", "Dardi", "Dardo", "Dass\xC3\xA8", "Dati", "Dato", "Davanzati", "Daven", "Daverio", "Dav\xC3\xAC", "Davico", "David", "Davide", "Davidi", "Davini", "Davino", "De Alberti", "De Amicis", "De Angelis", "De Bellis", "De Benedictis", "De Berardinis", "De Berardis", "De Blasi", "De Carlo", "De Cecco", "De Ciancio", "De Cicco", "De Costa", "De Costanzo", "De Cristofano", "De Cristofaro", "De Dominicis", "De Felice", "De Felicibus", "De Filippis", "De Flandre", "De Franceschi", "De Francesco", "De Franchi", "De Fuschi", "De Fusco", "De Giorgio", "De Girolamo", "De Grossi", "De Iuliis", "De Iulio", "De Iulis", "De Laurentiis", "De Leo", "De Leonardis", "De Leonibus", "De Luca", "De Lucia", "De Maggio", "De Maio", "De Marchi", "De Marco", "De Maria", "De Mario", "De Matthaeis", "De Medici", "De Paola", "De Paoli", "De Paolis", "De Paolo", "De Rosa", "De Sanctis", "De Santis", "De Simone", "De Simoni", "De Stefani", "De Stefanis", "De Stefano", "De Villa", "De Vincentiis", "Deangelis", "Debattista", "Debidda", "Decandia", "Decapitani", "Ded\xC3\xA8", "Defabritiis", "Defendente", "Defendenti", "Defeo", "Defilippi", "Defilippis", "Defilippo", "Defranceschi", "Defrancesco", "Defronzo", "Degan", "Degani", "Degano", "Deghenghi", "Degli Innocenti", "Degradi", "Degregori", "Degregorio", "Degrossi", "Deho", "Deiana", "Deias", "Deidda", "Deioannon", "Dejana", "Dejoannon", "Del Conte", "Del Grosso", "Del Monaco", "Del Monico", "Del Monte", "Del Piaz", "Deledda", "Delfabbro", "Delfabro", "Delfini", "Delfino", "Dell'aia", "Dell'arena", "Dell'atti", "Dell'elce", "Dell'era", "Dell'osbel", "Della Costa", "Della Croce", "Della Monica", "Della Sala", "Della Valle", "Della Vedova", "Della Volpe", "Dellabella", "Dellacroce", "Dellaferrera", "Dellamonica", "Dellamorte", "Dellaporta", "Dellavalle", "Dellavedova", "Delle Piane", "Dellepiane", "Dellera", "Delmati", "Delmiglio", "Delmonte", "Delogu", "Delponte", "Delugan", "Demagistris", "Demarchi", "Demarchis", "Demarco", "Demartini", "Demartinis", "Demartino", "Demasi", "Demeneghi", "Demi", "Demo", "Demurtas", "Demuru", "Denigri", "Denigris", "Deniro", "Denni", "Denti", "Deo", "Deodati", "Deodato", "Deon", "Depaol", "Depaoli", "Depaul", "Depeccati", "Depin\xC3\xA8", "Deregibus", "Deros", "Desanctis", "Desantis", "Descalzi", "Descalzo", "Desenzani", "Desiante", "Desiato", "Desideri", "Desiderio", "Destefani", "Destefanis", "Destefano", "Detond", "Dettoni", "Devizzi", "Dezza", "Di Benedetto", "Di Berardino", "Di Biase", "Di Biasi", "Di Carlo", "Di Ciancio", "Di Costa", "Di Costanzo", "Di Cristofano", "Di Cristofaro", "Di Cristofori", "Di Fant", "Di Felice", "Di Francesco", "Di Gioia", "Di Giorgio", "Di Girolami", "Di Girolamo", "Di Leo", "Di Leonardis", "Di Maggio", "Di Maio", "Di Marco", "Di Maria", "Di Mario", "Di Martino", "Di Palma", "Di Paola", "Di Paoli", "Di Paolo", "Di Pasquale", "Di Pierro", "Di Pietro", "Di Pilla", "Di Rosa", "Di Sabatino", "Di Stefano", "Diana", "Dias", "Dibari", "Dibartolo", "Dibartolomeo", "Dicandia", "Dieci", "Difronzo", "Digiuni", "Dignani", "Dilazzaro", "Dilecce", "Diliberto", "Dilorenzo", "Dimatteo", "Dimattia", "Dimino", "Dimonte", "Dini", "Dino", "Diodati", "Diodato", "Diolaiuti", "Dione", "Dioni", "Dionigi", "Dionigio", "Dionisi", "Dionisio", "Dioniso", "Diotallevi", "Dispinzieri", "Distefani", "Distefano", "Distinzieri", "Diverio", "D\xC3\xB2", "Dodera", "Dodero", "Dognini", "Dolce", "Dolcet", "Dolcetta", "Dolcetti", "Dolcetto", "Dolci", "Dolcini", "Dolciotti", "Dolera", "Dolfi", "Dolfini", "Dolfo", "Dolmeta", "Dolmetta", "Domeneghini", "Domenica", "Domenici", "Domenico", "Domenis", "Domicoli", "Domicolo", "Dominici", "Donadei", "Donadel", "Donadelli", "Donadello", "Donadeo", "Donadi", "Donadini", "Donadio", "Donado", "Donadon", "Donadona", "Donadoni", "Donadu", "Donatelli", "Donatello", "Donati", "Donatiello", "Donatini", "Donato", "Donatoni", "Donatucci", "Dondi", "Dondini", "Dondo", "Donelli", "Donello", "Doni", "Donida", "Donini", "Doniselli", "Donisi", "Donna", "Donnarumma", "Donnini", "Donnino", "Donnoli", "Dono", "Donzella", "Donzelli", "Donzello", "Dordoni", "Dore", "Dorgnach", "Doria", "Dorigato", "Dorigo", "Doriguzzi", "Dorio", "Dormetta", "Dornini", "Dossena", "Dot", "Dotti", "Dotto", "Dovera", "Draghi", "Drago", "Dragonetti", "Dragoni", "Draicchio", "Draisci", "Duca", "Duce", "Duci", "Duina", "Durandi", "Durando", "Durante", "Duranti", "Durazzo", "Durlo", "Dursi", "Durso", "Dutti", "Dutto", "Eccher", "Ecker", "Einaudi", "Elia", "Elias", "Eliseo", "Ellaro", "Elli", "Ellul", "Eltrudis", "Emiliani", "Emma", "Engaz", "Engiari", "Epifani", "Epifanio", "Erba", "Erbetta", "Ercilli", "Ercole", "Ercoles", "Ercoli", "Ermacora", "Ermagora", "Errico", "Erroi", "Espositi", "Esposito", "Esposti", "Eterno", "Etzi", "Eufemia", "Eupili", "Eupilio", "Eusebio", "Evangelista", "Evangelisti", "Fabbiani", "Fabbiano", "Fabbri", "Fabbrica", "Fabbris", "Fabbro", "Fabiani", "Fabiano", "Fabris", "Fabrizi", "Fabrizio", "Fabrizzi", "Fab\xC3\xA8n", "Faccendini", "Facchetti", "Facchin", "Facchinetti", "Facchini", "Facchino", "Faccincani", "Faccini", "Faccio", "Faccioli", "Facciolini", "Facciolo", "Faccione", "Facco", "Fachin", "Facincani", "Facini", "Facino", "Fada", "Fadda", "Faedda", "Faenza", "Faes", "Faga", "Fag\xC3\xA0", "Faganelli", "Faganello", "Faggi", "Faggini", "Fagini", "Fago", "Faidutti", "Failli", "Faini", "Faita", "Falappi", "Falasca", "Falaschi", "Falbo", "Falce", "Falchero", "Falchetti", "Falchetto", "Falchi", "Falcione", "Falcioni", "Falco", "Falcomat\xC3\xA0", "Falcomer", "Falcon", "Falcone", "Falconer", "Falconetti", "Falconi", "Falconieri", "Fallacara", "Falsetti", "Falsone", "Falsoni", "Falzon", "Falzone", "Falzoni", "Fam\xC3\xA0", "Fanciulletti", "Fanella", "Fanelli", "Fanello", "Fanetti", "Fangi", "Fania", "Fanin", "Fanini", "Fant", "Fante", "Fanti", "Fantin", "Fantini", "Fantino", "Fanton", "Fantoni", "Fantozzi", "Fantuzzi", "Fanucci", "Fanuzzi", "Fanzaga", "Fanzini", "Fappani", "Fara", "Faraci", "Faraldi", "Faranda", "Farci", "Far\xC3\xA8", "Farese", "Farina", "Farinacci", "Farinaccio", "Farinari", "Farinaro", "Farinati", "Farinazzo", "Farinelli", "Farinetti", "Farini", "Farioli", "Fariolo", "Farisei", "Fariselli", "Fariseo", "Farnese", "Farnesi", "Farneti", "Farnetti", "Farnocchi", "Farnocchia", "Faronato", "Farre", "Farri", "Farris", "Farro", "Farronato", "Farruggia", "Farrugia", "Faruffini", "Fasani", "Fasano", "Fasoli", "Fassa", "Fassetta", "Fassi", "Fassino", "Fatigati", "Fattore", "Fattori", "Fauli", "Fauri", "Fauro", "Fausti", "Faustini", "Faustino", "Fausto", "Fava", "Favale", "Favalli", "Favaloro", "Favara", "Favaro", "Favaron", "Favasuli", "Faverio", "Favero", "Faviero", "Favre", "Favret", "Fazari", "Fazi", "Fazii", "Fazio", "Fazzalari", "Fazzalaro", "Fazzari", "Fazzi", "Fazzini", "Fazzino", "Fazzio", "Fazzolari", "Fecarotta", "Feda", "Fede", "Fedele", "Fedeli", "Federella", "Federici", "Federico", "Felappi", "Feletti", "Feletto", "Felice", "Felici", "Feliciani", "Feliciano", "Felisa", "Felisi", "Fellet", "Felletti", "Felletto", "Fellini", "Feltrin", "Feltrinelli", "Feltrini", "Feltrino", "Fenaroli", "Fenech", "Feni", "Fenini", "Fenino", "Feno", "Fenoglio", "Fenu", "Fenucci", "Fenuccio", "Feo", "Feola", "Feoli", "Feregotti", "Feregotto", "Ferigo", "Ferilli", "Ferillo", "Ferla", "Ferlita", "Ferlito", "Ferman", "Fermani", "Fermi", "Fermo", "Ferniani", "Feronato", "Ferracuti", "Ferragamo", "Ferraguti", "Ferraguto", "Ferragutti", "Ferragutto", "Ferrandi", "Ferrando", "Ferrante", "Ferrantelli", "Ferrara", "Ferrarese", "Ferraresi", "Ferraretto", "Ferrari", "Ferrarini", "Ferrario", "Ferraris", "Ferraro", "Ferrato", "Ferrazza", "Ferrazzano", "Ferrazzi", "Ferrazzo", "Ferra\xC3\xBA", "Ferr\xC3\xA8", "Ferrea", "Ferreguti", "Ferregutti", "Ferreoli", "Ferrera", "Ferreri", "Ferrerio", "Ferrero", "Ferreti", "Ferreto", "Ferretti", "Ferretto", "Ferri", "Ferriello", "Ferrieri", "Ferrigno", "Ferrigutti", "Ferrilli", "Ferrillo", "Ferrise", "Ferrisi", "Ferro", "Ferronato", "Ferrone", "Ferroni", "Feruglio", "Fessia", "Festa", "Fettolini", "Feula", "Fezzoli", "Fiabane", "Fiamingo", "Fiammingo", "Ficara", "Ficarazzi", "Ficarotta", "Ficarra", "Fichera", "Fierro", "Figallo", "Figari", "Figaro", "Figini", "Figino", "Figliuolo", "Figone", "Figoni", "Figus", "Filiali", "Filiberti", "Filiberto", "Filidei", "Filighera", "Filipazzi", "Filippazzi", "Filippi", "Filippini", "Filippo", "Filipputti", "Filocamo", "Filocomo", "Filogamo", "Filoni", "Filosi", "Filosini", "Filoso", "Filz", "Filzi", "Fimelli", "Fincato", "Findanna", "Findanno", "Finella", "Finelli", "Finello", "Fineschi", "Fini", "Finocchiaro", "Finotti", "Finotto", "Finozzi", "Finozzo", "Fiocchi", "Fioni", "Fiora", "Fiorani", "Fioravante", "Fioravanti", "Fioravanzi", "Fioravanzo", "Fiordalisi", "Fiordaliso", "Fiordigigli", "Fiordigiglio", "Fiore", "Fiorelli", "Fiorello", "Fiorentina", "Fiorentini", "Fiorentino", "Fiorenzani", "Fiorenzano", "Fiorese", "Fioresi", "Fioretti", "Fiori", "Fiorinelli", "Fiorinello", "Fiorini", "Fiorito", "Fiorucci", "Firenze", "Firinu", "Firti", "Fisicaro", "Fisichella", "Fissiraga", "Fittipaldi", "Fiume", "Fiumefreddo", "Fiumi", "Flacchi", "Flacco", "Flaim", "Flamini", "Flandina", "Flora", "Florenzani", "Florenzano", "Flores", "Floresta", "Florestani", "Florestano", "Floridia", "Florindi", "Florio", "Floris", "Floro", "Foc\xC3\xA0", "Fochesato", "Fogazzi", "Fogliazza", "Foini", "Fois", "Folchi", "Folchini", "Folco", "Foletti", "Foletto", "Folgarait", "Folgherait", "Folgheraiter", "Folgora", "Folla", "Follador", "Folletti", "Folli", "Folliero", "Follini", "Follis", "Follo", "Fonnesu", "Fontana", "Fontanari", "Fontanazza", "Fontanazzi", "Fontanella", "Fontaneto", "Fonte", "Fontebasso", "Fontes", "Fonti", "Foppa", "Foppoli", "Foppolo", "Forastieri", "Forcati", "Foresta", "Foresti", "Foresto", "Forgiarini", "Forgione", "Forlani", "Forl\xC3\xAC", "Formenti", "Formicola", "Formigari", "Formigaro", "Formisano", "Fornaciari", "Fornara", "Fornari", "Fornarini", "Fornarino", "Fornaro", "Fornaroli", "Fornaron", "Fornasari", "Fornasier", "Fornasieri", "Fornasiero", "Fornera", "Forneri", "Fornero", "Forneron", "Fornerone", "Fornesi", "Fornino", "Foroni", "Forsetti", "Fortarel", "Forte", "Forti", "Fortini", "Fortino", "Fortugno", "Fortuna", "Fortunato", "Foscato", "Foschi", "Foschiatti", "Foschiatto", "Foschini", "Fosco", "Foscolo", "Fossa", "Fossaghi", "Fossale", "Fossali", "Fossati", "Foti", "Fozzati", "Fracassi", "Fracchiolla", "Fraccione", "Fradelizio", "Fragala", "Fragal\xC3\xA0", "Fragapane", "Fragomeni", "Fraguglia", "Franca", "Francalancia", "Francaviglia", "Francavilla", "Frances", "Francescatti", "Franceschetti", "Franceschi", "Franceschin", "Franceschinel", "Franceschinelli", "Franceschini", "Franceschino", "Francesconi", "Francescotti", "Francese", "Francesi", "Francesio", "Franchetti", "Franchetto", "Franchi", "Franchin", "Franchina", "Franchini", "Franchino", "Francia", "Francini", "Francioli", "Franciolli", "Franciosi", "Francioso", "Franciotti", "Francipane", "Francipani", "Francisci", "Franco", "Frandina", "Frangipane", "Frangipani", "Franzelli", "Franzin", "Franzinelli", "Franzini", "Franzino", "Franzoi", "Franzone", "Franzoni", "Franzosi", "Franzoso", "Fraracci", "Fraraccio", "Frare", "Frari", "Frascaroli", "Frascarolo", "Fraschini", "Frasi", "Frasisti", "Frassi", "Frassinetti", "Frate", "Fratello", "Frater", "Frati", "Fratia", "Fratini", "Fratta", "Frattin", "Frattini", "Frattola", "Frattoli", "Frau", "Frazzetto", "Frea", "Freddi", "Frediani", "Fregapane", "Fregoni", "Fregosi", "Fregoso", "Freguglia", "Freri", "Freschi", "Frezzi", "Frezzolini", "Frezzolino", "Fricano", "Frigau", "Frigeni", "Frigeri", "Frigerio", "Friggeri", "Frighi", "Frignati", "Frigo", "Frisa", "Frisanco", "Frisi", "Frisinghelli", "Frisone", "Frisoni", "Fritegotto", "Frittegotto", "Frizzarin", "Frizzi", "Frizzotti", "Frola", "Froli", "Frolo", "Froner", "Frongia", "Frosi", "Frosini", "Frosio", "Frumenti", "Frumentini", "Frumentino", "Frumento", "Fruner", "Fruscalzo", "Fruschi", "Frusci", "Fruscio", "Fruscione", "Frusin", "Fubini", "Fucci", "Fuccio", "Fugazza", "Fugazzi", "Fulco", "Fulcon", "Fulcone", "Fulconi", "Fulconis", "Fulghesu", "Fulici", "Fulico", "Fulla", "Fumagalli", "Fumei", "Fumeo", "Fumo", "Funari", "Funaro", "Furchi", "Furco", "Furini", "Furino", "Furiosi", "Furlan", "Furlanetti", "Furlanetto", "Furlani", "Furlano", "Furnari", "Furnaro", "Furoni", "Fusacchia", "Fusar", "Fusari", "Fusarpoli", "Fuschi", "Fusco", "Fusella", "Fuselli", "Fusello", "Fuser", "Fusi", "Fusinato", "Fusti", "Fustini", "Fusto", "Fuzio", "Gaballo", "Gabban", "Gabbana", "Gabbani", "Gabbano", "Gabbiadini", "Gabbianelli", "Gabbio", "Gabella", "Gabellieri", "Gaboardi", "Gabriel", "Gabriele", "Gabrieli", "Gabrielli", "Gaburo", "Gaburri", "Gaburro", "Gadda", "Gaddo", "Gadia", "Gaetani", "Gaetano", "Gaggeggi", "Gaggegi", "Gaggeri", "Gaggero", "Gaggiani", "Gaggiano", "Gaggio", "Gaggiola", "Gaggioli", "Gaggiolo", "Gagliani", "Gagliano", "Gagliardi", "Gagliardo", "Gaglio", "Gagnor", "Gai", "Gaiardi", "Gaiardo", "Gaiazzi", "Gaibotti", "Gaido", "Gaiga", "Gaipa", "Gaita", "Gaiti", "Gaito", "Gaj", "Galanda", "Galante", "Galanti", "Galantini", "Galantino", "Galassi", "Galasso", "Galastri", "Galastro", "Galata", "Galat\xC3\xA0", "Galati", "Galazzi", "Galazzo", "Galbani", "Galbiati", "Galeazzi", "Galelli", "Galeni", "Galeno", "Galeone", "Galeoni", "Galeotta", "Galeotti", "Galeotto", "Galestri", "Galestro", "Galetti", "Galetto", "Galgaro", "Galiani", "Galiano", "Galiardi", "Galieni", "Galieno", "Galiero", "Galimberti", "Galimberto", "Galina", "Galini", "Galioto", "Galiotta", "Galiotto", "Galisai", "Galizia", "Gallas", "Gallego", "Galleni", "Galleno", "Gallerani", "Gallerini", "Galletti", "Galli", "Galliani", "Galliano", "Gallico", "Galliena", "Gallieni", "Gallina", "Gallinara", "Gallinari", "Gallinaro", "Gallini", "Gallino", "Gallo", "Gallone", "Galloni", "Gallotta", "Gallotti", "Gallottini", "Gallucci", "Galluccio", "Galluppi", "Galluzzi", "Galluzzo", "Galotta", "Galuppi", "Galuppini", "Galuppo", "Galvani", "Galvanin", "Galvanini", "Galvanino", "Galvano", "Gamba", "Gambacorta", "Gambara", "Gambardella", "Gambaretti", "Gambaretto", "Gambari", "Gambarini", "Gambaro", "Gambatesa", "Gambella", "Gamberale", "Gamberini", "Gambina", "Gambini", "Gambino", "Gamuzza", "Ganassali", "Ganci", "Gandelli", "Gandi", "Gandini", "Gandino", "Gandolfi", "Gandolfo", "Gandossi", "Gandotti", "Gangemi", "Gangi", "Ganna", "Ganora", "Ganza", "Ganzerla", "Ganzerli", "Ganzetti", "Ganzi", "Garaldi", "Garau", "Garavagli", "Garavaglia", "Garavaglio", "Garavano", "Garbari", "Garbarini", "Garbarino", "Garbati", "Garbaz", "Garbellini", "Garbin", "Garbino", "Garbo", "Garboli", "Garcia", "Gardinazzi", "Gardini", "Gardino", "Gardon", "Garella", "Garelli", "Garello", "Gargi", "Gargioni", "Gargiuli", "Gargiulo", "Garibaldi", "Garibbo", "Gariboldi", "Garioni", "Garlaschelli", "Garlaschi", "Garlate", "Garlati", "Garlet", "Garneri", "Garnero", "Garofali", "Garofalo", "Garolfi", "Garruti", "Garsia", "Garuffi", "Garuffo", "Garufi", "Garufo", "Garuti", "Garutti", "Garza", "Garzelli", "Garzia", "Garzon", "Garzoni", "Gasco", "Gaspari", "Gasparini", "Gasparoni", "Gasparri", "Gasperi", "Gasperini", "Gastaldelli", "Gastaldello", "Gastaldi", "Gastaldo", "Gasti", "Gastoldi", "Gatel", "Gattai", "Gattara", "Gattari", "Gattelli", "Gatteschi", "Gatti", "Gattinara", "Gattinari", "Gattinoni", "Gatto", "Gattolin", "Gattoni", "Gattuso", "Gaucci", "Gaudenzi", "Gaudenzio", "Gautero", "Gauzzi", "Gava", "Gavardi", "Gavazza", "Gavazzeni", "Gavazzi", "Gavazzo", "Gavin", "Gavini", "Gavino", "Gavirati", "Gavoto", "Gay", "Gazza", "Gazzaniga", "Gazzera", "Gazzetta", "Gazzola", "Gazzoli", "Gazzolo", "Gebbia", "Geissa", "Geldani", "Gellera", "Gelli", "Gelmini", "Gelo", "Gemelli", "Gemmiti", "Genchi", "Genco", "Generani", "Generati", "Genero", "Genesio", "Gennai", "Gennaio", "Gennari", "Genovese", "Genovesi", "Genovessi", "Genovissi", "Gentile", "Gentili", "Gentinetta", "Gerace", "Geraci", "Gerardi", "Gerari", "Gerasia", "Geravini", "Gerelli", "Gerevini", "Germani", "Germano", "Germi", "Germinario", "Germini", "Germiniani", "Germino", "Gerola", "Geroldi", "Geroli", "Gerolimi", "Gerosa", "Gervasi", "Gervasini", "Gervasio", "Gervasoni", "Gessa", "Ges\xC3\xB9", "Gesualdi", "Gesualdo", "Gesuele", "Ghedini", "Ghelfi", "Gheller", "Ghelli", "Gheno", "Gherardi", "Gherardini", "Gherardo", "Ghergo", "Ghesla", "Ghetti", "Ghezzi", "Ghezzo", "Ghianda", "Ghidini", "Ghidoni", "Ghiglia", "Ghigliani", "Ghigliano", "Ghiglio", "Ghigliotti", "Ghigliotto", "Ghigna", "Ghilardi", "Ghilardini", "Ghillani", "Ghin", "Ghinazzi", "Ghini", "Ghio", "Ghione", "Ghioni", "Ghiorzi", "Ghiorzo", "Ghiotti", "Ghiotto", "Ghiozzi", "Ghirardelli", "Ghirardello", "Ghirimoldi", "Ghiringhelli", "Ghiringhello", "Ghirlandi", "Ghisalberti", "Ghiselli", "Ghisellini", "Ghisilieri", "Ghisleri", "Ghislieri", "Ghisoli", "Ghitti", "Ghittoni", "Ghizzardi", "Ghizzo", "Giacalone", "Giacco", "Giaccone", "Giacconi", "Giacinto", "Giac\xC3\xB2", "Giacobbe", "Giacobbi", "Giacobbo", "Giacobi", "Giacomazzi", "Giacomazzo", "Giacomelli", "Giacomello", "Giacometti", "Giacometto", "Giacomi", "Giacomini", "Giacomotti", "Giacone", "Giaconi", "Giacummo", "Giaimi", "Giaimis", "Giaimo", "Gialanella", "Giallombardo", "Giallonardi", "Giallonardo", "Gialloreto", "Giambelli", "Giambi", "Giambo", "Giamb\xC3\xB2", "Giamboi", "Giamboni", "Giambra", "Giambrone", "Giampaoli", "Giampaolo", "Giancipoli", "Giancippoli", "Giancola", "Giancoli", "Giancolo", "Gianfrotta", "Giangipoli", "Giani", "Gian\xC3\xAC", "Gianicolo", "Giannella", "Giannelli", "Giannetta", "Giannicchi", "Giannichedda", "Giannichi", "Giannico", "Giannini", "Giannino", "Giannoccari", "Giannone", "Giannoni", "Giannotta", "Giannuzzi", "Giannuzzo", "Gianotti", "Gianquinta", "Gianquinto", "Giansante", "Gianuzzi", "Giaquinta", "Giaquinto", "Giardina", "Giarelli", "Giarratana", "Giarratano", "Giarrizzo", "Giarrusso", "Giavarini", "Giavazzi", "Giaveri", "Giavon", "Giavoni", "Giberti", "Gigante", "Gigli", "Giglia", "Giglio", "Giglioli", "Gilardini", "Gilardino", "Gilardo", "Gilardone", "Gilardoni", "Gildone", "Gilet", "Gilli", "Gimondi", "Ginami", "Ginelli", "Ginex", "Ginghini", "Ginisi", "Ginosa", "Gioffr\xC3\xA8", "Gioffreda", "Gioffredi", "Gioffredo", "Gioia", "Gioini", "Gioitta", "Giommi", "Giordan", "Giordani", "Giordano", "Giordi", "Giordo", "Giorgetta", "Giorgetti", "Giorgi", "Giorgini", "Giorgio", "Giori", "Gioria", "Giorio", "Gios", "Giovacchini", "Giovagnorio", "Giovanardi", "Giovanetti", "Giovani", "Giovannardi", "Giovannelli", "Giovannetti", "Giovanniello", "Giovannini", "Giovannone", "Giovannoni", "Giovannotti", "Giovenzana", "Giovinazzo", "Giraldi", "Girardi", "Girasia", "Giraudi", "Giraudo", "Girelli", "Girgente", "Girgenti", "Girgentini", "Giribaldi", "Giribaldo", "Girola", "Girolami", "Girolamo", "Giromini", "Girompini", "Gironda", "Girondi", "Girotti", "Girotto", "Gismondi", "Gisulfo", "Giubba", "Giubbi", "Giubbini", "Giudice", "Giudici", "Giudissi", "Giuffra", "Giuffr\xC3\xA8", "Giuffrida", "Giuggia", "Giuggio", "Giugia", "Giugliano", "Giugni", "Giugno", "Giulebbi", "Giuli", "Giuliani", "Giuliano", "Giulini", "Giulino", "Giumelli", "Giunta", "Giunti", "Giuntini", "Giuntino", "Giunto", "Giupponi", "Giurati", "Giurato", "Giuriati", "Giuriato", "Giuriatti", "Giurisato", "Giusberti", "Giussani", "Giusti", "Giustina", "Giustini", "Giustiniani", "Giustiniano", "Giustino", "Giusto", "Gleria", "Glielmi", "Glielmo", "Gliozzi", "Gloder", "Glorioso", "Gnes", "Gnesetti", "Gnesi", "Gnesotto", "Gnocchi", "Gobbetti", "Gobbetto", "Gobbi", "Gobbo", "Gobetti", "Gobetto", "Godeas", "Goffetti", "Goffi", "Goggi", "Goggio", "Goglia", "Goglio", "Goi", "Goisis", "Gola", "Goldaniga", "Golfieri", "Golin", "Golini", "Golino", "Golles", "Gollino", "Golob", "Golop", "Gon", "Gonella", "Goreffi", "Gorelli", "Goretta", "Goretti", "Gorga", "Gorghi", "Gorgo", "Gorgone", "Gori", "Goria", "Goriani", "Goriano", "Gorini", "Gorla", "Gorlani", "Gornati", "Gorni", "Gorno", "Goro", "Gorra", "Gorrara", "Gorreta", "Gorrini", "Gortan", "Gortani", "Gos", "Gosgnach", "Gosparini", "Gotelli", "Goto", "Gottardi", "Gottardini", "Gottardo", "Gottarelli", "Gotti", "Gotto", "Govone", "Govoni", "Goy", "Gozza", "Gozzi", "Gozzini", "Gozzo", "Graboli", "Gracci", "Grada", "Gradi", "Grado", "Grainer", "Granata", "Granato", "Grande", "Grandi", "Grandis", "Granelli", "Granza", "Granzini", "Granzotto", "Grassadonia", "Grassani", "Grassano", "Grasselli", "Grassi", "Grasso", "Gratteri", "Grava", "Gravani", "Gravano", "Grazia", "Graziadei", "Graziadio", "Graziana", "Graziani", "Graziano", "Grazioli", "Grazzani", "Grecchi", "Grechi", "Greco", "Greghi", "Grego", "Gregori", "Gregoriadis", "Gregorio", "Gremmo", "Gremo", "Grespan", "Grieco", "Grifasi", "Grifeo", "Griffi", "Griffini", "Griffo", "Grifi", "Grifo", "Grignani", "Grigoletti", "Grigoletto", "Grigoli", "Grigolli", "Grilletti", "Grilletto", "Grilli", "Grillini", "Grillo", "Grimaldi", "Grimaldo", "Grimani", "Grimaudi", "Grimaudo", "Grimi", "Grimod", "Grimold", "Grimoldi", "Grinover", "Grinovero", "Grioni", "Grippo", "Grisafi", "Grisanti", "Grisi", "Griso", "Grisolia", "Grisoni", "Grisostomi", "Grisostomo", "Grispan", "Grispi", "Grispo", "Gritta", "Gritti", "Grolli", "Gromo", "Gropelli", "Groppelli", "Gros", "Grossi", "Grosso", "Grottaglie", "Gruber", "Gruf\xC3\xA8", "Grugni", "Grumelli", "Gruppelli", "Gruppi", "Guadalupi", "Guaita", "Guaitamacchi", "Guaitani", "Gualazzi", "Gualberti", "Gualdana", "Gualdani", "Gualeni", "Gualina", "Gualini", "Guallina", "Gualtieri", "Guano", "Guaragni", "Guaraldi", "Guarducci", "Guareschi", "Guariberto", "Guarini", "Guariniello", "Guarino", "Guarinoni", "Guarischi", "Guarisco", "Guarneri", "Guarnerio", "Guarnero", "Guarnieri", "Guarniero", "Guarnotta", "Guastalvino", "Guastavino", "Guatti", "Guazzi", "Guazzoni", "Gubbiotti", "Gubbiotto", "Gubernati", "Gubian", "Gucci", "Gucciardello", "Gucciardi", "Gucciardo", "Guderzo", "Guelfi", "Guelfo", "Gueli", "Guerci", "Guercilena", "Guercini", "Guercino", "Guereschi", "Guerini", "Guerinoni", "Guernieri", "Guerra", "Guerreschi", "Guerresco", "Guerrieri", "Guerriero", "Guerrini", "Guerrisi", "Guglielmetti", "Guglielmi", "Guglielmini", "Guglielmone", "Guglielmoni", "Guicciardi", "Guicciardini", "Guida", "Guidetti", "Guidi", "Guidone", "Guidotti", "Guidotto", "Guiglia", "Guirino", "Guiscardi", "Guiscardo", "Guiso", "Guizzardi", "Guizzardo", "Guizzari", "Guizzaro", "Guizzetti", "Guizzi", "Guizzo", "Gulinati", "Gulinelli", "Gulino", "Gulla", "Gulli", "Gullo", "Gullotta", "Gullotti", "Gumiero", "Gunella", "Gus", "Gusmaroli", "Gusmeroli", "Gusmini", "Gustavino", "Guttuso", "Guzzanti", "Guzzi", "Guzzo", "Guzzon", "Iaboni", "Iacchini", "Iaccino", "Iachini", "Iaco", "Iacobelli", "Iacobello", "Iacoe", "Iacoi", "Iacona", "Iaconelli", "Iaconi", "Iaconis", "Iacono", "Iacopi", "Iacopini", "Iacopino", "Iacopo", "Iacovelli", "Iacovetti", "Iacoviello", "Iacovitti", "Iacuzio", "Iagulli", "Iaia", "Iamarino", "Iammarino", "Iampis", "Iandolo", "Ianez", "Iannantuono", "Iannelli", "Iannello", "Ianni", "Iannicola", "Iannielli", "Ianniello", "Iannone", "Iannoni", "Iannucci", "Iannuccilli", "Iannuccillo", "Iannuccio", "Iannuzzelli", "Iannuzzi", "Iannuzzo", "Iaquinta", "Iaquinti", "Iaquinto", "Iavarone", "Iavaroni", "Iazeolla", "Icardi", "Icardo", "Idda", "Idini", "Idino", "Ielardi", "Ielpa", "Ielpo", "Iemma", "Iemme", "Iemmi", "Ienco", "Iennaro", "Ierardi", "Ierardo", "Iessi", "Iezzi", "Ignazi", "Ignazio", "Ilardi", "Ilardo", "Ilari", "Ilario", "Ilariucci", "Illarietti", "Illariuzzi", "Illia", "Imbrogno", "Imovilli", "Impacciatore", "Impallomeni", "Impallommeni", "Incampo", "Incantalupi", "Incantalupo", "Incardona", "Incerti", "Incisa", "Incorpora", "Indelicato", "Infante", "Infanti", "Infantocci", "Infantolino", "Ingarao", "Inghilterra", "Inghirami", "Ingiari", "Ingrami", "Ingrao", "Ingrosso", "Inguanta", "Inguanti", "Innaro", "Innocenti", "Inserra", "Intraprendente", "Invernizzi", "Inzaghi", "Inzitari", "Iob", "Iodice", "Iommi", "Ion", "Ioppi", "Iori", "Iorillo", "Iorio", "Iotti", "Iovaldi", "Ipavic", "Ipaviz", "Ipocoana", "Ippoliti", "Ippolito", "Irace", "Irato", "Irmici", "Ironi", "Isabella", "Isaia", "Isaija", "Isaja", "Isajia", "Isella", "Isnardi", "Isola", "Italia", "Italiani", "Italiano", "Iuculano", "Iudice", "Iudicelli", "Iudicello", "Iuliani", "Iuliano", "Iuorio", "Iurato", "Iuretic", "Iuri", "Iurilli", "Iurman", "Iuvara", "Ivaldi", "Ivaldo", "Ivan", "Ivancic", "Izzo", "L'abate", "La Bella", "La Gatta", "La Mela", "La Monaca", "La Monica", "La Penna", "La Pira", "La Rosa", "La Spina", "La Vecchia", "La Viola", "La Volpe", "Labadini", "Labate", "Labella", "Lacchini", "Laconi", "Lacopo", "Lacroce", "Ladini", "Ladu", "Laferrera", "Laffranchi", "Lagana", "Lagan\xC3\xA0", "Laganara", "Laghezza", "Lagomarsino", "Lagorio", "Lagrini", "Lagrotteria", "Laguzzi", "Lai", "Laiolo", "Laiso", "Laita", "Laiti", "Lajolo", "Lalinga", "Lama", "Lamagna", "Lamalfa", "Lamanna", "Lamatrice", "Lambertenghi", "Lamberti", "Lambertini", "Lamberto", "Lambiase", "Lamborghini", "Lambra", "Lambri", "Lambro", "Lambruschi", "Lambruschini", "Lami", "Lamillo", "Lamon", "Lamorte", "Lamotta", "Lampedecchia", "Lampis", "Lampugnani", "Lampugnano", "Lana", "Lanaro", "Lanci", "Lancia", "Lanciotti", "Lancuso", "Landi", "Landini", "Lando", "Landolfi", "Landolfo", "Landone", "Landoni", "Landriani", "Landriscina", "Landulfo", "Lanfranchi", "Lanfranco", "Lanfranconi", "Lange", "Lanni", "Lanza", "Lanzarotti", "Lanzarotto", "Lanzavecchia", "Lanzi", "Lapa", "Lapai", "Lapenna", "Lapi", "Lapo", "Lapolla", "Larai", "Laraia", "Larceri", "Larcinese", "Larcinesi", "Lari", "Laria", "Larobina", "Larocca", "Larosa", "Larussa", "Larva", "Lascari", "Lascaro", "Laspina", "Laterza", "Latin", "Latini", "Latino", "Latorraca", "Latrofa", "Lattanzi", "Lattanzio", "Lattari", "Lattaro", "Lattes", "Lattisi", "Lattuada", "Laudadio", "Laudamo", "Laudani", "Laudano", "Laudisa", "Laudisi", "Laudisio", "Laura", "Laureanti", "Laurenti", "Laureola", "Lauri", "Lauria", "Lauricella", "Laurini", "Laurino", "Laurito", "Lauro", "Laurora", "Lausdei", "Lavesi", "Lavia", "Laviani", "Laviano", "Lavio", "Laviola", "Lavolpe", "Lavolpicella", "Lazzara", "Lazzari", "Lazzarini", "Lazzarino", "Lazzaro", "Lazzarotti", "Lazzarotto", "Lazzeri", "Lazzero", "Lazzeroni", "Leani", "Leano", "Leanza", "Lecca", "Leccardi", "Lecci", "Legati", "Legato", "Leg\xC3\xA8", "Legname", "Legnami", "Legnani", "Legnano", "Leguleo", "Leinardi", "Lelli", "Lellis", "Lello", "Lembo", "Lemma", "Lemme", "Lemmi", "Lemmo", "Lenardi", "Lenardo", "Leni", "Lenta", "Lenti", "Lentini", "Lento", "Lentulo", "Lenzi", "Lenzo", "Leo", "Leocata", "Leon", "Leonardi", "Leonardini", "Leonardo", "Leoncini", "Leone", "Leonella", "Leonelli", "Leonello", "Leonetti", "Leoni", "Leopardi", "Leopardo", "Leopizzi", "Leotta", "Lercara", "Lercari", "Lercaro", "Lerna", "Lerza", "Lesina", "Lesmo", "Leto", "Letta", "Lettera", "Lettieri", "Lettiero", "Leuchi", "Leuci", "Leva", "Levante", "Levanti", "Levantino", "Levi", "Levo", "Lezza", "Lezzo", "Li Pera", "Li Puma", "Lib\xC3\xA8", "Libera", "Liberata", "Liberati", "Liberato", "Liberi", "Libero", "Liberti", "Libertini", "Liberto", "Libertucci", "Libonati", "Libone", "Liboni", "Liborio", "Librizzi", "Liccardi", "Liccardo", "Licchelli", "Lichelli", "Licheri", "Licini", "Licinio", "Liechti", "Lietti", "Ligabo", "Ligabue", "Ligato", "Ligorio", "Liguori", "Liguoro", "Liistri", "Lilli", "Lilliu", "Lillo", "Limonta", "Linaldeddu", "Linardi", "Linari", "Linati", "Lingiardi", "Lingiari", "Lini", "Lino", "Linz", "Lio", "Lioi", "Lion", "Lionelli", "Lionello", "Lionetti", "Lionetto", "Liotta", "Liotto", "Lipara", "Lipari", "Lipera", "Lippi", "Lippo", "Lisca", "Lissandri", "Lissandrin", "Lissandrini", "Lissone", "Lissoni", "Listri", "Liverani", "Liverio", "Livolsi", "Livori", "Livraghi", "Livrieri", "Lizza", "Lo Bascio", "Lo Gatto", "Lo Monaco", "Lo Presti", "Loaldi", "Lobascio", "Lobbia", "Lobianco", "Lobina", "Locardi", "Locasale", "Locatelli", "Locati", "Locci", "Loche", "Lochis", "Locorotondo", "Locurcio", "Loda", "Loddo", "Lodetti", "Lodi", "Lodigiani", "Lodoli", "Lodolo", "Lofaro", "Loffredo", "Logiodice", "Logiudice", "Logoluso", "Loi", "Loiacono", "Loiodice", "Loiudice", "Lojacono", "Lojodice", "Lojudice", "Lomartire", "Lomasto", "Lomastro", "Lombardi", "Lombardo", "Lomellini", "Lomi", "Lomonaco", "Lonardi", "Lonardo", "Lonati", "Longari", "Longaro", "Longeri", "Longetti", "Longhi", "Longhini", "Longhino", "Longin", "Longini", "Longino", "Longis", "Longo", "Longobardi", "Longobardo", "Longoni", "Lopardo", "Lopetrone", "Lopez", "Lopomo", "Loprete", "Loredan", "Loredani", "Lorenti", "Lorenzetti", "Lorenzi", "Lorenzini", "Lorenzon", "Lorenzone", "Lorenzoni", "Lorenzotti", "Loreo", "Loreti", "Loreto", "Loriga", "Lorio", "Loru", "Lorusso", "Losa", "Losapio", "Losio", "Lotito", "Lotti", "Lotto", "Lovaglio", "Lovascio", "Lovati", "Lovato", "Lovera", "Lovino", "Lualdi", "Lubatti", "Lubrano", "Luca", "Lucarelli", "Lucarello", "Lucarini", "Lucarino", "Lucca", "Lucchese", "Lucchesi", "Lucchetti", "Lucchi", "Lucchini", "Lucci", "Luchetti", "Luchini", "Luci", "Lucia", "Luciani", "Lucianini", "Luciano", "Lucidi", "Lucido", "Lucini", "Lucio", "Ludovici", "Ludovico", "Ludovisi", "Lugano", "Lugari", "Lugaro", "Lugato", "Lugrini", "Luis", "Luisi", "Luisini", "Luison", "Lullo", "Lumia", "Luna", "Lunardelli", "Lunardello", "Lunardi", "Lunardini", "Lunardino", "Lunardo", "Lunetta", "Lungarotti", "Lunghi", "Luongo", "Luparini", "Lupatini", "Luperini", "Lupi", "Lupini", "Lupo", "Luppi", "Lusardi", "Lusini", "Lusiti", "Lusso", "Lussu", "Lusvardi", "Lutzu", "Luvar\xC3\xA0", "Luzardi", "Luzardo", "Luzio", "Luzzardi", "Luzzatti", "Luzzatto", "Luzzi", "Macaluso", "Macari", "Macario", "Maccaferri", "Maccaferro", "Maccagni", "Maccagno", "Maccari", "Maccarinelli", "Maccario", "Maccarone", "Macchetta", "Macchi", "Macchia", "Macchiavelli", "Macchiavello", "Macci", "Maccio", "Macci\xC3\xB2", "Maccione", "Maccioni", "Macco", "Machelli", "Machello", "Machi", "Mach\xC3\xAC", "Machiavelli", "Macii", "Macone", "Maconi", "Macr\xC3\xAC", "Madafferi", "Madaro", "Maddalena", "Madd\xC3\xA8", "Maddi", "Madd\xC3\xAC", "Maddii", "Made", "Mad\xC3\xA8", "Madeo", "Maderna", "Madia", "Madini", "Maenza", "Maesano", "Maestrelli", "Maestrello", "Maestri", "Maff\xC3\xA8", "Maffei", "Maffeis", "Maffini", "Maffioli", "Maffri", "Mafrici", "Magaddino", "Magagna", "Magagni", "Magagnin", "Magagnini", "Magagnino", "Magagno", "Magaldi", "Magaletta", "Magalli", "Maganuco", "Magaton", "Magenes", "Magenta", "Maggi", "Maggiani", "Maggio", "Maggioni", "Maggiora", "Maggiore", "Maghini", "Magi", "Magisano", "Magistrelli", "Magistrello", "Magistri", "Magistris", "Magistro", "Magliani", "Magliano", "Maglio", "Magliocca", "Magliocco", "Magliulo", "Magnabosco", "Magnaghi", "Magnan", "Magnani", "Magnano", "Magnavita", "Magnelli", "Magni", "Magnifico", "Magnin", "Magnini", "Magno", "Magnoni", "Magri", "Magr\xC3\xAC", "Magrin", "Magrini", "Magrino", "Magro", "Maida", "Maiella", "Maiellaro", "Maienza", "Maier", "Maieron", "Maina", "Mainardi", "Mainardis", "Mainas", "Maineri", "Mainero", "Maini", "Mainieri", "Mainiero", "Maino", "Mainoldi", "Maio", "Maiocchi", "Maioli", "Maiolo", "Maione", "Maiorana", "Maiorano", "Maiori", "Mair", "Maisano", "Maisto", "Maiuolo", "Majellaro", "Majer", "Majo", "Majorana", "Majorano", "Malabarba", "Malacrida", "Malagodi", "Malagola", "Malagoli", "Malaguti", "Malandra", "Malandri", "Malandro", "Malaspina", "Malaterra", "Malatesta", "Malavasi", "Malavolta", "Malavolti", "Malchiodi", "Maldari", "Maldi", "Maldifassi", "Maldini", "Maldino", "Malerba", "Malesani", "Malfa", "Malfatti", "Malfatto", "Malfitani", "Malfitano", "Malgeri", "Malgherini", "Malgioglio", "Malgiolio", "Malgrati", "Malica", "Malintoppi", "Malisani", "Malizia", "Mallia", "Mallica", "Malossi", "Malossini", "Malta", "Maltese", "Maltesi", "Malvagna", "Malvitani", "Malvolti", "Mambretti", "Mameli", "Mamertino", "Mammato", "Mammoliti", "Mamoli", "Mamolo", "Manara", "Manca", "Mancin", "Mancina", "Mancinelli", "Mancini", "Mancino", "Manco", "Mancon", "Mancone", "Manconi", "Mancosu", "Mancusi", "Mancuso", "Mancusu", "Manda", "Mandelli", "Mandi", "Mando", "Mandotti", "Mandrelli", "Mandrilli", "Mandrini", "Mandrino", "Mandriota", "Mandro", "Mandroni", "Manea", "Manelli", "Manenti", "Manera", "Maneri", "Manero", "Manes", "Manfredi", "Manfredini", "Manfridi", "Manfrin", "Manfrini", "Manfron", "Manfroni", "Mangano", "Mangia", "Mangiagalli", "Mangiamela", "Mangiamele", "Mangiameli", "Mangiapelo", "Mangiaracina", "Mangiarotti", "Mangiaterra", "Mangione", "Mango", "Mangosio", "Maniago", "Maniello", "Manieri", "Maniero", "Manin", "Manini", "Maniscalco", "Manna", "Mannari", "Mannaro", "Manni", "Mannina", "Mannini", "Mannino", "Mannoni", "Mannori", "Mannu", "Mannucchi", "Mannucci", "Manoni", "Mansi", "Manso", "Mansuelli", "Mansueto", "Manteca", "Mantega", "Mantegazza", "Mantelli", "Mantello", "Manti", "Mantica", "Mantineo", "Mantoan", "Mantoani", "Mantovan", "Mantovani", "Mantovano", "Mantuan", "Manueddu", "Manunza", "Manzan", "Manzano", "Manzato", "Manzi", "Manzo", "Manzoni", "Mapelli", "Marabelli", "Maraboli", "Marafon", "Maragliano", "Maraglio", "Maragnani", "Maragnano", "Maraldo", "Marana", "Marandola", "Marangon", "Marangone", "Marangoni", "Marani", "Marano", "Maranta", "Maranzana", "Maranzano", "Marasca", "Maraschi", "Marasco", "Marassi", "Marazza", "Marazzi", "Marazzina", "Marazzini", "Marazzo", "Marcarelli", "Marcarini", "Marcello", "Marcheggiani", "Marcheggiano", "Marchegiani", "Marchegiano", "Marchesani", "Marchesano", "Marchese", "Marchesi", "Marchesin", "Marchesini", "Marchesino", "Marchesoni", "Marchesotti", "Marchet", "Marchetta", "Marchetti", "Marchetto", "Marchi", "Marchiggiani", "Marchiggiano", "Marchigiani", "Marchigiano", "Marchini", "Marchiori", "Marchiorri", "Marchisio", "Marci", "Marcia", "Marcianesi", "Marciano", "Marcian\xC3\xB2", "Marcigaglia", "Marcis", "Marcolongo", "Marcon", "Marconato", "Marconetti", "Marconi", "Marcucci", "Marcuccio", "Marcuz", "Mardegan", "Maregnani", "Marelli", "Maremonti", "Marenco", "Marendoli", "Marenghi", "Marengo", "Maretti", "Maretto", "Margheritti", "Margon", "Margutti", "Marianelli", "Mariani", "Marianini", "Mariano", "Mariconti", "Marin", "Marina", "Marinacci", "Marinaccio", "Marinari", "Marinaro", "Marinelli", "Marinello", "Marini", "Marino", "Marinoni", "Mariotti", "Mariotto", "Mariz", "Marizza", "Marletta", "Marlia", "Marnini", "Marocco", "Marolda", "Marongiu", "Maroni", "Marosi", "Maroso", "Marostica", "Marotta", "Marovelli", "Marquez", "Marra", "Marras", "Marri", "Marro", "Marrocco", "Marroccu", "Marrocu", "Marrone", "Marroni", "Marrosu", "Marsala", "Marsano", "Marseglia", "Marsetti", "Marsi", "Marsico", "Marsigli", "Marsiglia", "Marsiglio", "Marsiglione", "Marsiglioni", "Marsili", "Marsilia", "Marsiliano", "Marsilio", "Marsilli", "Marson", "Martani", "Martel", "Martell", "Martella", "Martellacci", "Martellaccio", "Martellenghi", "Martelli", "Martellini", "Martello", "Martignon", "Martignone", "Martignoni", "Martin", "Martina", "Martinelli", "Martinenghi", "Martinez", "Martini", "Martinis", "Martino", "Martinotti", "Martinuzzi", "Martinuzzo", "Martiradonna", "Martirano", "Martocchia", "Martorana", "Martorano", "Martorelli", "Martorello", "Martori", "Martorini", "Marturana", "Marturano", "Marubbi", "Maruca", "Marucchi", "Maruccia", "Marucco", "Marulli", "Marullo", "Maruzzo", "Marvaldi", "Marveggio", "Marzani", "Marzano", "Marzarotto", "Marzi", "Marziali", "Marziani", "Marziliano", "Marzio", "Marzocca", "Marzocchetti", "Marzocchi", "Marzocco", "Marzorati", "Marzotta", "Marzotti", "Marzotto", "Marzucchi", "Marzucco", "Marzulli", "Marzullo", "Marzuoli", "Marzuolo", "Masala", "Mascali", "Mascarini", "Mascaroni", "Mascheroni", "Mascherpa", "Maschi", "Maschietti", "Maschietto", "Maschio", "Masci", "Masciadri", "Masciarelli", "Masciari", "Masciaro", "Mascini", "Mascino", "Mascio", "Mascoli", "Mascolo", "Maselli", "Maserati", "Maset", "Masetti", "Masetto", "Masi", "Masielli", "Masiello", "Masier", "Masiero", "Masilli", "Masillo", "Masina", "Masini", "Masino", "Maso", "Masola", "Masoli", "Masolini", "Masolino", "Masolo", "Mason", "Masotina", "Masotto", "Massa", "Massacri", "Massafra", "Massagni", "Massara", "Massarelli", "Massarente", "Massarenti", "Massari", "Massariol", "Massaro", "Massarotti", "Massarotto", "Massasogni", "Massazza", "Mass\xC3\xA8", "Masselli", "Masseroni", "Massignan", "Massignani", "Massimiliani", "Massimini", "Massimino", "Massironi", "Massola", "Massoli", "Massolo", "Mastantuoni", "Mastantuono", "Mastrandrea", "Mastrangeli", "Mastrangelo", "Mastrantoni", "Mastrantonio", "Mastrapasqua", "Mastri", "Mastro", "Mastrogiacomi", "Mastrogiacomo", "Mastromarini", "Mastromarino", "Mastronardi", "Mastronardo", "Mastronzo", "Mastropaolo", "Mastropasqua", "Mastrota", "Mastrototaro", "Masu", "Masuino", "Masulli", "Masullo", "Matarazzi", "Matassi", "Matassoni", "Matelli", "Matera", "Materazzi", "Matiz", "Matone", "Matraxia", "Matta", "Mattalia", "Mattana", "Mattarozzi", "Mattavelli", "Mattea", "Mattei", "Matteo", "Mattera", "Matti", "Mattiola", "Mattioli", "Mattiucci", "Mattiussi", "Mattiuzzo", "Matto", "Mattonai", "Maturo", "Mauceri", "Maugeri", "Maurelli", "Mauri", "Maurici", "Maurizi", "Mauro", "Mavrici", "Mayer", "Mazelli", "Mazza", "Mazzacurati", "Mazzadi", "Mazzaia", "Mazzali", "Mazzante", "Mazzanti", "Mazzantini", "Mazzara", "Mazzarella", "Mazzarelli", "Mazzarello", "Mazzarese", "Mazzaresi", "Mazzari", "Mazzariello", "Mazzarino", "Mazzaro", "Mazzatorta", "Mazzavillani", "Mazzei", "Mazzeo", "Mazzi", "Mazzieri", "Mazzilli", "Mazzillo", "Mazzini", "Mazzitelli", "Mazzocca", "Mazzocchi", "Mazzocchin", "Mazzocco", "Mazzochin", "Mazzola", "Mazzolari", "Mazzoleni", "Mazzoletti", "Mazzolini", "Mazzolino", "Mazzolo", "Mazzone", "Mazzoni", "Mazzuca", "Mazzucchelli", "Mazzuia", "Mazzuolo", "Mea", "Meazza", "Meda", "Medda", "Medde", "Medeot", "Medetti", "Medici", "Medico", "Medioli", "Medri", "Medved", "Medves", "Megale", "Megali", "Megalizzi", "Meglio", "Mei", "Meier", "Meina", "Meini", "Meir", "Mejer", "Mela", "Melandri", "Melandro", "Melardi", "Melchior", "Melchiori", "Melchiorre", "Melchiorri", "Mele", "Melfi", "Meli", "Mel\xC3\xAC", "Melilli", "Melillo", "Melinc", "Melini", "Melino", "Melis", "Mella", "Melle", "Melli", "Mellini", "Mellino", "Mello", "Melo", "Meloncelli", "Melone", "Meloni", "Melotti", "Melpi", "Melzi", "Mem\xC3\xA8", "Memmi", "Memmo", "Memmola", "Memmoli", "Memmolo", "Memola", "Memoli", "Memolo", "Mencacci", "Mendicino", "Mendola", "Mendolaro", "Mendoza", "Mendozza", "Menegale", "Menegatti", "Menegatto", "Meneghetti", "Meneghin", "Meneghini", "Menegoli", "Menegolo", "Menescardi", "Mengacci", "Mengarda", "Mengardi", "Mengardo", "Menghi", "Menghini", "Mengo", "Mengozzi", "Menicatti", "Menichelli", "Menichetti", "Menico", "Menicocci", "Meniconi", "Menicucci", "Menini", "Menni", "Menno", "Mennone", "Mennoni", "Menoni", "Mento", "Mentone", "Mentoni", "Meo", "Meomartini", "Meomartino", "Meoni", "Merati", "Meraviglia", "Mercandelli", "Mercante", "Mercantelli", "Mercanti", "Mercantini", "Mercia", "Mercuri", "Meregalli", "Meriggi", "Merighetti", "Merighetto", "Merighi", "Merigo", "Merisio", "Merlani", "Merlano", "Merli", "Merlin", "Merlini", "Merlo", "Meroni", "Mertini", "Merzagora", "Merzari", "Merzario", "Meschini", "Mesiani", "Mesiano", "Mesiti", "Messina", "Messineo", "Messinese", "Messinesi", "Metelli", "Meyer", "Meyr", "Mezzadra", "Mezzadri", "Mezzadro", "Mezzadroli", "Mezzari", "Mezzaro", "Mezzasalma", "Mezzasoma", "Mezzi", "Mezzogori", "Miandri", "Miandro", "Miani", "Mianini", "Miano", "Micale", "Micaletti", "Micaletto", "Micali", "Micalizzi", "Miccicch\xC3\xA8", "Miccich\xC3\xA8", "Miccoli", "Miccolis", "Micele", "Miceli", "Micelli", "Micera", "Miceri", "Micero", "Michelacci", "Michelassi", "Michelazzi", "Michelazzo", "Michele", "Micheli", "Michelin", "Michelini", "Michelino", "Michelli", "Michelon", "Michetti", "Micicch\xC3\xA8", "Micillo", "Miclavez", "Micossi", "Midali", "Miesi", "Mietto", "Migale", "Migali", "Mighetti", "Mighetto", "Migli", "Migliaccio", "Migliari", "Migliaro", "Migliavacca", "Migliazza", "Miglietta", "Miglietti", "Miglietto", "Miglio", "Migliora", "Migliore", "Migliori", "Migliorini", "Mignogna", "Mignogni", "Mignona", "Mignone", "Mignoni", "Migotto", "Milan", "Milandri", "Milanese", "Milanesi", "Milani", "Milanin", "Milano", "Milazzo", "Milesi", "Mileto", "Milillo", "Militello", "Milo", "Mina", "Minacapilli", "Minelli", "Minello", "Minervino", "Minet", "Minetta", "Minetti", "Minetto", "Mingardi", "Mingardo", "Minghi", "Mingo", "Mingolini", "Mini", "Minicocci", "Minicucci", "Minicuci", "Miniero", "Minima", "Minimi", "Minimo", "Miniscalchi", "Miniscalco", "Minniti", "Minnozzi", "Mino", "Minoia", "Minoja", "Minola", "Minolfi", "Minoli", "Minozzi", "Mion", "Mione", "Mior", "Mioso", "Miotto", "Mira", "Mirabella", "Mirabelli", "Mirabile", "Mirabili", "Mirabilia", "Mirabilio", "Miracoli", "Miraglia", "Miranda", "Mirandola", "Mirotta", "Mirotti", "Mirotto", "Mirra", "Mirtini", "Mirto", "Misitano", "Misiti", "Missaglia", "Missiaglia", "Mistretta", "Mitri", "Mlekuz", "Mlinz", "Moal", "Moali", "Moca", "Moccia", "Mocciaro", "Moccio", "Mocerino", "Mochen", "Mochi", "Modafferi", "Modiano", "Modigliani", "Modignani", "Modini", "Modoni", "Modonutti", "Modonutto", "Modugno", "Moggia", "Moglia", "Moine", "Moioli", "Moiraghi", "Moiso", "Molaschi", "Mol\xC3\xA8", "Moles", "Molignani", "Molignano", "Molin", "Molinari", "Molinaro", "Molinengo", "Molineri", "Molineris", "Molinetti", "Molinetto", "Molini", "Molino", "Moliterni", "Moliterno", "Mollaschi", "Mollica", "Molteni", "Mombelli", "Momoli", "Momolo", "Monachesi", "Monachini", "Monaci", "Monaco", "Monaro", "Monassi", "Monasso", "Moncada", "Moncalvo", "Monci", "Moncini", "Mondadori", "Mondaini", "Mondilli", "Mondillo", "Mondin", "Mondini", "Mondino", "Mondolfi", "Mondolfo", "Monega", "Moneghetti", "Monego", "Mones", "Moneta", "Monforte", "Monforti", "Monfreda", "Monfredini", "Mongelli", "Mongello", "Monghi", "Mongillo", "Mongiusti", "Monici", "Monico", "Monni", "Monopoli", "Mont\xC3\xA0", "Montagna", "Montagnana", "Montagnani", "Montagner", "Montaldi", "Montaldo", "Montale", "Montalenti", "Montalti", "Montalto", "Montanari", "Montanaro", "Montanelli", "Montani", "Montanini", "Monte", "Montebello", "Montecalvo", "Montecchi", "Montecchia", "Montecchio", "Montecolle", "Montefameglio", "Montelanico", "Monteleone", "Montellanico", "Montemaggiore", "Montemarano", "Montemerli", "Montemerlo", "Montesano", "Montesi", "Monti", "Montibello", "Monticelli", "Montico", "Montigiani", "Montin", "Montini", "Montis", "Montrasio", "Monzani", "Morabito", "Morandi", "Morando", "Morandotti", "Morasca", "Moratti", "Morchi", "Morchia", "Morchio", "Morelli", "Morello", "Moreschi", "Moret", "Moretta", "Moretti", "Morettini", "Morettino", "Moretto", "Morgante", "Morganti", "Morgnoni", "Mori", "Morici", "Morico", "Moricone", "Moriconi", "Morini", "Morino", "Morisco", "Morisi", "Mormandi", "Moro", "Morocco", "Morocutti", "Moroni", "Morosini", "Morosino", "Morosinotto", "Morra", "Morricone", "Morriconi", "Morrone", "Morsini", "Morstabilini", "Morsut", "Mortari", "Mortaro", "Mortoni", "Morucci", "Moruccio", "Moruzzi", "Mosca", "Moscariello", "Moscat", "Moscatelli", "Moscatello", "Moscati", "Moscato", "Moschen", "Moschetti", "Moschetto", "Moschi", "Moschin", "Moschini", "Moschino", "Moschitta", "Moschitto", "Moser", "Mosetti", "Mosetto", "Mosna", "Mostacchi", "Mosti", "Mosto", "Motta", "Motteran", "Motterani", "Mottes", "Mottesi", "Motti", "Mottin", "Mottini", "Motto", "Mottola", "Motton", "Mottura", "Motzo", "Mozzanica", "Muccioli", "Mucciolini", "Mucciolo", "Muggiolu", "Mugheddu", "Mugnai", "Mugnaini", "Mugnaio", "Muiesan", "Mula", "Mulas", "Mulazzani", "Mulazzano", "Mule", "Mul\xC3\xA8", "Muleddu", "Munac\xC3\xB2", "Munaf\xC3\xB2", "Munaretti", "Munaretto", "Muneratti", "Muneratto", "Mura", "Murabito", "Muratore", "Muratori", "Mureddu", "Murer", "Muresu", "Murgia", "Muriglio", "Murno", "Murro", "Murroni", "Murru", "Mursia", "Murtas", "Musacchi", "Musacco", "Musati", "Musazzi", "Musca", "Muscariello", "Muscas", "Muscatelli", "Muscatello", "Muscella", "Musco", "Musella", "Muselli", "Musello", "Musmarra", "Mussati", "Mussato", "Mussi", "Mussida", "Mussner", "Musso", "Mussolini", "Mussolino", "Mussomeli", "Musti", "Musto", "Mustu", "Musumarra", "Musumeci", "Muti", "Mutinelli", "Mutini", "Mutino", "Mutti", "Muttoni", "Muzi", "Muzio", "Muzioli", "Muziotti", "Muzzi", "Muzzicato", "Nacar", "Nadal", "Nadalini", "Nadalino", "Naggi", "Naggia", "Naitana", "Naliato", "Nalti", "Nana", "Nani", "Nania", "Nanni", "Nannini", "Napelli", "Napello", "Napoletani", "Napoletano", "Napoli", "Napoliello", "Napolitano", "Nappa", "Nappi", "Nappo", "Nardacchione", "Nardecchi", "Nardecchia", "Nardella", "Nardelli", "Nardello", "Nardeschi", "Nardese", "Nardi", "Nardicchi", "Nardicchia", "Nardicchio", "Nardiello", "Nardin", "Nardini", "Nardinocchi", "Nardo", "Nardon", "Nardone", "Nardoni", "Nardovino", "Nardulli", "Nasato", "Nascimben", "Nascimbene", "Nascimbeni", "Naselli", "Naso", "Nassimbeni", "Natale", "Natali", "Natalini", "Natalino", "Nateri", "Natero", "Natola", "Natoli", "Natta", "Nattero", "Natti", "Nava", "Navas", "Nave", "Nazario", "Nazarri", "Nazzari", "Nazzario", "Necchi", "Negrelli", "Negrello", "Negretti", "Negretto", "Negri", "Negrin", "Negrini", "Negrino", "Negro", "Negroni", "Neiviller", "Nelli", "Nenci", "Nencini", "Nencioni", "Nepi", "Nepote", "Nepoti", "Neretti", "Neri", "Nerini", "Nerli", "Nero", "Nerone", "Neroni", "Nervetti", "Nervi", "Nesci", "Nescis", "Nespola", "Nespole", "Nespoli", "Nespolo", "Nicastro", "Nicchi", "Niccodemo", "Niccolai", "Nicefaro", "Nicefori", "Niceforo", "Nichele", "Nicheli", "Nicito", "Nicodemo", "Nicolai", "Nicolazzi", "Nicoletta", "Nicoletti", "Nicoletto", "Nicoli", "Nicolini", "Nicolino", "Nicol\xC3\xB2", "Nicolosi", "Nicosia", "Nicotera", "Nicotra", "Nieddu", "Nieri", "Niero", "Nigrelli", "Nigro", "Niro", "Nisi", "Niso", "Nistri", "Nistro", "Nizzi", "Nizzola", "Nobile", "Nobili", "Noce", "Nocenti", "Nocentini", "Nocera", "Nocerini", "Nocerino", "Noci", "Nocito", "Nodari", "Nodaro", "Nogara", "Nogaro", "Nogarol", "Nola", "Nolano", "Noletto", "Noli", "Nones", "Nora", "Norcia", "Nordio", "Nori", "Norrito", "Noschese", "Noseda", "Nossa", "Nossardi", "Not", "Notarangeli", "Notarangelo", "Notararigo", "Notari", "Notaristefani", "Notaristefano", "Notaro", "Notarpietro", "Notarstefano", "Noto", "Novara", "Novarese", "Novaresi", "Novarini", "Novaro", "Novati", "Novazzi", "Novella", "Novelli", "Novellini", "Novellino", "Novellis", "Novello", "Novembrini", "Noviello", "Nuara", "Nucci", "Nuccio", "Nugnes", "Nunes", "Nunez", "Nurchis", "Nurra", "Nuschese", "Nusco", "Nuzzachi", "Nuzzaci", "Nuzzaco", "Nuzzi", "Nuzzo", "Oberti", "Obiso", "Obizzo", "Occhinegro", "Occhineri", "Occhinero", "Occhinigro", "Occhino", "Occhionegro", "Occhionero", "Occhipinti", "Occhipinto", "Occhiuto", "Odasso", "Oddi", "Oddo", "Oddone", "Oddoni", "Odicino", "Odoni", "Offredi", "Oggioni", "Ogliari", "Ogliaro", "Oldani", "Oleotti", "Olgiati", "Oliva", "Olivari", "Oliveri", "Oliverio", "Olivero", "Oliveti", "Oliveto", "Olivetti", "Olivetto", "Olivi", "Olivieri", "Oliviero", "Olivo", "Olla", "Olmi", "Omacini", "Omassi", "Omegna", "Omini", "Omodei", "Omodeo", "Oneda", "Oneta", "Oneto", "Ongania", "Onofri", "Onofrio", "Opezzi", "Opizzi", "Oppi", "Oppini", "Oppio", "Oppizi", "Oppizio", "Oppizzi", "Orchi", "Orco", "Orfanini", "Oriali", "Oriani", "Origoni", "Orio", "Oriola", "Orioli", "Oriolo", "Orlandi", "Orlandini", "Orlandino", "Orlando", "Ormella", "Orr\xC3\xB9", "Orsatti", "Orsenigo", "Orsi", "Orsina", "Orsini", "Orsino", "Orso", "Orsoni", "Ortense", "Ortensi", "Ortolan", "Ortolani", "Orvieto", "Oselladore", "Osio", "Osmic", "Osmici", "Ossia", "Ossian", "Ossiani", "Ossola", "Ostagoli", "Ostan", "Ostano", "Ostuni", "Ottaviani", "Ottaviano", "Ottolia", "Ottolina", "Ottolini", "Ottone", "Ottoni", "Ozzella", "Ozzello", "Pacciani", "Pace", "Pacelli", "Pacello", "Paci", "Paciani", "Pacifici", "Pacifico", "Pacini", "Pacino", "Paciosi", "Paciulli", "Padovan", "Padovani", "Padovano", "Padronaggio", "Padula", "Paduli", "Padulli", "Padulo", "Padus", "Paes", "Paesan", "Paese", "Paesi", "Paffumi", "Pagan", "Pagana", "Paganelli", "Paganello", "Paganetti", "Paganetto", "Pagani", "Paganin", "Paganini", "Pagano", "Paganoni", "Paglia", "Pagliaccio", "Pagliai", "Pagliara", "Pagliari", "Pagliarini", "Pagliarisi", "Pagliaro", "Pagliarulo", "Pagnanelli", "Pagnani", "Pagni", "Pagnini", "Pagno", "Pagnoni", "Pagnozzi", "Pagnozzo", "Paiaro", "Paielli", "Paiello", "Paina", "Paini", "Paissan", "Pajello", "Pala", "Paladini", "Paladino", "Palamuso", "Palavicino", "Palazzi", "Palazzini", "Palazzo", "Palazzoli", "Palazzolo", "Palermo", "Palese", "Palladini", "Palladino", "Pallavicini", "Pallavicino", "Pallini", "Pallino", "Pallitta", "Pallitto", "Pallucca", "Palma", "Palmarin", "Palmas", "Palmenteri", "Palmentieri", "Palmer", "Palmeri", "Palmerini", "Palmerio", "Palmero", "Palmese", "Palmieri", "Palmiero", "Palminteri", "Palmintieri", "Palmiotta", "Palmiotti", "Palmiotto", "Palmisano", "Palmisciano", "Palmitessa", "Palomba", "Palombella", "Palombelli", "Palombi", "Palombieri", "Palombo", "Paloschi", "Palucci", "Paluccio", "Paludetti", "Paludi", "Paludo", "Palumbella", "Palumbi", "Palumbo", "Pamio", "Panarelli", "Panarello", "Panariello", "Panasci", "Panasc\xC3\xAC", "Pancaldi", "Pancaldo", "Pancallo", "Pancera", "Panciroli", "Pancotti", "Pandolfa", "Pandolfi", "Pandolfo", "Pane", "Panecaldo", "Panelli", "Panetta", "Pangalli", "Pangallo", "Pani", "Panichelli", "Panichi", "Panico", "Panicucci", "Panigada", "Panigati", "Panigatti", "Panigazzi", "Paniz", "Panizza", "Panizzi", "Panizzoli", "Panizzolo", "Pannaci", "Pannunzi", "Pannunzio", "Panozzo", "Pantaleo", "Pantaleone", "Pantani", "Pantano", "Pantella", "Pantelli", "Pantini", "Pantino", "Pantoni", "Panunti", "Panunzi", "Panunzio", "Panza", "Panzera", "Panzeri", "Panzin", "Paolacci", "Paolati", "Paolazzi", "Paoletti", "Paoletto", "Paoli", "Paolicelli", "Paolillo", "Paolinelli", "Paolini", "Paolino", "Paolo", "Paoloni", "Paolucci", "Papa", "Papace", "Papagni", "Papalato", "Papale", "Papaleo", "Papalia", "Paparella", "Papei", "Papeo", "Papetti", "Papi", "Papia", "Papini", "Papino", "Papone", "Paponi", "Pappa", "Pappada", "Pappad\xC3\xA0", "Pappalardi", "Pappalardo", "Pappi", "Papucci", "Papurello", "Parabiaghi", "Paraboschi", "Paracciani", "Paraciani", "Paracini", "Paradiso", "Paragiani", "Parati", "Paravati", "Paravato", "Parazzoli", "Pardi", "Pardini", "Pardo", "Pardoni", "Parente", "Parentela", "Parenti", "Parenzan", "Pareschi", "Parie", "Parietti", "Parigi", "Parini", "Paris", "Parise", "Parisi", "Parisini", "Parisio", "Parma", "Parmeggiani", "Parmegiani", "Parmiggiani", "Parmigiani", "Parmini", "Parodi", "Parolari", "Parolaro", "Parolo", "Paronzini", "Parravicini", "Parri", "Parrinello", "Parsani", "Partel", "Partele", "Parteli", "Parti", "Partini", "Parzanese", "Parzani", "Parzini", "Pasca", "Pascal", "Pascale", "Pascalis", "Pascarella", "Pasco", "Pascoli", "Pascolin", "Pascolini", "Pascucci", "Pascuccio", "Pascuzzi", "Pascuzzo", "Pasetti", "Pasetto", "Pasi", "Pasini", "Pasino", "Pasoli", "Pasolini", "Pasolino", "Pasqua", "Pasqual", "Pasquale", "Pasqualetti", "Pasqualetto", "Pasquali", "Pasqualini", "Pasqualinotto", "Pasqualis", "Pasqualon", "Pasqualone", "Pasqualoni", "Pasqualotto", "Pasquato", "Pasquina", "Pasquini", "Pasquino", "Passador", "Passadore", "Passadori", "Passafiume", "Passalacqua", "Passalenti", "Passamonte", "Passamonti", "Passaniti", "Passarella", "Passaretti", "Passarini", "Passatore", "Passatori", "Passera", "Passerini", "Passi", "Passivo", "Passolungo", "Passon", "Passoni", "Pastor", "Pastora", "Pastore", "Pastorelli", "Pastorello", "Pastoressa", "Pastori", "Pastorin", "Pastorina", "Pastorini", "Pastorino", "Pastoris", "Patacca", "Patane", "Patan\xC3\xA8", "Patania", "Paterno", "Patern\xC3\xB2", "Paternoster", "Paternostri", "Paternostro", "Patetta", "Pati", "Patirani", "Patrignani", "Patruno", "Patti", "Patuzzi", "Patuzzo", "Pau", "Paulli", "Paulucci", "Pautassi", "Pautasso", "Pavan", "Pavanel", "Pavanelli", "Pavanello", "Paveglio", "Pavesi", "Pavia", "Paviglianiti", "Pavoncelli", "Pavoncello", "Pavone", "Pavoni", "Pazzi", "Pea", "Peccati", "Peccenati", "Pecchi", "Pecchia", "Pecchio", "Pecchioli", "Pecora", "Pecorari", "Pecoraro", "Pecori", "Pecoriello", "Pecoroni", "Peddio", "Peddiu", "Pedemonte", "Pederoda", "Pedersoli", "Pederzini", "Pederzoli", "Ped\xC3\xB2", "Pedrali", "Pedrazzi", "Pedrazzini", "Pedrazzo", "Pedretti", "Pedrinazzi", "Pedrinelli", "Pedrini", "Pedrocchi", "Pege", "Pegoraro", "Peita", "Peiti", "Pelacani", "Pelagalli", "Pelagatta", "Pelagatti", "Pelegatti", "Pelegatto", "Peletti", "Peli", "Pelis", "Pelizon", "Pelizzari", "Pelizzaro", "Pelizzola", "Pelizzon", "Pellacani", "Pellagatta", "Pellagatti", "Pellanera", "Pellegatta", "Pellegrin", "Pellegrina", "Pellegrini", "Pellegrino", "Peller", "Pelleri", "Pellerin", "Pellerini", "Pelletta", "Pelletti", "Pellettieri", "Pelletto", "Pellicano", "Pellican\xC3\xB2", "Pellicari", "Pelliccia", "Pellini", "Pellitteri", "Pellizari", "Pellizza", "Pellizzari", "Pellizzola", "Pellizzon", "Pelosi", "Pelosini", "Peloso", "Pelu", "Pel\xC3\xB9", "Pelucchi", "Pelucchini", "Peluchi", "Peluffo", "Pelusi", "Peluso", "Penati", "Penna", "Pennacchi", "Pennacchia", "Pennacchietti", "Pennacchio", "Pennaccini", "Pennaccino", "Pennacini", "Pennacino", "Pennese", "Pennesi", "Pennetta", "Pennise", "Pennisi", "Pensa", "Pensalfini", "Pensato", "Penso", "Penza", "Penzo", "Pepa", "Pepe", "Pepi", "Peppe", "Peppetti", "Peppi", "Peracchi", "Peraccini", "Perani", "Perasso", "Perazzoli", "Percivaldi", "Percivalle", "Percivalli", "Perdoni", "Perego", "Peregrini", "Peregrino", "Perelli", "Peresin", "Peretti", "Perez", "Pergola", "Pergolese", "Pergolesi", "Pergoli", "Pergolizzi", "Peric", "Perich", "Perillo", "Perin", "Perini", "Perino", "Perla", "Perletti", "Perna", "Perola", "Peron", "Peroncini", "Peroni", "Perosa", "Perosi", "Perosini", "Perosino", "Perosio", "Perotti", "Perozzi", "Perozzini", "Perozzino", "Perozzo", "Perrella", "Perrelli", "Perrello", "Perrini", "Perrino", "Perrone", "Perroni", "Perrucchetti", "Perruccio", "Persani", "Perteghella", "Perti", "Pertile", "Pertili", "Pertini", "Pertino", "Perucchetti", "Perugina", "Perugini", "Perugino", "Peruzzi", "Peruzzini", "Peruzzo", "Perversi", "Pes", "Pesaresi", "Pesatori", "Pescatori", "Pesce", "Pescetto", "Pesci", "Pescio", "Pesenti", "Pessato", "Pessina", "Pessot", "Pessotto", "Pestoni", "Petelin", "Petercini", "Petrali", "Petralia", "Petraliti", "Petralito", "Petralli", "Petrantoni", "Petrarca", "Petrarulo", "Petrazzi", "Petrazzini", "Petrazzo", "Petrazzoli", "Petrazzuoli", "Petrazzuolo", "Petrecca", "Petrella", "Petretti", "Petretto", "Petri", "Petrilli", "Petrini", "Petrino", "Petrioli", "Petris", "Petro", "Petrocchi", "Petrocco", "Petrolini", "Petrone", "Petronelli", "Petroni", "Petronio", "Petrosini", "Petrosino", "Petrotto", "Petrozza", "Petrozzi", "Petrozzo", "Petrucci", "Petruccio", "Petruzzelli", "Petruzzello", "Petruzzi", "Petruzzo", "Pettenati", "Petti", "Pettinari", "Pettinaro", "Pettinati", "Pettinato", "Pettirossi", "Pettirosso", "Petto", "Pettoni", "Pettorossi", "Pettorosso", "Petza", "Petzeu", "Pevere", "Peverelli", "Peveri", "Peverotto", "Peviani", "Peyrachia", "Pezzato", "Pezzella", "Pezzi", "Pezzia", "Pezzimenti", "Pezzini", "Pezzo", "Pezzoli", "Pezzolla", "Pezzolo", "Pezzoni", "Pezzotti", "Pfeifer", "Pia", "Piacentini", "Piacentino", "Piacenza", "Piacquadio", "Piagentini", "Piagneri", "Piana", "Pianezza", "Piani", "Piano", "Piantanida", "Piardi", "Pias", "Piatti", "Piaz", "Piazza", "Piazzalonga", "Piazzani", "Piazzardi", "Piazzella", "Piazzese", "Piazzesi", "Piazzetta", "Piazzi", "Piazzini", "Piazzo", "Piazzola", "Piazzolla", "Piazzoni", "Pica", "Picani", "Picano", "Picardi", "Picardo", "Picarella", "Picarello", "Picariello", "Picca", "Piccaluga", "Piccardi", "Piccardo", "Piccardoni", "Picchi", "Picchini", "Picchio", "Piccin", "Piccinelli", "Piccini", "Piccinin", "Piccinini", "Piccinino", "Piccinni", "Piccinno", "Piccino", "Piccione", "Piccioni", "Piccoli", "Piccolis", "Piccolo", "Piccolomini", "Piccone", "Piceno", "Picolli", "Picollo", "Pienig", "Pieniz", "Pieraccini", "Pierami", "Pierantoni", "Pierantonio", "Piergiovanni", "Pieri", "Pierini", "Pierluca", "Piero", "Pierobon", "Pierone", "Pieroni", "Pierorazio", "Pierotti", "Pierotto", "Pierro", "Pierucci", "Pietra", "Pietramale", "Pietrantoni", "Pietrantonio", "Pietrantuoni", "Pietrantuono", "Pietrasanta", "Pietri", "Pietro", "Pietroni", "Pietropaolo", "Pietrosante", "Pietrosanti", "Pietrosanto", "Pievani", "Pievano", "Pifferi", "Piga", "Piganzoli", "Pigazzi", "Pignatari", "Pignataro", "Pignatelli", "Pignone", "Pigozzi", "Pilati", "Pilato", "Pileci", "Pili", "Pilia", "Piliu", "Pilla", "Pillai", "Pillitteri", "Pillon", "Pilo", "Pilon", "Pilone", "Piloni", "Pilosu", "Pilota", "Piloti", "Pilotti", "Pilti", "Piludu", "Pilurzu", "Piluso", "Pilutzu", "Pin", "Pinci", "Pinella", "Pinelli", "Pinello", "Pini", "Pininfarina", "Pinna", "Pino", "Pinoli", "Pinoni", "Pinotti", "Pintacorona", "Pinto", "Pintomarro", "Pinton", "Pintus", "Pinzani", "Pinzano", "Pinzone", "Pinzoni", "Pioletti", "Pioli", "Piolini", "Pioltelli", "Piora", "Piovan", "Piovani", "Piovano", "Piovesan", "Piperis", "Piperno", "Pira", "Piraccini", "Pirali", "Piranda", "Pirandelli", "Pirandello", "Piras", "Pircher", "Piredda", "Pireddu", "Pirella", "Pirelli", "Pirodda", "Piroddi", "Piroddu", "Pirola", "Piron", "Pirone", "Piroscia", "Pirotta", "Pirotti", "Pirotto", "Pirovani", "Pirovano", "Pirovini", "Pirozzi", "Pirozzo", "Pirrello", "Pirretta", "Pirri", "Pirro", "Pirrotta", "Pisa", "Pisani", "Pisano", "Pisanu", "Pisaroni", "Pisati", "Piscedda", "Pischedda", "Pischeddu", "Pisciavino", "Pisciotta", "Pisco", "Piscopello", "Piscopiello", "Piscopo", "Piselli", "Piseri", "Piso", "Pissavini", "Pissetti", "Pistone", "Pistore", "Pistorelli", "Pistorello", "Pistori", "Pistorino", "Pistorio", "Pistritto", "Pisu", "Pitari", "Pitaro", "Pittalis", "Pittaluga", "Pittamiglio", "Pittarella", "Pittarello", "Pittari", "Pittaro", "Pitter", "Pitteri", "Pitto", "Pittorino", "Pitzalis", "Piu", "Piuma", "Piumi", "Piva", "Piverotto", "Pivirotto", "Pizzagalli", "Pizzala", "Pizzardo", "Pizzati", "Pizzato", "Pizzatti", "Pizzetti", "Pizzi", "Pizzicarola", "Pizzicaroli", "Pizzigoni", "Pizzimenti", "Pizzimento", "Pizzini", "Pizzo", "Pizzocchero", "Pizzochera", "Pizzochero", "Pizzocri", "Pizzol", "Pizzolati", "Pizzolato", "Pizzone", "Pizzoni", "Pizzorni", "Pizzorno", "Pizzul", "Pizzuti", "Pizzuto", "Placido", "Platania", "Plataroti", "Plateroti", "Plati", "Platinetti", "Platini", "Plutino", "Pochettino", "Podda", "Podenzani", "Podest\xC3\xA0", "Podetti", "Poerio", "Poggi", "Poggiato", "Poggio", "Poggioni", "Pogliaghi", "Pogliani", "Pogliano", "Pogna", "Pognani", "Pogni", "Poillucci", "Pol", "Pola", "Polcini", "Polcino", "Polegato", "Polella", "Polelli", "Polello", "Polesel", "Polet", "Poleto", "Poletti", "Poletto", "Poli", "Polimena", "Polimene", "Polimeni", "Polimeno", "Polin", "Polini", "Polino", "Politi", "Polito", "Poll", "Polla", "Pollam", "Pollastri", "Polledri", "Polletti", "Polli", "Pollini", "Pollo", "Polloni", "Polo", "Polonara", "Poloni", "Polonio", "Polucci", "Poluzzi", "Polverini", "Polverino", "Poma", "Pomarici", "Pomarico", "Pomi", "Pomiato", "Pomo", "Pompili", "Pompilio", "Pompilli", "Pomponi", "Pomponio", "Poncetti", "Poncia", "Pont", "Ponta", "Pontiggia", "Pontigia", "Pontoglio", "Pontremoli", "Ponzelli", "Ponzetta", "Ponzi", "Ponziani", "Ponziano", "Ponzinibbi", "Ponzio", "Ponzone", "Ponzoni", "Pooli", "Porati", "Porato", "Poratto", "Porcari", "Porcaro", "Porcedda", "Porceddu", "Porcelli", "Porchera", "Porcinari", "Porco", "Porcu", "Porfirio", "Porqueddu", "Porrato", "Porrini", "Porro", "Porru", "Porta", "Portelli", "Portello", "Portento", "Portinari", "Portinaro", "Porto", "Portonaro", "Porzio", "Positano", "Possenti", "Postini", "Postregna", "Potecchi", "Potenza", "Potere", "Potest\xC3\xA0", "Potestia", "Potestio", "Potz", "Pouli", "Povoli", "Poz", "Pozzaglia", "Pozzetti", "Pozzetto", "Pozzi", "Pozzo", "Pozzoli", "Pozzolo", "Pozzoni", "Prada", "Pradel", "Pradella", "Pradelli", "Praian\xC3\xB2", "Prandi", "Prandin", "Prandina", "Prandini", "Prandino", "Prando", "Prata", "Pratellesi", "Pratese", "Pratesi", "Prati", "Prato", "Pravettoni", "Preabianca", "Preatoni", "Prebianca", "Preci", "Preda", "Predieri", "Preganella", "Preganelli", "Preiano", "Preian\xC3\xB2", "Preitano", "Prejan\xC3\xB2", "Premessi", "Prencipe", "Presi", "Prestagiacomo", "Prestapino", "Preste", "Presti", "Prestia", "Prestianni", "Prestifilippo", "Prestigiacomo", "Prestigianni", "Prestigiovanni", "Prestipino", "Preta", "Prete", "Preti", "Previ", "Previte", "Previtera", "Previti", "Prevosti", "Prezzavento", "Prignano", "Primiceri", "Primieri", "Prina", "Principe", "Principi", "Princisvalle", "Princisvalli", "Princivalle", "Princivalli", "Prinelli", "Prinzio", "Prisco", "Privitera", "Priviteri", "Prizzon", "Pro", "Prochilo", "Procida", "Procopio", "Prodi", "Proietti", "Proietto", "Prola", "Prolo", "Properzi", "Properzio", "Prosdocimi", "Prosdocimo", "Protti", "Provana", "Provenza", "Provenzale", "Provenzali", "Provenzani", "Provenzano", "Prudente", "Prugnoli", "Pruner", "Pruneri", "Puccetti", "Pucci", "Puccini", "Puccio", "Pudda", "Puddu", "Puggioni", "Puglia", "Pugliese", "Pugliesi", "Puglioli", "Puglise", "Puglisi", "Pugni", "Pulci", "Pulcini", "Pulcino", "Pulega", "Pulicelli", "Pulici", "Pulisci", "Pulvirenti", "Puma", "Punzi", "Punzio", "Punzo", "Pusceddu", "Pusterla", "Putignano", "Putz", "Putzo", "Putzu", "Puz", "Puzzi", "Puzzillo", "Puzzo", "Puzzu", "Quaglia", "Quagliesi", "Quaglietti", "Quaglioni", "Quaini", "Quaranta", "Quarenghi", "Quarone", "Quaroni", "Quartarone", "Quartaroni", "Quartiani", "Quartieri", "Quarto", "Quassi", "Quassolo", "Quatela", "Quattrini", "Quattrocchi", "Quattrociocchi", "Queirolo", "Quer", "Querenghi", "Queri", "Quero", "Querques", "Querzola", "Quilici", "Quilico", "Quinque", "Quintarelli", "Quint\xC3\xA8", "Quinto", "Quirico", "Quirini", "Quirino", "Quisini", "Racar", "Raccar", "Raccaro", "Racchetti", "Raccis", "Rachini", "Rachino", "Radaelli", "Radi", "Radicchi", "Radice", "Radini", "Radino", "Rado", "Rafaldi", "Raffaglio", "Raffaldi", "Raffaldo", "Raggi", "Raggio", "Raggiotti", "Raggiotto", "Ragiotto", "Ragno", "Ragonese", "Ragonesi", "Ragusa", "Raguseo", "Ragusi", "Ragusin", "Ragusini", "Raguso", "Rai", "Raia", "Raimondi", "Raimondo", "Rain\xC3\xA8", "Raineri", "Rainoldi", "Raisi", "Rakar", "Ralli", "Rallo", "Ramagli", "Ramaglia", "Ramaglie", "Ramaioli", "Ramazzotti", "Ramelli", "Ramolivaz", "Ramoni", "Rampinelli", "Rampoldi", "Ramundo", "Rancati", "Randazzo", "Raneri", "Ranghetti", "Rangone", "Rangoni", "Ranieri", "Ranise", "Ranoldi", "Ranzani", "Rao", "Rapagnani", "Rapallo", "Raparelli", "Rapelli", "Rapetti", "Rapisarda", "Rapisardi", "Rapisardo", "Rasori", "Rassu", "Rastelli", "Rastellini", "Rastellino", "Rastello", "Rastiello", "Rastrelli", "Rastrello", "Ratta", "Ratti", "Rattichieri", "Rau", "Rava", "Ravagnan", "Ravagnani", "Ravagnin", "Ravagnini", "Ravanelli", "Ravanello", "Ravanetti", "Ravani", "Ravasi", "Ravazzani", "Ravazzini", "Ravegnani", "Ravelli", "Ravello", "Ravenna", "Ravenni", "Ravera", "Ravezzani", "Raviele", "Ravignani", "Ravizza", "Ravizzini", "Ravoni", "Razeti", "Razeto", "Rea", "Reale", "Reali", "Realini", "Reati", "Rebaudengo", "Rebizzi", "Rebizzo", "Rebughini", "Rebuzzi", "Rebuzzini", "Recagni", "Recalcati", "Reccagni", "Recco", "Recina", "Recine", "Redaelli", "Redavid", "Redigonda", "Redivo", "Redolfi", "Redondi", "Regazzetti", "Regazzi", "Regazzin", "Regazzini", "Regazzo", "Regazzola", "Regazzoni", "Reggiani", "Reggiardi", "Reggiardo", "Regiardo", "Regoli", "Regolo", "Regorda", "Reina", "Reineri", "Reinero", "Remersaro", "Remondi", "Remondini", "Remondino", "Renai", "Renazzi", "Renda", "Rende", "Rendina", "Rendini", "Reni", "Renier", "Renieri", "Reniero", "Renna", "Renne", "Renzi", "Repetti", "Repetto", "Repossi", "Repupilli", "Resa", "Rescaldina", "Rescigno", "Resconi", "Resegotti", "Resta", "Restelli", "Restivo", "Rettore", "Rettori", "Retus", "Retusi", "Revelant", "Revelli", "Revello", "Revere", "Reverzani", "Reyneri", "Reynero", "Rezoagli", "Rezzaghi", "Rezzoagli", "Ria", "Riavez", "Ribaudo", "Ribbisi", "Ribisi", "Ribola", "Riboldi", "Riboli", "Riboni", "Ricardi", "Ricardo", "Ricasoli", "Riccardi", "Riccardo", "Riccelli", "Riccetti", "Ricchi", "Ricchitelli", "Ricchiuti", "Ricchiuto", "Ricci", "Ricciardi", "Ricciardo", "Ricciarelli", "Ricciarello", "Riccio", "Ricciuti", "Ricciuto", "Ricco", "Ricc\xC3\xB2", "Riccobon", "Riccoboni", "Riccobono", "Riccobuono", "Riccucci", "Rice", "Ricetti", "Ricetto", "Richetta", "Richetti", "Richetto", "Ricotti", "Ricucci", "Riefoli", "Riefolo", "Rigamonti", "Rigano", "Rigante", "Riganti", "Riggio", "Riggione", "Righi", "Righini", "Rigon", "Rigone", "Rigoni", "Rigotti", "Rigotto", "Riguer", "Riina", "Rimedio", "Rimola", "Rimoldi", "Rimoli", "Rimolo", "Rimondi", "Rimondini", "Rimondo", "Rinaldelli", "Rinaldetti", "Rinaldi", "Rinaldin", "Rinaldini", "Rinaldino", "Rinaldis", "Rinaldo", "Rinaldoni", "Rinalducci", "Rinalduzzi", "Rinaudi", "Rinaudo", "Rineri", "Rinieri", "Rinoldi", "Rinuccini", "Rio", "Rioldi", "Rioli", "Riolo", "Ripamonti", "Ripari", "Ripoli", "Riponi", "Riscaldina", "Risi", "Riso", "Rispola", "Rispoli", "Rispolo", "Risso", "Rissolo", "Rissone", "Rita", "Ritorto", "Riva", "Rivadossi", "Rivalta", "Rivamonti", "Rivano", "Rivarola", "Rivera", "Rivero", "Rivetti", "Rivier", "Riviera", "Rivieri", "Riviero", "Rivoira", "Rivoiro", "Rivolta", "Rizza", "Rizzardi", "Rizzardini", "Rizzardo", "Rizzari", "Rizzati", "Rizzato", "Rizzetti", "Rizzetto", "Rizzi", "Rizzo", "Rizzoli", "Rizzolo", "Rizzotti", "Rizzotto", "Rizzuti", "Rizzuto", "Roani", "Roano", "Roasio", "Robbia", "Robbiani", "Robbiati", "Robbio", "Robecchi", "Roberti", "Robertone", "Robuffo", "Robustelli", "Robusti", "Robustini", "Roca", "Rocca", "Rocchi", "Rocco", "Roccon", "Rocconi", "Roda", "Rodolatti", "Rodrighi", "Rodrigo", "Rodrigues", "Rodriguez", "Rodriquez", "Roffi", "Roffo", "Rofrano", "Rogante", "Roganti", "Roggero", "Roggiani", "Roggiano", "Rognoni", "Roi", "Rolandi", "Rolando", "Rold", "Roldi", "Roldo", "Rolgi", "Romagnoli", "Roman", "Romanelli", "Romanello", "Romani", "Romaniello", "Romanin", "Romanini", "Romano", "Roman\xC3\xB2", "Romanoni", "Romei", "Romeo", "Romiti", "Romito", "Roncada", "Roncade", "Roncagli", "Roncaglia", "Roncaioli", "Roncalli", "Roncallo", "Roncaroli", "Roncarolo", "Roncati", "Roncato", "Ronchi", "Roncioni", "Roncolato", "Roncone", "Ronconi", "Roncoroni", "Rondana", "Rondani", "Rondanina", "Rondanini", "Rondanino", "Rondano", "Rondina", "Rondine", "Rondini", "Rondinini", "Rondino", "Rongioletti", "Ropolo", "Roppolo", "Rosa", "Rosalia", "Rosanova", "Rosari", "Rosaria", "Rosario", "Rosasco", "Rosati", "Rosato", "Roscigno", "Roscio", "Roselli", "Rosellini", "Rosi", "Rosolen", "Rosolino", "Rospigliosi", "Rossani", "Rossano", "Rossato", "Rosselli", "Rossellini", "Rossellino", "Rossello", "Rosset", "Rossetti", "Rossettini", "Rossetto", "Rossi", "Rossin", "Rossini", "Rossino", "Rosso", "Rossoni", "Rosucci", "Rota", "Rotelli", "Rotondi", "Rotta", "Rottoli", "Rovari", "Rovaris", "Rovarotto", "Rovasio", "Rovati", "Rovatti", "Roveda", "Rovegno", "Rovelli", "Rover", "Rovere", "Roveri", "Roversi", "Roverso", "Rovida", "Roviscalli", "Rovito", "Rozza", "Rozzarini", "Rozzi", "Rozzoni", "Rubano", "Rubanu", "Rubatti", "Rubattino", "Rubatto", "Rubbia", "Rubbiati", "Rubbio", "Rubin", "Rubini", "Rubino", "Rubuano", "Ruffini", "Ruffinoni", "Ruffo", "Rugger", "Ruggeri", "Ruggerini", "Ruggero", "Ruggerone", "Ruggeroni", "Ruggi", "Ruggieri", "Ruggiero", "Rugilo", "Rugoni", "Ruiu", "Rujo", "Rundeddu", "Ruotolo", "Ruozi", "Ruozzi", "Rupena", "Ruperti", "Ruperto", "Rusca", "Ruscone", "Rusconi", "Russi", "Russo", "Rustichelli", "Rustichello", "Ruta", "Rutelli", "Rutigliano", "Ruvolo", "Ruzza", "Ruzzante", "Ruzzanti", "Sabadini", "Sabatelli", "Sabatello", "Sabatini", "Sabatino", "Sabato", "Sabattoli", "Sabbadini", "Sabbatelli", "Sabbatini", "Sabbatino", "Sabbioni", "Sabella", "Sabidussi", "Sabini", "Sabino", "Sacc\xC3\xA0", "Saccardi", "Saccardo", "Saccaro", "Sacchetti", "Sacchi", "Sacchinelli", "Sacchini", "Sacchino", "Sacco", "Saccoman", "Saccomani", "Saccomanni", "Saccomanno", "Saccomano", "Saccon", "Sacconi", "Sacerdote", "Sacerdoti", "Saggina", "Sagginella", "Sagginelli", "Saggini", "Saggino", "Sagina", "Sagini", "Sailis", "Saini", "Sala", "Saladino", "Salafia", "Salamon", "Salamone", "Salamoni", "Salanitri", "Salanitro", "Salaris", "Salati", "Sale", "Salemi", "Salerni", "Salernitano", "Salerno", "Salis", "Sallusti", "Sallustio", "Salmistraro", "Salmoiraghi", "Salmoirago", "Salnitri", "Salnitro", "Salomon", "Salomone", "Salomoni", "Salpetra", "Salpetri", "Salpetro", "Salpietra", "Salpietro", "Saltaformaggio", "Salv\xC3\xA0", "Salvadei", "Salvadeo", "Salvaderi", "Salvador", "Salvadore", "Salvadori", "Salvalalio", "Salvaneschi", "Salvaterra", "Salvati", "Salvato", "Salvatore", "Salvatori", "Salvemini", "Salvestrini", "Salvi", "Salviati", "Salviato", "Salvidio", "Salvini", "Salvischiani", "Salvo", "Salvucci", "Samarati", "Sambataro", "Sambiagio", "Sammarco", "Sammartano", "Sammataro", "Sampieri", "Sampietro", "Sanbiagio", "Sandon\xC3\xA0", "Sandonini", "Sandonnini", "Sandra", "Sandri", "Sandrin", "Sandrini", "Sandro", "Sandulli", "Sanese", "Sanesi", "Sanfrancesco", "Sanfratello", "Sangalli", "Sangervasi", "Sangervasio", "Sangion", "Sangiorgi", "Sangiorgio", "Sanguineti", "Sanguinetti", "Sanitate", "Sanna", "Sannella", "Sannelli", "Sanneris", "Sannini", "Sannino", "Sanpietro", "Sansalvadore", "Sansalvatore", "Sanson", "Sansone", "Sansonetti", "Sansonetto", "Sansoni", "Santa", "Santacroce", "Santaera", "Santagata", "Santagati", "Santagostino", "Santamaria", "Santambrogio", "Santangelo", "Santanocito", "Santapaola", "Santarelli", "Santarossa", "Santececca", "Santella", "Santi", "Santia", "Santi\xC3\xA0", "Santin", "Santini", "Santino", "Santinon", "Santo", "Santon", "Santonastaso", "Santone", "Santoni", "Santonocito", "Santoro", "Santucci", "Santuccio", "Santus", "Sanvito", "Sanza", "Sanzeni", "Sanzi", "Sanzo", "Sanzogni", "Sanzogno", "Sapia", "Sapio", "Saponara", "Saponaro", "Sara", "Saracchi", "Saracco", "Saraceni", "Saraceno", "Saracini", "Saracino", "Sarchi", "Sarci", "Sarc\xC3\xAC", "Sardano", "Sardara", "Sardella", "Sardi", "Sardina", "Sardini", "Sardino", "Sardo", "Saresani", "Sargentelli", "Sargenti", "Sarno", "Sarotti", "Sarotto", "Sarra", "Sarritzu", "Sarro", "Sartarelli", "Sartelli", "Sarti", "Sartini", "Sartino", "Sartirana", "Sartirani", "Sarto", "Sartor", "Sartore", "Sartorelli", "Sartori", "Sartorio", "Saruggia", "Sarzola", "Sassi", "Sasso", "Sassone", "Sassoni", "Sassu", "Sauda", "Savasta", "Savastano", "Savella", "Savelli", "Savello", "Savi", "Savia", "Saviani", "Saviano", "Savini", "Savio", "Savioli", "Savioni", "Savoia", "Savoldelli", "Savoldi", "Savorelli", "Sbaragli", "Sbaraglia", "Sbaraglio", "Sbardella", "Sbardellati", "Sbarzi", "Sberna", "Sberviglieri", "Sbrana", "Sbrozi", "Scaccabarozzi", "Scacchi", "Scaccia", "Scaccini", "Scacco", "Scaffidi", "Scafidi", "Scaglia", "Scaglione", "Scala", "Scalcione", "Scalese", "Scalesi", "Scalfari", "Scalfaro", "Scalise", "Scalisi", "Scalmani", "Scalvini", "Scalzi", "Scalzo", "Scalzone", "Scambiali", "Scambiati", "Scamoni", "Scampitelli", "Scanarotti", "Scancarello", "Scandella", "Scandellari", "Scandelli", "Scandiani", "Scandurra", "Scannapieco", "Scannapiecoro", "Scannarotti", "Scano", "Scantamburlo", "Scanu", "Scanzani", "Scanzano", "Scapigliati", "Scapin", "Scapini", "Scapino", "Scappin", "Scappini", "Scappino", "Scarabella", "Scarabelli", "Scarabello", "Scarafone", "Scarafoni", "Scaramel", "Scaramella", "Scaramelli", "Scaramello", "Scarano", "Scaravelli", "Scaravetti", "Scaravetto", "Scarcella", "Scarcelli", "Scarfi", "Scarf\xC3\xAC", "Scarfo", "Scarf\xC3\xB2", "Scariati", "Scarioni", "Scariot", "Scarlata", "Scarlato", "Scarlatti", "Scarlatto", "Scarone", "Scaroni", "Scarpa", "Scarpella", "Scarpelli", "Scarpellini", "Scarpello", "Scarpini", "Scarpulla", "Scarrafoni", "Scarsi", "Scarso", "Scartezzini", "Scarzi", "Scarzo", "Scattone", "Scattoni", "Scavolini", "Scavuzzo", "Scazzoli", "Scazzosi", "Scazzoso", "Schembri", "Schetti", "Schettini", "Schettino", "Schiaffino", "Schiano", "Schiatti", "Schiavi", "Schiavini", "Schiavo", "Schiavoi", "Schiavon", "Schiavone", "Schiavoni", "Schiepati", "Schiepatti", "Schieppati", "Schifani", "Schifano", "Schillaci", "Schino", "Schipa", "Schipani", "Schiratti", "Schiratto", "Schir\xC3\xB2", "Schiros", "Schirripa", "Schisani", "Schisano", "Schivardi", "Schivo", "Sciacca", "Sciaccaluga", "Scial\xC3\xB2", "Scialpi", "Sciancalepore", "Sciancalepre", "Sciannamblo", "Sciara", "Sciarra", "Sciascia", "Scibetta", "Scicli", "Sciclone", "Scicolone", "Scida", "Scilini", "Scimonelli", "Scimonello", "Sciortino", "Sciorto", "Scioscia", "Scivetti", "Sclano", "Scoglio", "Scognamiglio", "Scola", "Scolari", "Scolaris", "Scollo", "Scolz", "Sconfietti", "Scoppio", "Scordia", "Scordio", "Scordo", "Scorletti", "Scornaienchi", "Scorpio", "Scorpo", "Scorza", "Scorzelli", "Scorzo", "Scotti", "Scotto", "Scrittore", "Scrittori", "Scrivani", "Scucchia", "Scudera", "Scuderi", "Scudero", "Scudieri", "Scudiero", "Scurati", "Scuratti", "Scurci", "Scuri", "Scuteri", "Scuto", "Sebastiani", "Sebastiano", "Secchi", "Secci", "Secciani", "Sech", "Sechi", "Secoli", "Secolo", "Secondi", "Secondo", "Seculin", "Seculini", "Securi", "Securo", "Sedati", "Sedran", "Sedrani", "Segagni", "Segalini", "Seggio", "Seghieri", "Seghizzi", "Segnan", "Seguin", "Seidner", "Selini", "Selis", "Sella", "Sellari", "Sellaro", "Selleri", "Selmi", "Selmo", "Selva", "Selvaggi", "Selvaggio", "Sembeni", "Sembenico", "Sembenotti", "Sementa", "Semeraro", "Seminara", "Seminari", "Sena", "Senarega", "Senatore", "Senatori", "Senes", "Senna", "Sentinelli", "Sepe", "Sepi", "Sepio", "Seppi", "Serafini", "Seragni", "Seragnoli", "Serallegri", "Serangeli", "Serangelo", "Serao", "Serati", "Seravalle", "Seravalli", "Serbelloni", "Seregni", "Seren", "Serena", "Serenella", "Serenelli", "Sereni", "Sereno", "Serfilippi", "Serino", "Serio", "Sernese", "Sernesi", "Sernicola", "Serpici", "Serpico", "Serra", "Serradimigni", "Serrao", "Serrati", "Serrato", "Serratto", "Serravalle", "Servelli", "Servello", "Servente", "Serventi", "Servida", "Servidati", "Servilli", "Servillo", "Sessa", "Sessarego", "Sessegolo", "Sessi", "Sesso", "Sestini", "Setta", "Setti", "Settimi", "Settimio", "Setto", "Settura", "Severgnini", "Severi", "Severini", "Severino", "Severo", "Seveso", "Sferra", "Sfogliarini", "Sfolcini", "Sfondrini", "Sforza", "Sgalippa", "Sgambati", "Sgaramella", "Sgaramelli", "Sgarbi", "Sgargi", "Sgarzi", "Sgherri", "Sgobbi", "Sgro", "Sgr\xC3\xB2", "Sgroi", "Sguerri", "Siani", "Siano", "Sibaldi", "Sibani", "Siboni", "Sibra", "Sica", "Sicari", "Siccardi", "Siccardo", "Sichieri", "Sicignano", "Siciliani", "Siciliano", "Sicuteri", "Siddi", "Sidoti", "Siena", "Sighieri", "Sighinolfi", "Signori", "Signorini", "Sigotti", "Silani", "Silano", "Silanus", "Silini", "Silipo", "Silla", "Silva", "Silvaggio", "Silvestra", "Silvestre", "Silvestri", "Silvestro", "Simaz", "Simbeni", "Simeone", "Simeoni", "Simi", "Simina", "Simini", "Simino", "Simion", "Simionati", "Simionato", "Simione", "Simioni", "Simon", "Simonazzi", "Simoncelli", "Simoncini", "Simone", "Simonelli", "Simonetti", "Simoni", "Simonini", "Sinagoga", "Sinatra", "Sinibaldi", "Sion", "Sione", "Sioni", "Siri", "Sirignano", "Siro", "Sirone", "Sironi", "Sisenna", "Sisinna", "Sisinni", "Sisinno", "Sisti", "Sisto", "Sistu", "Siverio", "Sivier", "Sivieri", "Siviero", "Sivori", "Soardi", "Soardo", "Soave", "Sobatti", "Sobrero", "Soccol", "Soffiantini", "Soffiati", "Soffiatti", "Soffientini", "Soffritti", "Soggiri", "Sogni", "Soldano", "Soldati", "Soldi", "Soldini", "Soldo", "Solimando", "Solimeo", "Solinas", "Solito", "Sollai", "Somarelli", "Somaschi", "Somaschini", "Somasco", "Somenzi", "Somma", "Sommariva", "Sommavilla", "Soncini", "Soncino", "Sonda", "Sonvico", "Sonzogni", "Sonzogno", "Sora", "Soranzo", "Sorba", "Sorbi", "Sorbino", "Sorbo", "Sorcinelli", "Soregaroli", "Soresi", "Soresina", "Soresini", "Sorgon", "Sorice", "Soriente", "Sormani", "Soro", "Sorrenti", "Sorrentino", "Sorrento", "Soru", "Sorvino", "Sosio", "Sottile", "Sottura", "Sozzi", "Spaccatrosi", "Spada", "Spadaccini", "Spadafora", "Spadavecchia", "Spadini", "Spadoni", "Spadotto", "Spaghi", "Spagliardi", "Spagna", "Spagnoli", "Spagnolo", "Spagnuolo", "Spalma", "Spanalatte", "Spano", "Span\xC3\xB2", "Spanu", "Sparacello", "Spazzadeschi", "Specchia", "Spediacci", "Spelta", "Spera", "Sperandio", "Speranza", "Sperduti", "Sperduto", "Speri", "Speriani", "Sperlecchi", "Speziga", "Spezio", "Spezzaferri", "Spezzaferro", "Spicciariello", "Spiezie", "Spiezio", "Spina", "Spinaci", "Spinas", "Spinazzi", "Spinazzola", "Spinella", "Spinelli", "Spinello", "Spinetta", "Spinetti", "Spinetto", "Spini", "Spinola", "Spinosa", "Spinosi", "Spinoso", "Spinozzi", "Spiota", "Spiotta", "Spiotti", "Spiridione", "Spiridioni", "Spitalere", "Spitaleri", "Spitaliere", "Spitalieri", "Spizzi", "Spoldi", "Spolti", "Sponchiado", "Sporchia", "Sportelli", "Sportello", "Spotorno", "Spreafichi", "Spreafico", "Sprela", "Squillace", "Squizzato", "Stabile", "Stagnari", "Staiti", "Staltari", "Stalteri", "Stambogli", "Stamboglis", "Stamboli", "Stampa", "Stanboglis", "Stanco", "Stangalini", "Stangalino", "Stanghellini", "Starace", "Staraci", "Stazio", "Stefana", "Stefanacci", "Stefanazzi", "Stefan\xC3\xA8", "Stefanel", "Stefanelli", "Stefanello", "Stefani", "Stefanini", "Stefano", "Stefanon", "Stefanoni", "Stefanutti", "Stella", "Stellari", "Stellario", "Stellaro", "Stellati", "Stellato", "Stellina", "Stellini", "Stellino", "Stevan", "Stia", "Stigliani", "Stigliano", "Stillante", "Stillanti", "Stocchetti", "Stocchi", "Stocco", "Stochino", "Stoppa", "Stoppani", "Storace", "Storaci", "Storri", "Storti", "Stracchi", "Stracquadagno", "Stracquadanio", "Stracqualursi", "Strada", "Stradiotti", "Stradiotto", "Strafforelli", "Strafforello", "Stragazzi", "Stramaccioni", "Strangi", "Strangio", "Strianese", "Striano", "Stridi", "Stroppa", "Stroppari", "Strozzi", "Stucchi", "Stucco", "Stupia", "Stuppa", "Stuppani", "Stuppia", "Stura", "Sturiale", "Sturla", "Stuto", "Suailis", "Suardi", "Succu", "Sudati", "Sulis", "Summa", "Suprani", "Surdo", "Susani", "Susanni", "Suzzani", "Sverberi", "Svizzero", "Tabarelli", "Tabarri", "Tacca", "Taccari", "Tacchi", "Tacchinardi", "Tacchini", "Tacchino", "Tacci", "Taccoli", "Taccon", "Taccone", "Tacconi", "Tadd\xC3\xA8", "Taddei", "Taddeo", "Tad\xC3\xA8", "Tadei", "Tadeo", "Tadiello", "Tadiotto", "Tafani", "Taffarel", "Taffarelli", "Taffarello", "Taffuri", "Tafuri", "Taggiasco", "Tagiasco", "Tagliabue", "Tagliacozzi", "Tagliacozzo", "Tagliaferri", "Tagliaferro", "Tagliafierro", "Taglialapietra", "Taglialatela", "Tagliapietra", "Tagliapietre", "Tagliati", "Tagliavia", "Tagliavini", "Tagliazucchi", "Taglieri", "Taiani", "Taibbi", "Taibi", "Taini", "Taino", "Taiocchi", "Tajani", "Tajocchi", "Talami", "Talamini", "Talarico", "Talevi", "Taliaferri", "Tallarico", "Tallevi", "Taloni", "Tam", "Tamagni", "Tamagno", "Tamansi", "Tamanti", "Tamantini", "Tamanzi", "Tamborini", "Tamborino", "Tamburi", "Tamburini", "Tamburino", "Tamburo", "Tamburri", "Tamburro", "Tam\xC3\xA8", "Tamelli", "Tamiazzo", "Tammaro", "Tamone", "Tamoni", "Tamurri", "Tancredi", "Tani", "Tanini", "Tanino", "Tano", "Tansini", "Tanzer", "Tanzi", "Tanzillo", "Tanzini", "Taormina", "Tarabella", "Tarabelli", "Tarabello", "Taralli", "Tarallo", "Tarantino", "Taranto", "Tararan", "Taravella", "Taravelli", "Taravello", "Tarchiani", "Tardini", "Tardivi", "Tardivo", "Tardy", "Tarenzi", "Taribella", "Taribelli", "Taribello", "Taricco", "Tarigo", "Tarizzo", "Tarozzo", "Tarquini", "Tarquinio", "Tartaglia", "Tascini", "Tasin", "Tassara", "Tassari", "Tassaro", "Tassi", "Tassinari", "Tassistro", "Tasso", "Tassone", "Tassoni", "Tatangeli", "Tatangelo", "Tatulli", "Tavano", "Tavanti", "Tavazzi", "Taveggia", "Tavella", "Tavelli", "Taveri", "Taverna", "Taverni", "Tavernini", "Taverno", "Tazzari", "Tealdi", "Teani", "Teatino", "Tebaldi", "Tecce", "Tecchi", "Tecchio", "Tecci", "Teci", "Tedaldi", "Tedeschi", "Tedesco", "Tedoldi", "Tedoldini", "Tegner", "Tela", "Telese", "Telesio", "Teli", "Tellitocci", "Telloli", "Temporali", "Tenani", "Tenchiri", "Tenconi", "Tendas", "Tentori", "Teobaldi", "Teoldi", "Teotino", "Terenghi", "Terenzi", "Terenzio", "Terlizzi", "Termine", "Terracciano", "Terracina", "Terracini", "Terranova", "Terranuova", "Terrenghi", "Teruzzi", "Terzaghi", "Terzago", "Terzi", "Terzini", "Terzo", "Terzoni", "Terzuoli", "Terzuolo", "Tessarin", "Tessaroli", "Tessarolo", "Tessera", "Testa", "Testacci", "Testadiferro", "Testaferrata", "Testagrossa", "Testaguzza", "Testaverde", "Testi", "Testina", "Testini", "Testino", "Testoni", "Testori", "Testorio", "Tetta", "Tettamanti", "Tettamanzi", "Tezzele", "The", "Thun", "Tiberi", "Tiberio", "Tibollo", "Tidili", "Tidu", "Tierno", "Tiezzi", "Tilocca", "Tinti", "Tintori", "Tiozzo", "Tiralongo", "Tiranzoni", "Tirelli", "Tirinzoni", "Tirone", "Tironi", "Tivegna", "Toaiar", "Toaiari", "Toajar", "Toajari", "Tocco", "Toce", "Todari", "Todaro", "Todde", "Toderi", "Todero", "Todisco", "Todon", "Todone", "Todoni", "Tofani", "Tofano", "Toffali", "Toffanetti", "Toffanin", "Toffanini", "Toffoli", "Toffolo", "Tognetti", "Tognetto", "Togni", "Tognin", "Tognini", "Tognutti", "Toja", "Tola", "Toldo", "Toledo", "Toletti", "Tolledi", "Tollini", "Tolomei", "Tolomeo", "Tolomi", "Tolotti", "Tolotto", "Tolu", "Tomarchio", "Tomaselli", "Tomasello", "Tomasi", "Tomasich", "Tomasini", "Tomasino", "Tomassini", "Tombesi", "Tombolato", "Tomei", "Tomeo", "Tomio", "Tomiotti", "Tomiotto", "Tommaselli", "Tommasello", "Tommasi", "Tommasini", "Tommasino", "Tommaso", "Tommassini", "Tona", "Tonani", "Tonarelli", "Tonella", "Tonelli", "Toni", "Toninelli", "Tonioli", "Toniolo", "Tonoli", "Tonon", "Tonucci", "Torassa", "Toregiani", "Torelli", "Toribio", "Tormen", "Tormene", "Tornese", "Tornesi", "Tornielli", "Torno", "Tornusciolo", "Torrassa", "Torre", "Torreggiani", "Torregiani", "Torres", "Torresan", "Torresani", "Torretta", "Torretti", "Torri", "Torriani", "Torrisi", "Torti", "Tortora", "Tortorella", "Torza", "Tosa", "Tosati", "Tosato", "Tosatti", "Tosatto", "Tosca", "Toscan", "Toscana", "Toscanelli", "Toscanese", "Toscanesi", "Toscani", "Toscanini", "Toscanino", "Toscano", "Toschi", "Tosco", "Toselli", "Tosello", "Tosetti", "Tosetto", "Tosi", "Tosin", "Tosini", "Tosino", "Toso", "Tosolin", "Tosolini", "Tosolino", "Toson", "Tosone", "Tosoni", "Tossuti", "Tosti", "Tosto", "Tota", "Totaro", "Toti", "Totti", "Tovagliari", "Tovani", "Tovi", "Tovini", "Tovo", "Toxiri", "Tozzi", "Trabalza", "Trabucchi", "Trabucco", "Traina", "Traini", "Trainini", "Traino", "Traisci", "Tramontana", "Tramontani", "Tramontano", "Tramonte", "Tramonti", "Tramontin", "Tramontini", "Trani", "Trapani", "Trapattoni", "Trap\xC3\xA8", "Trasforini", "Trasi", "Trasino", "Travagli", "Travaglia", "Travaglio", "Traversi", "Traversini", "Traversino", "Traverso", "Trebaldi", "Treccani", "Tregattini", "Treglia", "Tremea", "Tremolada", "Tremolaterra", "Tremonte", "Tremonti", "Trenti", "Trentin", "Trentini", "Trento", "Trequattrini", "Tres", "Tresoldi", "Treu", "Treves", "Trevisan", "Trevisani", "Trezza", "Trezzi", "Tricarico", "Tricerri", "Trida", "Triggiani", "Triggiano", "Triglia", "Trigoso", "Trimarchi", "Trimarco", "Trinca", "Trinchi", "Trinchitella", "Tripi", "Tripicchio", "Triulcio", "Triulzi", "Triulzio", "Trivellato", "Trivulzio", "Trocello", "Trogu", "Troia", "Troiani", "Troiano", "Troilo", "Troise", "Troisi", "Troisio", "Troja", "Trolese", "Trolesi", "Trolio", "Trombadore", "Trombadori", "Trombatore", "Trombini", "Tromby", "Troncato", "Tronchin", "Troncon", "Tronconi", "Tropea", "Trosino", "Trova", "Trovarelli", "Trovarello", "Trovato", "Troya", "Truffi", "Truffo", "Truisi", "Trupiano", "Tucceri", "Tucci", "Tuccia", "Tuccio", "Tuci", "Tucio", "Tudisco", "Tufanisco", "Tufi", "Tufo", "Tugnoli", "Tugnolo", "Tulli", "Tullio", "Tullo", "Tumello", "Tumiati", "Tummolo", "Tunioli", "Tuniz", "Tuoti", "Tuoto", "Tuozzi", "Tuozzo", "Tupputi", "Tura", "Turatello", "Turati", "Turato", "Turatti", "Turba", "Turchetta", "Turchetti", "Turchetto", "Turchi", "Turcino", "Turcinovich", "Turco", "Turcone", "Turconi", "Turel", "Turella", "Turelli", "Turello", "Turi", "Turiello", "Turin", "Turina", "Turini", "Turino", "Turle", "Turletti", "Turletto", "Turnisi", "Turone", "Turoni", "Turotti", "Turra", "Turrer", "Turri", "Turrina", "Turrini", "Turrino", "Turrisi", "Turro", "Tuscano", "Tussi", "Tuti", "Tuzi", "Tuzio", "Tuzza", "Tuzzi", "Tuzzio", "Tuzzo", "Ubaldi", "Ubaldini", "Ubalducci", "Ubbiali", "Uberti", "Ubertini", "Ubertino", "Uberto", "Ubiali", "Uboldi", "Uccelli", "Uccheddu", "Ucchino", "Ugazio", "Ugg\xC3\xA8", "Uggeri", "Uggetti", "Ugolini", "Ugolino", "Ugoni", "Ulemi", "Ulivi", "Ulli", "Unali", "Ungaro", "Urbani", "Urbano", "Urbinati", "Urbini", "Urbisaglia", "Urgu", "Urpi", "Urriani", "Urriano", "Ursi", "Ursini", "Ursino", "Urso", "Ursone", "Urzi", "Urzini", "Urzo", "Usai", "Useglio", "Useli", "Usigli", "Usseglio", "Utzeri", "Uzzi", "Vacalebre", "Vacca", "Vaccarezza", "Vaccari", "Vaccarini", "Vaccaro", "Vaccaroni", "Vacondio", "Vaghetti", "Vaghi", "Vaglio", "Vaiani", "Vailati", "Vairetti", "Vairetto", "Vairo", "Vajna", "Valania", "Valbuzzi", "Valcarenghi", "Valcasali", "Valdameri", "Valdemarin", "Valena", "Valenari", "Valent", "Valente", "Valenti", "Valentini", "Valentino", "Valenza", "Valenzi", "Valenzia", "Valenziano", "Valeri", "Valeria", "Valeriana", "Valeriani", "Valeriano", "Valerio", "Valesi", "Valgolio", "Valiante", "Valianti", "Vallarini", "Vallarino", "Valle", "Vallebona", "Valletta", "Valli", "Vallisneri", "Valori", "Valpreda", "Valsecchi", "Valseriati", "Valtancoli", "Valtorta", "Valz", "Vanazzi", "Vangi", "Vanini", "Vanni", "Vannicola", "Vannini", "Vannino", "Vannone", "Vannoni", "Vannucci", "Vannuccini", "Vanone", "Vanoni", "Vanz", "Vanza", "Vanzetti", "Vanzetto", "Vanzi", "Vanzin", "Vanzini", "Vanzo", "Vanzulli", "Varalli", "Varallo", "Varana", "Varanelli", "Varani", "Varano", "Vardanega", "Vardiero", "Varesi", "Vargiu", "Varipapa", "Varischetti", "Varischi", "Varisco", "Varner", "Varone", "Varriale", "Varricchio", "Vasconi", "Vascotto", "Vasetti", "Vasi", "Vasile", "Vasini", "Vasino", "Vassalli", "Vassallo", "Vassetta", "Vassetti", "Vasta", "Vecchi", "Vecchini", "Vecchio", "Vecchione", "Vecchioni", "Vecchiotti", "Vedda", "Vedova", "Vedovati", "Vedovato", "Vedovelli", "Vedovello", "Velardi", "Velardo", "Veleno", "Velenosi", "Vella", "Venchiarutti", "Venditti", "Venditto", "Vendrame", "Vendrami", "Vendramin", "Vendramini", "Vendruscolo", "Venere", "Veneri", "Veneziani", "Venier", "Venneri", "Ventre", "Ventrice", "Ventrici", "Ventricini", "Ventriglia", "Ventriglio", "Ventura", "Venturella", "Venturelli", "Venturello", "Venturi", "Venturin", "Venturini", "Venturino", "Venturoli", "Venuto", "Venza", "Veranoli", "Verardi", "Verardo", "Vercellese", "Vercellesi", "Vercelli", "Verda", "Verde", "Verdelli", "Verderio", "Verdi", "Verga", "Vergani", "Vergari", "Vergillito", "Vergori", "Verlengia", "Vernaccia", "Vernassa", "Vernazza", "Verola", "Veroli", "Verolo", "Verona", "Veronelli", "Veronese", "Veronesi", "Veronica", "Verrando", "Verrazzani", "Verri", "Verrua", "Versace", "Vertemati", "Verticale", "Vertola", "Verza", "Vesce", "Veschi", "Vescia", "Vesco", "Vescovi", "Vescovo", "Vespa", "Vespe", "Vespi", "Vespo", "Vespucci", "Vettori", "Vezza", "Vezzani", "Vezzari", "Vezzaro", "Vezzoni", "Vezzosi", "Viadana", "Vialardi", "Vianella", "Vianelli", "Vianello", "Viani", "Viano", "Vicari", "Vicario", "Vicentin", "Vicentini", "Vicinanza", "Vicini", "Vico", "Vidali", "Vidon", "Vidoni", "Vieri", "Viero", "Vietri", "Vigani", "Vigano", "Vigan\xC3\xB2", "Viggiani", "Viggiano", "Vighi", "Vigli", "Viglia", "Viglini", "Viglino", "Viglio", "Vigna", "Vignali", "Vignati", "Vignato", "Vignazia", "Vigne", "Vignogna", "Vignola", "Vignole", "Vignoli", "Vignolo", "Vigo", "Vigogna", "Vigon", "Vigone", "Vigoni", "Vigorelli", "Vilardi", "Vilardo", "Villa", "Villaggio", "Villan", "Villani", "Villano", "Villanova", "Villar", "Villari", "Villas", "Villaz", "Villi", "Villini", "Villino", "Villis", "Villoresi", "Villotti", "Vimercati", "Vinattieri", "Vincenza", "Vincenzi", "Vincenzo", "Vinci", "Vinciguerra", "Vincis", "Vio", "Viola", "Violante", "Violanti", "Violetti", "Violi", "Violin", "Violini", "Violo", "Violoni", "Viotti", "Viotto", "Virga", "Virgillito", "Virgola", "Viroli", "Virtuani", "Virzi", "Virzio", "Virzo", "Visco", "Visconti", "Viscontini", "Viscontino", "Visentin", "Visentini", "Visigalli", "Visintin", "Visintini", "Vismara", "Vissani", "Vita", "Vitagliani", "Vitagliano", "Vitale", "Vitali", "Vitaliani", "Vitaliano", "Vitalini", "Vitalone", "Vitaloni", "Vitari", "Vitelleschi", "Vitelli", "Vitellio", "Vitello", "Vitellozzi", "Viti", "Vitiello", "Vito", "Vitti", "Vittoriano", "Vivaldi", "Vivaldini", "Vivaldo", "Vivardi", "Viventi", "Vivenza", "Vivenzi", "Vivenzio", "Viviani", "Vizio", "Vodopivec", "Volo", "Volonghi", "Volont\xC3\xA8", "Volpe", "Volpi", "Volpicella", "Volpini", "Volpino", "Volpon", "Volpone", "Volponi", "Voltolina", "Voltolini", "Vorabbi", "Vulcano", "Vulpetti", "Vulpis", "Zaccagni", "Zaccagnini", "Zaccagnino", "Zaccagno", "Zaccara", "Zaccaria", "Zacchetti", "Zacchetto", "Zacchi", "Zaccone", "Zacconi", "Zadra", "Zadro", "Zaffarese", "Zaggia", "Zaghi", "Zago", "Zagorda", "Zagordi", "Zagordo", "Zagotto", "Zaino", "Zaliani", "Zaltron", "Zamana", "Zamara", "Zamarchi", "Zamarco", "Zamaro", "Zamataro", "Zamati", "Zambarbieri", "Zambataro", "Zambelli", "Zambito", "Zamboni", "Zambotti", "Zambotto", "Zambrotta", "Zammataro", "Zammuto", "Zampa", "Zamparese", "Zampati", "Zampatti", "Zampedri", "Zampella", "Zamperetti", "Zampieri", "Zampito", "Zampol", "Zampoli", "Zampolla", "Zampolo", "Zamproni", "Zamprotta", "Zamuner", "Zan", "Zanaboni", "Zanardelli", "Zanardi", "Zanardo", "Zanatta", "Zanca", "Zanchet", "Zanchetta", "Zanchetti", "Zanchetto", "Zanchi", "Zanchini", "Zanco", "Zandomeneghi", "Zandomenego", "Zandonella", "Zandonini", "Zaneletti", "Zanella", "Zanelli", "Zanello", "Zanelotti", "Zanette", "Zanetti", "Zanfi", "Zanfini", "Zanfino", "Zangani", "Zangara", "Zangrande", "Zangrandi", "Zangrando", "Zani", "Zanichelli", "Zanigni", "Zanin", "Zaninelli", "Zaninetti", "Zanini", "Zanino", "Zanni", "Zanon", "Zanoncelli", "Zanoncini", "Zanoni", "Zanotti", "Zantedeschi", "Zanuccoli", "Zappa", "Zappacosta", "Zappal\xC3\xA0", "Zappale", "Zappavigna", "Zappelli", "Zappia", "Zappulla", "Zaramella", "Zarantonello", "Zari", "Zaro", "Zarotti", "Zarzana", "Zatta", "Zavatta", "Zavattari", "Zavattaro", "Zavatteri", "Zavattero", "Zavattin", "Zavattini", "Zazzara", "Zazzaro", "Zazzaroni", "Zazzeri", "Zazzero", "Zazzeroni", "Zecca", "Zecchi", "Zecchin", "Zecchini", "Zeccoli", "Zedda", "Zeini", "Zelca", "Zelli", "Zelmi", "Zelmo", "Zema", "Zen", "Zendrini", "Zener", "Zeneri", "Zenerin", "Zeni", "Zennaro", "Zeno", "Zeoli", "Zeppa", "Zeppi", "Zeppilli", "Zeppillo", "Zeppo", "Zepponi", "Zerbelloni", "Zerbi", "Zerbini", "Zerbino", "Zetti", "Zian", "Ziani", "Ziano", "Zibordi", "Zicola", "Zigliani", "Ziglioli", "Zili", "Ziliani", "Zilio", "Zilli", "Zillino", "Zillio", "Zillitto", "Zillo", "Zimelli", "Zinetti", "Zingarella", "Zingarelli", "Zingarello", "Zingaro", "Zini", "Zinno", "Ziravello", "Zita", "Zito", "Ziveri", "Zivieri", "Zizza", "Zocca", "Zocchi", "Zocco", "Zoccola", "Zoccolante", "Zoccolanti", "Zoia", "Zol", "Zola", "Zolfanelli", "Zoncada", "Zoppi", "Zora", "Zoratti", "Zordan", "Zordani", "Zorza", "Zorzan", "Zorzati", "Zorzato", "Zorzenon", "Zorzenone", "Zorzenoni", "Zorzet", "Zorzetti", "Zorzetto", "Zorzi", "Zorzin", "Zotti", "Zottin", "Zottini", "Zottis", "Zotto", "Zuan", "Zuanella", "Zuanelli", "Zuani", "Zucca", "Zuccal\xC3\xA0", "Zuccarelli", "Zuccarello", "Zuccatelli", "Zuccatosta", "Zucchelli", "Zucchetti", "Zucchi", "Zucco", "Zuccotti", "Zuffada", "Zuffellato", "Zuffetti", "Zulian", "Zuliani", "Zuliano", "Zulli", "Zullian", "Zulliani", "Zullino", "Zullo", "Zumbo", "Zummo", "Zuncheddu", "Zuppa", "Zurri", "Zurrida", "Zurro", "Zurru"]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["encoding/binary"] = (function() {
	var $pkg = {}, $init, errors, io, math, reflect, overflow;
	errors = $packages["errors"];
	io = $packages["io"];
	math = $packages["math"];
	reflect = $packages["reflect"];
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = reflect.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		overflow = errors.New("binary: varint overflows a 64-bit integer");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["math/bits"] = (function() {
	var $pkg = {}, $init, deBruijn32tab, deBruijn64tab, len8tab, LeadingZeros, TrailingZeros, TrailingZeros32, TrailingZeros64, Len, Len32, Len64;
	LeadingZeros = function(x) {
		var x;
		return 32 - Len(x) >> 0;
	};
	$pkg.LeadingZeros = LeadingZeros;
	TrailingZeros = function(x) {
		var x;
		if (true) {
			return TrailingZeros32(((x >>> 0)));
		}
		return TrailingZeros64((new $Uint64(0, x)));
	};
	$pkg.TrailingZeros = TrailingZeros;
	TrailingZeros32 = function(x) {
		var x, x$1;
		if (x === 0) {
			return 32;
		}
		return (((x$1 = ($imul((((x & (-x >>> 0)) >>> 0)), 125613361) >>> 0) >>> 27 >>> 0, ((x$1 < 0 || x$1 >= deBruijn32tab.length) ? ($throwRuntimeError("index out of range"), undefined) : deBruijn32tab[x$1])) >> 0));
	};
	$pkg.TrailingZeros32 = TrailingZeros32;
	TrailingZeros64 = function(x) {
		var x, x$1, x$2;
		if ((x.$high === 0 && x.$low === 0)) {
			return 64;
		}
		return (((x$1 = $shiftRightUint64($mul64(((x$2 = new $Uint64(-x.$high, -x.$low), new $Uint64(x.$high & x$2.$high, (x.$low & x$2.$low) >>> 0))), new $Uint64(66559345, 3033172745)), 58), (($flatten64(x$1) < 0 || $flatten64(x$1) >= deBruijn64tab.length) ? ($throwRuntimeError("index out of range"), undefined) : deBruijn64tab[$flatten64(x$1)])) >> 0));
	};
	$pkg.TrailingZeros64 = TrailingZeros64;
	Len = function(x) {
		var x;
		if (true) {
			return Len32(((x >>> 0)));
		}
		return Len64((new $Uint64(0, x)));
	};
	$pkg.Len = Len;
	Len32 = function(x) {
		var n, x, y, y$1;
		n = 0;
		if (x >= 65536) {
			x = (y = (16), y < 32 ? (x >>> y) : 0) >>> 0;
			n = 16;
		}
		if (x >= 256) {
			x = (y$1 = (8), y$1 < 32 ? (x >>> y$1) : 0) >>> 0;
			n = n + (8) >> 0;
		}
		n = n + ((((x < 0 || x >= len8tab.length) ? ($throwRuntimeError("index out of range"), undefined) : len8tab[x]) >> 0)) >> 0;
		return n;
	};
	$pkg.Len32 = Len32;
	Len64 = function(x) {
		var n, x;
		n = 0;
		if ((x.$high > 1 || (x.$high === 1 && x.$low >= 0))) {
			x = $shiftRightUint64(x, (32));
			n = 32;
		}
		if ((x.$high > 0 || (x.$high === 0 && x.$low >= 65536))) {
			x = $shiftRightUint64(x, (16));
			n = n + (16) >> 0;
		}
		if ((x.$high > 0 || (x.$high === 0 && x.$low >= 256))) {
			x = $shiftRightUint64(x, (8));
			n = n + (8) >> 0;
		}
		n = n + (((($flatten64(x) < 0 || $flatten64(x) >= len8tab.length) ? ($throwRuntimeError("index out of range"), undefined) : len8tab[$flatten64(x)]) >> 0)) >> 0;
		return n;
	};
	$pkg.Len64 = Len64;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		deBruijn32tab = $toNativeArray($kindUint8, [0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9]);
		deBruijn64tab = $toNativeArray($kindUint8, [0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6]);
		len8tab = $toNativeArray($kindUint8, [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["math/rand"] = (function() {
	var $pkg = {}, $init, nosync, math, Source, Source64, Rand, lockedSource, rngSource, arrayType, ptrType, ptrType$1, sliceType, ptrType$2, ptrType$3, sliceType$1, ptrType$5, ke, we, fe, kn, wn, fn, globalRand, rng_cooked, absInt32, NewSource, New, read, Seed, Int, Int63n, Intn, seedrand;
	nosync = $packages["github.com/gopherjs/gopherjs/nosync"];
	math = $packages["math"];
	Source = $pkg.Source = $newType(8, $kindInterface, "rand.Source", true, "math/rand", true, null);
	Source64 = $pkg.Source64 = $newType(8, $kindInterface, "rand.Source64", true, "math/rand", true, null);
	Rand = $pkg.Rand = $newType(0, $kindStruct, "rand.Rand", true, "math/rand", true, function(src_, s64_, readVal_, readPos_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.src = $ifaceNil;
			this.s64 = $ifaceNil;
			this.readVal = new $Int64(0, 0);
			this.readPos = 0;
			return;
		}
		this.src = src_;
		this.s64 = s64_;
		this.readVal = readVal_;
		this.readPos = readPos_;
	});
	lockedSource = $pkg.lockedSource = $newType(0, $kindStruct, "rand.lockedSource", true, "math/rand", false, function(lk_, src_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.lk = new nosync.Mutex.ptr(false);
			this.src = $ifaceNil;
			return;
		}
		this.lk = lk_;
		this.src = src_;
	});
	rngSource = $pkg.rngSource = $newType(0, $kindStruct, "rand.rngSource", true, "math/rand", false, function(tap_, feed_, vec_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.tap = 0;
			this.feed = 0;
			this.vec = arrayType.zero();
			return;
		}
		this.tap = tap_;
		this.feed = feed_;
		this.vec = vec_;
	});
	arrayType = $arrayType($Int64, 607);
	ptrType = $ptrType(lockedSource);
	ptrType$1 = $ptrType($Int8);
	sliceType = $sliceType($Int);
	ptrType$2 = $ptrType($Int64);
	ptrType$3 = $ptrType(Rand);
	sliceType$1 = $sliceType($Uint8);
	ptrType$5 = $ptrType(rngSource);
	Rand.ptr.prototype.ExpFloat64 = function() {
		var _r, _r$1, _r$2, _r$3, i, j, r, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; i = $f.i; j = $f.j; r = $f.r; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* while (true) { */ case 1:
			_r = r.Uint32(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			j = _r;
			i = (j & 255) >>> 0;
			x = (j) * (((i < 0 || i >= we.length) ? ($throwRuntimeError("index out of range"), undefined) : we[i]));
			if (j < ((i < 0 || i >= ke.length) ? ($throwRuntimeError("index out of range"), undefined) : ke[i])) {
				$s = -1; return x;
			}
			/* */ if (i === 0) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (i === 0) { */ case 4:
				_r$1 = r.Float64(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_r$2 = math.Log(_r$1); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				$s = -1; return 7.69711747013105 - _r$2;
			/* } */ case 5:
			_r$3 = r.Float64(); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			/* */ if ($fround(((i < 0 || i >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[i]) + $fround(($fround(_r$3)) * ($fround((x$1 = i - 1 >>> 0, ((x$1 < 0 || x$1 >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[x$1])) - ((i < 0 || i >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[i]))))) < ($fround(math.Exp(-x)))) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if ($fround(((i < 0 || i >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[i]) + $fround(($fround(_r$3)) * ($fround((x$1 = i - 1 >>> 0, ((x$1 < 0 || x$1 >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[x$1])) - ((i < 0 || i >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[i]))))) < ($fround(math.Exp(-x)))) { */ case 8:
				$s = -1; return x;
			/* } */ case 9:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.ExpFloat64 }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.i = i; $f.j = j; $f.r = r; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.ExpFloat64 = function() { return this.$val.ExpFloat64(); };
	absInt32 = function(i) {
		var i;
		if (i < 0) {
			return ((-i >>> 0));
		}
		return ((i >>> 0));
	};
	Rand.ptr.prototype.NormFloat64 = function() {
		var _r, _r$1, _r$2, _r$3, _r$4, _r$5, i, j, r, x, x$1, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; i = $f.i; j = $f.j; r = $f.r; x = $f.x; x$1 = $f.x$1; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* while (true) { */ case 1:
			_r = r.Uint32(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			j = ((_r >> 0));
			i = j & 127;
			x = (j) * (((i < 0 || i >= wn.length) ? ($throwRuntimeError("index out of range"), undefined) : wn[i]));
			if (absInt32(j) < ((i < 0 || i >= kn.length) ? ($throwRuntimeError("index out of range"), undefined) : kn[i])) {
				$s = -1; return x;
			}
			/* */ if (i === 0) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (i === 0) { */ case 4:
				/* while (true) { */ case 6:
					_r$1 = r.Float64(); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_r$2 = math.Log(_r$1); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					x = -_r$2 * 0.29047645161474317;
					_r$3 = r.Float64(); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					_r$4 = math.Log(_r$3); /* */ $s = 11; case 11: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					y = -_r$4;
					if (y + y >= x * x) {
						/* break; */ $s = 7; continue;
					}
				/* } */ $s = 6; continue; case 7:
				if (j > 0) {
					$s = -1; return 3.442619855899 + x;
				}
				$s = -1; return -3.442619855899 - x;
			/* } */ case 5:
			_r$5 = r.Float64(); /* */ $s = 14; case 14: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			/* */ if ($fround(((i < 0 || i >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[i]) + $fround(($fround(_r$5)) * ($fround((x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[x$1])) - ((i < 0 || i >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[i]))))) < ($fround(math.Exp(-0.5 * x * x)))) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if ($fround(((i < 0 || i >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[i]) + $fround(($fround(_r$5)) * ($fround((x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[x$1])) - ((i < 0 || i >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[i]))))) < ($fround(math.Exp(-0.5 * x * x)))) { */ case 12:
				$s = -1; return x;
			/* } */ case 13:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.NormFloat64 }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f.i = i; $f.j = j; $f.r = r; $f.x = x; $f.x$1 = x$1; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.NormFloat64 = function() { return this.$val.NormFloat64(); };
	NewSource = function(seed) {
		var rng, seed;
		rng = new rngSource.ptr(0, 0, arrayType.zero());
		rng.Seed(seed);
		return rng;
	};
	$pkg.NewSource = NewSource;
	New = function(src) {
		var _tuple, s64, src;
		_tuple = $assertType(src, Source64, true);
		s64 = _tuple[0];
		return new Rand.ptr(src, s64, new $Int64(0, 0), 0);
	};
	$pkg.New = New;
	Rand.ptr.prototype.Seed = function(seed) {
		var _tuple, lk, ok, r, seed, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; lk = $f.lk; ok = $f.ok; r = $f.r; seed = $f.seed; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_tuple = $assertType(r.src, ptrType, true);
		lk = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (ok) { */ case 1:
			$r = lk.seedPos(seed, (r.$ptr_readPos || (r.$ptr_readPos = new ptrType$1(function() { return this.$target.readPos; }, function($v) { this.$target.readPos = $v; }, r)))); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return;
		/* } */ case 2:
		$r = r.src.Seed(seed); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		r.readPos = 0;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Seed }; } $f._tuple = _tuple; $f.lk = lk; $f.ok = ok; $f.r = r; $f.seed = seed; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Seed = function(seed) { return this.$val.Seed(seed); };
	Rand.ptr.prototype.Int63 = function() {
		var _r, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.src.Int63(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Int63 }; } $f._r = _r; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Int63 = function() { return this.$val.Int63(); };
	Rand.ptr.prototype.Uint32 = function() {
		var _r, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.Int63(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return (($shiftRightInt64(_r, 31).$low >>> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Uint32 }; } $f._r = _r; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Uint32 = function() { return this.$val.Uint32(); };
	Rand.ptr.prototype.Uint64 = function() {
		var _r, _r$1, _r$2, r, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; r = $f.r; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (!($interfaceIsEqual(r.s64, $ifaceNil))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!($interfaceIsEqual(r.s64, $ifaceNil))) { */ case 1:
			_r = r.s64.Uint64(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		_r$1 = r.Int63(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = r.Int63(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return (x = $shiftRightUint64(((x$1 = _r$1, new $Uint64(x$1.$high, x$1.$low))), 31), x$2 = $shiftLeft64(((x$3 = _r$2, new $Uint64(x$3.$high, x$3.$low))), 32), new $Uint64(x.$high | x$2.$high, (x.$low | x$2.$low) >>> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Uint64 }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.r = r; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Uint64 = function() { return this.$val.Uint64(); };
	Rand.ptr.prototype.Int31 = function() {
		var _r, r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.Int63(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return (((x = $shiftRightInt64(_r, 32), x.$low + ((x.$high >> 31) * 4294967296)) >> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Int31 }; } $f._r = _r; $f.r = r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Int31 = function() { return this.$val.Int31(); };
	Rand.ptr.prototype.Int = function() {
		var _r, r, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.Int63(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		u = ((_r.$low >>> 0));
		$s = -1; return ((((u << 1 >>> 0) >>> 1 >>> 0) >> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Int }; } $f._r = _r; $f.r = r; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Int = function() { return this.$val.Int(); };
	Rand.ptr.prototype.Int63n = function(n) {
		var _r, _r$1, _r$2, max, n, r, v, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; max = $f.max; n = $f.n; r = $f.r; v = $f.v; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if ((n.$high < 0 || (n.$high === 0 && n.$low <= 0))) {
			$panic(new $String("invalid argument to Int63n"));
		}
		/* */ if ((x = (x$1 = new $Int64(n.$high - 0, n.$low - 1), new $Int64(n.$high & x$1.$high, (n.$low & x$1.$low) >>> 0)), (x.$high === 0 && x.$low === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((x = (x$1 = new $Int64(n.$high - 0, n.$low - 1), new $Int64(n.$high & x$1.$high, (n.$low & x$1.$low) >>> 0)), (x.$high === 0 && x.$low === 0))) { */ case 1:
			_r = r.Int63(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return (x$2 = _r, x$3 = new $Int64(n.$high - 0, n.$low - 1), new $Int64(x$2.$high & x$3.$high, (x$2.$low & x$3.$low) >>> 0));
		/* } */ case 2:
		max = ((x$4 = (x$5 = $div64(new $Uint64(2147483648, 0), (new $Uint64(n.$high, n.$low)), true), new $Uint64(2147483647 - x$5.$high, 4294967295 - x$5.$low)), new $Int64(x$4.$high, x$4.$low)));
		_r$1 = r.Int63(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		v = _r$1;
		/* while (true) { */ case 5:
			/* if (!((v.$high > max.$high || (v.$high === max.$high && v.$low > max.$low)))) { break; } */ if(!((v.$high > max.$high || (v.$high === max.$high && v.$low > max.$low)))) { $s = 6; continue; }
			_r$2 = r.Int63(); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			v = _r$2;
		/* } */ $s = 5; continue; case 6:
		$s = -1; return $div64(v, n, true);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Int63n }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.max = max; $f.n = n; $f.r = r; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Int63n = function(n) { return this.$val.Int63n(n); };
	Rand.ptr.prototype.Int31n = function(n) {
		var _r, _r$1, _r$2, _r$3, _r$4, max, n, r, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; max = $f.max; n = $f.n; r = $f.r; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (n <= 0) {
			$panic(new $String("invalid argument to Int31n"));
		}
		/* */ if ((n & ((n - 1 >> 0))) === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((n & ((n - 1 >> 0))) === 0) { */ case 1:
			_r = r.Int31(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r & ((n - 1 >> 0));
		/* } */ case 2:
		max = (((2147483647 - (_r$1 = 2147483648 % ((n >>> 0)), _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) >>> 0) >> 0));
		_r$2 = r.Int31(); /* */ $s = 4; case 4: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		v = _r$2;
		/* while (true) { */ case 5:
			/* if (!(v > max)) { break; } */ if(!(v > max)) { $s = 6; continue; }
			_r$3 = r.Int31(); /* */ $s = 7; case 7: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			v = _r$3;
		/* } */ $s = 5; continue; case 6:
		$s = -1; return (_r$4 = v % n, _r$4 === _r$4 ? _r$4 : $throwRuntimeError("integer divide by zero"));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Int31n }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.max = max; $f.n = n; $f.r = r; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Int31n = function(n) { return this.$val.Int31n(n); };
	Rand.ptr.prototype.Intn = function(n) {
		var _r, _r$1, n, r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; n = $f.n; r = $f.r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (n <= 0) {
			$panic(new $String("invalid argument to Intn"));
		}
		/* */ if (n <= 2147483647) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (n <= 2147483647) { */ case 1:
			_r = r.Int31n(((n >> 0))); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return ((_r >> 0));
		/* } */ case 2:
		_r$1 = r.Int63n((new $Int64(0, n))); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return (((x = _r$1, x.$low + ((x.$high >> 31) * 4294967296)) >> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Intn }; } $f._r = _r; $f._r$1 = _r$1; $f.n = n; $f.r = r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Intn = function(n) { return this.$val.Intn(n); };
	Rand.ptr.prototype.Float64 = function() {
		var _r, f, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* again: */ case 1:
		_r = r.Int63(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		f = ($flatten64(_r)) / 9.223372036854776e+18;
		/* */ if (f === 1) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (f === 1) { */ case 3:
			/* goto again */ $s = 1; continue;
		/* } */ case 4:
		$s = -1; return f;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Float64 }; } $f._r = _r; $f.f = f; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Float64 = function() { return this.$val.Float64(); };
	Rand.ptr.prototype.Float32 = function() {
		var _r, f, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* again: */ case 1:
		_r = r.Float64(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		f = ($fround(_r));
		/* */ if (f === 1) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (f === 1) { */ case 3:
			/* goto again */ $s = 1; continue;
		/* } */ case 4:
		$s = -1; return f;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Float32 }; } $f._r = _r; $f.f = f; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Float32 = function() { return this.$val.Float32(); };
	Rand.ptr.prototype.Perm = function(n) {
		var _r, i, j, m, n, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; j = $f.j; m = $f.m; n = $f.n; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		m = $makeSlice(sliceType, n);
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < n)) { break; } */ if(!(i < n)) { $s = 2; continue; }
			_r = r.Intn(i + 1 >> 0); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			j = _r;
			((i < 0 || i >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + i] = ((j < 0 || j >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + j]));
			((j < 0 || j >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + j] = i);
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return m;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Perm }; } $f._r = _r; $f.i = i; $f.j = j; $f.m = m; $f.n = n; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Perm = function(n) { return this.$val.Perm(n); };
	Rand.ptr.prototype.Read = function(p) {
		var _r, _r$1, _tuple, _tuple$1, _tuple$2, err, lk, n, ok, p, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; err = $f.err; lk = $f.lk; n = $f.n; ok = $f.ok; p = $f.p; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		r = this;
		_tuple = $assertType(r.src, ptrType, true);
		lk = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (ok) { */ case 1:
			_r = lk.read(p, (r.$ptr_readVal || (r.$ptr_readVal = new ptrType$2(function() { return this.$target.readVal; }, function($v) { this.$target.readVal = $v; }, r))), (r.$ptr_readPos || (r.$ptr_readPos = new ptrType$1(function() { return this.$target.readPos; }, function($v) { this.$target.readPos = $v; }, r)))); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple$1 = _r;
			n = _tuple$1[0];
			err = _tuple$1[1];
			$s = -1; return [n, err];
		/* } */ case 2:
		_r$1 = read(p, $methodVal(r, "Int63"), (r.$ptr_readVal || (r.$ptr_readVal = new ptrType$2(function() { return this.$target.readVal; }, function($v) { this.$target.readVal = $v; }, r))), (r.$ptr_readPos || (r.$ptr_readPos = new ptrType$1(function() { return this.$target.readPos; }, function($v) { this.$target.readPos = $v; }, r)))); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$2 = _r$1;
		n = _tuple$2[0];
		err = _tuple$2[1];
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Read }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.err = err; $f.lk = lk; $f.n = n; $f.ok = ok; $f.p = p; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Read = function(p) { return this.$val.Read(p); };
	read = function(p, int63, readVal, readPos) {
		var _r, err, int63, n, p, pos, readPos, readVal, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; int63 = $f.int63; n = $f.n; p = $f.p; pos = $f.pos; readPos = $f.readPos; readVal = $f.readVal; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		pos = readPos.$get();
		val = readVal.$get();
		n = 0;
		/* while (true) { */ case 1:
			/* if (!(n < p.$length)) { break; } */ if(!(n < p.$length)) { $s = 2; continue; }
			/* */ if (pos === 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (pos === 0) { */ case 3:
				_r = int63(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				val = _r;
				pos = 7;
			/* } */ case 4:
			((n < 0 || n >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + n] = ((val.$low << 24 >>> 24)));
			val = $shiftRightInt64(val, (8));
			pos = pos - (1) << 24 >> 24;
			n = n + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		readPos.$set(pos);
		readVal.$set(val);
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: read }; } $f._r = _r; $f.err = err; $f.int63 = int63; $f.n = n; $f.p = p; $f.pos = pos; $f.readPos = readPos; $f.readVal = readVal; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Seed = function(seed) {
		var seed, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; seed = $f.seed; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = globalRand.Seed(seed); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Seed }; } $f.seed = seed; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Seed = Seed;
	Int = function() {
		var _r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = globalRand.Int(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int }; } $f._r = _r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Int = Int;
	Int63n = function(n) {
		var _r, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = globalRand.Int63n(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int63n }; } $f._r = _r; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Int63n = Int63n;
	Intn = function(n) {
		var _r, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = globalRand.Intn(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Intn }; } $f._r = _r; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Intn = Intn;
	lockedSource.ptr.prototype.Int63 = function() {
		var _r, n, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		r = this;
		r.lk.Lock();
		_r = r.src.Int63(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		n = _r;
		r.lk.Unlock();
		$s = -1; return n;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lockedSource.ptr.prototype.Int63 }; } $f._r = _r; $f.n = n; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	lockedSource.prototype.Int63 = function() { return this.$val.Int63(); };
	lockedSource.ptr.prototype.Uint64 = function() {
		var _r, n, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Uint64(0, 0);
		r = this;
		r.lk.Lock();
		_r = r.src.Uint64(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		n = _r;
		r.lk.Unlock();
		$s = -1; return n;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lockedSource.ptr.prototype.Uint64 }; } $f._r = _r; $f.n = n; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	lockedSource.prototype.Uint64 = function() { return this.$val.Uint64(); };
	lockedSource.ptr.prototype.Seed = function(seed) {
		var r, seed, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; r = $f.r; seed = $f.seed; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		r.lk.Lock();
		$r = r.src.Seed(seed); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		r.lk.Unlock();
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lockedSource.ptr.prototype.Seed }; } $f.r = r; $f.seed = seed; $f.$s = $s; $f.$r = $r; return $f;
	};
	lockedSource.prototype.Seed = function(seed) { return this.$val.Seed(seed); };
	lockedSource.ptr.prototype.seedPos = function(seed, readPos) {
		var r, readPos, seed, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; r = $f.r; readPos = $f.readPos; seed = $f.seed; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		r.lk.Lock();
		$r = r.src.Seed(seed); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		readPos.$set(0);
		r.lk.Unlock();
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lockedSource.ptr.prototype.seedPos }; } $f.r = r; $f.readPos = readPos; $f.seed = seed; $f.$s = $s; $f.$r = $r; return $f;
	};
	lockedSource.prototype.seedPos = function(seed, readPos) { return this.$val.seedPos(seed, readPos); };
	lockedSource.ptr.prototype.read = function(p, readVal, readPos) {
		var _r, _tuple, err, n, p, r, readPos, readVal, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; n = $f.n; p = $f.p; r = $f.r; readPos = $f.readPos; readVal = $f.readVal; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		r = this;
		r.lk.Lock();
		_r = read(p, $methodVal(r.src, "Int63"), readVal, readPos); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		r.lk.Unlock();
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: lockedSource.ptr.prototype.read }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.n = n; $f.p = p; $f.r = r; $f.readPos = readPos; $f.readVal = readVal; $f.$s = $s; $f.$r = $r; return $f;
	};
	lockedSource.prototype.read = function(p, readVal, readPos) { return this.$val.read(p, readVal, readPos); };
	seedrand = function(x) {
		var _q, _r, hi, lo, x;
		hi = (_q = x / 44488, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		lo = (_r = x % 44488, _r === _r ? _r : $throwRuntimeError("integer divide by zero"));
		x = ($imul(48271, lo)) - ($imul(3399, hi)) >> 0;
		if (x < 0) {
			x = x + (2147483647) >> 0;
		}
		return x;
	};
	rngSource.ptr.prototype.Seed = function(seed) {
		var i, rng, seed, u, x, x$1, x$2, x$3, x$4, x$5;
		rng = this;
		rng.tap = 0;
		rng.feed = 334;
		seed = $div64(seed, new $Int64(0, 2147483647), true);
		if ((seed.$high < 0 || (seed.$high === 0 && seed.$low < 0))) {
			seed = (x = new $Int64(0, 2147483647), new $Int64(seed.$high + x.$high, seed.$low + x.$low));
		}
		if ((seed.$high === 0 && seed.$low === 0)) {
			seed = new $Int64(0, 89482311);
		}
		x$1 = (((seed.$low + ((seed.$high >> 31) * 4294967296)) >> 0));
		i = -20;
		while (true) {
			if (!(i < 607)) { break; }
			x$1 = seedrand(x$1);
			if (i >= 0) {
				u = new $Int64(0, 0);
				u = $shiftLeft64((new $Int64(0, x$1)), 40);
				x$1 = seedrand(x$1);
				u = (x$2 = $shiftLeft64((new $Int64(0, x$1)), 20), new $Int64(u.$high ^ x$2.$high, (u.$low ^ x$2.$low) >>> 0));
				x$1 = seedrand(x$1);
				u = (x$3 = (new $Int64(0, x$1)), new $Int64(u.$high ^ x$3.$high, (u.$low ^ x$3.$low) >>> 0));
				u = (x$4 = ((i < 0 || i >= rng_cooked.length) ? ($throwRuntimeError("index out of range"), undefined) : rng_cooked[i]), new $Int64(u.$high ^ x$4.$high, (u.$low ^ x$4.$low) >>> 0));
				(x$5 = rng.vec, ((i < 0 || i >= x$5.length) ? ($throwRuntimeError("index out of range"), undefined) : x$5[i] = u));
			}
			i = i + (1) >> 0;
		}
	};
	rngSource.prototype.Seed = function(seed) { return this.$val.Seed(seed); };
	rngSource.ptr.prototype.Int63 = function() {
		var rng, x, x$1;
		rng = this;
		return ((x = (x$1 = rng.Uint64(), new $Uint64(x$1.$high & 2147483647, (x$1.$low & 4294967295) >>> 0)), new $Int64(x.$high, x.$low)));
	};
	rngSource.prototype.Int63 = function() { return this.$val.Int63(); };
	rngSource.ptr.prototype.Uint64 = function() {
		var rng, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8;
		rng = this;
		rng.tap = rng.tap - (1) >> 0;
		if (rng.tap < 0) {
			rng.tap = rng.tap + (607) >> 0;
		}
		rng.feed = rng.feed - (1) >> 0;
		if (rng.feed < 0) {
			rng.feed = rng.feed + (607) >> 0;
		}
		x$6 = (x = (x$1 = rng.vec, x$2 = rng.feed, ((x$2 < 0 || x$2 >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[x$2])), x$3 = (x$4 = rng.vec, x$5 = rng.tap, ((x$5 < 0 || x$5 >= x$4.length) ? ($throwRuntimeError("index out of range"), undefined) : x$4[x$5])), new $Int64(x.$high + x$3.$high, x.$low + x$3.$low));
		(x$7 = rng.vec, x$8 = rng.feed, ((x$8 < 0 || x$8 >= x$7.length) ? ($throwRuntimeError("index out of range"), undefined) : x$7[x$8] = x$6));
		return (new $Uint64(x$6.$high, x$6.$low));
	};
	rngSource.prototype.Uint64 = function() { return this.$val.Uint64(); };
	ptrType$3.methods = [{prop: "ExpFloat64", name: "ExpFloat64", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "NormFloat64", name: "NormFloat64", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Seed", name: "Seed", pkg: "", typ: $funcType([$Int64], [], false)}, {prop: "Int63", name: "Int63", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Uint32", name: "Uint32", pkg: "", typ: $funcType([], [$Uint32], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}, {prop: "Int31", name: "Int31", pkg: "", typ: $funcType([], [$Int32], false)}, {prop: "Int", name: "Int", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Int63n", name: "Int63n", pkg: "", typ: $funcType([$Int64], [$Int64], false)}, {prop: "Int31n", name: "Int31n", pkg: "", typ: $funcType([$Int32], [$Int32], false)}, {prop: "Intn", name: "Intn", pkg: "", typ: $funcType([$Int], [$Int], false)}, {prop: "Float64", name: "Float64", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Float32", name: "Float32", pkg: "", typ: $funcType([], [$Float32], false)}, {prop: "Perm", name: "Perm", pkg: "", typ: $funcType([$Int], [sliceType], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType$1], [$Int, $error], false)}];
	ptrType.methods = [{prop: "Int63", name: "Int63", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}, {prop: "Seed", name: "Seed", pkg: "", typ: $funcType([$Int64], [], false)}, {prop: "seedPos", name: "seedPos", pkg: "math/rand", typ: $funcType([$Int64, ptrType$1], [], false)}, {prop: "read", name: "read", pkg: "math/rand", typ: $funcType([sliceType$1, ptrType$2, ptrType$1], [$Int, $error], false)}];
	ptrType$5.methods = [{prop: "Seed", name: "Seed", pkg: "", typ: $funcType([$Int64], [], false)}, {prop: "Int63", name: "Int63", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}];
	Source.init([{prop: "Int63", name: "Int63", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Seed", name: "Seed", pkg: "", typ: $funcType([$Int64], [], false)}]);
	Source64.init([{prop: "Int63", name: "Int63", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Seed", name: "Seed", pkg: "", typ: $funcType([$Int64], [], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}]);
	Rand.init("math/rand", [{prop: "src", name: "src", anonymous: false, exported: false, typ: Source, tag: ""}, {prop: "s64", name: "s64", anonymous: false, exported: false, typ: Source64, tag: ""}, {prop: "readVal", name: "readVal", anonymous: false, exported: false, typ: $Int64, tag: ""}, {prop: "readPos", name: "readPos", anonymous: false, exported: false, typ: $Int8, tag: ""}]);
	lockedSource.init("math/rand", [{prop: "lk", name: "lk", anonymous: false, exported: false, typ: nosync.Mutex, tag: ""}, {prop: "src", name: "src", anonymous: false, exported: false, typ: Source64, tag: ""}]);
	rngSource.init("math/rand", [{prop: "tap", name: "tap", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "feed", name: "feed", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "vec", name: "vec", anonymous: false, exported: false, typ: arrayType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = nosync.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		ke = $toNativeArray($kindUint32, [3801129273, 0, 2615860924, 3279400049, 3571300752, 3733536696, 3836274812, 3906990442, 3958562475, 3997804264, 4028649213, 4053523342, 4074002619, 4091154507, 4105727352, 4118261130, 4129155133, 4138710916, 4147160435, 4154685009, 4161428406, 4167506077, 4173011791, 4178022498, 4182601930, 4186803325, 4190671498, 4194244443, 4197554582, 4200629752, 4203493986, 4206168142, 4208670408, 4211016720, 4213221098, 4215295924, 4217252177, 4219099625, 4220846988, 4222502074, 4224071896, 4225562770, 4226980400, 4228329951, 4229616109, 4230843138, 4232014925, 4233135020, 4234206673, 4235232866, 4236216336, 4237159604, 4238064994, 4238934652, 4239770563, 4240574564, 4241348362, 4242093539, 4242811568, 4243503822, 4244171579, 4244816032, 4245438297, 4246039419, 4246620374, 4247182079, 4247725394, 4248251127, 4248760037, 4249252839, 4249730206, 4250192773, 4250641138, 4251075867, 4251497493, 4251906522, 4252303431, 4252688672, 4253062674, 4253425844, 4253778565, 4254121205, 4254454110, 4254777611, 4255092022, 4255397640, 4255694750, 4255983622, 4256264513, 4256537670, 4256803325, 4257061702, 4257313014, 4257557464, 4257795244, 4258026541, 4258251531, 4258470383, 4258683258, 4258890309, 4259091685, 4259287526, 4259477966, 4259663135, 4259843154, 4260018142, 4260188212, 4260353470, 4260514019, 4260669958, 4260821380, 4260968374, 4261111028, 4261249421, 4261383632, 4261513736, 4261639802, 4261761900, 4261880092, 4261994441, 4262105003, 4262211835, 4262314988, 4262414513, 4262510454, 4262602857, 4262691764, 4262777212, 4262859239, 4262937878, 4263013162, 4263085118, 4263153776, 4263219158, 4263281289, 4263340187, 4263395872, 4263448358, 4263497660, 4263543789, 4263586755, 4263626565, 4263663224, 4263696735, 4263727099, 4263754314, 4263778377, 4263799282, 4263817020, 4263831582, 4263842955, 4263851124, 4263856071, 4263857776, 4263856218, 4263851370, 4263843206, 4263831695, 4263816804, 4263798497, 4263776735, 4263751476, 4263722676, 4263690284, 4263654251, 4263614520, 4263571032, 4263523724, 4263472530, 4263417377, 4263358192, 4263294892, 4263227394, 4263155608, 4263079437, 4262998781, 4262913534, 4262823581, 4262728804, 4262629075, 4262524261, 4262414220, 4262298801, 4262177846, 4262051187, 4261918645, 4261780032, 4261635148, 4261483780, 4261325704, 4261160681, 4260988457, 4260808763, 4260621313, 4260425802, 4260221905, 4260009277, 4259787550, 4259556329, 4259315195, 4259063697, 4258801357, 4258527656, 4258242044, 4257943926, 4257632664, 4257307571, 4256967906, 4256612870, 4256241598, 4255853155, 4255446525, 4255020608, 4254574202, 4254106002, 4253614578, 4253098370, 4252555662, 4251984571, 4251383021, 4250748722, 4250079132, 4249371435, 4248622490, 4247828790, 4246986404, 4246090910, 4245137315, 4244119963, 4243032411, 4241867296, 4240616155, 4239269214, 4237815118, 4236240596, 4234530035, 4232664930, 4230623176, 4228378137, 4225897409, 4223141146, 4220059768, 4216590757, 4212654085, 4208145538, 4202926710, 4196809522, 4189531420, 4180713890, 4169789475, 4155865042, 4137444620, 4111806704, 4073393724, 4008685917, 3873074895]);
		we = $toNativeArray($kindFloat32, [2.0249555365836613e-09, 1.4866739783681027e-11, 2.4409616689036184e-11, 3.1968806074589295e-11, 3.844677007314168e-11, 4.42282044321729e-11, 4.951644302919611e-11, 5.443358958023836e-11, 5.905943789574764e-11, 6.34494193296753e-11, 6.764381416113352e-11, 7.167294535648239e-11, 7.556032188826833e-11, 7.932458162551725e-11, 8.298078890689453e-11, 8.654132271912474e-11, 9.001651507523079e-11, 9.341507428706208e-11, 9.674443190998971e-11, 1.0001099254308699e-10, 1.0322031424037093e-10, 1.0637725422757427e-10, 1.0948611461891744e-10, 1.1255067711157807e-10, 1.1557434870246297e-10, 1.1856014781042035e-10, 1.2151082917633005e-10, 1.2442885610752796e-10, 1.2731647680563896e-10, 1.3017574518325858e-10, 1.330085347417409e-10, 1.3581656632677408e-10, 1.386014220061682e-10, 1.413645728254309e-10, 1.4410737880776736e-10, 1.4683107507629245e-10, 1.4953686899854546e-10, 1.522258291641876e-10, 1.5489899640730442e-10, 1.575573282952547e-10, 1.6020171300645814e-10, 1.628330109637588e-10, 1.6545202707884954e-10, 1.68059510752272e-10, 1.7065616975120435e-10, 1.73242697965037e-10, 1.758197337720091e-10, 1.783878739169964e-10, 1.8094774290045024e-10, 1.834998542005195e-10, 1.8604476292871652e-10, 1.8858298256319017e-10, 1.9111498494872592e-10, 1.9364125580789704e-10, 1.9616222535212557e-10, 1.9867835154840918e-10, 2.011900368525943e-10, 2.0369768372052732e-10, 2.062016807302669e-10, 2.0870240258208383e-10, 2.1120022397624894e-10, 2.136955057352452e-10, 2.1618855317040442e-10, 2.1867974098199738e-10, 2.2116936060356807e-10, 2.2365774510202385e-10, 2.2614519978869652e-10, 2.2863201609713002e-10, 2.3111849933865614e-10, 2.3360494094681883e-10, 2.3609159072179864e-10, 2.3857874009713953e-10, 2.4106666662859766e-10, 2.4355562011635357e-10, 2.460458781161634e-10, 2.485376904282077e-10, 2.5103127909709144e-10, 2.5352694943414633e-10, 2.560248957284017e-10, 2.585253955356137e-10, 2.610286709003873e-10, 2.6353494386732734e-10, 2.6604446423661443e-10, 2.6855745405285347e-10, 2.71074163116225e-10, 2.7359478571575835e-10, 2.7611959940720965e-10, 2.786487707240326e-10, 2.8118254946640775e-10, 2.8372118543451563e-10, 2.8626484516180994e-10, 2.8881380620404684e-10, 2.9136826285025563e-10, 2.9392840938946563e-10, 2.96494523377433e-10, 2.990667713476114e-10, 3.016454031001814e-10, 3.042306406797479e-10, 3.068226783753403e-10, 3.09421765987139e-10, 3.12028125559749e-10, 3.1464195138219964e-10, 3.17263521010247e-10, 3.1989300097734485e-10, 3.225306410836737e-10, 3.2517669112941405e-10, 3.2783134540359526e-10, 3.3049485370639786e-10, 3.3316743808242677e-10, 3.3584937608743815e-10, 3.385408342548857e-10, 3.4124211789610115e-10, 3.4395342130011386e-10, 3.4667499426710435e-10, 3.494071143528288e-10, 3.521500313574677e-10, 3.54903967325626e-10, 3.576691720574843e-10, 3.6044595086437425e-10, 3.632345535464765e-10, 3.660352021483959e-10, 3.688482297370399e-10, 3.716738583570134e-10, 3.7451239331964814e-10, 3.773641121807003e-10, 3.802292924959261e-10, 3.831082673322328e-10, 3.8600128648980103e-10, 3.8890865527996255e-10, 3.9183070676962473e-10, 3.9476774627011935e-10, 3.977200790927782e-10, 4.006880383045086e-10, 4.0367195697221803e-10, 4.066721681628138e-10, 4.0968900494320337e-10, 4.127228558914453e-10, 4.15774054074447e-10, 4.188429603146915e-10, 4.2192993543466173e-10, 4.25035395767992e-10, 4.2815970213716525e-10, 4.313032986313914e-10, 4.3446651831757777e-10, 4.376498607960855e-10, 4.408536868893975e-10, 4.4407846844229937e-10, 4.4732464954400086e-10, 4.5059267428371186e-10, 4.538830145062178e-10, 4.5719619756745544e-10, 4.605326675566346e-10, 4.638929240741163e-10, 4.672775499869886e-10, 4.706869893844612e-10, 4.74121908400349e-10, 4.775827511238617e-10, 4.810701836888143e-10, 4.845848167178701e-10, 4.881271498113904e-10, 4.916979601254923e-10, 4.952977472605369e-10, 4.989272883726414e-10, 5.025872495956207e-10, 5.062783525744408e-10, 5.100013189540675e-10, 5.13756870379467e-10, 5.175458395179078e-10, 5.21369003525507e-10, 5.252272505806843e-10, 5.29121357839557e-10, 5.330522134805449e-10, 5.3702081670437e-10, 5.41028055689452e-10, 5.450749851476644e-10, 5.491624932574268e-10, 5.532918012640664e-10, 5.574638528571541e-10, 5.616799247931681e-10, 5.659410717839819e-10, 5.702485705860738e-10, 5.746036979559221e-10, 5.790077306500052e-10, 5.83462111958255e-10, 5.879682296594524e-10, 5.925275825546805e-10, 5.971417249561739e-10, 6.01812211176167e-10, 6.065408175714992e-10, 6.113292094767075e-10, 6.16179329782085e-10, 6.21092954844471e-10, 6.260721940876124e-10, 6.311191569352559e-10, 6.362359528111483e-10, 6.414249686947926e-10, 6.466885360545405e-10, 6.520292639144998e-10, 6.574497612987784e-10, 6.629528592760892e-10, 6.685415554485985e-10, 6.742187919073217e-10, 6.799880103436351e-10, 6.858525969377638e-10, 6.918161599145378e-10, 6.978825850545434e-10, 7.040559801829716e-10, 7.103406751696184e-10, 7.167412219288849e-10, 7.232625609532306e-10, 7.2990985477972e-10, 7.366885990123251e-10, 7.436047333442275e-10, 7.506645305355164e-10, 7.57874762946642e-10, 7.652426470272644e-10, 7.727759543385559e-10, 7.804830115532013e-10, 7.883728114777e-10, 7.964550685635174e-10, 8.047402189070851e-10, 8.132396422944055e-10, 8.219657177122031e-10, 8.309318788590758e-10, 8.401527806789488e-10, 8.496445214056791e-10, 8.594246980742071e-10, 8.695127395874636e-10, 8.799300732498239e-10, 8.90700457834015e-10, 9.01850316648023e-10, 9.134091816243028e-10, 9.254100818978372e-10, 9.37890431984556e-10, 9.508922538259412e-10, 9.64463842123564e-10, 9.78660263939446e-10, 9.935448019859905e-10, 1.0091912860943353e-09, 1.0256859805934937e-09, 1.0431305819125214e-09, 1.0616465484503124e-09, 1.0813799855569073e-09, 1.1025096391392708e-09, 1.1252564435793033e-09, 1.149898620766976e-09, 1.176793218427008e-09, 1.2064089727203964e-09, 1.2393785997488749e-09, 1.2765849488616254e-09, 1.319313880365769e-09, 1.36954347862428e-09, 1.4305497897382224e-09, 1.5083649884672923e-09, 1.6160853766322703e-09, 1.7921247819074893e-09]);
		fe = $toNativeArray($kindFloat32, [1, 0.9381436705589294, 0.900469958782196, 0.8717043399810791, 0.847785472869873, 0.8269932866096497, 0.8084216713905334, 0.7915276288986206, 0.7759568691253662, 0.7614634037017822, 0.7478685975074768, 0.7350381016731262, 0.7228676676750183, 0.7112747430801392, 0.7001926302909851, 0.6895664930343628, 0.6793505549430847, 0.669506311416626, 0.6600008606910706, 0.6508058309555054, 0.6418967247009277, 0.633251965045929, 0.62485271692276, 0.6166821718215942, 0.608725368976593, 0.6009689569473267, 0.5934008955955505, 0.5860103368759155, 0.5787873864173889, 0.5717230439186096, 0.5648092031478882, 0.5580382943153381, 0.5514034032821655, 0.5448982119560242, 0.5385168790817261, 0.5322538614273071, 0.526104211807251, 0.5200631618499756, 0.5141264200210571, 0.5082897543907166, 0.5025495290756226, 0.4969019889831543, 0.4913438558578491, 0.4858720004558563, 0.48048335313796997, 0.4751752018928528, 0.4699448347091675, 0.4647897481918335, 0.4597076177597046, 0.4546961486339569, 0.4497532546520233, 0.44487687945365906, 0.4400651156902313, 0.4353161156177521, 0.4306281507015228, 0.42599955201148987, 0.42142874002456665, 0.4169141948223114, 0.4124544560909271, 0.40804818272590637, 0.4036940038204193, 0.39939069747924805, 0.3951369822025299, 0.39093172550201416, 0.38677382469177246, 0.38266217708587646, 0.378595769405365, 0.37457355856895447, 0.37059465050697327, 0.366658091545105, 0.362762987613678, 0.358908474445343, 0.35509374737739563, 0.35131800174713135, 0.3475804924964905, 0.34388044476509094, 0.34021714329719543, 0.33658990263938904, 0.3329980671405792, 0.3294409513473511, 0.32591795921325684, 0.32242849469184875, 0.3189719021320343, 0.3155476748943329, 0.31215524673461914, 0.3087940812110901, 0.30546361207962036, 0.30216339230537415, 0.29889291524887085, 0.29565170407295227, 0.2924392819404602, 0.2892552316188812, 0.28609907627105713, 0.2829704284667969, 0.27986884117126465, 0.2767939269542694, 0.2737452983856201, 0.2707225978374481, 0.26772540807724, 0.26475343108177185, 0.2618062496185303, 0.258883535861969, 0.2559850215911865, 0.25311028957366943, 0.25025907158851624, 0.24743106961250305, 0.2446259707212448, 0.24184346199035645, 0.23908329010009766, 0.23634515702724457, 0.2336287796497345, 0.23093391954898834, 0.22826029360294342, 0.22560766339302063, 0.22297576069831848, 0.22036437690258026, 0.21777324378490448, 0.21520215272903442, 0.212650865316391, 0.21011915802955627, 0.20760682225227356, 0.20511364936828613, 0.20263944566249847, 0.20018397271633148, 0.19774706661701202, 0.1953285187482834, 0.19292815029621124, 0.19054576754570007, 0.18818120658397675, 0.18583425879478455, 0.18350479006767273, 0.18119260668754578, 0.17889754474163055, 0.17661945521831512, 0.17435817420482635, 0.1721135377883911, 0.16988539695739746, 0.16767361760139465, 0.16547803580760956, 0.16329853236675262, 0.16113494336605072, 0.1589871346950531, 0.15685498714447021, 0.15473836660385132, 0.15263713896274567, 0.1505511850118637, 0.1484803706407547, 0.14642459154129028, 0.1443837285041809, 0.14235764741897583, 0.1403462439775467, 0.13834942877292633, 0.136367067694664, 0.13439907133579254, 0.1324453204870224, 0.1305057406425476, 0.12858019769191742, 0.12666863203048706, 0.12477091699838638, 0.12288697808980942, 0.1210167184472084, 0.11916005611419678, 0.11731690168380737, 0.11548716574907303, 0.11367076635360718, 0.11186762899160385, 0.11007767915725708, 0.1083008274435997, 0.10653700679540634, 0.10478614270687103, 0.1030481606721878, 0.10132300108671188, 0.0996105819940567, 0.09791085124015808, 0.09622374176979065, 0.09454918652772903, 0.09288713335990906, 0.09123751521110535, 0.08960027992725372, 0.08797537535429001, 0.08636274188756943, 0.0847623273730278, 0.08317409455776215, 0.08159798383712769, 0.08003395050764084, 0.07848194986581802, 0.07694194465875626, 0.07541389018297195, 0.07389774918556213, 0.07239348441362381, 0.070901058614254, 0.06942043453454971, 0.06795158982276917, 0.06649449467658997, 0.06504911929368973, 0.06361543387174606, 0.06219341605901718, 0.06078304722905159, 0.0593843050301075, 0.05799717456102371, 0.05662164092063904, 0.05525768920779228, 0.05390531197190285, 0.05256449431180954, 0.05123523622751236, 0.04991753399372101, 0.04861138388514519, 0.047316793352365494, 0.04603376239538193, 0.044762298464775085, 0.04350241273641586, 0.04225412383675575, 0.04101744294166565, 0.039792392402887344, 0.03857899457216263, 0.03737728297710419, 0.03618728369474411, 0.03500903770327568, 0.03384258225560188, 0.0326879620552063, 0.031545232981443405, 0.030414443463087082, 0.0292956605553627, 0.028188949450850487, 0.027094384655356407, 0.02601204626262188, 0.024942025542259216, 0.023884421214461327, 0.022839335724711418, 0.021806888282299042, 0.020787203684449196, 0.019780423492193222, 0.018786700442433357, 0.017806200310587883, 0.016839107498526573, 0.015885621309280396, 0.014945968054234982, 0.01402039173990488, 0.013109165243804455, 0.012212592177093029, 0.011331013403832912, 0.010464809834957123, 0.009614413604140282, 0.008780314587056637, 0.007963077165186405, 0.007163353264331818, 0.0063819061033427715, 0.005619642324745655, 0.004877655766904354, 0.004157294984906912, 0.003460264764726162, 0.0027887988835573196, 0.0021459676790982485, 0.001536299823783338, 0.0009672692976891994, 0.0004541343660093844]);
		kn = $toNativeArray($kindUint32, [1991057938, 0, 1611602771, 1826899878, 1918584482, 1969227037, 2001281515, 2023368125, 2039498179, 2051788381, 2061460127, 2069267110, 2075699398, 2081089314, 2085670119, 2089610331, 2093034710, 2096037586, 2098691595, 2101053571, 2103168620, 2105072996, 2106796166, 2108362327, 2109791536, 2111100552, 2112303493, 2113412330, 2114437283, 2115387130, 2116269447, 2117090813, 2117856962, 2118572919, 2119243101, 2119871411, 2120461303, 2121015852, 2121537798, 2122029592, 2122493434, 2122931299, 2123344971, 2123736059, 2124106020, 2124456175, 2124787725, 2125101763, 2125399283, 2125681194, 2125948325, 2126201433, 2126441213, 2126668298, 2126883268, 2127086657, 2127278949, 2127460589, 2127631985, 2127793506, 2127945490, 2128088244, 2128222044, 2128347141, 2128463758, 2128572095, 2128672327, 2128764606, 2128849065, 2128925811, 2128994934, 2129056501, 2129110560, 2129157136, 2129196237, 2129227847, 2129251929, 2129268426, 2129277255, 2129278312, 2129271467, 2129256561, 2129233410, 2129201800, 2129161480, 2129112170, 2129053545, 2128985244, 2128906855, 2128817916, 2128717911, 2128606255, 2128482298, 2128345305, 2128194452, 2128028813, 2127847342, 2127648860, 2127432031, 2127195339, 2126937058, 2126655214, 2126347546, 2126011445, 2125643893, 2125241376, 2124799783, 2124314271, 2123779094, 2123187386, 2122530867, 2121799464, 2120980787, 2120059418, 2119015917, 2117825402, 2116455471, 2114863093, 2112989789, 2110753906, 2108037662, 2104664315, 2100355223, 2094642347, 2086670106, 2074676188, 2054300022, 2010539237]);
		wn = $toNativeArray($kindFloat32, [1.7290404663583558e-09, 1.2680928529462676e-10, 1.689751810696194e-10, 1.9862687883343e-10, 2.223243117382978e-10, 2.4244936613904144e-10, 2.601613091623989e-10, 2.761198769629658e-10, 2.9073962681813725e-10, 3.042996965518796e-10, 3.169979556627567e-10, 3.289802041894774e-10, 3.4035738116777736e-10, 3.5121602848242617e-10, 3.61625090983253e-10, 3.7164057942185025e-10, 3.813085680537398e-10, 3.906675816178762e-10, 3.997501218933053e-10, 4.0858399996679395e-10, 4.1719308563337165e-10, 4.255982233303257e-10, 4.3381759295968436e-10, 4.4186720948857783e-10, 4.497613115272969e-10, 4.57512583373898e-10, 4.6513240481438345e-10, 4.726310454117311e-10, 4.800177477726209e-10, 4.873009773476156e-10, 4.944885056978876e-10, 5.015873272284921e-10, 5.086040477664255e-10, 5.155446070048697e-10, 5.224146670812502e-10, 5.292193350214802e-10, 5.359634958068682e-10, 5.426517013518151e-10, 5.492881705038144e-10, 5.558769555769061e-10, 5.624218868405251e-10, 5.689264614971989e-10, 5.75394121238304e-10, 5.818281967329142e-10, 5.882316855831959e-10, 5.946076964136182e-10, 6.009590047817426e-10, 6.072883862451306e-10, 6.135985053390414e-10, 6.19892026598734e-10, 6.261713370037114e-10, 6.324390455780815e-10, 6.386973727678935e-10, 6.449488165749528e-10, 6.511955974453087e-10, 6.574400468473129e-10, 6.636843297158634e-10, 6.699307220081607e-10, 6.761814441702541e-10, 6.824387166481927e-10, 6.887046488657234e-10, 6.949815167800466e-10, 7.012714853260604e-10, 7.075767749498141e-10, 7.13899661608508e-10, 7.202424212593428e-10, 7.266072743483676e-10, 7.329966078550854e-10, 7.394128087589991e-10, 7.458582640396116e-10, 7.523354716987285e-10, 7.588469852493063e-10, 7.653954137154528e-10, 7.719834771435785e-10, 7.786139510912449e-10, 7.852897221383159e-10, 7.920137878869582e-10, 7.987892014504894e-10, 8.056192379868321e-10, 8.125072836762115e-10, 8.194568912323064e-10, 8.264716688799467e-10, 8.3355555791087e-10, 8.407127216614185e-10, 8.479473234679347e-10, 8.552640262671218e-10, 8.626675485068347e-10, 8.701631637464402e-10, 8.777562010564566e-10, 8.854524335966119e-10, 8.932581896381464e-10, 9.011799639857543e-10, 9.092249730890956e-10, 9.174008219758889e-10, 9.25715837318819e-10, 9.341788453909317e-10, 9.42799727177146e-10, 9.515889187738935e-10, 9.605578554783278e-10, 9.697193048552322e-10, 9.790869226478094e-10, 9.886760299337993e-10, 9.985036131254788e-10, 1.008588212947359e-09, 1.0189509236369076e-09, 1.0296150598776421e-09, 1.040606933955246e-09, 1.0519566329136865e-09, 1.0636980185552147e-09, 1.0758701707302976e-09, 1.0885182755160372e-09, 1.101694735439196e-09, 1.115461056855338e-09, 1.1298901814171813e-09, 1.1450695946990663e-09, 1.1611052119775422e-09, 1.178127595480305e-09, 1.1962995039027646e-09, 1.2158286599728285e-09, 1.2369856250415978e-09, 1.2601323318151003e-09, 1.2857697129220469e-09, 1.3146201904845611e-09, 1.3477839955200466e-09, 1.3870635751089821e-09, 1.43574030442295e-09, 1.5008658760251592e-09, 1.6030947680434338e-09]);
		fn = $toNativeArray($kindFloat32, [1, 0.963599681854248, 0.9362826943397522, 0.9130436182022095, 0.8922816514968872, 0.8732430338859558, 0.8555005788803101, 0.8387836217880249, 0.8229072093963623, 0.8077383041381836, 0.7931770086288452, 0.7791460752487183, 0.7655841708183289, 0.7524415850639343, 0.7396772503852844, 0.7272568941116333, 0.7151514887809753, 0.7033361196517944, 0.6917891502380371, 0.6804918646812439, 0.6694276928901672, 0.6585819721221924, 0.6479418277740479, 0.6374954581260681, 0.6272324919700623, 0.6171433925628662, 0.6072195172309875, 0.5974531769752502, 0.5878370404243469, 0.5783646702766418, 0.5690299868583679, 0.5598273873329163, 0.550751805305481, 0.5417983531951904, 0.5329626798629761, 0.5242405533790588, 0.5156282186508179, 0.5071220397949219, 0.49871864914894104, 0.4904148280620575, 0.48220765590667725, 0.47409430146217346, 0.466072142124176, 0.45813870429992676, 0.45029163360595703, 0.44252872467041016, 0.4348478317260742, 0.42724698781967163, 0.41972434520721436, 0.41227802634239197, 0.40490642189979553, 0.39760786294937134, 0.3903807997703552, 0.3832238018512726, 0.3761354684829712, 0.3691144585609436, 0.36215949058532715, 0.3552693724632263, 0.3484429717063904, 0.3416791558265686, 0.33497685194015503, 0.32833510637283325, 0.3217529058456421, 0.3152293860912323, 0.30876362323760986, 0.3023548424243927, 0.2960021495819092, 0.2897048592567444, 0.28346219658851624, 0.2772735059261322, 0.271138072013855, 0.2650552988052368, 0.25902456045150757, 0.25304529070854187, 0.24711695313453674, 0.24123899638652802, 0.23541094362735748, 0.22963231801986694, 0.22390270233154297, 0.21822164952754974, 0.21258877217769623, 0.20700371265411377, 0.20146611332893372, 0.1959756463766098, 0.19053204357624054, 0.18513499200344086, 0.17978426814079285, 0.1744796335697174, 0.16922089457511902, 0.16400785744190216, 0.1588403731584549, 0.15371830761432648, 0.14864157140254974, 0.14361007511615753, 0.13862377405166626, 0.13368265330791473, 0.12878671288490295, 0.12393598258495331, 0.11913054436445236, 0.11437050998210907, 0.10965602099895477, 0.1049872562289238, 0.10036443918943405, 0.09578784555196762, 0.09125780314207077, 0.08677466958761215, 0.08233889937400818, 0.07795098423957825, 0.07361150532960892, 0.06932111829519272, 0.06508058309555054, 0.06089077144861221, 0.05675266310572624, 0.05266740173101425, 0.048636294901371, 0.044660862535238266, 0.040742866694927216, 0.03688438981771469, 0.03308788686990738, 0.029356317594647408, 0.025693291798233986, 0.02210330404341221, 0.018592102453112602, 0.015167297795414925, 0.011839478276669979, 0.0086244847625494, 0.005548994988203049, 0.0026696291752159595]);
		rng_cooked = $toNativeArray($kindInt64, [new $Int64(-973649357, 3952672746), new $Int64(-1065661887, 3130416987), new $Int64(324977939, 3414273807), new $Int64(1241840476, 2806224363), new $Int64(-1477934308, 1997590414), new $Int64(2103305448, 2402795971), new $Int64(1663160183, 1140819369), new $Int64(1120601685, 1788868961), new $Int64(1848035537, 1089001426), new $Int64(1235702047, 873593504), new $Int64(1911387977, 581324885), new $Int64(-1654874170, 1609182556), new $Int64(1069394745, 1241596776), new $Int64(1895445337, 1771189259), new $Int64(-1374618802, 3467012610), new $Int64(-140526423, 2344407434), new $Int64(-1745367887, 782467244), new $Int64(26335124, 3404933915), new $Int64(1063924276, 618867887), new $Int64(-968700782, 520164395), new $Int64(-1591572833, 1341358184), new $Int64(-1515085039, 665794848), new $Int64(1527227641, 3183648150), new $Int64(1781176124, 696329606), new $Int64(1789146075, 4151988961), new $Int64(-2087444114, 998951326), new $Int64(-612324923, 1364957564), new $Int64(63173359, 4090230633), new $Int64(-1498029007, 4009697548), new $Int64(248009524, 2569622517), new $Int64(778703922, 3742421481), new $Int64(-1109106023, 1506914633), new $Int64(1738099768, 1983412561), new $Int64(236311649, 1436266083), new $Int64(-1111517500, 3922894967), new $Int64(-1336974714, 1792680179), new $Int64(563141142, 1188796351), new $Int64(1349617468, 405968250), new $Int64(1044074554, 433754187), new $Int64(870549669, 4073162024), new $Int64(-1094251604, 433121399), new $Int64(2451824, 4162580594), new $Int64(-137262572, 4132415622), new $Int64(-1536231048, 3033822028), new $Int64(2016407895, 824682382), new $Int64(2366218, 3583765414), new $Int64(-624604839, 535386927), new $Int64(1637219058, 2286693689), new $Int64(1453075389, 2968466525), new $Int64(193683513, 1351410206), new $Int64(-283806096, 1412813499), new $Int64(492736522, 4126267639), new $Int64(512765208, 2105529399), new $Int64(2132966268, 2413882233), new $Int64(947457634, 32226200), new $Int64(1149341356, 2032329073), new $Int64(106485445, 1356518208), new $Int64(-2067810156, 3430061722), new $Int64(-1484435135, 3820169661), new $Int64(-1665985194, 2981816134), new $Int64(1017155588, 4184371017), new $Int64(206574701, 2119206761), new $Int64(-852109057, 2472200560), new $Int64(-560457548, 2853524696), new $Int64(1307803389, 1681119904), new $Int64(-174986835, 95608918), new $Int64(392686347, 3690479145), new $Int64(-1205570926, 1397922290), new $Int64(-1159314025, 1516129515), new $Int64(-320178155, 1547420459), new $Int64(1311333971, 1470949486), new $Int64(-1953469798, 1336785672), new $Int64(-45086614, 4131677129), new $Int64(-1392278100, 4246329084), new $Int64(-1142500187, 3788585631), new $Int64(-66478285, 3080389532), new $Int64(-646438364, 2215402037), new $Int64(391002300, 1171593935), new $Int64(1408774047, 1423855166), new $Int64(-519177718, 2276716302), new $Int64(-368453140, 2068027241), new $Int64(1369359303, 3427553297), new $Int64(189241615, 3289637845), new $Int64(1057480830, 3486407650), new $Int64(-1512910664, 3071877822), new $Int64(1159653919, 3363620705), new $Int64(-934256930, 4159821533), new $Int64(-76621938, 1894661), new $Int64(-674493898, 1156868282), new $Int64(348271067, 776219088), new $Int64(-501428838, 2425634259), new $Int64(1716021749, 680510161), new $Int64(-574263456, 1310101429), new $Int64(1095885995, 2964454134), new $Int64(-325695512, 3467098407), new $Int64(1990672920, 2109628894), new $Int64(-2139648704, 1232604732), new $Int64(-1838070714, 3261916179), new $Int64(1699175360, 434597899), new $Int64(235436061, 1624796439), new $Int64(-1626402839, 3589632480), new $Int64(1198416575, 864579159), new $Int64(-1938748161, 1380889830), new $Int64(619206309, 2654509477), new $Int64(1419738251, 1468209306), new $Int64(-1744284772, 100794388), new $Int64(-1191421458, 2991674471), new $Int64(-208666741, 2224662036), new $Int64(-173659161, 977097250), new $Int64(1351320195, 726419512), new $Int64(-183459897, 1747974366), new $Int64(-753095183, 1556430604), new $Int64(-1049492215, 1080776742), new $Int64(-385846958, 280794874), new $Int64(117767733, 919835643), new $Int64(-967009426, 3434019658), new $Int64(-1951414480, 2461941785), new $Int64(133215641, 3615001066), new $Int64(417204809, 3103414427), new $Int64(790056561, 3380809712), new $Int64(-1267681408, 2724693469), new $Int64(547796833, 598827710), new $Int64(-1846559452, 3452273442), new $Int64(-75778224, 649274915), new $Int64(-801301329, 2585724112), new $Int64(-1510934263, 3165579553), new $Int64(1185578221, 2635894283), new $Int64(-52910178, 2053289721), new $Int64(985976581, 3169337108), new $Int64(1170569632, 144717764), new $Int64(1079216270, 1383666384), new $Int64(-124804942, 681540375), new $Int64(1375448925, 537050586), new $Int64(-1964768344, 315246468), new $Int64(226402871, 849323088), new $Int64(-885062465, 45543944), new $Int64(-946445250, 2319052083), new $Int64(-40708194, 3613090841), new $Int64(560472520, 2992171180), new $Int64(-381863169, 2068244785), new $Int64(917538188, 4239862634), new $Int64(-1369555809, 3892253031), new $Int64(720683925, 958186149), new $Int64(-423297785, 1877702262), new $Int64(1357886971, 837674867), new $Int64(1837048883, 1507589294), new $Int64(1905518400, 873336795), new $Int64(-1879761037, 2764496274), new $Int64(-1806480530, 4196182374), new $Int64(-1066765755, 550964545), new $Int64(818747069, 420611474), new $Int64(-1924830376, 204265180), new $Int64(1549974541, 1787046383), new $Int64(1215581865, 3102292318), new $Int64(418321538, 1552199393), new $Int64(1243493047, 980542004), new $Int64(267284263, 3293718720), new $Int64(1179528763, 3771917473), new $Int64(599484404, 2195808264), new $Int64(252818753, 3894702887), new $Int64(-1367475956, 2099949527), new $Int64(1424094358, 338442522), new $Int64(490737398, 637158004), new $Int64(-1727621530, 281976339), new $Int64(574970164, 3619802330), new $Int64(-431930823, 3084554784), new $Int64(-1264611183, 4129772886), new $Int64(-2104399043, 1680378557), new $Int64(-1621962591, 3339087776), new $Int64(1680500332, 4220317857), new $Int64(-1935828963, 2959322499), new $Int64(1675600481, 1488354890), new $Int64(-834863562, 3958162143), new $Int64(-1226511573, 2773705983), new $Int64(1876039582, 225908689), new $Int64(-1183735113, 908216283), new $Int64(-605696219, 3574646075), new $Int64(-1827723091, 1936937569), new $Int64(1519770881, 75492235), new $Int64(816689472, 1935193178), new $Int64(2142521206, 2018250883), new $Int64(455141620, 3943126022), new $Int64(-601399488, 3066544345), new $Int64(1932392669, 2793082663), new $Int64(-1239009361, 3297036421), new $Int64(1640597065, 2206987825), new $Int64(-553246738, 807894872), new $Int64(-1781325307, 766252117), new $Int64(2060649606, 3833114345), new $Int64(845619743, 1255067973), new $Int64(1201145605, 741697208), new $Int64(-1476242608, 2810093753), new $Int64(1109032642, 4229340371), new $Int64(1462188720, 1361684224), new $Int64(-1159399429, 1906263026), new $Int64(475781207, 3904421704), new $Int64(-623537128, 1769075545), new $Int64(1062308525, 2621599764), new $Int64(1279509432, 3431891480), new $Int64(-1742751146, 1871896503), new $Int64(128756421, 1412808876), new $Int64(1605404688, 952876175), new $Int64(-230443691, 1824438899), new $Int64(1662295856, 1005035476), new $Int64(-156574141, 527508597), new $Int64(1288873303, 3066806859), new $Int64(565995893, 3244940914), new $Int64(-889746188, 209092916), new $Int64(-247669406, 1242699167), new $Int64(-713830396, 456723774), new $Int64(1776978905, 1001252870), new $Int64(1468772157, 2026725874), new $Int64(857254202, 2137562569), new $Int64(765939740, 3183366709), new $Int64(1533887628, 2612072960), new $Int64(56977098, 1727148468), new $Int64(-1197583895, 3803658212), new $Int64(1883670356, 479946959), new $Int64(685713571, 1562982345), new $Int64(-1946242443, 1766109365), new $Int64(700596547, 3257093788), new $Int64(-184714929, 2365720207), new $Int64(93384808, 3742754173), new $Int64(-458385235, 2878193673), new $Int64(1096135042, 2174002182), new $Int64(-834260953, 3573511231), new $Int64(-754572527, 1760299077), new $Int64(-1375627191, 2260779833), new $Int64(-866019274, 1452805722), new $Int64(-1229671918, 2940011802), new $Int64(1890251082, 1886183802), new $Int64(893897673, 2514369088), new $Int64(1644345561, 3924317791), new $Int64(-1974867432, 500935732), new $Int64(1403501753, 676580929), new $Int64(-1565912283, 1184984890), new $Int64(-691968413, 1271474274), new $Int64(-1828754738, 3163791473), new $Int64(2051027584, 2842487377), new $Int64(1511537551, 2170968612), new $Int64(573262976, 3535856740), new $Int64(-2053227187, 1488599718), new $Int64(-1180531831, 3408913763), new $Int64(-2086531912, 2501050084), new $Int64(-875130448, 1639124157), new $Int64(-2009482504, 4088176393), new $Int64(1574896563, 3989947576), new $Int64(-165243708, 3414355209), new $Int64(-792329287, 2275136352), new $Int64(-2057774345, 2151835223), new $Int64(-931144933, 1654534827), new $Int64(-679921451, 377892833), new $Int64(-482716010, 660204544), new $Int64(85706799, 390828249), new $Int64(-1422172693, 3402783878), new $Int64(-1468634160, 3717936603), new $Int64(1113532086, 2211058823), new $Int64(1564224320, 2692150867), new $Int64(1952770442, 1928910388), new $Int64(788716862, 3931011137), new $Int64(1083670504, 1112701047), new $Int64(-68150572, 2452299106), new $Int64(-896164822, 2337204777), new $Int64(1774877857, 273889282), new $Int64(1798719843, 1462008793), new $Int64(2138834788, 1554494002), new $Int64(-1194967131, 182675323), new $Int64(-1598554764, 1882802136), new $Int64(589279648, 3700220025), new $Int64(381039426, 3083431543), new $Int64(-851859191, 3622207527), new $Int64(338126939, 432729309), new $Int64(-1667470126, 2391914317), new $Int64(-1849558151, 235747924), new $Int64(2120733629, 3088823825), new $Int64(-745079795, 2314658321), new $Int64(1165929723, 2957634338), new $Int64(501323675, 4117056981), new $Int64(1564699815, 1482500298), new $Int64(-740826490, 840489337), new $Int64(799522364, 3483178565), new $Int64(532129761, 2074004656), new $Int64(724246478, 3643392642), new $Int64(-665153481, 1583624461), new $Int64(-885822954, 287473085), new $Int64(1667835381, 3136843981), new $Int64(1138806821, 1266970974), new $Int64(135185781, 1998688839), new $Int64(392094735, 1492900209), new $Int64(1031326774, 1538112737), new $Int64(-2070568842, 2207265429), new $Int64(-1886797613, 963263315), new $Int64(1671145500, 2295892134), new $Int64(1068469660, 2002560897), new $Int64(-356250305, 1369254035), new $Int64(33436120, 3353312708), new $Int64(57507843, 947771099), new $Int64(-1945755145, 1747061399), new $Int64(1507240140, 2047354631), new $Int64(720000810, 4165367136), new $Int64(479265078, 3388864963), new $Int64(-952181250, 286492130), new $Int64(2045622690, 2795735007), new $Int64(-715730566, 3703961339), new $Int64(-148436487, 1797825479), new $Int64(1429039600, 1116589674), new $Int64(-1665420098, 2593309206), new $Int64(1329049334, 3404995677), new $Int64(-750579440, 3453462936), new $Int64(1014767077, 3016498634), new $Int64(75698599, 1650371545), new $Int64(1592007860, 212344364), new $Int64(1127766888, 3843932156), new $Int64(-748019856, 3573129983), new $Int64(-890581831, 665897820), new $Int64(1071492673, 1675628772), new $Int64(243225682, 2831752928), new $Int64(2120298836, 1486294219), new $Int64(-1954407413, 268782709), new $Int64(-1002123503, 4186179080), new $Int64(624342951, 1613720397), new $Int64(857179861, 2703686015), new $Int64(-911618704, 2205342611), new $Int64(-672703993, 1411666394), new $Int64(-1528454899, 677744900), new $Int64(-1876628533, 4172867247), new $Int64(135494707, 2163418403), new $Int64(849547544, 2841526879), new $Int64(-1117516959, 1082141470), new $Int64(-1770111792, 4046134367), new $Int64(51415528, 2142943655), new $Int64(-249824333, 3124627521), new $Int64(998228909, 219992939), new $Int64(-1078790951, 1756846531), new $Int64(1283749206, 1225118210), new $Int64(-525858006, 1647770243), new $Int64(-2035959705, 444807907), new $Int64(2036369448, 3952076173), new $Int64(53201823, 1461839639), new $Int64(315761893, 3699250910), new $Int64(702974850, 1373688981), new $Int64(734022261, 147523747), new $Int64(-2047330906, 1211276581), new $Int64(1294440951, 2548832680), new $Int64(1144696256, 1995631888), new $Int64(-1992983070, 2011457303), new $Int64(-1351022674, 3057425772), new $Int64(667839456, 81484597), new $Int64(-1681980888, 3646681560), new $Int64(-1372462725, 635548515), new $Int64(602489502, 2508044581), new $Int64(-1794220117, 1014917157), new $Int64(719992433, 3214891315), new $Int64(-1294799037, 959582252), new $Int64(226415134, 3347040449), new $Int64(-362868096, 4102971975), new $Int64(397887437, 4078022210), new $Int64(-536803826, 2851767182), new $Int64(-1398321012, 1540160644), new $Int64(-1549098876, 1057290595), new $Int64(-112592988, 3907769253), new $Int64(579300318, 4248952684), new $Int64(-1054576049, 132554364), new $Int64(-1085862414, 1029351092), new $Int64(697840928, 2583007416), new $Int64(298619124, 1486185789), new $Int64(55905697, 2871589073), new $Int64(2017643612, 723203291), new $Int64(146250550, 2494333952), new $Int64(-1082993397, 2230939180), new $Int64(-1804568072, 3943232912), new $Int64(1768732449, 2181367922), new $Int64(-729261111, 2889274791), new $Int64(1824032949, 2046728161), new $Int64(1653899792, 1376052477), new $Int64(1022327048, 381236993), new $Int64(-1113097690, 3188942166), new $Int64(-74480109, 350070824), new $Int64(144881592, 61758415), new $Int64(-741824226, 3492950336), new $Int64(-2030042720, 3093818430), new $Int64(-453590535, 2962480613), new $Int64(-1912050708, 3154871160), new $Int64(-1636478569, 3228564679), new $Int64(610731502, 888276216), new $Int64(-946702974, 3574998604), new $Int64(-1277068380, 1967526716), new $Int64(-1556147941, 1554691298), new $Int64(-1573024234, 339944798), new $Int64(1223764147, 1154515356), new $Int64(1825645307, 967516237), new $Int64(1546195135, 596588202), new $Int64(-1867600880, 3764362170), new $Int64(-1655392592, 266611402), new $Int64(-393255880, 2047856075), new $Int64(-1000726433, 21444105), new $Int64(-949424754, 3065563181), new $Int64(-232418803, 1140663212), new $Int64(633187674, 2323741028), new $Int64(2126290159, 3103873707), new $Int64(1008658319, 2766828349), new $Int64(-485587503, 1970872996), new $Int64(1628585413, 3766615585), new $Int64(-595148528, 2036813414), new $Int64(-1994877121, 3105536507), new $Int64(13954645, 3396176938), new $Int64(-721402003, 1377154485), new $Int64(-61839181, 3807014186), new $Int64(543009040, 3710110597), new $Int64(-1751425519, 916420443), new $Int64(734556788, 2103831255), new $Int64(-1766161494, 717331943), new $Int64(-1574598896, 3550505941), new $Int64(45939673, 378749927), new $Int64(-1997615719, 611017331), new $Int64(592130075, 758907650), new $Int64(1012992349, 154266815), new $Int64(-1040454942, 1407468696), new $Int64(-1678191250, 970098704), new $Int64(-285057486, 1971660656), new $Int64(998365243, 3332747885), new $Int64(1947089649, 1935189867), new $Int64(1510248801, 203520055), new $Int64(-1305165746, 3916463034), new $Int64(-388598655, 3474113316), new $Int64(1036101639, 316544223), new $Int64(-1773744891, 1650844677), new $Int64(-907191419, 4267565603), new $Int64(-1070275024, 2501167616), new $Int64(-1520651863, 3929401789), new $Int64(-2091360852, 337170252), new $Int64(-960502090, 2061966842), new $Int64(-304190848, 2508461464), new $Int64(-1941471116, 2791377107), new $Int64(1240791848, 1227227588), new $Int64(1813978778, 1709681848), new $Int64(1153692192, 3768820575), new $Int64(-1002297449, 2887126398), new $Int64(-1447111334, 296561685), new $Int64(700300844, 3729960077), new $Int64(-1572311344, 372833036), new $Int64(2078875613, 2409779288), new $Int64(1829161290, 555274064), new $Int64(-1105595719, 4239804901), new $Int64(1839403216, 3723486978), new $Int64(-1649093095, 2145871984), new $Int64(-1582765715, 3565480803), new $Int64(-1568653827, 2197313814), new $Int64(974785092, 3613674566), new $Int64(438638731, 3042093666), new $Int64(-96556264, 3324034321), new $Int64(869420878, 3708873369), new $Int64(946682149, 1698090092), new $Int64(1618900382, 4213940712), new $Int64(-1843479747, 2087477361), new $Int64(-1766167800, 2407950639), new $Int64(-1296225558, 3942568569), new $Int64(-1223900450, 4088074412), new $Int64(723260036, 2964773675), new $Int64(-673921829, 1539178386), new $Int64(1062961552, 2694849566), new $Int64(460977733, 2120273838), new $Int64(-1604570740, 2484608657), new $Int64(880846449, 2956190677), new $Int64(1970902366, 4223313749), new $Int64(662161910, 3502682327), new $Int64(705634754, 4133891139), new $Int64(-1031359300, 1166449596), new $Int64(1038247601, 3362705993), new $Int64(93734798, 3892921029), new $Int64(1876124043, 786869787), new $Int64(1057490746, 1046342263), new $Int64(242763728, 493777327), new $Int64(-853573201, 3304827646), new $Int64(616460742, 125356352), new $Int64(499300063, 74094113), new $Int64(-795586925, 2500816079), new $Int64(-490248444, 514015239), new $Int64(1377565129, 543520454), new $Int64(-2039776725, 3614531153), new $Int64(2056746300, 2356753985), new $Int64(1390062617, 2018141668), new $Int64(131272971, 2087974891), new $Int64(-1502927041, 3166972343), new $Int64(372256200, 1517638666), new $Int64(-935275664, 173466846), new $Int64(-695774461, 4241513471), new $Int64(-1413550842, 2783126920), new $Int64(1972004134, 4167264826), new $Int64(29260506, 3907395640), new $Int64(-910901561, 1539634186), new $Int64(-595957298, 178241987), new $Int64(-113277636, 182168164), new $Int64(-1102530459, 2386154934), new $Int64(1379126408, 4077374341), new $Int64(-2114679722, 1732699140), new $Int64(-421057745, 1041306002), new $Int64(1860414813, 2068001749), new $Int64(1005320202, 3208962910), new $Int64(844054010, 697710380), new $Int64(-1509359403, 2228431183), new $Int64(-810313977, 3554678728), new $Int64(-750989047, 173470263), new $Int64(-85886265, 3848297795), new $Int64(-926936977, 246236185), new $Int64(-1984190461, 2066374846), new $Int64(1771673660, 312890749), new $Int64(703378057, 3573310289), new $Int64(-598851901, 143166754), new $Int64(613554316, 2081511079), new $Int64(1197802104, 486038032), new $Int64(-1906483789, 2982218564), new $Int64(364901986, 1000939191), new $Int64(1902782651, 2750454885), new $Int64(-671844857, 3375313137), new $Int64(-1643868040, 881302957), new $Int64(-1508784745, 2514186393), new $Int64(-1703622845, 360024739), new $Int64(1399671872, 292500025), new $Int64(1381210821, 2276300752), new $Int64(521803381, 4069087683), new $Int64(-1938982667, 1637778212), new $Int64(720490469, 1676670893), new $Int64(1067262482, 3855174429), new $Int64(2114075974, 2067248671), new $Int64(-89426259, 2884561259), new $Int64(-805741095, 2456511185), new $Int64(983726246, 561175414), new $Int64(-1719489563, 432588903), new $Int64(885133709, 4059399550), new $Int64(-93096266, 1075014784), new $Int64(-1733832628, 2728058415), new $Int64(1839142064, 1299703678), new $Int64(1262333188, 2347583393), new $Int64(1285481956, 2468164145), new $Int64(-1158354011, 1140014346), new $Int64(2033889184, 1936972070), new $Int64(-1737578993, 3870530098), new $Int64(-484494257, 1717789158), new $Int64(-232997156, 1153452491), new $Int64(-990424416, 3948827651), new $Int64(-1357145630, 2101413152), new $Int64(1495744672, 3854091229), new $Int64(83644069, 4215565463), new $Int64(-1385277313, 1202710438), new $Int64(-564909037, 2072216740), new $Int64(705690639, 2066751068), new $Int64(-2113583312, 173902580), new $Int64(-741983806, 142459001), new $Int64(172391592, 1889151926), new $Int64(-498943125, 3034199774), new $Int64(1618587731, 516490102), new $Int64(93114264, 3692577783), new $Int64(-2078821353, 2953948865), new $Int64(-320938673, 4041040923), new $Int64(-1942517976, 592046130), new $Int64(-705643640, 384297211), new $Int64(-2051649464, 265863924), new $Int64(2101717619, 1333136237), new $Int64(1499611781, 1406273556), new $Int64(1074670496, 426305476), new $Int64(125704633, 2750898176), new $Int64(488068495, 1633944332), new $Int64(2037723464, 3236349343), new $Int64(-1703423246, 4013676611), new $Int64(1718532237, 2265047407), new $Int64(1433593806, 875071080), new $Int64(-343047503, 1418843655), new $Int64(2009228711, 451657300), new $Int64(1229446621, 1866374663), new $Int64(1653472867, 1551455622), new $Int64(577191481, 3560962459), new $Int64(1669204077, 3347903778), new $Int64(-298327194, 2675874918), new $Int64(-1831355577, 2762991672), new $Int64(530492383, 3689068477), new $Int64(844089962, 4071997905), new $Int64(1508155730, 1381702441), new $Int64(2089931018, 2373284878), new $Int64(-864267462, 2143983064), new $Int64(308739063, 1938207195), new $Int64(1754949306, 1188152253), new $Int64(1272345009, 615870490), new $Int64(742653194, 2662252621), new $Int64(1477718295, 3839976789), new $Int64(-2091334213, 306752547), new $Int64(-1426688067, 2162363077), new $Int64(-57052633, 2767224719), new $Int64(-1471624099, 2628837712), new $Int64(1678405918, 2967771969), new $Int64(1694285728, 499792248), new $Int64(-1744131281, 4285253508), new $Int64(962357072, 2856511070), new $Int64(679471692, 2526409716), new $Int64(-1793706473, 1240875658), new $Int64(-914893422, 2577342868), new $Int64(-1001298215, 4136853496), new $Int64(-1477114974, 2403540137), new $Int64(1372824515, 1371410668), new $Int64(-176562048, 371758825), new $Int64(-441063112, 1528834084), new $Int64(-71688630, 1504757260), new $Int64(-1461820072, 699052551), new $Int64(-505543539, 3347789870), new $Int64(1951619734, 3430604759), new $Int64(2119672219, 1935601723), new $Int64(966789690, 834676166)]);
		globalRand = New(new lockedSource.ptr(new nosync.Mutex.ptr(false), $assertType(NewSource(new $Int64(0, 1)), Source64)));
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["math/big"] = (function() {
	var $pkg = {}, $init, bytes, binary, errors, fmt, nosync, io, math, bits, rand, strconv, strings, Word, Int, byteReader, nat, divisor, sliceType, arrayType, structType, sliceType$1, sliceType$2, ptrType$1, ptrType$3, ptrType$4, arrayType$1, sliceType$3, ptrType$6, intOne, natOne, natTwo, karatsubaThreshold, natPool, leafSize, cacheBase10, addWW_g, subWW_g, mulWW_g, mulAddWWW_g, nlz, divWW_g, addVV_g, subVV_g, addVW_g, subVW_g, shlVU_g, shrVU_g, mulAddVWW_g, addMulVVW_g, divWVW_g, mulWW, divWW, addVV, subVV, addVW, subVW, shlVU, shrVU, mulAddVWW, addMulVVW, divWVW, NewInt, low64, Jacobi, writeMultiple, scanSign, basicMul, karatsubaAdd, karatsubaSub, karatsuba, alias, addAt, max, karatsubaLen, getNat, putNat, greaterThan, maxPow, pow, divisors;
	bytes = $packages["bytes"];
	binary = $packages["encoding/binary"];
	errors = $packages["errors"];
	fmt = $packages["fmt"];
	nosync = $packages["github.com/gopherjs/gopherjs/nosync"];
	io = $packages["io"];
	math = $packages["math"];
	bits = $packages["math/bits"];
	rand = $packages["math/rand"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	Word = $pkg.Word = $newType(4, $kindUintptr, "big.Word", true, "math/big", true, null);
	Int = $pkg.Int = $newType(0, $kindStruct, "big.Int", true, "math/big", true, function(neg_, abs_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.neg = false;
			this.abs = nat.nil;
			return;
		}
		this.neg = neg_;
		this.abs = abs_;
	});
	byteReader = $pkg.byteReader = $newType(0, $kindStruct, "big.byteReader", true, "math/big", false, function(ScanState_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.ScanState = $ifaceNil;
			return;
		}
		this.ScanState = ScanState_;
	});
	nat = $pkg.nat = $newType(12, $kindSlice, "big.nat", true, "math/big", false, null);
	divisor = $pkg.divisor = $newType(0, $kindStruct, "big.divisor", true, "math/big", false, function(bbb_, nbits_, ndigits_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.bbb = nat.nil;
			this.nbits = 0;
			this.ndigits = 0;
			return;
		}
		this.bbb = bbb_;
		this.nbits = nbits_;
		this.ndigits = ndigits_;
	});
	sliceType = $sliceType($emptyInterface);
	arrayType = $arrayType(divisor, 64);
	structType = $structType("math/big", [{prop: "Mutex", name: "Mutex", anonymous: true, exported: true, typ: nosync.Mutex, tag: ""}, {prop: "table", name: "table", anonymous: false, exported: false, typ: arrayType, tag: ""}]);
	sliceType$1 = $sliceType($Uint8);
	sliceType$2 = $sliceType(Word);
	ptrType$1 = $ptrType(Int);
	ptrType$3 = $ptrType(Word);
	ptrType$4 = $ptrType(nat);
	arrayType$1 = $arrayType(nat, 16);
	sliceType$3 = $sliceType(divisor);
	ptrType$6 = $ptrType(rand.Rand);
	addWW_g = function(x, y, c) {
		var c, x, y, yc, z0, z1;
		z1 = 0;
		z0 = 0;
		yc = y + c >>> 0;
		z0 = x + yc >>> 0;
		if (z0 < x || yc < y) {
			z1 = 1;
		}
		return [z1, z0];
	};
	subWW_g = function(x, y, c) {
		var c, x, y, yc, z0, z1;
		z1 = 0;
		z0 = 0;
		yc = y + c >>> 0;
		z0 = x - yc >>> 0;
		if (z0 > x || yc < y) {
			z1 = 1;
		}
		return [z1, z0];
	};
	mulWW_g = function(x, y) {
		var t, w0, w1, w2, x, x0, x1, y, y0, y1, z0, z1;
		z1 = 0;
		z0 = 0;
		x0 = (x & 65535) >>> 0;
		x1 = x >>> 16 >>> 0;
		y0 = (y & 65535) >>> 0;
		y1 = y >>> 16 >>> 0;
		w0 = $imul(x0, y0) >>> 0;
		t = ($imul(x1, y0) >>> 0) + (w0 >>> 16 >>> 0) >>> 0;
		w1 = (t & 65535) >>> 0;
		w2 = t >>> 16 >>> 0;
		w1 = w1 + (($imul(x0, y1) >>> 0)) >>> 0;
		z1 = (($imul(x1, y1) >>> 0) + w2 >>> 0) + (w1 >>> 16 >>> 0) >>> 0;
		z0 = $imul(x, y) >>> 0;
		return [z1, z0];
	};
	mulAddWWW_g = function(x, y, c) {
		var _tuple, c, x, y, z0, z1, zz0;
		z1 = 0;
		z0 = 0;
		_tuple = mulWW_g(x, y);
		z1 = _tuple[0];
		zz0 = _tuple[1];
		z0 = zz0 + c >>> 0;
		if (z0 < zz0) {
			z1 = z1 + (1) >>> 0;
		}
		return [z1, z0];
	};
	nlz = function(x) {
		var x;
		return ((bits.LeadingZeros(((x >>> 0))) >>> 0));
	};
	divWW_g = function(u1, u0, v) {
		var _q, _q$1, _tmp, _tmp$1, _tmp$2, _tmp$3, q, q0, q1, r, rhat, s, u0, u1, un0, un1, un10, un21, un32, v, vn0, vn1, y, y$1, y$2, y$3, y$4;
		q = 0;
		r = 0;
		if (u1 >= v) {
			_tmp = 4294967295;
			_tmp$1 = 4294967295;
			q = _tmp;
			r = _tmp$1;
			return [q, r];
		}
		s = nlz(v);
		v = (y = (s), y < 32 ? (v << y) : 0) >>> 0;
		vn1 = v >>> 16 >>> 0;
		vn0 = (v & 65535) >>> 0;
		un32 = (((y$1 = s, y$1 < 32 ? (u1 << y$1) : 0) >>> 0) | ((y$2 = ((32 - s >>> 0)), y$2 < 32 ? (u0 >>> y$2) : 0) >>> 0)) >>> 0;
		un10 = (y$3 = s, y$3 < 32 ? (u0 << y$3) : 0) >>> 0;
		un1 = un10 >>> 16 >>> 0;
		un0 = (un10 & 65535) >>> 0;
		q1 = (_q = un32 / vn1, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		rhat = un32 - ($imul(q1, vn1) >>> 0) >>> 0;
		while (true) {
			if (!(q1 >= 65536 || ($imul(q1, vn0) >>> 0) > (($imul(65536, rhat) >>> 0) + un1 >>> 0))) { break; }
			q1 = q1 - (1) >>> 0;
			rhat = rhat + (vn1) >>> 0;
			if (rhat >= 65536) {
				break;
			}
		}
		un21 = (($imul(un32, 65536) >>> 0) + un1 >>> 0) - ($imul(q1, v) >>> 0) >>> 0;
		q0 = (_q$1 = un21 / vn1, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
		rhat = un21 - ($imul(q0, vn1) >>> 0) >>> 0;
		while (true) {
			if (!(q0 >= 65536 || ($imul(q0, vn0) >>> 0) > (($imul(65536, rhat) >>> 0) + un0 >>> 0))) { break; }
			q0 = q0 - (1) >>> 0;
			rhat = rhat + (vn1) >>> 0;
			if (rhat >= 65536) {
				break;
			}
		}
		_tmp$2 = ($imul(q1, 65536) >>> 0) + q0 >>> 0;
		_tmp$3 = (y$4 = s, y$4 < 32 ? ((((($imul(un21, 65536) >>> 0) + un0 >>> 0) - ($imul(q0, v) >>> 0) >>> 0)) >>> y$4) : 0) >>> 0;
		q = _tmp$2;
		r = _tmp$3;
		return [q, r];
	};
	addVV_g = function(z, x, y) {
		var _i, _i$1, _ref, _ref$1, _tuple, c, i, i$1, x, xi, y, yi, z, zi;
		c = 0;
		if (false) {
			_ref = z;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				_tuple = addWW_g(((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), ((i < 0 || i >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i]), c);
				c = _tuple[0];
				((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = _tuple[1]);
				_i++;
			}
			return c;
		}
		_ref$1 = $subslice(x, 0, z.$length);
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			xi = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			yi = ((i$1 < 0 || i$1 >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i$1]);
			zi = (xi + yi >>> 0) + c >>> 0;
			((i$1 < 0 || i$1 >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i$1] = zi);
			c = (((((xi & yi) >>> 0) | (((((xi | yi) >>> 0)) & ~zi) >>> 0)) >>> 0)) >>> 31 >>> 0;
			_i$1++;
		}
		return c;
	};
	subVV_g = function(z, x, y) {
		var _i, _i$1, _ref, _ref$1, _tuple, c, i, i$1, x, xi, y, yi, z, zi;
		c = 0;
		if (false) {
			_ref = z;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				_tuple = subWW_g(((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), ((i < 0 || i >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i]), c);
				c = _tuple[0];
				((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = _tuple[1]);
				_i++;
			}
			return c;
		}
		_ref$1 = $subslice(x, 0, z.$length);
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			xi = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			yi = ((i$1 < 0 || i$1 >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i$1]);
			zi = (xi - yi >>> 0) - c >>> 0;
			((i$1 < 0 || i$1 >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i$1] = zi);
			c = (((((yi & ~xi) >>> 0) | (((((yi | (~xi >>> 0)) >>> 0)) & zi) >>> 0)) >>> 0)) >>> 31 >>> 0;
			_i$1++;
		}
		return c;
	};
	addVW_g = function(z, x, y) {
		var _i, _i$1, _ref, _ref$1, _tuple, c, i, i$1, x, xi, y, z, zi;
		c = 0;
		if (false) {
			c = y;
			_ref = z;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				_tuple = addWW_g(((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), c, 0);
				c = _tuple[0];
				((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = _tuple[1]);
				_i++;
			}
			return c;
		}
		c = y;
		_ref$1 = $subslice(x, 0, z.$length);
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			xi = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			zi = xi + c >>> 0;
			((i$1 < 0 || i$1 >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i$1] = zi);
			c = ((xi & ~zi) >>> 0) >>> 31 >>> 0;
			_i$1++;
		}
		return c;
	};
	subVW_g = function(z, x, y) {
		var _i, _i$1, _ref, _ref$1, _tuple, c, i, i$1, x, xi, y, z, zi;
		c = 0;
		if (false) {
			c = y;
			_ref = z;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				_tuple = subWW_g(((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), c, 0);
				c = _tuple[0];
				((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = _tuple[1]);
				_i++;
			}
			return c;
		}
		c = y;
		_ref$1 = $subslice(x, 0, z.$length);
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			xi = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			zi = xi - c >>> 0;
			((i$1 < 0 || i$1 >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i$1] = zi);
			c = (((zi & ~xi) >>> 0)) >>> 31 >>> 0;
			_i$1++;
		}
		return c;
	};
	shlVU_g = function(z, x, s) {
		var $C5$9D, c, i, n, s, w, w1, x, x$1, x$2, y, y$1, y$2, y$3, z;
		c = 0;
		n = z.$length;
		if (n > 0) {
			$C5$9D = 32 - s >>> 0;
			w1 = (x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			c = (y = $C5$9D, y < 32 ? (w1 >>> y) : 0) >>> 0;
			i = n - 1 >> 0;
			while (true) {
				if (!(i > 0)) { break; }
				w = w1;
				w1 = (x$2 = i - 1 >> 0, ((x$2 < 0 || x$2 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$2]));
				((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = ((((y$1 = s, y$1 < 32 ? (w << y$1) : 0) >>> 0) | ((y$2 = $C5$9D, y$2 < 32 ? (w1 >>> y$2) : 0) >>> 0)) >>> 0));
				i = i - (1) >> 0;
			}
			(0 >= z.$length ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + 0] = ((y$3 = s, y$3 < 32 ? (w1 << y$3) : 0) >>> 0));
		}
		return c;
	};
	shrVU_g = function(z, x, s) {
		var $C5$9D, c, i, n, s, w, w1, x, x$1, x$2, y, y$1, y$2, y$3, z;
		c = 0;
		n = z.$length;
		if (n > 0) {
			$C5$9D = 32 - s >>> 0;
			w1 = (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]);
			c = (y = $C5$9D, y < 32 ? (w1 << y) : 0) >>> 0;
			i = 0;
			while (true) {
				if (!(i < (n - 1 >> 0))) { break; }
				w = w1;
				w1 = (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
				((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = ((((y$1 = s, y$1 < 32 ? (w >>> y$1) : 0) >>> 0) | ((y$2 = $C5$9D, y$2 < 32 ? (w1 << y$2) : 0) >>> 0)) >>> 0));
				i = i + (1) >> 0;
			}
			(x$2 = n - 1 >> 0, ((x$2 < 0 || x$2 >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + x$2] = ((y$3 = s, y$3 < 32 ? (w1 >>> y$3) : 0) >>> 0)));
		}
		return c;
	};
	mulAddVWW_g = function(z, x, y, r) {
		var _i, _ref, _tuple, c, i, r, x, y, z;
		c = 0;
		c = r;
		_ref = z;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			_tuple = mulAddWWW_g(((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), y, c);
			c = _tuple[0];
			((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = _tuple[1]);
			_i++;
		}
		return c;
	};
	addMulVVW_g = function(z, x, y) {
		var _i, _ref, _tuple, _tuple$1, c, i, x, y, z, z0, z1;
		c = 0;
		_ref = z;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			_tuple = mulAddWWW_g(((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), y, ((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i]));
			z1 = _tuple[0];
			z0 = _tuple[1];
			_tuple$1 = addWW_g(z0, c, 0);
			c = _tuple$1[0];
			((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = _tuple$1[1]);
			c = c + (z1) >>> 0;
			_i++;
		}
		return c;
	};
	divWVW_g = function(z, xn, x, y) {
		var _tuple, i, r, x, xn, y, z;
		r = 0;
		r = xn;
		i = z.$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			_tuple = divWW_g(r, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), y);
			((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = _tuple[0]);
			r = _tuple[1];
			i = i - (1) >> 0;
		}
		return r;
	};
	mulWW = function(x, y) {
		var _tuple, x, y, z0, z1;
		z1 = 0;
		z0 = 0;
		_tuple = mulWW_g(x, y);
		z1 = _tuple[0];
		z0 = _tuple[1];
		return [z1, z0];
	};
	divWW = function(x1, x0, y) {
		var _tuple, q, r, x0, x1, y;
		q = 0;
		r = 0;
		_tuple = divWW_g(x1, x0, y);
		q = _tuple[0];
		r = _tuple[1];
		return [q, r];
	};
	addVV = function(z, x, y) {
		var c, x, y, z;
		c = 0;
		c = addVV_g(z, x, y);
		return c;
	};
	subVV = function(z, x, y) {
		var c, x, y, z;
		c = 0;
		c = subVV_g(z, x, y);
		return c;
	};
	addVW = function(z, x, y) {
		var c, x, y, z;
		c = 0;
		c = addVW_g(z, x, y);
		return c;
	};
	subVW = function(z, x, y) {
		var c, x, y, z;
		c = 0;
		c = subVW_g(z, x, y);
		return c;
	};
	shlVU = function(z, x, s) {
		var c, s, x, z;
		c = 0;
		c = shlVU_g(z, x, s);
		return c;
	};
	shrVU = function(z, x, s) {
		var c, s, x, z;
		c = 0;
		c = shrVU_g(z, x, s);
		return c;
	};
	mulAddVWW = function(z, x, y, r) {
		var c, r, x, y, z;
		c = 0;
		c = mulAddVWW_g(z, x, y, r);
		return c;
	};
	addMulVVW = function(z, x, y) {
		var c, x, y, z;
		c = 0;
		c = addMulVVW_g(z, x, y);
		return c;
	};
	divWVW = function(z, xn, x, y) {
		var r, x, xn, y, z;
		r = 0;
		r = divWVW_g(z, xn, x, y);
		return r;
	};
	Int.ptr.prototype.Sign = function() {
		var x;
		x = this;
		if (x.abs.$length === 0) {
			return 0;
		}
		if (x.neg) {
			return -1;
		}
		return 1;
	};
	Int.prototype.Sign = function() { return this.$val.Sign(); };
	Int.ptr.prototype.SetInt64 = function(x) {
		var neg, x, z;
		z = this;
		neg = false;
		if ((x.$high < 0 || (x.$high === 0 && x.$low < 0))) {
			neg = true;
			x = new $Int64(-x.$high, -x.$low);
		}
		z.abs = z.abs.setUint64((new $Uint64(x.$high, x.$low)));
		z.neg = neg;
		return z;
	};
	Int.prototype.SetInt64 = function(x) { return this.$val.SetInt64(x); };
	Int.ptr.prototype.SetUint64 = function(x) {
		var x, z;
		z = this;
		z.abs = z.abs.setUint64(x);
		z.neg = false;
		return z;
	};
	Int.prototype.SetUint64 = function(x) { return this.$val.SetUint64(x); };
	NewInt = function(x) {
		var x;
		return new Int.ptr(false, nat.nil).SetInt64(x);
	};
	$pkg.NewInt = NewInt;
	Int.ptr.prototype.Set = function(x) {
		var x, z;
		z = this;
		if (!(z === x)) {
			z.abs = z.abs.set(x.abs);
			z.neg = x.neg;
		}
		return z;
	};
	Int.prototype.Set = function(x) { return this.$val.Set(x); };
	Int.ptr.prototype.Bits = function() {
		var x, x$1;
		x = this;
		return (x$1 = x.abs, $subslice(new sliceType$2(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length));
	};
	Int.prototype.Bits = function() { return this.$val.Bits(); };
	Int.ptr.prototype.SetBits = function(abs) {
		var abs, z;
		z = this;
		z.abs = ($subslice(new nat(abs.$array), abs.$offset, abs.$offset + abs.$length)).norm();
		z.neg = false;
		return z;
	};
	Int.prototype.SetBits = function(abs) { return this.$val.SetBits(abs); };
	Int.ptr.prototype.Abs = function(x) {
		var x, z;
		z = this;
		z.Set(x);
		z.neg = false;
		return z;
	};
	Int.prototype.Abs = function(x) { return this.$val.Abs(x); };
	Int.ptr.prototype.Neg = function(x) {
		var x, z;
		z = this;
		z.Set(x);
		z.neg = z.abs.$length > 0 && !z.neg;
		return z;
	};
	Int.prototype.Neg = function(x) { return this.$val.Neg(x); };
	Int.ptr.prototype.Add = function(x, y) {
		var neg, x, y, z;
		z = this;
		neg = x.neg;
		if (x.neg === y.neg) {
			z.abs = z.abs.add(x.abs, y.abs);
		} else {
			if (x.abs.cmp(y.abs) >= 0) {
				z.abs = z.abs.sub(x.abs, y.abs);
			} else {
				neg = !neg;
				z.abs = z.abs.sub(y.abs, x.abs);
			}
		}
		z.neg = z.abs.$length > 0 && neg;
		return z;
	};
	Int.prototype.Add = function(x, y) { return this.$val.Add(x, y); };
	Int.ptr.prototype.Sub = function(x, y) {
		var neg, x, y, z;
		z = this;
		neg = x.neg;
		if (!(x.neg === y.neg)) {
			z.abs = z.abs.add(x.abs, y.abs);
		} else {
			if (x.abs.cmp(y.abs) >= 0) {
				z.abs = z.abs.sub(x.abs, y.abs);
			} else {
				neg = !neg;
				z.abs = z.abs.sub(y.abs, x.abs);
			}
		}
		z.neg = z.abs.$length > 0 && neg;
		return z;
	};
	Int.prototype.Sub = function(x, y) { return this.$val.Sub(x, y); };
	Int.ptr.prototype.Mul = function(x, y) {
		var x, y, z;
		z = this;
		z.abs = z.abs.mul(x.abs, y.abs);
		z.neg = z.abs.$length > 0 && !(x.neg === y.neg);
		return z;
	};
	Int.prototype.Mul = function(x, y) { return this.$val.Mul(x, y); };
	Int.ptr.prototype.MulRange = function(a, b) {
		var _tmp, _tmp$1, a, b, neg, x, x$1, z;
		z = this;
		if ((a.$high > b.$high || (a.$high === b.$high && a.$low > b.$low))) {
			return z.SetInt64(new $Int64(0, 1));
		} else if ((a.$high < 0 || (a.$high === 0 && a.$low <= 0)) && (b.$high > 0 || (b.$high === 0 && b.$low >= 0))) {
			return z.SetInt64(new $Int64(0, 0));
		}
		neg = false;
		if ((a.$high < 0 || (a.$high === 0 && a.$low < 0))) {
			neg = (x = (x$1 = new $Int64(b.$high - a.$high, b.$low - a.$low), new $Int64(x$1.$high & 0, (x$1.$low & 1) >>> 0)), (x.$high === 0 && x.$low === 0));
			_tmp = new $Int64(-b.$high, -b.$low);
			_tmp$1 = new $Int64(-a.$high, -a.$low);
			a = _tmp;
			b = _tmp$1;
		}
		z.abs = z.abs.mulRange((new $Uint64(a.$high, a.$low)), (new $Uint64(b.$high, b.$low)));
		z.neg = neg;
		return z;
	};
	Int.prototype.MulRange = function(a, b) { return this.$val.MulRange(a, b); };
	Int.ptr.prototype.Binomial = function(n, k) {
		var _r, _tmp, _tmp$1, a, b, k, n, x, x$1, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; a = $f.a; b = $f.b; k = $f.k; n = $f.n; x = $f.x; x$1 = $f.x$1; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		a = [a];
		b = [b];
		z = this;
		if ((x = $div64(n, new $Int64(0, 2), false), (x.$high < k.$high || (x.$high === k.$high && x.$low < k.$low))) && (k.$high < n.$high || (k.$high === n.$high && k.$low <= n.$low))) {
			k = new $Int64(n.$high - k.$high, n.$low - k.$low);
		}
		_tmp = new Int.ptr(false, nat.nil);
		_tmp$1 = new Int.ptr(false, nat.nil);
		a[0] = $clone(_tmp, Int);
		b[0] = $clone(_tmp$1, Int);
		a[0].MulRange((x$1 = new $Int64(n.$high - k.$high, n.$low - k.$low), new $Int64(x$1.$high + 0, x$1.$low + 1)), n);
		b[0].MulRange(new $Int64(0, 1), k);
		_r = z.Quo(a[0], b[0]); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Binomial }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.a = a; $f.b = b; $f.k = k; $f.n = n; $f.x = x; $f.x$1 = x$1; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Binomial = function(n, k) { return this.$val.Binomial(n, k); };
	Int.ptr.prototype.Quo = function(x, y) {
		var _r, _tuple, x, y, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; x = $f.x; y = $f.y; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		_r = z.abs.div(nat.nil, x.abs, y.abs); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		z.abs = _tuple[0];
		z.neg = z.abs.$length > 0 && !(x.neg === y.neg);
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Quo }; } $f._r = _r; $f._tuple = _tuple; $f.x = x; $f.y = y; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Quo = function(x, y) { return this.$val.Quo(x, y); };
	Int.ptr.prototype.Rem = function(x, y) {
		var _r, _tuple, x, y, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; x = $f.x; y = $f.y; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		_r = (nat.nil).div(z.abs, x.abs, y.abs); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		z.abs = _tuple[1];
		z.neg = z.abs.$length > 0 && x.neg;
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Rem }; } $f._r = _r; $f._tuple = _tuple; $f.x = x; $f.y = y; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Rem = function(x, y) { return this.$val.Rem(x, y); };
	Int.ptr.prototype.QuoRem = function(x, y, r) {
		var _r, _tmp, _tmp$1, _tuple, r, x, y, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; r = $f.r; x = $f.x; y = $f.y; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		_r = z.abs.div(r.abs, x.abs, y.abs); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		z.abs = _tuple[0];
		r.abs = _tuple[1];
		_tmp = z.abs.$length > 0 && !(x.neg === y.neg);
		_tmp$1 = r.abs.$length > 0 && x.neg;
		z.neg = _tmp;
		r.neg = _tmp$1;
		$s = -1; return [z, r];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.QuoRem }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.r = r; $f.x = x; $f.y = y; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.QuoRem = function(x, y, r) { return this.$val.QuoRem(x, y, r); };
	Int.ptr.prototype.Div = function(x, y) {
		var _r, r, x, y, y_neg, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; x = $f.x; y = $f.y; y_neg = $f.y_neg; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = [r];
		z = this;
		y_neg = y.neg;
		r[0] = new Int.ptr(false, nat.nil);
		_r = z.QuoRem(x, y, r[0]); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		if (r[0].neg) {
			if (y_neg) {
				z.Add(z, intOne);
			} else {
				z.Sub(z, intOne);
			}
		}
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Div }; } $f._r = _r; $f.r = r; $f.x = x; $f.y = y; $f.y_neg = y_neg; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Div = function(x, y) { return this.$val.Div(x, y); };
	Int.ptr.prototype.Mod = function(x, y) {
		var _r, q, x, y, y0, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; q = $f.q; x = $f.x; y = $f.y; y0 = $f.y0; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		y0 = y;
		if (z === y || alias(z.abs, y.abs)) {
			y0 = new Int.ptr(false, nat.nil).Set(y);
		}
		q = new Int.ptr(false, nat.nil);
		_r = q.QuoRem(x, y, z); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		if (z.neg) {
			if (y0.neg) {
				z.Sub(z, y0);
			} else {
				z.Add(z, y0);
			}
		}
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Mod }; } $f._r = _r; $f.q = q; $f.x = x; $f.y = y; $f.y0 = y0; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Mod = function(x, y) { return this.$val.Mod(x, y); };
	Int.ptr.prototype.DivMod = function(x, y, m) {
		var _r, m, x, y, y0, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; m = $f.m; x = $f.x; y = $f.y; y0 = $f.y0; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		y0 = y;
		if (z === y || alias(z.abs, y.abs)) {
			y0 = new Int.ptr(false, nat.nil).Set(y);
		}
		_r = z.QuoRem(x, y, m); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		if (m.neg) {
			if (y0.neg) {
				z.Add(z, intOne);
				m.Sub(m, y0);
			} else {
				z.Sub(z, intOne);
				m.Add(m, y0);
			}
		}
		$s = -1; return [z, m];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.DivMod }; } $f._r = _r; $f.m = m; $f.x = x; $f.y = y; $f.y0 = y0; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.DivMod = function(x, y, m) { return this.$val.DivMod(x, y, m); };
	Int.ptr.prototype.Cmp = function(y) {
		var r, x, y;
		r = 0;
		x = this;
		if (x.neg === y.neg) {
			r = x.abs.cmp(y.abs);
			if (x.neg) {
				r = -r;
			}
		} else if (x.neg) {
			r = -1;
		} else {
			r = 1;
		}
		return r;
	};
	Int.prototype.Cmp = function(y) { return this.$val.Cmp(y); };
	low64 = function(x) {
		var v, x, x$1, x$2, x$3;
		if (x.$length === 0) {
			return new $Uint64(0, 0);
		}
		v = ((x$1 = (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]), new $Uint64(0, x$1.constructor === Number ? x$1 : 1)));
		if (true && x.$length > 1) {
			return (x$2 = $shiftLeft64(((x$3 = (1 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 1]), new $Uint64(0, x$3.constructor === Number ? x$3 : 1))), 32), new $Uint64(x$2.$high | v.$high, (x$2.$low | v.$low) >>> 0));
		}
		return v;
	};
	Int.ptr.prototype.Int64 = function() {
		var v, x, x$1;
		x = this;
		v = ((x$1 = low64(x.abs), new $Int64(x$1.$high, x$1.$low)));
		if (x.neg) {
			v = new $Int64(-v.$high, -v.$low);
		}
		return v;
	};
	Int.prototype.Int64 = function() { return this.$val.Int64(); };
	Int.ptr.prototype.Uint64 = function() {
		var x;
		x = this;
		return low64(x.abs);
	};
	Int.prototype.Uint64 = function() { return this.$val.Uint64(); };
	Int.ptr.prototype.IsInt64 = function() {
		var w, x, x$1, x$2;
		x = this;
		if (x.abs.$length <= 2) {
			w = ((x$1 = low64(x.abs), new $Int64(x$1.$high, x$1.$low)));
			return (w.$high > 0 || (w.$high === 0 && w.$low >= 0)) || x.neg && (x$2 = new $Int64(-w.$high, -w.$low), (w.$high === x$2.$high && w.$low === x$2.$low));
		}
		return false;
	};
	Int.prototype.IsInt64 = function() { return this.$val.IsInt64(); };
	Int.ptr.prototype.IsUint64 = function() {
		var x;
		x = this;
		return !x.neg && x.abs.$length <= 2;
	};
	Int.prototype.IsUint64 = function() { return this.$val.IsUint64(); };
	Int.ptr.prototype.SetString = function(s, base) {
		var _r, _tuple, _tuple$1, base, err, err$1, r, s, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; base = $f.base; err = $f.err; err$1 = $f.err$1; r = $f.r; s = $f.s; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		r = strings.NewReader(s);
		_r = z.scan(r, base); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [ptrType$1.nil, false];
		}
		_tuple$1 = r.ReadByte();
		err$1 = _tuple$1[1];
		if (!($interfaceIsEqual(err$1, io.EOF))) {
			$s = -1; return [ptrType$1.nil, false];
		}
		$s = -1; return [z, true];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.SetString }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.base = base; $f.err = err; $f.err$1 = err$1; $f.r = r; $f.s = s; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.SetString = function(s, base) { return this.$val.SetString(s, base); };
	Int.ptr.prototype.SetBytes = function(buf) {
		var buf, z;
		z = this;
		z.abs = z.abs.setBytes(buf);
		z.neg = false;
		return z;
	};
	Int.prototype.SetBytes = function(buf) { return this.$val.SetBytes(buf); };
	Int.ptr.prototype.Bytes = function() {
		var buf, x;
		x = this;
		buf = $makeSlice(sliceType$1, ($imul(x.abs.$length, 4)));
		return $subslice(buf, x.abs.bytes(buf));
	};
	Int.prototype.Bytes = function() { return this.$val.Bytes(); };
	Int.ptr.prototype.BitLen = function() {
		var x;
		x = this;
		return x.abs.bitLen();
	};
	Int.prototype.BitLen = function() { return this.$val.BitLen(); };
	Int.ptr.prototype.Exp = function(x, y, m) {
		var _r, m, mWords, x, y, yWords, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; m = $f.m; mWords = $f.mWords; x = $f.x; y = $f.y; yWords = $f.yWords; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		yWords = nat.nil;
		if (!y.neg) {
			yWords = y.abs;
		}
		mWords = nat.nil;
		if (!(m === ptrType$1.nil)) {
			mWords = m.abs;
		}
		_r = z.abs.expNN(x.abs, yWords, mWords); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		z.abs = _r;
		z.neg = z.abs.$length > 0 && x.neg && yWords.$length > 0 && ((((0 >= yWords.$length ? ($throwRuntimeError("index out of range"), undefined) : yWords.$array[yWords.$offset + 0]) & 1) >>> 0) === 1);
		if (z.neg && mWords.$length > 0) {
			z.abs = z.abs.sub(mWords, z.abs);
			z.neg = false;
		}
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Exp }; } $f._r = _r; $f.m = m; $f.mWords = mWords; $f.x = x; $f.y = y; $f.yWords = yWords; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Exp = function(x, y, m) { return this.$val.Exp(x, y, m); };
	Int.ptr.prototype.GCD = function(x, y, a, b) {
		var A, B, X, Y, _r, _r$1, _tmp, _tmp$1, _tmp$2, _tuple, a, b, lastX, lastY, q, r, temp, x, y, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; A = $f.A; B = $f.B; X = $f.X; Y = $f.Y; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tuple = $f._tuple; a = $f.a; b = $f.b; lastX = $f.lastX; lastY = $f.lastY; q = $f.q; r = $f.r; temp = $f.temp; x = $f.x; y = $f.y; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		if (a.Sign() <= 0 || b.Sign() <= 0) {
			z.SetInt64(new $Int64(0, 0));
			if (!(x === ptrType$1.nil)) {
				x.SetInt64(new $Int64(0, 0));
			}
			if (!(y === ptrType$1.nil)) {
				y.SetInt64(new $Int64(0, 0));
			}
			$s = -1; return z;
		}
		/* */ if (x === ptrType$1.nil && y === ptrType$1.nil) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (x === ptrType$1.nil && y === ptrType$1.nil) { */ case 1:
			_r = z.binaryGCD(a, b); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		A = new Int.ptr(false, nat.nil).Set(a);
		B = new Int.ptr(false, nat.nil).Set(b);
		X = new Int.ptr(false, nat.nil);
		Y = new Int.ptr(false, nat.nil).SetInt64(new $Int64(0, 1));
		lastX = new Int.ptr(false, nat.nil).SetInt64(new $Int64(0, 1));
		lastY = new Int.ptr(false, nat.nil);
		q = new Int.ptr(false, nat.nil);
		temp = new Int.ptr(false, nat.nil);
		r = new Int.ptr(false, nat.nil);
		/* while (true) { */ case 4:
			/* if (!(B.abs.$length > 0)) { break; } */ if(!(B.abs.$length > 0)) { $s = 5; continue; }
			_r$1 = q.QuoRem(A, B, r); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple = _r$1;
			q = _tuple[0];
			r = _tuple[1];
			_tmp = B;
			_tmp$1 = r;
			_tmp$2 = A;
			A = _tmp;
			B = _tmp$1;
			r = _tmp$2;
			temp.Set(X);
			X.Mul(X, q);
			X.neg = !X.neg;
			X.Add(X, lastX);
			lastX.Set(temp);
			temp.Set(Y);
			Y.Mul(Y, q);
			Y.neg = !Y.neg;
			Y.Add(Y, lastY);
			lastY.Set(temp);
		/* } */ $s = 4; continue; case 5:
		if (!(x === ptrType$1.nil)) {
			Int.copy(x, lastX);
		}
		if (!(y === ptrType$1.nil)) {
			Int.copy(y, lastY);
		}
		Int.copy(z, A);
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.GCD }; } $f.A = A; $f.B = B; $f.X = X; $f.Y = Y; $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tuple = _tuple; $f.a = a; $f.b = b; $f.lastX = lastX; $f.lastY = lastY; $f.q = q; $f.r = r; $f.temp = temp; $f.x = x; $f.y = y; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.GCD = function(x, y, a, b) { return this.$val.GCD(x, y, a, b); };
	Int.ptr.prototype.binaryGCD = function(a, b) {
		var _r, _r$1, _tmp, _tmp$1, _tmp$2, _tmp$3, a, b, k, t, u, v, vk, x, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; a = $f.a; b = $f.b; k = $f.k; t = $f.t; u = $f.u; v = $f.v; vk = $f.vk; x = $f.x; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		u = z;
		v = new Int.ptr(false, nat.nil);
			/* */ if (a.abs.$length > b.abs.$length) { $s = 2; continue; }
			/* */ if (a.abs.$length < b.abs.$length) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (a.abs.$length > b.abs.$length) { */ case 2:
				_r = v.Rem(a, b); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_r;
				u.Set(b);
				$s = 5; continue;
			/* } else if (a.abs.$length < b.abs.$length) { */ case 3:
				_r$1 = v.Rem(b, a); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_r$1;
				u.Set(a);
				$s = 5; continue;
			/* } else { */ case 4:
				v.Set(b);
				u.Set(a);
			/* } */ case 5:
		case 1:
		if (v.abs.$length === 0) {
			$s = -1; return u;
		}
		k = u.abs.trailingZeroBits();
		vk = v.abs.trailingZeroBits();
		if (vk < k) {
			k = vk;
		}
		u.Rsh(u, k);
		v.Rsh(v, k);
		t = new Int.ptr(false, nat.nil);
		if (!(((((x = u.abs, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) & 1) >>> 0) === 0))) {
			t.Neg(v);
		} else {
			t.Set(u);
		}
		while (true) {
			if (!(t.abs.$length > 0)) { break; }
			t.Rsh(t, t.abs.trailingZeroBits());
			if (t.neg) {
				_tmp = t;
				_tmp$1 = v;
				v = _tmp;
				t = _tmp$1;
				v.neg = v.abs.$length > 0 && !v.neg;
			} else {
				_tmp$2 = t;
				_tmp$3 = u;
				u = _tmp$2;
				t = _tmp$3;
			}
			t.Sub(u, v);
		}
		$s = -1; return z.Lsh(u, k);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.binaryGCD }; } $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.a = a; $f.b = b; $f.k = k; $f.t = t; $f.u = u; $f.v = v; $f.vk = vk; $f.x = x; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.binaryGCD = function(a, b) { return this.$val.binaryGCD(a, b); };
	Int.ptr.prototype.Rand = function(rnd, n) {
		var _r, n, rnd, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; rnd = $f.rnd; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.neg = false;
		if (n.neg || (n.abs.$length === 0)) {
			z.abs = nat.nil;
			$s = -1; return z;
		}
		_r = z.abs.random(rnd, n.abs, n.abs.bitLen()); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		z.abs = _r;
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Rand }; } $f._r = _r; $f.n = n; $f.rnd = rnd; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Rand = function(rnd, n) { return this.$val.Rand(rnd, n); };
	Int.ptr.prototype.ModInverse = function(g, n) {
		var _r, _r$1, d, g, g2, n, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; d = $f.d; g = $f.g; g2 = $f.g2; n = $f.n; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		/* */ if (g.neg) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (g.neg) { */ case 1:
			g2 = new Int.ptr(false, nat.nil);
			_r = g2.Mod(g, n); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			g = _r;
		/* } */ case 2:
		d = new Int.ptr(false, nat.nil);
		_r$1 = d.GCD(z, ptrType$1.nil, g, n); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		if (z.neg) {
			z.Add(z, n);
		}
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.ModInverse }; } $f._r = _r; $f._r$1 = _r$1; $f.d = d; $f.g = g; $f.g2 = g2; $f.n = n; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.ModInverse = function(g, n) { return this.$val.ModInverse(g, n); };
	Jacobi = function(x, y) {
		var _r, _r$1, _tmp, _tmp$1, _tmp$2, a, b, bmod8, c, j, s, x, x$1, x$2, x$3, x$4, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; a = $f.a; b = $f.b; bmod8 = $f.bmod8; c = $f.c; j = $f.j; s = $f.s; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		a = [a];
		b = [b];
		c = [c];
		/* */ if ((y.abs.$length === 0) || ((((x$1 = y.abs, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])) & 1) >>> 0) === 0)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((y.abs.$length === 0) || ((((x$1 = y.abs, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])) & 1) >>> 0) === 0)) { */ case 1:
			_r = fmt.Sprintf("big: invalid 2nd argument to Int.Jacobi: need odd integer but got %s", new sliceType([y])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$panic(new $String(_r));
		/* } */ case 2:
		_tmp = new Int.ptr(false, nat.nil);
		_tmp$1 = new Int.ptr(false, nat.nil);
		_tmp$2 = new Int.ptr(false, nat.nil);
		a[0] = $clone(_tmp, Int);
		b[0] = $clone(_tmp$1, Int);
		c[0] = $clone(_tmp$2, Int);
		a[0].Set(x);
		b[0].Set(y);
		j = 1;
		if (b[0].neg) {
			if (a[0].neg) {
				j = -1;
			}
			b[0].neg = false;
		}
		/* while (true) { */ case 4:
			if (b[0].Cmp(intOne) === 0) {
				$s = -1; return j;
			}
			if (a[0].abs.$length === 0) {
				$s = -1; return 0;
			}
			_r$1 = a[0].Mod(a[0], b[0]); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$1;
			if (a[0].abs.$length === 0) {
				$s = -1; return 0;
			}
			s = a[0].abs.trailingZeroBits();
			if (!((((s & 1) >>> 0) === 0))) {
				bmod8 = ((x$2 = b[0].abs, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0])) & 7) >>> 0;
				if ((bmod8 === 3) || (bmod8 === 5)) {
					j = -j;
				}
			}
			c[0].Rsh(a[0], s);
			if (((((x$3 = b[0].abs, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])) & 3) >>> 0) === 3) && ((((x$4 = c[0].abs, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0])) & 3) >>> 0) === 3)) {
				j = -j;
			}
			a[0].Set(b[0]);
			b[0].Set(c[0]);
		/* } */ $s = 4; continue; case 5:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Jacobi }; } $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f.a = a; $f.b = b; $f.bmod8 = bmod8; $f.c = c; $f.j = j; $f.s = s; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Jacobi = Jacobi;
	Int.ptr.prototype.modSqrt3Mod4Prime = function(x, p) {
		var _r, p, x, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; x = $f.x; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.Set(p);
		z.Add(z, intOne);
		z.Rsh(z, 2);
		_r = z.Exp(x, z, p); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.modSqrt3Mod4Prime }; } $f._r = _r; $f.p = p; $f.x = x; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.modSqrt3Mod4Prime = function(x, p) { return this.$val.modSqrt3Mod4Prime(x, p); };
	Int.ptr.prototype.modSqrtTonelliShanks = function(x, p) {
		var _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _tmp, _tmp$1, _tmp$2, _tmp$3, b, e, g, m, n, p, r, s, t, x, y, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; b = $f.b; e = $f.e; g = $f.g; m = $f.m; n = $f.n; p = $f.p; r = $f.r; s = $f.s; t = $f.t; x = $f.x; y = $f.y; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = [b];
		g = [g];
		n = [n];
		s = [s];
		t = [t];
		y = [y];
		z = this;
		s[0] = new Int.ptr(false, nat.nil);
		s[0].Sub(p, intOne);
		e = s[0].abs.trailingZeroBits();
		s[0].Rsh(s[0], e);
		n[0] = new Int.ptr(false, nat.nil);
		n[0].SetInt64(new $Int64(0, 2));
		/* while (true) { */ case 1:
			_r = Jacobi(n[0], p); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* if (!(!((_r === -1)))) { break; } */ if(!(!((_r === -1)))) { $s = 2; continue; }
			n[0].Add(n[0], intOne);
		/* } */ $s = 1; continue; case 2:
		_tmp = new Int.ptr(false, nat.nil);
		_tmp$1 = new Int.ptr(false, nat.nil);
		_tmp$2 = new Int.ptr(false, nat.nil);
		_tmp$3 = new Int.ptr(false, nat.nil);
		y[0] = $clone(_tmp, Int);
		b[0] = $clone(_tmp$1, Int);
		g[0] = $clone(_tmp$2, Int);
		t[0] = $clone(_tmp$3, Int);
		y[0].Add(s[0], intOne);
		y[0].Rsh(y[0], 1);
		_r$1 = y[0].Exp(x, y[0], p); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		_r$2 = b[0].Exp(x, s[0], p); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		_r$3 = g[0].Exp(n[0], s[0], p); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$3;
		r = e;
		/* while (true) { */ case 7:
			m = 0;
			t[0].Set(b[0]);
			/* while (true) { */ case 9:
				/* if (!(!((t[0].Cmp(intOne) === 0)))) { break; } */ if(!(!((t[0].Cmp(intOne) === 0)))) { $s = 10; continue; }
				_r$4 = t[0].Mul(t[0], t[0]).Mod(t[0], p); /* */ $s = 11; case 11: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				_r$4;
				m = m + (1) >>> 0;
			/* } */ $s = 9; continue; case 10:
			if (m === 0) {
				$s = -1; return z.Set(y[0]);
			}
			_r$5 = t[0].SetInt64(new $Int64(0, 0)).SetBit(t[0], ((((r - m >>> 0) - 1 >>> 0) >> 0)), 1).Exp(g[0], t[0], p); /* */ $s = 12; case 12: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			_r$5;
			_r$6 = g[0].Mul(t[0], t[0]).Mod(g[0], p); /* */ $s = 13; case 13: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_r$6;
			_r$7 = y[0].Mul(y[0], t[0]).Mod(y[0], p); /* */ $s = 14; case 14: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_r$7;
			_r$8 = b[0].Mul(b[0], g[0]).Mod(b[0], p); /* */ $s = 15; case 15: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			_r$8;
			r = m;
		/* } */ $s = 7; continue; case 8:
		$s = -1; return ptrType$1.nil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.modSqrtTonelliShanks }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.b = b; $f.e = e; $f.g = g; $f.m = m; $f.n = n; $f.p = p; $f.r = r; $f.s = s; $f.t = t; $f.x = x; $f.y = y; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.modSqrtTonelliShanks = function(x, p) { return this.$val.modSqrtTonelliShanks(x, p); };
	Int.ptr.prototype.ModSqrt = function(x, p) {
		var _1, _r, _r$1, _r$2, _r$3, _r$4, p, x, x$1, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; p = $f.p; x = $f.x; x$1 = $f.x$1; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
			_r = Jacobi(x, p); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_1 = _r;
			if (_1 === (-1)) {
				$s = -1; return ptrType$1.nil;
			} else if (_1 === (0)) {
				$s = -1; return z.SetInt64(new $Int64(0, 0));
			} else if (_1 === (1)) {
				/* break; */ $s = 1; continue;
			}
		case 1:
		/* */ if (x.neg || x.Cmp(p) >= 0) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (x.neg || x.Cmp(p) >= 0) { */ case 3:
			_r$1 = new Int.ptr(false, nat.nil).Mod(x, p); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			x = _r$1;
		/* } */ case 4:
		/* */ if (p.abs.$length > 0 && ((_r$2 = (x$1 = p.abs, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])) % 4, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero")) === 3)) { $s = 6; continue; }
		/* */ $s = 7; continue;
		/* if (p.abs.$length > 0 && ((_r$2 = (x$1 = p.abs, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])) % 4, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero")) === 3)) { */ case 6:
			_r$3 = z.modSqrt3Mod4Prime(x, p); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			$s = -1; return _r$3;
		/* } */ case 7:
		_r$4 = z.modSqrtTonelliShanks(x, p); /* */ $s = 9; case 9: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		$s = -1; return _r$4;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.ModSqrt }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.ModSqrt = function(x, p) { return this.$val.ModSqrt(x, p); };
	Int.ptr.prototype.Lsh = function(x, n) {
		var n, x, z;
		z = this;
		z.abs = z.abs.shl(x.abs, n);
		z.neg = x.neg;
		return z;
	};
	Int.prototype.Lsh = function(x, n) { return this.$val.Lsh(x, n); };
	Int.ptr.prototype.Rsh = function(x, n) {
		var n, t, x, z;
		z = this;
		if (x.neg) {
			t = z.abs.sub(x.abs, natOne);
			t = t.shr(t, n);
			z.abs = t.add(t, natOne);
			z.neg = true;
			return z;
		}
		z.abs = z.abs.shr(x.abs, n);
		z.neg = false;
		return z;
	};
	Int.prototype.Rsh = function(x, n) { return this.$val.Rsh(x, n); };
	Int.ptr.prototype.Bit = function(i) {
		var i, t, x, x$1;
		x = this;
		if (i === 0) {
			if (x.abs.$length > 0) {
				return (((((x$1 = x.abs, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])) & 1) >>> 0) >>> 0));
			}
			return 0;
		}
		if (i < 0) {
			$panic(new $String("negative bit index"));
		}
		if (x.neg) {
			t = (nat.nil).sub(x.abs, natOne);
			return (t.bit(((i >>> 0))) ^ 1) >>> 0;
		}
		return x.abs.bit(((i >>> 0)));
	};
	Int.prototype.Bit = function(i) { return this.$val.Bit(i); };
	Int.ptr.prototype.SetBit = function(x, i, b) {
		var b, i, t, x, z;
		z = this;
		if (i < 0) {
			$panic(new $String("negative bit index"));
		}
		if (x.neg) {
			t = z.abs.sub(x.abs, natOne);
			t = t.setBit(t, ((i >>> 0)), (b ^ 1) >>> 0);
			z.abs = t.add(t, natOne);
			z.neg = z.abs.$length > 0;
			return z;
		}
		z.abs = z.abs.setBit(x.abs, ((i >>> 0)), b);
		z.neg = false;
		return z;
	};
	Int.prototype.SetBit = function(x, i, b) { return this.$val.SetBit(x, i, b); };
	Int.ptr.prototype.And = function(x, y) {
		var _tmp, _tmp$1, x, x1, y, y1, y1$1, z;
		z = this;
		if (x.neg === y.neg) {
			if (x.neg) {
				x1 = (nat.nil).sub(x.abs, natOne);
				y1 = (nat.nil).sub(y.abs, natOne);
				z.abs = z.abs.add(z.abs.or(x1, y1), natOne);
				z.neg = true;
				return z;
			}
			z.abs = z.abs.and(x.abs, y.abs);
			z.neg = false;
			return z;
		}
		if (x.neg) {
			_tmp = y;
			_tmp$1 = x;
			x = _tmp;
			y = _tmp$1;
		}
		y1$1 = (nat.nil).sub(y.abs, natOne);
		z.abs = z.abs.andNot(x.abs, y1$1);
		z.neg = false;
		return z;
	};
	Int.prototype.And = function(x, y) { return this.$val.And(x, y); };
	Int.ptr.prototype.AndNot = function(x, y) {
		var x, x1, x1$1, y, y1, y1$1, z;
		z = this;
		if (x.neg === y.neg) {
			if (x.neg) {
				x1 = (nat.nil).sub(x.abs, natOne);
				y1 = (nat.nil).sub(y.abs, natOne);
				z.abs = z.abs.andNot(y1, x1);
				z.neg = false;
				return z;
			}
			z.abs = z.abs.andNot(x.abs, y.abs);
			z.neg = false;
			return z;
		}
		if (x.neg) {
			x1$1 = (nat.nil).sub(x.abs, natOne);
			z.abs = z.abs.add(z.abs.or(x1$1, y.abs), natOne);
			z.neg = true;
			return z;
		}
		y1$1 = (nat.nil).sub(y.abs, natOne);
		z.abs = z.abs.and(x.abs, y1$1);
		z.neg = false;
		return z;
	};
	Int.prototype.AndNot = function(x, y) { return this.$val.AndNot(x, y); };
	Int.ptr.prototype.Or = function(x, y) {
		var _tmp, _tmp$1, x, x1, y, y1, y1$1, z;
		z = this;
		if (x.neg === y.neg) {
			if (x.neg) {
				x1 = (nat.nil).sub(x.abs, natOne);
				y1 = (nat.nil).sub(y.abs, natOne);
				z.abs = z.abs.add(z.abs.and(x1, y1), natOne);
				z.neg = true;
				return z;
			}
			z.abs = z.abs.or(x.abs, y.abs);
			z.neg = false;
			return z;
		}
		if (x.neg) {
			_tmp = y;
			_tmp$1 = x;
			x = _tmp;
			y = _tmp$1;
		}
		y1$1 = (nat.nil).sub(y.abs, natOne);
		z.abs = z.abs.add(z.abs.andNot(y1$1, x.abs), natOne);
		z.neg = true;
		return z;
	};
	Int.prototype.Or = function(x, y) { return this.$val.Or(x, y); };
	Int.ptr.prototype.Xor = function(x, y) {
		var _tmp, _tmp$1, x, x1, y, y1, y1$1, z;
		z = this;
		if (x.neg === y.neg) {
			if (x.neg) {
				x1 = (nat.nil).sub(x.abs, natOne);
				y1 = (nat.nil).sub(y.abs, natOne);
				z.abs = z.abs.xor(x1, y1);
				z.neg = false;
				return z;
			}
			z.abs = z.abs.xor(x.abs, y.abs);
			z.neg = false;
			return z;
		}
		if (x.neg) {
			_tmp = y;
			_tmp$1 = x;
			x = _tmp;
			y = _tmp$1;
		}
		y1$1 = (nat.nil).sub(y.abs, natOne);
		z.abs = z.abs.add(z.abs.xor(x.abs, y1$1), natOne);
		z.neg = true;
		return z;
	};
	Int.prototype.Xor = function(x, y) { return this.$val.Xor(x, y); };
	Int.ptr.prototype.Not = function(x) {
		var x, z;
		z = this;
		if (x.neg) {
			z.abs = z.abs.sub(x.abs, natOne);
			z.neg = false;
			return z;
		}
		z.abs = z.abs.add(x.abs, natOne);
		z.neg = true;
		return z;
	};
	Int.prototype.Not = function(x) { return this.$val.Not(x); };
	Int.ptr.prototype.Sqrt = function(x) {
		var _r, x, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; x = $f.x; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		if (x.neg) {
			$panic(new $String("square root of negative number"));
		}
		z.neg = false;
		_r = z.abs.sqrt(x.abs); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		z.abs = _r;
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Sqrt }; } $f._r = _r; $f.x = x; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Sqrt = function(x) { return this.$val.Sqrt(x); };
	Int.ptr.prototype.Text = function(base) {
		var _r, base, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; base = $f.base; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = this;
		if (x === ptrType$1.nil) {
			$s = -1; return "<nil>";
		}
		_r = x.abs.itoa(x.neg, base); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return ($bytesToString(_r));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Text }; } $f._r = _r; $f.base = base; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Text = function(base) { return this.$val.Text(base); };
	Int.ptr.prototype.Append = function(buf, base) {
		var _arg, _arg$1, _r, base, buf, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; base = $f.base; buf = $f.buf; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = this;
		if (x === ptrType$1.nil) {
			$s = -1; return $appendSlice(buf, "<nil>");
		}
		_arg = buf;
		_r = x.abs.itoa(x.neg, base); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg$1 = _r;
		$s = -1; return $appendSlice(_arg, _arg$1);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Append }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f.base = base; $f.buf = buf; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Append = function(buf, base) { return this.$val.Append(buf, base); };
	Int.ptr.prototype.String = function() {
		var _r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = this;
		_r = x.Text(10); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.String }; } $f._r = _r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.String = function() { return this.$val.String(); };
	writeMultiple = function(s, text, count) {
		var _r, b, count, s, text, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; count = $f.count; s = $f.s; text = $f.text; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ if (text.length > 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (text.length > 0) { */ case 1:
			b = (new sliceType$1($stringToBytes(text)));
			/* while (true) { */ case 3:
				/* if (!(count > 0)) { break; } */ if(!(count > 0)) { $s = 4; continue; }
				_r = s.Write(b); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_r;
				count = count - (1) >> 0;
			/* } */ $s = 3; continue; case 4:
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: writeMultiple }; } $f._r = _r; $f.b = b; $f.count = count; $f.s = s; $f.text = text; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.ptr.prototype.Format = function(s, ch) {
		var _1, _2, _arg, _arg$1, _arg$2, _i, _r, _r$1, _r$10, _r$11, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _tuple, _tuple$1, base, ch, d, d$1, digits, i, left, length, precision, precisionSet, prefix, right, s, sign, width, widthSet, x, zeros, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; base = $f.base; ch = $f.ch; d = $f.d; d$1 = $f.d$1; digits = $f.digits; i = $f.i; left = $f.left; length = $f.length; precision = $f.precision; precisionSet = $f.precisionSet; prefix = $f.prefix; right = $f.right; s = $f.s; sign = $f.sign; width = $f.width; widthSet = $f.widthSet; x = $f.x; zeros = $f.zeros; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = this;
		base = 0;
			_1 = ch;
			/* */ if (_1 === (98)) { $s = 2; continue; }
			/* */ if (_1 === (111)) { $s = 3; continue; }
			/* */ if ((_1 === (100)) || (_1 === (115)) || (_1 === (118))) { $s = 4; continue; }
			/* */ if ((_1 === (120)) || (_1 === (88))) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (98)) { */ case 2:
				base = 2;
				$s = 7; continue;
			/* } else if (_1 === (111)) { */ case 3:
				base = 8;
				$s = 7; continue;
			/* } else if ((_1 === (100)) || (_1 === (115)) || (_1 === (118))) { */ case 4:
				base = 10;
				$s = 7; continue;
			/* } else if ((_1 === (120)) || (_1 === (88))) { */ case 5:
				base = 16;
				$s = 7; continue;
			/* } else { */ case 6:
				_arg = s;
				_arg$1 = new $Int32(ch);
				_r = x.String(); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_arg$2 = new $String(_r);
				_r$1 = fmt.Fprintf(_arg, "%%!%c(big.Int=%s)", new sliceType([_arg$1, _arg$2])); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_r$1;
				$s = -1; return;
			/* } */ case 7:
		case 1:
		/* */ if (x === ptrType$1.nil) { $s = 10; continue; }
		/* */ $s = 11; continue;
		/* if (x === ptrType$1.nil) { */ case 10:
			_r$2 = fmt.Fprint(s, new sliceType([new $String("<nil>")])); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_r$2;
			$s = -1; return;
		/* } */ case 11:
		sign = "";
			/* */ if (x.neg) { $s = 14; continue; }
			_r$3 = s.Flag(43); /* */ $s = 18; case 18: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			/* */ if (_r$3) { $s = 15; continue; }
			_r$4 = s.Flag(32); /* */ $s = 19; case 19: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			/* */ if (_r$4) { $s = 16; continue; }
			/* */ $s = 17; continue;
			/* if (x.neg) { */ case 14:
				sign = "-";
				$s = 17; continue;
			/* } else if (_r$3) { */ case 15:
				sign = "+";
				$s = 17; continue;
			/* } else if (_r$4) { */ case 16:
				sign = " ";
			/* } */ case 17:
		case 13:
		prefix = "";
		_r$5 = s.Flag(35); /* */ $s = 22; case 22: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		/* */ if (_r$5) { $s = 20; continue; }
		/* */ $s = 21; continue;
		/* if (_r$5) { */ case 20:
			_2 = ch;
			if (_2 === (111)) {
				prefix = "0";
			} else if (_2 === (120)) {
				prefix = "0x";
			} else if (_2 === (88)) {
				prefix = "0X";
			}
		/* } */ case 21:
		_r$6 = x.abs.utoa(base); /* */ $s = 23; case 23: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		digits = _r$6;
		if (ch === 88) {
			_ref = digits;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				d = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (97 <= d && d <= 122) {
					((i < 0 || i >= digits.$length) ? ($throwRuntimeError("index out of range"), undefined) : digits.$array[digits.$offset + i] = (65 + ((d - 97 << 24 >>> 24)) << 24 >>> 24));
				}
				_i++;
			}
		}
		left = 0;
		zeros = 0;
		right = 0;
		_r$7 = s.Precision(); /* */ $s = 24; case 24: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_tuple = _r$7;
		precision = _tuple[0];
		precisionSet = _tuple[1];
		if (precisionSet) {
			if (digits.$length < precision) {
				zeros = precision - digits.$length >> 0;
			} else if ((digits.$length === 1) && ((0 >= digits.$length ? ($throwRuntimeError("index out of range"), undefined) : digits.$array[digits.$offset + 0]) === 48) && (precision === 0)) {
				$s = -1; return;
			}
		}
		length = ((sign.length + prefix.length >> 0) + zeros >> 0) + digits.$length >> 0;
		_r$8 = s.Width(); /* */ $s = 25; case 25: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		_tuple$1 = _r$8;
		width = _tuple$1[0];
		widthSet = _tuple$1[1];
		/* */ if (widthSet && length < width) { $s = 26; continue; }
		/* */ $s = 27; continue;
		/* if (widthSet && length < width) { */ case 26:
				d$1 = width - length >> 0;
				_r$9 = s.Flag(45); /* */ $s = 33; case 33: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				/* */ if (_r$9) { $s = 29; continue; }
				_r$10 = s.Flag(48); /* */ $s = 34; case 34: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
				/* */ if (_r$10 && !precisionSet) { $s = 30; continue; }
				/* */ $s = 31; continue;
				/* if (_r$9) { */ case 29:
					right = d$1;
					$s = 32; continue;
				/* } else if (_r$10 && !precisionSet) { */ case 30:
					zeros = d$1;
					$s = 32; continue;
				/* } else { */ case 31:
					left = d$1;
				/* } */ case 32:
			case 28:
		/* } */ case 27:
		$r = writeMultiple(s, " ", left); /* */ $s = 35; case 35: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = writeMultiple(s, sign, 1); /* */ $s = 36; case 36: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = writeMultiple(s, prefix, 1); /* */ $s = 37; case 37: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = writeMultiple(s, "0", zeros); /* */ $s = 38; case 38: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$11 = s.Write(digits); /* */ $s = 39; case 39: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
		_r$11;
		$r = writeMultiple(s, " ", right); /* */ $s = 40; case 40: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Format }; } $f._1 = _1; $f._2 = _2; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.base = base; $f.ch = ch; $f.d = d; $f.d$1 = d$1; $f.digits = digits; $f.i = i; $f.left = left; $f.length = length; $f.precision = precision; $f.precisionSet = precisionSet; $f.prefix = prefix; $f.right = right; $f.s = s; $f.sign = sign; $f.width = width; $f.widthSet = widthSet; $f.x = x; $f.zeros = zeros; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Format = function(s, ch) { return this.$val.Format(s, ch); };
	Int.ptr.prototype.scan = function(r, base) {
		var _r, _r$1, _tuple, _tuple$1, base, err, neg, r, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; base = $f.base; err = $f.err; neg = $f.neg; r = $f.r; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		_r = scanSign(r); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		neg = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [ptrType$1.nil, 0, err];
		}
		_r$1 = z.abs.scan(r, base, false); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		z.abs = _tuple$1[0];
		base = _tuple$1[1];
		err = _tuple$1[3];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [ptrType$1.nil, base, err];
		}
		z.neg = z.abs.$length > 0 && neg;
		$s = -1; return [z, base, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.scan }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.base = base; $f.err = err; $f.neg = neg; $f.r = r; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.scan = function(r, base) { return this.$val.scan(r, base); };
	scanSign = function(r) {
		var _1, _r, _r$1, _tmp, _tmp$1, _tuple, ch, err, neg, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; ch = $f.ch; err = $f.err; neg = $f.neg; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		neg = false;
		err = $ifaceNil;
		ch = 0;
		_r = r.ReadByte(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		ch = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			_tmp = false;
			_tmp$1 = err;
			neg = _tmp;
			err = _tmp$1;
			$s = -1; return [neg, err];
		}
			_1 = ch;
			/* */ if (_1 === (45)) { $s = 3; continue; }
			/* */ if (_1 === (43)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_1 === (45)) { */ case 3:
				neg = true;
				$s = 6; continue;
			/* } else if (_1 === (43)) { */ case 4:
				$s = 6; continue;
			/* } else { */ case 5:
				_r$1 = r.UnreadByte(); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_r$1;
			/* } */ case 6:
		case 2:
		$s = -1; return [neg, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: scanSign }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.ch = ch; $f.err = err; $f.neg = neg; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	byteReader.ptr.prototype.ReadByte = function() {
		var _r, _r$1, _tuple, ch, err, r, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; ch = $f.ch; err = $f.err; r = $f.r; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.ScanState.ReadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		ch = _tuple[0];
		size = _tuple[1];
		err = _tuple[2];
		/* */ if (!((size === 1)) && $interfaceIsEqual(err, $ifaceNil)) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((size === 1)) && $interfaceIsEqual(err, $ifaceNil)) { */ case 2:
			_r$1 = fmt.Errorf("invalid rune %#U", new sliceType([new $Int32(ch)])); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			err = _r$1;
		/* } */ case 3:
		$s = -1; return [((ch << 24 >>> 24)), err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: byteReader.ptr.prototype.ReadByte }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.ch = ch; $f.err = err; $f.r = r; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	byteReader.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	byteReader.ptr.prototype.UnreadByte = function() {
		var _r, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.ScanState.UnreadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: byteReader.ptr.prototype.UnreadByte }; } $f._r = _r; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	byteReader.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Int.ptr.prototype.Scan = function(s, ch) {
		var _1, _r, _tuple, base, ch, err, s, x, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _tuple = $f._tuple; base = $f.base; ch = $f.ch; err = $f.err; s = $f.s; x = $f.x; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		$r = s.SkipSpace(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		base = 0;
		_1 = ch;
		if (_1 === (98)) {
			base = 2;
		} else if (_1 === (111)) {
			base = 8;
		} else if (_1 === (100)) {
			base = 10;
		} else if ((_1 === (120)) || (_1 === (88))) {
			base = 16;
		} else if ((_1 === (115)) || (_1 === (118))) {
		} else {
			$s = -1; return errors.New("Int.Scan: invalid verb");
		}
		_r = z.scan((x = new byteReader.ptr(s), new x.constructor.elem(x)), base); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		err = _tuple[2];
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.Scan }; } $f._1 = _1; $f._r = _r; $f._tuple = _tuple; $f.base = base; $f.ch = ch; $f.err = err; $f.s = s; $f.x = x; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.Scan = function(s, ch) { return this.$val.Scan(s, ch); };
	Int.ptr.prototype.GobEncode = function() {
		var b, buf, i, x;
		x = this;
		if (x === ptrType$1.nil) {
			return [sliceType$1.nil, $ifaceNil];
		}
		buf = $makeSlice(sliceType$1, (1 + ($imul(x.abs.$length, 4)) >> 0));
		i = x.abs.bytes(buf) - 1 >> 0;
		b = 2;
		if (x.neg) {
			b = (b | (1)) >>> 0;
		}
		((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = b);
		return [$subslice(buf, i), $ifaceNil];
	};
	Int.prototype.GobEncode = function() { return this.$val.GobEncode(); };
	Int.ptr.prototype.GobDecode = function(buf) {
		var _r, b, buf, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; buf = $f.buf; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		if (buf.$length === 0) {
			Int.copy(z, new Int.ptr(false, nat.nil));
			$s = -1; return $ifaceNil;
		}
		b = (0 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 0]);
		/* */ if (!(((b >>> 1 << 24 >>> 24) === 1))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(((b >>> 1 << 24 >>> 24) === 1))) { */ case 1:
			_r = fmt.Errorf("Int.GobDecode: encoding version %d not supported", new sliceType([new $Uint8((b >>> 1 << 24 >>> 24))])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		z.neg = !((((b & 1) >>> 0) === 0));
		z.abs = z.abs.setBytes($subslice(buf, 1));
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.GobDecode }; } $f._r = _r; $f.b = b; $f.buf = buf; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.GobDecode = function(buf) { return this.$val.GobDecode(buf); };
	Int.ptr.prototype.MarshalText = function() {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, err, text, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; err = $f.err; text = $f.text; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		text = sliceType$1.nil;
		err = $ifaceNil;
		x = this;
		if (x === ptrType$1.nil) {
			_tmp = (new sliceType$1($stringToBytes("<nil>")));
			_tmp$1 = $ifaceNil;
			text = _tmp;
			err = _tmp$1;
			$s = -1; return [text, err];
		}
		_r = x.abs.itoa(x.neg, 10); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tmp$2 = _r;
		_tmp$3 = $ifaceNil;
		text = _tmp$2;
		err = _tmp$3;
		$s = -1; return [text, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.MarshalText }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.err = err; $f.text = text; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.MarshalText = function() { return this.$val.MarshalText(); };
	Int.ptr.prototype.UnmarshalText = function(text) {
		var _r, _r$1, _tuple, ok, text, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; ok = $f.ok; text = $f.text; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		_r = z.SetString(($bytesToString(text)), 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		ok = _tuple[1];
		/* */ if (!ok) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!ok) { */ case 2:
			_r$1 = fmt.Errorf("math/big: cannot unmarshal %q into a *big.Int", new sliceType([text])); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
		/* } */ case 3:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.UnmarshalText }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.ok = ok; $f.text = text; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.UnmarshalText = function(text) { return this.$val.UnmarshalText(text); };
	Int.ptr.prototype.MarshalJSON = function() {
		var _r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = this;
		_r = x.MarshalText(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.MarshalJSON }; } $f._r = _r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.MarshalJSON = function() { return this.$val.MarshalJSON(); };
	Int.ptr.prototype.UnmarshalJSON = function(text) {
		var _r, text, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; text = $f.text; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		if (($bytesToString(text)) === "null") {
			$s = -1; return $ifaceNil;
		}
		_r = z.UnmarshalText(text); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.UnmarshalJSON }; } $f._r = _r; $f.text = text; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.UnmarshalJSON = function(text) { return this.$val.UnmarshalJSON(text); };
	nat.prototype.clear = function() {
		var _i, _ref, i, z;
		z = this;
		_ref = z;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = 0);
			_i++;
		}
	};
	$ptrType(nat).prototype.clear = function() { return this.$get().clear(); };
	nat.prototype.norm = function() {
		var i, x, z;
		z = this;
		i = z.$length;
		while (true) {
			if (!(i > 0 && ((x = i - 1 >> 0, ((x < 0 || x >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + x])) === 0))) { break; }
			i = i - (1) >> 0;
		}
		return $subslice(z, 0, i);
	};
	$ptrType(nat).prototype.norm = function() { return this.$get().norm(); };
	nat.prototype.make = function(n) {
		var n, z;
		z = this;
		if (n <= z.$capacity) {
			return $subslice(z, 0, n);
		}
		return $makeSlice(nat, n, (n + 4 >> 0));
	};
	$ptrType(nat).prototype.make = function(n) { return this.$get().make(n); };
	nat.prototype.setWord = function(x) {
		var x, z;
		z = this;
		if (x === 0) {
			return $subslice(z, 0, 0);
		}
		z = z.make(1);
		(0 >= z.$length ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + 0] = x);
		return z;
	};
	$ptrType(nat).prototype.setWord = function(x) { return this.$get().setWord(x); };
	nat.prototype.setUint64 = function(x) {
		var w, x, x$1, z;
		z = this;
		w = ((x.$low >>> 0));
		if ((x$1 = (new $Uint64(0, w.constructor === Number ? w : 1)), (x$1.$high === x.$high && x$1.$low === x.$low))) {
			return z.setWord(w);
		}
		z = z.make(2);
		(1 >= z.$length ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + 1] = (($shiftRightUint64(x, 32).$low >>> 0)));
		(0 >= z.$length ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + 0] = ((x.$low >>> 0)));
		return z;
	};
	$ptrType(nat).prototype.setUint64 = function(x) { return this.$get().setUint64(x); };
	nat.prototype.set = function(x) {
		var x, z;
		z = this;
		z = z.make(x.$length);
		$copySlice(z, x);
		return z;
	};
	$ptrType(nat).prototype.set = function(x) { return this.$get().set(x); };
	nat.prototype.add = function(x, y) {
		var c, m, n, x, x$1, x$2, x$3, y, z;
		z = this;
		m = x.$length;
		n = y.$length;
		if (m < n) {
			return z.add(y, x);
		} else if ((m === 0)) {
			return $subslice(z, 0, 0);
		} else if ((n === 0)) {
			return z.set(x);
		}
		z = z.make(m + 1 >> 0);
		c = addVV((x$1 = $subslice(z, 0, n), $subslice(new sliceType$2(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length)), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length), $subslice(new sliceType$2(y.$array), y.$offset, y.$offset + y.$length));
		if (m > n) {
			c = addVW((x$2 = $subslice(z, n, m), $subslice(new sliceType$2(x$2.$array), x$2.$offset, x$2.$offset + x$2.$length)), (x$3 = $subslice(x, n), $subslice(new sliceType$2(x$3.$array), x$3.$offset, x$3.$offset + x$3.$length)), c);
		}
		((m < 0 || m >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + m] = c);
		return z.norm();
	};
	$ptrType(nat).prototype.add = function(x, y) { return this.$get().add(x, y); };
	nat.prototype.sub = function(x, y) {
		var c, m, n, x, x$1, x$2, x$3, y, z;
		z = this;
		m = x.$length;
		n = y.$length;
		if (m < n) {
			$panic(new $String("underflow"));
		} else if ((m === 0)) {
			return $subslice(z, 0, 0);
		} else if ((n === 0)) {
			return z.set(x);
		}
		z = z.make(m);
		c = subVV((x$1 = $subslice(z, 0, n), $subslice(new sliceType$2(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length)), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length), $subslice(new sliceType$2(y.$array), y.$offset, y.$offset + y.$length));
		if (m > n) {
			c = subVW((x$2 = $subslice(z, n), $subslice(new sliceType$2(x$2.$array), x$2.$offset, x$2.$offset + x$2.$length)), (x$3 = $subslice(x, n), $subslice(new sliceType$2(x$3.$array), x$3.$offset, x$3.$offset + x$3.$length)), c);
		}
		if (!((c === 0))) {
			$panic(new $String("underflow"));
		}
		return z.norm();
	};
	$ptrType(nat).prototype.sub = function(x, y) { return this.$get().sub(x, y); };
	nat.prototype.cmp = function(y) {
		var i, m, n, r, x, y;
		r = 0;
		x = this;
		m = x.$length;
		n = y.$length;
		if (!((m === n)) || (m === 0)) {
			if (m < n) {
				r = -1;
			} else if (m > n) {
				r = 1;
			}
			return r;
		}
		i = m - 1 >> 0;
		while (true) {
			if (!(i > 0 && (((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]) === ((i < 0 || i >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i])))) { break; }
			i = i - (1) >> 0;
		}
		if (((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]) < ((i < 0 || i >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i])) {
			r = -1;
		} else if (((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]) > ((i < 0 || i >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i])) {
			r = 1;
		}
		return r;
	};
	$ptrType(nat).prototype.cmp = function(y) { return this.$get().cmp(y); };
	nat.prototype.mulAddWW = function(x, y, r) {
		var m, r, x, x$1, y, z;
		z = this;
		m = x.$length;
		if ((m === 0) || (y === 0)) {
			return z.setWord(r);
		}
		z = z.make(m + 1 >> 0);
		((m < 0 || m >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + m] = mulAddVWW((x$1 = $subslice(z, 0, m), $subslice(new sliceType$2(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length)), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length), y, r));
		return z.norm();
	};
	$ptrType(nat).prototype.mulAddWW = function(x, y, r) { return this.$get().mulAddWW(x, y, r); };
	basicMul = function(z, x, y) {
		var _i, _ref, d, i, x, x$1, x$2, y, z;
		$subslice(z, 0, (x.$length + y.$length >> 0)).clear();
		_ref = y;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			d = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((d === 0))) {
				(x$2 = x.$length + i >> 0, ((x$2 < 0 || x$2 >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + x$2] = addMulVVW((x$1 = $subslice(z, i, (i + x.$length >> 0)), $subslice(new sliceType$2(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length)), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length), d)));
			}
			_i++;
		}
	};
	nat.prototype.montgomery = function(x, y, m, k, n) {
		var c, c2, c3, cx, cy, d, i, k, m, n, t, x, x$1, y, z;
		z = this;
		if (!((x.$length === n)) || !((y.$length === n)) || !((m.$length === n))) {
			$panic(new $String("math/big: mismatched montgomery number lengths"));
		}
		z = z.make(n);
		z.clear();
		c = 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			d = ((i < 0 || i >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i]);
			c2 = addMulVVW($subslice(new sliceType$2(z.$array), z.$offset, z.$offset + z.$length), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length), d);
			t = $imul((0 >= z.$length ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + 0]), k) >>> 0;
			c3 = addMulVVW($subslice(new sliceType$2(z.$array), z.$offset, z.$offset + z.$length), $subslice(new sliceType$2(m.$array), m.$offset, m.$offset + m.$length), t);
			$copySlice(z, $subslice(z, 1));
			cx = c + c2 >>> 0;
			cy = cx + c3 >>> 0;
			(x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + x$1] = cy));
			if (cx < c2 || cy < c3) {
				c = 1;
			} else {
				c = 0;
			}
			i = i + (1) >> 0;
		}
		if (!((c === 0))) {
			subVV($subslice(new sliceType$2(z.$array), z.$offset, z.$offset + z.$length), $subslice(new sliceType$2(z.$array), z.$offset, z.$offset + z.$length), $subslice(new sliceType$2(m.$array), m.$offset, m.$offset + m.$length));
		}
		return z;
	};
	$ptrType(nat).prototype.montgomery = function(x, y, m, k, n) { return this.$get().montgomery(x, y, m, k, n); };
	karatsubaAdd = function(z, x, n) {
		var c, n, x, x$1, x$2, x$3, z;
		c = addVV((x$1 = $subslice(z, 0, n), $subslice(new sliceType$2(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length)), $subslice(new sliceType$2(z.$array), z.$offset, z.$offset + z.$length), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length));
		if (!((c === 0))) {
			addVW((x$2 = $subslice(z, n, (n + (n >> 1 >> 0) >> 0)), $subslice(new sliceType$2(x$2.$array), x$2.$offset, x$2.$offset + x$2.$length)), (x$3 = $subslice(z, n), $subslice(new sliceType$2(x$3.$array), x$3.$offset, x$3.$offset + x$3.$length)), c);
		}
	};
	karatsubaSub = function(z, x, n) {
		var c, n, x, x$1, x$2, x$3, z;
		c = subVV((x$1 = $subslice(z, 0, n), $subslice(new sliceType$2(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length)), $subslice(new sliceType$2(z.$array), z.$offset, z.$offset + z.$length), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length));
		if (!((c === 0))) {
			subVW((x$2 = $subslice(z, n, (n + (n >> 1 >> 0) >> 0)), $subslice(new sliceType$2(x$2.$array), x$2.$offset, x$2.$offset + x$2.$length)), (x$3 = $subslice(z, n), $subslice(new sliceType$2(x$3.$array), x$3.$offset, x$3.$offset + x$3.$length)), c);
		}
	};
	karatsuba = function(z, x, y) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, n, n2, p, r, s, x, x0, x1, xd, y, y0, y1, yd, z;
		n = y.$length;
		if (!(((n & 1) === 0)) || n < karatsubaThreshold || n < 2) {
			basicMul(z, x, y);
			return;
		}
		n2 = n >> 1 >> 0;
		_tmp = $subslice(x, n2);
		_tmp$1 = $subslice(x, 0, n2);
		x1 = _tmp;
		x0 = _tmp$1;
		_tmp$2 = $subslice(y, n2);
		_tmp$3 = $subslice(y, 0, n2);
		y1 = _tmp$2;
		y0 = _tmp$3;
		karatsuba(z, x0, y0);
		karatsuba($subslice(z, n), x1, y1);
		s = 1;
		xd = $subslice(z, ($imul(2, n)), (($imul(2, n)) + n2 >> 0));
		if (!((subVV($subslice(new sliceType$2(xd.$array), xd.$offset, xd.$offset + xd.$length), $subslice(new sliceType$2(x1.$array), x1.$offset, x1.$offset + x1.$length), $subslice(new sliceType$2(x0.$array), x0.$offset, x0.$offset + x0.$length)) === 0))) {
			s = -s;
			subVV($subslice(new sliceType$2(xd.$array), xd.$offset, xd.$offset + xd.$length), $subslice(new sliceType$2(x0.$array), x0.$offset, x0.$offset + x0.$length), $subslice(new sliceType$2(x1.$array), x1.$offset, x1.$offset + x1.$length));
		}
		yd = $subslice(z, (($imul(2, n)) + n2 >> 0), ($imul(3, n)));
		if (!((subVV($subslice(new sliceType$2(yd.$array), yd.$offset, yd.$offset + yd.$length), $subslice(new sliceType$2(y0.$array), y0.$offset, y0.$offset + y0.$length), $subslice(new sliceType$2(y1.$array), y1.$offset, y1.$offset + y1.$length)) === 0))) {
			s = -s;
			subVV($subslice(new sliceType$2(yd.$array), yd.$offset, yd.$offset + yd.$length), $subslice(new sliceType$2(y1.$array), y1.$offset, y1.$offset + y1.$length), $subslice(new sliceType$2(y0.$array), y0.$offset, y0.$offset + y0.$length));
		}
		p = $subslice(z, ($imul(n, 3)));
		karatsuba(p, xd, yd);
		r = $subslice(z, ($imul(n, 4)));
		$copySlice(r, $subslice(z, 0, ($imul(n, 2))));
		karatsubaAdd($subslice(z, n2), r, n);
		karatsubaAdd($subslice(z, n2), $subslice(r, n), n);
		if (s > 0) {
			karatsubaAdd($subslice(z, n2), p, n);
		} else {
			karatsubaSub($subslice(z, n2), p, n);
		}
	};
	alias = function(x, y) {
		var x, x$1, x$2, y;
		return x.$capacity > 0 && y.$capacity > 0 && (x$1 = $subslice(x, 0, x.$capacity), $indexPtr(x$1.$array, x$1.$offset + (x.$capacity - 1 >> 0), ptrType$3)) === (x$2 = $subslice(y, 0, y.$capacity), $indexPtr(x$2.$array, x$2.$offset + (y.$capacity - 1 >> 0), ptrType$3));
	};
	addAt = function(z, x, i) {
		var c, i, j, n, x, x$1, x$2, x$3, x$4, z;
		n = x.$length;
		if (n > 0) {
			c = addVV((x$1 = $subslice(z, i, (i + n >> 0)), $subslice(new sliceType$2(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length)), (x$2 = $subslice(z, i), $subslice(new sliceType$2(x$2.$array), x$2.$offset, x$2.$offset + x$2.$length)), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length));
			if (!((c === 0))) {
				j = i + n >> 0;
				if (j < z.$length) {
					addVW((x$3 = $subslice(z, j), $subslice(new sliceType$2(x$3.$array), x$3.$offset, x$3.$offset + x$3.$length)), (x$4 = $subslice(z, j), $subslice(new sliceType$2(x$4.$array), x$4.$offset, x$4.$offset + x$4.$length)), c);
				}
			}
		}
	};
	max = function(x, y) {
		var x, y;
		if (x > y) {
			return x;
		}
		return y;
	};
	karatsubaLen = function(n) {
		var i, n, y;
		i = 0;
		while (true) {
			if (!(n > karatsubaThreshold)) { break; }
			n = (n >> $min((1), 31)) >> 0;
			i = i + (1) >>> 0;
		}
		return (y = i, y < 32 ? (n << y) : 0) >> 0;
	};
	nat.prototype.mul = function(x, y) {
		var i, k, m, n, t, x, x0, x0$1, xi, y, y0, y0$1, y1, z;
		z = this;
		m = x.$length;
		n = y.$length;
		if (m < n) {
			return z.mul(y, x);
		} else if ((m === 0) || (n === 0)) {
			return $subslice(z, 0, 0);
		} else if ((n === 1)) {
			return z.mulAddWW(x, (0 >= y.$length ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + 0]), 0);
		}
		if (alias(z, x) || alias(z, y)) {
			z = nat.nil;
		}
		if (n < karatsubaThreshold) {
			z = z.make(m + n >> 0);
			basicMul(z, x, y);
			return z.norm();
		}
		k = karatsubaLen(n);
		x0 = $subslice(x, 0, k);
		y0 = $subslice(y, 0, k);
		z = z.make(max($imul(6, k), m + n >> 0));
		karatsuba(z, x0, y0);
		z = $subslice(z, 0, (m + n >> 0));
		$subslice(z, ($imul(2, k))).clear();
		if (k < n || !((m === n))) {
			t = nat.nil;
			x0$1 = x0.norm();
			y1 = $subslice(y, k);
			t = t.mul(x0$1, y1);
			addAt(z, t, k);
			y0$1 = y0.norm();
			i = k;
			while (true) {
				if (!(i < x.$length)) { break; }
				xi = $subslice(x, i);
				if (xi.$length > k) {
					xi = $subslice(xi, 0, k);
				}
				xi = xi.norm();
				t = t.mul(xi, y0$1);
				addAt(z, t, i);
				t = t.mul(xi, y1);
				addAt(z, t, i + k >> 0);
				i = i + (k) >> 0;
			}
		}
		return z.norm();
	};
	$ptrType(nat).prototype.mul = function(x, y) { return this.$get().mul(x, y); };
	nat.prototype.mulRange = function(a, b) {
		var a, b, m, x, z;
		z = this;
		if ((a.$high === 0 && a.$low === 0)) {
			return z.setUint64(new $Uint64(0, 0));
		} else if ((a.$high > b.$high || (a.$high === b.$high && a.$low > b.$low))) {
			return z.setUint64(new $Uint64(0, 1));
		} else if ((a.$high === b.$high && a.$low === b.$low)) {
			return z.setUint64(a);
		} else if ((x = new $Uint64(a.$high + 0, a.$low + 1), (x.$high === b.$high && x.$low === b.$low))) {
			return z.mul((nat.nil).setUint64(a), (nat.nil).setUint64(b));
		}
		m = $div64((new $Uint64(a.$high + b.$high, a.$low + b.$low)), new $Uint64(0, 2), false);
		return z.mul((nat.nil).mulRange(a, m), (nat.nil).mulRange(new $Uint64(m.$high + 0, m.$low + 1), b));
	};
	$ptrType(nat).prototype.mulRange = function(a, b) { return this.$get().mulRange(a, b); };
	nat.prototype.divW = function(x, y) {
		var m, q, r, x, y, z;
		q = nat.nil;
		r = 0;
		z = this;
		m = x.$length;
		if ((y === 0)) {
			$panic(new $String("division by zero"));
		} else if ((y === 1)) {
			q = z.set(x);
			return [q, r];
		} else if ((m === 0)) {
			q = $subslice(z, 0, 0);
			return [q, r];
		}
		z = z.make(m);
		r = divWVW($subslice(new sliceType$2(z.$array), z.$offset, z.$offset + z.$length), 0, $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length), y);
		q = z.norm();
		return [q, r];
	};
	$ptrType(nat).prototype.divW = function(x, y) { return this.$get().divW(x, y); };
	nat.prototype.div = function(z2, u, v) {
		var _r, _tuple, _tuple$1, q, r, r2, u, v, z, z2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; q = $f.q; r = $f.r; r2 = $f.r2; u = $f.u; v = $f.v; z = $f.z; z2 = $f.z2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		q = nat.nil;
		r = nat.nil;
		z = this;
		if (v.$length === 0) {
			$panic(new $String("division by zero"));
		}
		if (u.cmp(v) < 0) {
			q = $subslice(z, 0, 0);
			r = z2.set(u);
			$s = -1; return [q, r];
		}
		if (v.$length === 1) {
			r2 = 0;
			_tuple = z.divW(u, (0 >= v.$length ? ($throwRuntimeError("index out of range"), undefined) : v.$array[v.$offset + 0]));
			q = _tuple[0];
			r2 = _tuple[1];
			r = z2.setWord(r2);
			$s = -1; return [q, r];
		}
		_r = z.divLarge(z2, u, v); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		q = _tuple$1[0];
		r = _tuple$1[1];
		$s = -1; return [q, r];
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.div }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.q = q; $f.r = r; $f.r2 = r2; $f.u = u; $f.v = v; $f.z = z; $f.z2 = z2; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.div = function(z2, u, v) { return this.$get().div(z2, u, v); };
	getNat = function(n) {
		var _r, n, v, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; v = $f.v; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = ptrType$4.nil;
		_r = natPool.Get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		v = _r;
		if (!($interfaceIsEqual(v, $ifaceNil))) {
			z = $assertType(v, ptrType$4);
		}
		if (z === ptrType$4.nil) {
			z = $newDataPointer(nat.nil, ptrType$4);
		}
		z.$set(z.make(n));
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: getNat }; } $f._r = _r; $f.n = n; $f.v = v; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	putNat = function(x) {
		var x;
		natPool.Put(x);
	};
	nat.prototype.divLarge = function(u, uIn, v) {
		var _index, _r, _r$1, _tmp, _tmp$1, _tuple, _tuple$1, _tuple$2, c, c$1, j, m, n, prevRhat, q, qhat, qhatv, qhatvp, r, rhat, shift, u, uIn, ujn, ujn2, v, v1, v1p, vn1, vn2, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, x1, x2, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _index = $f._index; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; c = $f.c; c$1 = $f.c$1; j = $f.j; m = $f.m; n = $f.n; prevRhat = $f.prevRhat; q = $f.q; qhat = $f.qhat; qhatv = $f.qhatv; qhatvp = $f.qhatvp; r = $f.r; rhat = $f.rhat; shift = $f.shift; u = $f.u; uIn = $f.uIn; ujn = $f.ujn; ujn2 = $f.ujn2; v = $f.v; v1 = $f.v1; v1p = $f.v1p; vn1 = $f.vn1; vn2 = $f.vn2; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; x1 = $f.x1; x2 = $f.x2; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		q = nat.nil;
		r = nat.nil;
		z = this;
		n = v.$length;
		m = uIn.$length - n >> 0;
		if (alias(z, uIn) || alias(z, v)) {
			z = nat.nil;
		}
		q = z.make(m + 1 >> 0);
		_r = getNat(n + 1 >> 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		qhatvp = _r;
		qhatv = qhatvp.$get();
		if (alias(u, uIn) || alias(u, v)) {
			u = nat.nil;
		}
		u = u.make(uIn.$length + 1 >> 0);
		u.clear();
		v1p = ptrType$4.nil;
		shift = nlz((x = n - 1 >> 0, ((x < 0 || x >= v.$length) ? ($throwRuntimeError("index out of range"), undefined) : v.$array[v.$offset + x])));
		/* */ if (shift > 0) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (shift > 0) { */ case 2:
			_r$1 = getNat(n); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			v1p = _r$1;
			v1 = v1p.$get();
			shlVU($subslice(new sliceType$2(v1.$array), v1.$offset, v1.$offset + v1.$length), $subslice(new sliceType$2(v.$array), v.$offset, v.$offset + v.$length), shift);
			v = v1;
		/* } */ case 3:
		(x$2 = uIn.$length, ((x$2 < 0 || x$2 >= u.$length) ? ($throwRuntimeError("index out of range"), undefined) : u.$array[u.$offset + x$2] = shlVU((x$1 = $subslice(u, 0, uIn.$length), $subslice(new sliceType$2(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length)), $subslice(new sliceType$2(uIn.$array), uIn.$offset, uIn.$offset + uIn.$length), shift)));
		vn1 = (x$3 = n - 1 >> 0, ((x$3 < 0 || x$3 >= v.$length) ? ($throwRuntimeError("index out of range"), undefined) : v.$array[v.$offset + x$3]));
		j = m;
		while (true) {
			if (!(j >= 0)) { break; }
			qhat = 4294967295;
			ujn = (x$4 = j + n >> 0, ((x$4 < 0 || x$4 >= u.$length) ? ($throwRuntimeError("index out of range"), undefined) : u.$array[u.$offset + x$4]));
			if (!((ujn === vn1))) {
				rhat = 0;
				_tuple = divWW(ujn, (x$5 = (j + n >> 0) - 1 >> 0, ((x$5 < 0 || x$5 >= u.$length) ? ($throwRuntimeError("index out of range"), undefined) : u.$array[u.$offset + x$5])), vn1);
				qhat = _tuple[0];
				rhat = _tuple[1];
				vn2 = (x$6 = n - 2 >> 0, ((x$6 < 0 || x$6 >= v.$length) ? ($throwRuntimeError("index out of range"), undefined) : v.$array[v.$offset + x$6]));
				_tuple$1 = mulWW(qhat, vn2);
				x1 = _tuple$1[0];
				x2 = _tuple$1[1];
				ujn2 = (x$7 = (j + n >> 0) - 2 >> 0, ((x$7 < 0 || x$7 >= u.$length) ? ($throwRuntimeError("index out of range"), undefined) : u.$array[u.$offset + x$7]));
				while (true) {
					if (!(greaterThan(x1, x2, rhat, ujn2))) { break; }
					qhat = qhat - (1) >>> 0;
					prevRhat = rhat;
					rhat = rhat + (vn1) >>> 0;
					if (rhat < prevRhat) {
						break;
					}
					_tuple$2 = mulWW(qhat, vn2);
					x1 = _tuple$2[0];
					x2 = _tuple$2[1];
				}
			}
			((n < 0 || n >= qhatv.$length) ? ($throwRuntimeError("index out of range"), undefined) : qhatv.$array[qhatv.$offset + n] = mulAddVWW((x$8 = $subslice(qhatv, 0, n), $subslice(new sliceType$2(x$8.$array), x$8.$offset, x$8.$offset + x$8.$length)), $subslice(new sliceType$2(v.$array), v.$offset, v.$offset + v.$length), qhat, 0));
			c = subVV((x$9 = $subslice(u, j, (j + qhatv.$length >> 0)), $subslice(new sliceType$2(x$9.$array), x$9.$offset, x$9.$offset + x$9.$length)), (x$10 = $subslice(u, j), $subslice(new sliceType$2(x$10.$array), x$10.$offset, x$10.$offset + x$10.$length)), $subslice(new sliceType$2(qhatv.$array), qhatv.$offset, qhatv.$offset + qhatv.$length));
			if (!((c === 0))) {
				c$1 = addVV((x$11 = $subslice(u, j, (j + n >> 0)), $subslice(new sliceType$2(x$11.$array), x$11.$offset, x$11.$offset + x$11.$length)), (x$12 = $subslice(u, j), $subslice(new sliceType$2(x$12.$array), x$12.$offset, x$12.$offset + x$12.$length)), $subslice(new sliceType$2(v.$array), v.$offset, v.$offset + v.$length));
				_index = j + n >> 0;
				((_index < 0 || _index >= u.$length) ? ($throwRuntimeError("index out of range"), undefined) : u.$array[u.$offset + _index] = (((_index < 0 || _index >= u.$length) ? ($throwRuntimeError("index out of range"), undefined) : u.$array[u.$offset + _index]) + (c$1) >>> 0));
				qhat = qhat - (1) >>> 0;
			}
			((j < 0 || j >= q.$length) ? ($throwRuntimeError("index out of range"), undefined) : q.$array[q.$offset + j] = qhat);
			j = j - (1) >> 0;
		}
		if (!(v1p === ptrType$4.nil)) {
			putNat(v1p);
		}
		putNat(qhatvp);
		q = q.norm();
		shrVU($subslice(new sliceType$2(u.$array), u.$offset, u.$offset + u.$length), $subslice(new sliceType$2(u.$array), u.$offset, u.$offset + u.$length), shift);
		r = u.norm();
		_tmp = q;
		_tmp$1 = r;
		q = _tmp;
		r = _tmp$1;
		$s = -1; return [q, r];
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.divLarge }; } $f._index = _index; $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.c = c; $f.c$1 = c$1; $f.j = j; $f.m = m; $f.n = n; $f.prevRhat = prevRhat; $f.q = q; $f.qhat = qhat; $f.qhatv = qhatv; $f.qhatvp = qhatvp; $f.r = r; $f.rhat = rhat; $f.shift = shift; $f.u = u; $f.uIn = uIn; $f.ujn = ujn; $f.ujn2 = ujn2; $f.v = v; $f.v1 = v1; $f.v1p = v1p; $f.vn1 = vn1; $f.vn2 = vn2; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.x1 = x1; $f.x2 = x2; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.divLarge = function(u, uIn, v) { return this.$get().divLarge(u, uIn, v); };
	nat.prototype.bitLen = function() {
		var i, x;
		x = this;
		i = x.$length - 1 >> 0;
		if (i >= 0) {
			return ($imul(i, 32)) + bits.Len(((((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]) >>> 0))) >> 0;
		}
		return 0;
	};
	$ptrType(nat).prototype.bitLen = function() { return this.$get().bitLen(); };
	nat.prototype.trailingZeroBits = function() {
		var i, x;
		x = this;
		if (x.$length === 0) {
			return 0;
		}
		i = 0;
		while (true) {
			if (!(((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]) === 0)) { break; }
			i = i + (1) >>> 0;
		}
		return (i * 32 >>> 0) + ((bits.TrailingZeros(((((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]) >>> 0))) >>> 0)) >>> 0;
	};
	$ptrType(nat).prototype.trailingZeroBits = function() { return this.$get().trailingZeroBits(); };
	nat.prototype.shl = function(x, s) {
		var _q, _r, m, n, s, x, x$1, z;
		z = this;
		m = x.$length;
		if (m === 0) {
			return $subslice(z, 0, 0);
		}
		n = m + (((_q = s / 32, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero")) >> 0)) >> 0;
		z = z.make(n + 1 >> 0);
		((n < 0 || n >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + n] = shlVU((x$1 = $subslice(z, (n - m >> 0), n), $subslice(new sliceType$2(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length)), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length), (_r = s % 32, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))));
		$subslice(z, 0, (n - m >> 0)).clear();
		return z.norm();
	};
	$ptrType(nat).prototype.shl = function(x, s) { return this.$get().shl(x, s); };
	nat.prototype.shr = function(x, s) {
		var _q, _r, m, n, s, x, x$1, z;
		z = this;
		m = x.$length;
		n = m - (((_q = s / 32, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero")) >> 0)) >> 0;
		if (n <= 0) {
			return $subslice(z, 0, 0);
		}
		z = z.make(n);
		shrVU($subslice(new sliceType$2(z.$array), z.$offset, z.$offset + z.$length), (x$1 = $subslice(x, (m - n >> 0)), $subslice(new sliceType$2(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length)), (_r = s % 32, _r === _r ? _r : $throwRuntimeError("integer divide by zero")));
		return z.norm();
	};
	$ptrType(nat).prototype.shr = function(x, s) { return this.$get().shr(x, s); };
	nat.prototype.setBit = function(x, i, b) {
		var _1, _q, _r, b, i, j, m, n, x, y, z;
		z = this;
		j = (((_q = i / 32, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero")) >> 0));
		m = (y = ((_r = i % 32, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))), y < 32 ? (1 << y) : 0) >>> 0;
		n = x.$length;
		_1 = b;
		if (_1 === (0)) {
			z = z.make(n);
			$copySlice(z, x);
			if (j >= n) {
				return z;
			}
			((j < 0 || j >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + j] = ((((j < 0 || j >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + j]) & ~(m)) >>> 0));
			return z.norm();
		} else if (_1 === (1)) {
			if (j >= n) {
				z = z.make(j + 1 >> 0);
				$subslice(z, n).clear();
			} else {
				z = z.make(n);
			}
			$copySlice(z, x);
			((j < 0 || j >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + j] = ((((j < 0 || j >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + j]) | (m)) >>> 0));
			return z;
		}
		$panic(new $String("set bit is not 0 or 1"));
	};
	$ptrType(nat).prototype.setBit = function(x, i, b) { return this.$get().setBit(x, i, b); };
	nat.prototype.bit = function(i) {
		var _q, _r, i, j, x, y;
		x = this;
		j = (_q = i / 32, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		if (j >= ((x.$length >>> 0))) {
			return 0;
		}
		return ((((((y = ((_r = i % 32, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))), y < 32 ? (((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]) >>> y) : 0) >>> 0) & 1) >>> 0) >>> 0));
	};
	$ptrType(nat).prototype.bit = function(i) { return this.$get().bit(i); };
	nat.prototype.and = function(x, y) {
		var i, m, n, x, y, z;
		z = this;
		m = x.$length;
		n = y.$length;
		if (m > n) {
			m = n;
		}
		z = z.make(m);
		i = 0;
		while (true) {
			if (!(i < m)) { break; }
			((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = ((((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]) & ((i < 0 || i >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i])) >>> 0));
			i = i + (1) >> 0;
		}
		return z.norm();
	};
	$ptrType(nat).prototype.and = function(x, y) { return this.$get().and(x, y); };
	nat.prototype.andNot = function(x, y) {
		var i, m, n, x, y, z;
		z = this;
		m = x.$length;
		n = y.$length;
		if (n > m) {
			n = m;
		}
		z = z.make(m);
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = ((((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]) & ~((i < 0 || i >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i])) >>> 0));
			i = i + (1) >> 0;
		}
		$copySlice($subslice(z, n, m), $subslice(x, n, m));
		return z.norm();
	};
	$ptrType(nat).prototype.andNot = function(x, y) { return this.$get().andNot(x, y); };
	nat.prototype.or = function(x, y) {
		var _tmp, _tmp$1, i, m, n, s, x, y, z;
		z = this;
		m = x.$length;
		n = y.$length;
		s = x;
		if (m < n) {
			_tmp = m;
			_tmp$1 = n;
			n = _tmp;
			m = _tmp$1;
			s = y;
		}
		z = z.make(m);
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = ((((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]) | ((i < 0 || i >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i])) >>> 0));
			i = i + (1) >> 0;
		}
		$copySlice($subslice(z, n, m), $subslice(s, n, m));
		return z.norm();
	};
	$ptrType(nat).prototype.or = function(x, y) { return this.$get().or(x, y); };
	nat.prototype.xor = function(x, y) {
		var _tmp, _tmp$1, i, m, n, s, x, y, z;
		z = this;
		m = x.$length;
		n = y.$length;
		s = x;
		if (m < n) {
			_tmp = m;
			_tmp$1 = n;
			n = _tmp;
			m = _tmp$1;
			s = y;
		}
		z = z.make(m);
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = ((((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]) ^ ((i < 0 || i >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i])) >>> 0));
			i = i + (1) >> 0;
		}
		$copySlice($subslice(z, n, m), $subslice(s, n, m));
		return z.norm();
	};
	$ptrType(nat).prototype.xor = function(x, y) { return this.$get().xor(x, y); };
	greaterThan = function(x1, x2, y1, y2) {
		var x1, x2, y1, y2;
		return x1 > y1 || (x1 === y1) && x2 > y2;
	};
	nat.prototype.modW = function(d) {
		var d, q, r, x;
		r = 0;
		x = this;
		q = nat.nil;
		q = q.make(x.$length);
		r = divWVW($subslice(new sliceType$2(q.$array), q.$offset, q.$offset + q.$length), 0, $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length), d);
		return r;
	};
	$ptrType(nat).prototype.modW = function(d) { return this.$get().modW(d); };
	nat.prototype.random = function(rand$1, limit, n) {
		var _1, _i, _i$1, _index, _r, _r$1, _r$2, _ref, _ref$1, bitLengthOfMSW, i, i$1, limit, mask, n, rand$1, y, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _i$1 = $f._i$1; _index = $f._index; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _ref$1 = $f._ref$1; bitLengthOfMSW = $f.bitLengthOfMSW; i = $f.i; i$1 = $f.i$1; limit = $f.limit; mask = $f.mask; n = $f.n; rand$1 = $f.rand$1; y = $f.y; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		if (alias(z, limit)) {
			z = nat.nil;
		}
		z = z.make(limit.$length);
		bitLengthOfMSW = (((_r = n % 32, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) >>> 0));
		if (bitLengthOfMSW === 0) {
			bitLengthOfMSW = 32;
		}
		mask = (((((y = bitLengthOfMSW, y < 32 ? (1 << y) : 0) >>> 0)) - 1 >>> 0));
		/* while (true) { */ case 1:
				_1 = 32;
				/* */ if (_1 === (32)) { $s = 4; continue; }
				/* */ if (_1 === (64)) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (_1 === (32)) { */ case 4:
					_ref = z;
					_i = 0;
					/* while (true) { */ case 8:
						/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 9; continue; }
						i = _i;
						_r$1 = rand$1.Uint32(); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						((i < 0 || i >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i] = ((_r$1 >>> 0)));
						_i++;
					/* } */ $s = 8; continue; case 9:
					$s = 7; continue;
				/* } else if (_1 === (64)) { */ case 5:
					_ref$1 = z;
					_i$1 = 0;
					/* while (true) { */ case 11:
						/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 12; continue; }
						i$1 = _i$1;
						_r$2 = rand$1.Uint32(); /* */ $s = 13; case 13: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						((i$1 < 0 || i$1 >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + i$1] = ((((_r$2 >>> 0)) | 0) >>> 0));
						_i$1++;
					/* } */ $s = 11; continue; case 12:
					$s = 7; continue;
				/* } else { */ case 6:
					$panic(new $String("unknown word size"));
				/* } */ case 7:
			case 3:
			_index = limit.$length - 1 >> 0;
			((_index < 0 || _index >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + _index] = ((((_index < 0 || _index >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + _index]) & (mask)) >>> 0));
			if (z.cmp(limit) < 0) {
				/* break; */ $s = 2; continue;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return z.norm();
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.random }; } $f._1 = _1; $f._i = _i; $f._i$1 = _i$1; $f._index = _index; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._ref$1 = _ref$1; $f.bitLengthOfMSW = bitLengthOfMSW; $f.i = i; $f.i$1 = i$1; $f.limit = limit; $f.mask = mask; $f.n = n; $f.rand$1 = rand$1; $f.y = y; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.random = function(rand$1, limit, n) { return this.$get().random(rand$1, limit, n); };
	nat.prototype.expNN = function(x, y, m) {
		var _r, _r$1, _r$2, _r$3, _r$4, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, i, j, j$1, m, q, r, shift, v, w, x, x$1, y, y$1, y$2, y$3, z, zz, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$17 = $f._tmp$17; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; i = $f.i; j = $f.j; j$1 = $f.j$1; m = $f.m; q = $f.q; r = $f.r; shift = $f.shift; v = $f.v; w = $f.w; x = $f.x; x$1 = $f.x$1; y = $f.y; y$1 = $f.y$1; y$2 = $f.y$2; y$3 = $f.y$3; z = $f.z; zz = $f.zz; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		if (alias(z, x) || alias(z, y)) {
			z = nat.nil;
		}
		if ((m.$length === 1) && ((0 >= m.$length ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + 0]) === 1)) {
			$s = -1; return z.setWord(0);
		}
		if (y.$length === 0) {
			$s = -1; return z.setWord(1);
		}
		/* */ if ((y.$length === 1) && ((0 >= y.$length ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + 0]) === 1) && !((m.$length === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((y.$length === 1) && ((0 >= y.$length ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + 0]) === 1) && !((m.$length === 0))) { */ case 1:
			_r = z.div(z, x, m); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			z = _tuple[1];
			$s = -1; return z;
		/* } */ case 2:
		if (!((m.$length === 0))) {
			z = z.make(m.$length);
		}
		z = z.set(x);
		/* */ if (x.cmp(natOne) > 0 && y.$length > 1 && m.$length > 0) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (x.cmp(natOne) > 0 && y.$length > 1 && m.$length > 0) { */ case 4:
			/* */ if ((((0 >= m.$length ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + 0]) & 1) >>> 0) === 1) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if ((((0 >= m.$length ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + 0]) & 1) >>> 0) === 1) { */ case 6:
				_r$1 = z.expNNMontgomery(x, y, m); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$s = -1; return _r$1;
			/* } */ case 7:
			_r$2 = z.expNNWindowed(x, y, m); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			$s = -1; return _r$2;
		/* } */ case 5:
		v = (x$1 = y.$length - 1 >> 0, ((x$1 < 0 || x$1 >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + x$1]));
		shift = nlz(v) + 1 >>> 0;
		v = (y$1 = (shift), y$1 < 32 ? (v << y$1) : 0) >>> 0;
		q = nat.nil;
		w = 32 - ((shift >> 0)) >> 0;
		_tmp = nat.nil;
		_tmp$1 = nat.nil;
		zz = _tmp;
		r = _tmp$1;
		j = 0;
		/* while (true) { */ case 10:
			/* if (!(j < w)) { break; } */ if(!(j < w)) { $s = 11; continue; }
			zz = zz.mul(z, z);
			_tmp$2 = z;
			_tmp$3 = zz;
			zz = _tmp$2;
			z = _tmp$3;
			if (!((((v & 2147483648) >>> 0) === 0))) {
				zz = zz.mul(z, x);
				_tmp$4 = z;
				_tmp$5 = zz;
				zz = _tmp$4;
				z = _tmp$5;
			}
			/* */ if (!((m.$length === 0))) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if (!((m.$length === 0))) { */ case 12:
				_r$3 = zz.div(r, z, m); /* */ $s = 14; case 14: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				_tuple$1 = _r$3;
				zz = _tuple$1[0];
				r = _tuple$1[1];
				_tmp$6 = q;
				_tmp$7 = z;
				_tmp$8 = zz;
				_tmp$9 = r;
				zz = _tmp$6;
				r = _tmp$7;
				q = _tmp$8;
				z = _tmp$9;
			/* } */ case 13:
			v = (y$2 = (1), y$2 < 32 ? (v << y$2) : 0) >>> 0;
			j = j + (1) >> 0;
		/* } */ $s = 10; continue; case 11:
		i = y.$length - 2 >> 0;
		/* while (true) { */ case 15:
			/* if (!(i >= 0)) { break; } */ if(!(i >= 0)) { $s = 16; continue; }
			v = ((i < 0 || i >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i]);
			j$1 = 0;
			/* while (true) { */ case 17:
				/* if (!(j$1 < 32)) { break; } */ if(!(j$1 < 32)) { $s = 18; continue; }
				zz = zz.mul(z, z);
				_tmp$10 = z;
				_tmp$11 = zz;
				zz = _tmp$10;
				z = _tmp$11;
				if (!((((v & 2147483648) >>> 0) === 0))) {
					zz = zz.mul(z, x);
					_tmp$12 = z;
					_tmp$13 = zz;
					zz = _tmp$12;
					z = _tmp$13;
				}
				/* */ if (!((m.$length === 0))) { $s = 19; continue; }
				/* */ $s = 20; continue;
				/* if (!((m.$length === 0))) { */ case 19:
					_r$4 = zz.div(r, z, m); /* */ $s = 21; case 21: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					_tuple$2 = _r$4;
					zz = _tuple$2[0];
					r = _tuple$2[1];
					_tmp$14 = q;
					_tmp$15 = z;
					_tmp$16 = zz;
					_tmp$17 = r;
					zz = _tmp$14;
					r = _tmp$15;
					q = _tmp$16;
					z = _tmp$17;
				/* } */ case 20:
				v = (y$3 = (1), y$3 < 32 ? (v << y$3) : 0) >>> 0;
				j$1 = j$1 + (1) >> 0;
			/* } */ $s = 17; continue; case 18:
			i = i - (1) >> 0;
		/* } */ $s = 15; continue; case 16:
		$s = -1; return z.norm();
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.expNN }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$17 = _tmp$17; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.i = i; $f.j = j; $f.j$1 = j$1; $f.m = m; $f.q = q; $f.r = r; $f.shift = shift; $f.v = v; $f.w = w; $f.x = x; $f.x$1 = x$1; $f.y = y; $f.y$1 = y$1; $f.y$2 = y$2; $f.y$3 = y$3; $f.z = z; $f.zz = zz; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.expNN = function(x, y, m) { return this.$get().expNN(x, y, m); };
	nat.prototype.expNNWindowed = function(x, y, m) {
		var _q, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, _tmp$27, _tmp$28, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, i, i$1, j, m, p, p1, p2, powers, r, x, x$1, y, y$1, yi, z, zz, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$17 = $f._tmp$17; _tmp$18 = $f._tmp$18; _tmp$19 = $f._tmp$19; _tmp$2 = $f._tmp$2; _tmp$20 = $f._tmp$20; _tmp$21 = $f._tmp$21; _tmp$22 = $f._tmp$22; _tmp$23 = $f._tmp$23; _tmp$24 = $f._tmp$24; _tmp$25 = $f._tmp$25; _tmp$26 = $f._tmp$26; _tmp$27 = $f._tmp$27; _tmp$28 = $f._tmp$28; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; i = $f.i; i$1 = $f.i$1; j = $f.j; m = $f.m; p = $f.p; p1 = $f.p1; p2 = $f.p2; powers = $f.powers; r = $f.r; x = $f.x; x$1 = $f.x$1; y = $f.y; y$1 = $f.y$1; yi = $f.yi; z = $f.z; zz = $f.zz; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		_tmp = nat.nil;
		_tmp$1 = nat.nil;
		zz = _tmp;
		r = _tmp$1;
		powers = arrayType$1.zero();
		powers[0] = natOne;
		powers[1] = x;
		i = 2;
		/* while (true) { */ case 1:
			/* if (!(i < 16)) { break; } */ if(!(i < 16)) { $s = 2; continue; }
			_tmp$2 = $indexPtr(powers, (_q = i / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")), ptrType$4);
			_tmp$3 = $indexPtr(powers, i, ptrType$4);
			_tmp$4 = $indexPtr(powers, (i + 1 >> 0), ptrType$4);
			p2 = _tmp$2;
			p = _tmp$3;
			p1 = _tmp$4;
			p.$set(p.mul(p2.$get(), p2.$get()));
			_r = zz.div(r, p.$get(), m); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			zz = _tuple[0];
			r = _tuple[1];
			_tmp$5 = r;
			_tmp$6 = p.$get();
			p.$set(_tmp$5);
			r = _tmp$6;
			p1.$set(p1.mul(p.$get(), x));
			_r$1 = zz.div(r, p1.$get(), m); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			zz = _tuple$1[0];
			r = _tuple$1[1];
			_tmp$7 = r;
			_tmp$8 = p1.$get();
			p1.$set(_tmp$7);
			r = _tmp$8;
			i = i + (2) >> 0;
		/* } */ $s = 1; continue; case 2:
		z = z.setWord(1);
		i$1 = y.$length - 1 >> 0;
		/* while (true) { */ case 5:
			/* if (!(i$1 >= 0)) { break; } */ if(!(i$1 >= 0)) { $s = 6; continue; }
			yi = ((i$1 < 0 || i$1 >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i$1]);
			j = 0;
			/* while (true) { */ case 7:
				/* if (!(j < 32)) { break; } */ if(!(j < 32)) { $s = 8; continue; }
				/* */ if (!((i$1 === (y.$length - 1 >> 0))) || !((j === 0))) { $s = 9; continue; }
				/* */ $s = 10; continue;
				/* if (!((i$1 === (y.$length - 1 >> 0))) || !((j === 0))) { */ case 9:
					zz = zz.mul(z, z);
					_tmp$9 = z;
					_tmp$10 = zz;
					zz = _tmp$9;
					z = _tmp$10;
					_r$2 = zz.div(r, z, m); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_tuple$2 = _r$2;
					zz = _tuple$2[0];
					r = _tuple$2[1];
					_tmp$11 = r;
					_tmp$12 = z;
					z = _tmp$11;
					r = _tmp$12;
					zz = zz.mul(z, z);
					_tmp$13 = z;
					_tmp$14 = zz;
					zz = _tmp$13;
					z = _tmp$14;
					_r$3 = zz.div(r, z, m); /* */ $s = 12; case 12: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					_tuple$3 = _r$3;
					zz = _tuple$3[0];
					r = _tuple$3[1];
					_tmp$15 = r;
					_tmp$16 = z;
					z = _tmp$15;
					r = _tmp$16;
					zz = zz.mul(z, z);
					_tmp$17 = z;
					_tmp$18 = zz;
					zz = _tmp$17;
					z = _tmp$18;
					_r$4 = zz.div(r, z, m); /* */ $s = 13; case 13: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					_tuple$4 = _r$4;
					zz = _tuple$4[0];
					r = _tuple$4[1];
					_tmp$19 = r;
					_tmp$20 = z;
					z = _tmp$19;
					r = _tmp$20;
					zz = zz.mul(z, z);
					_tmp$21 = z;
					_tmp$22 = zz;
					zz = _tmp$21;
					z = _tmp$22;
					_r$5 = zz.div(r, z, m); /* */ $s = 14; case 14: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
					_tuple$5 = _r$5;
					zz = _tuple$5[0];
					r = _tuple$5[1];
					_tmp$23 = r;
					_tmp$24 = z;
					z = _tmp$23;
					r = _tmp$24;
				/* } */ case 10:
				zz = zz.mul(z, (x$1 = yi >>> 28 >>> 0, ((x$1 < 0 || x$1 >= powers.length) ? ($throwRuntimeError("index out of range"), undefined) : powers[x$1])));
				_tmp$25 = z;
				_tmp$26 = zz;
				zz = _tmp$25;
				z = _tmp$26;
				_r$6 = zz.div(r, z, m); /* */ $s = 15; case 15: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_tuple$6 = _r$6;
				zz = _tuple$6[0];
				r = _tuple$6[1];
				_tmp$27 = r;
				_tmp$28 = z;
				z = _tmp$27;
				r = _tmp$28;
				yi = (y$1 = (4), y$1 < 32 ? (yi << y$1) : 0) >>> 0;
				j = j + (4) >> 0;
			/* } */ $s = 7; continue; case 8:
			i$1 = i$1 - (1) >> 0;
		/* } */ $s = 5; continue; case 6:
		$s = -1; return z.norm();
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.expNNWindowed }; } $f._q = _q; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$17 = _tmp$17; $f._tmp$18 = _tmp$18; $f._tmp$19 = _tmp$19; $f._tmp$2 = _tmp$2; $f._tmp$20 = _tmp$20; $f._tmp$21 = _tmp$21; $f._tmp$22 = _tmp$22; $f._tmp$23 = _tmp$23; $f._tmp$24 = _tmp$24; $f._tmp$25 = _tmp$25; $f._tmp$26 = _tmp$26; $f._tmp$27 = _tmp$27; $f._tmp$28 = _tmp$28; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f.i = i; $f.i$1 = i$1; $f.j = j; $f.m = m; $f.p = p; $f.p1 = p1; $f.p2 = p2; $f.powers = powers; $f.r = r; $f.x = x; $f.x$1 = x$1; $f.y = y; $f.y$1 = y$1; $f.yi = yi; $f.z = z; $f.zz = zz; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.expNNWindowed = function(x, y, m) { return this.$get().expNNWindowed(x, y, m); };
	nat.prototype.expNNMontgomery = function(x, y, m) {
		var RR, _r, _r$1, _r$2, _tmp, _tmp$1, _tuple, _tuple$1, _tuple$2, i, i$1, i$2, j, k0, m, numWords, one, powers, rr, t, x, x$1, x$2, y, y$1, y$2, yi, z, zz, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; RR = $f.RR; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; j = $f.j; k0 = $f.k0; m = $f.m; numWords = $f.numWords; one = $f.one; powers = $f.powers; rr = $f.rr; t = $f.t; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; y = $f.y; y$1 = $f.y$1; y$2 = $f.y$2; yi = $f.yi; z = $f.z; zz = $f.zz; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		numWords = m.$length;
		/* */ if (x.$length > numWords) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (x.$length > numWords) { */ case 1:
			_r = (nat.nil).div(nat.nil, x, m); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			x = _tuple[1];
		/* } */ case 2:
		if (x.$length < numWords) {
			rr = $makeSlice(nat, numWords);
			$copySlice(rr, x);
			x = rr;
		}
		k0 = 2 - (0 >= m.$length ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + 0]) >>> 0;
		t = (0 >= m.$length ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + 0]) - 1 >>> 0;
		i = 1;
		while (true) {
			if (!(i < 32)) { break; }
			t = $imul(t, (t)) >>> 0;
			k0 = $imul(k0, (((t + 1 >>> 0)))) >>> 0;
			i = (y$1 = (1), y$1 < 32 ? (i << y$1) : 0) >> 0;
		}
		k0 = -k0 >>> 0;
		RR = (nat.nil).setWord(1);
		zz = (nat.nil).shl(RR, ((($imul(($imul(2, numWords)), 32)) >>> 0)));
		_r$1 = RR.div(RR, zz, m); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		RR = _tuple$1[1];
		if (RR.$length < numWords) {
			zz = zz.make(numWords);
			$copySlice(zz, RR);
			RR = zz;
		}
		one = $makeSlice(nat, numWords);
		(0 >= one.$length ? ($throwRuntimeError("index out of range"), undefined) : one.$array[one.$offset + 0] = 1);
		powers = arrayType$1.zero();
		powers[0] = powers[0].montgomery(one, RR, m, k0, numWords);
		powers[1] = powers[1].montgomery(x, RR, m, k0, numWords);
		i$1 = 2;
		while (true) {
			if (!(i$1 < 16)) { break; }
			((i$1 < 0 || i$1 >= powers.length) ? ($throwRuntimeError("index out of range"), undefined) : powers[i$1] = ((i$1 < 0 || i$1 >= powers.length) ? ($throwRuntimeError("index out of range"), undefined) : powers[i$1]).montgomery((x$1 = i$1 - 1 >> 0, ((x$1 < 0 || x$1 >= powers.length) ? ($throwRuntimeError("index out of range"), undefined) : powers[x$1])), powers[1], m, k0, numWords));
			i$1 = i$1 + (1) >> 0;
		}
		z = z.make(numWords);
		$copySlice(z, powers[0]);
		zz = zz.make(numWords);
		i$2 = y.$length - 1 >> 0;
		while (true) {
			if (!(i$2 >= 0)) { break; }
			yi = ((i$2 < 0 || i$2 >= y.$length) ? ($throwRuntimeError("index out of range"), undefined) : y.$array[y.$offset + i$2]);
			j = 0;
			while (true) {
				if (!(j < 32)) { break; }
				if (!((i$2 === (y.$length - 1 >> 0))) || !((j === 0))) {
					zz = zz.montgomery(z, z, m, k0, numWords);
					z = z.montgomery(zz, zz, m, k0, numWords);
					zz = zz.montgomery(z, z, m, k0, numWords);
					z = z.montgomery(zz, zz, m, k0, numWords);
				}
				zz = zz.montgomery(z, (x$2 = yi >>> 28 >>> 0, ((x$2 < 0 || x$2 >= powers.length) ? ($throwRuntimeError("index out of range"), undefined) : powers[x$2])), m, k0, numWords);
				_tmp = zz;
				_tmp$1 = z;
				z = _tmp;
				zz = _tmp$1;
				yi = (y$2 = (4), y$2 < 32 ? (yi << y$2) : 0) >>> 0;
				j = j + (4) >> 0;
			}
			i$2 = i$2 - (1) >> 0;
		}
		zz = zz.montgomery(z, one, m, k0, numWords);
		/* */ if (zz.cmp(m) >= 0) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (zz.cmp(m) >= 0) { */ case 5:
			zz = zz.sub(zz, m);
			/* */ if (zz.cmp(m) >= 0) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (zz.cmp(m) >= 0) { */ case 7:
				_r$2 = (nat.nil).div(nat.nil, zz, m); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_tuple$2 = _r$2;
				zz = _tuple$2[1];
			/* } */ case 8:
		/* } */ case 6:
		$s = -1; return zz.norm();
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.expNNMontgomery }; } $f.RR = RR; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.j = j; $f.k0 = k0; $f.m = m; $f.numWords = numWords; $f.one = one; $f.powers = powers; $f.rr = rr; $f.t = t; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.y = y; $f.y$1 = y$1; $f.y$2 = y$2; $f.yi = yi; $f.z = z; $f.zz = zz; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.expNNMontgomery = function(x, y, m) { return this.$get().expNNMontgomery(x, y, m); };
	nat.prototype.bytes = function(buf) {
		var _i, _ref, buf, d, i, j, y, z;
		i = 0;
		z = this;
		i = buf.$length;
		_ref = z;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			d = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			j = 0;
			while (true) {
				if (!(j < 4)) { break; }
				i = i - (1) >> 0;
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = ((d << 24 >>> 24)));
				d = (y = (8), y < 32 ? (d >>> y) : 0) >>> 0;
				j = j + (1) >> 0;
			}
			_i++;
		}
		while (true) {
			if (!(i < buf.$length && (((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i]) === 0))) { break; }
			i = i + (1) >> 0;
		}
		return i;
	};
	$ptrType(nat).prototype.bytes = function(buf) { return this.$get().bytes(buf); };
	nat.prototype.setBytes = function(buf) {
		var _q, buf, d, i, k, s, x, y, z;
		z = this;
		z = z.make((_q = (((buf.$length + 4 >> 0) - 1 >> 0)) / 4, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")));
		k = 0;
		s = 0;
		d = 0;
		i = buf.$length;
		while (true) {
			if (!(i > 0)) { break; }
			d = (d | (((y = s, y < 32 ? ((((x = i - 1 >> 0, ((x < 0 || x >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + x])) >>> 0)) << y) : 0) >>> 0))) >>> 0;
			s = s + (8) >>> 0;
			if (s === 32) {
				((k < 0 || k >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + k] = d);
				k = k + (1) >> 0;
				s = 0;
				d = 0;
			}
			i = i - (1) >> 0;
		}
		if (k < z.$length) {
			((k < 0 || k >= z.$length) ? ($throwRuntimeError("index out of range"), undefined) : z.$array[z.$offset + k] = d);
		}
		return z.norm();
	};
	$ptrType(nat).prototype.setBytes = function(buf) { return this.$get().setBytes(buf); };
	nat.prototype.sqrt = function(x) {
		var _q, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, n, x, z, z1, z2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; n = $f.n; x = $f.x; z = $f.z; z1 = $f.z1; z2 = $f.z2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		if (x.cmp(natOne) <= 0) {
			$s = -1; return z.set(x);
		}
		if (alias(z, x)) {
			z = nat.nil;
		}
		_tmp = nat.nil;
		_tmp$1 = nat.nil;
		z1 = _tmp;
		z2 = _tmp$1;
		z1 = z;
		z1 = z1.setUint64(new $Uint64(0, 1));
		z1 = z1.shl(z1, ((((_q = x.bitLen() / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0) >>> 0)));
		n = 0;
		/* while (true) { */ case 1:
			_r = z2.div(nat.nil, x, z1); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			z2 = _tuple[0];
			z2 = z2.add(z2, z1);
			z2 = z2.shr(z2, 1);
			if (z2.cmp(z1) >= 0) {
				if ((n & 1) === 0) {
					$s = -1; return z1;
				}
				$s = -1; return z.set(z1);
			}
			_tmp$2 = z2;
			_tmp$3 = z1;
			z1 = _tmp$2;
			z2 = _tmp$3;
			n = n + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return nat.nil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.sqrt }; } $f._q = _q; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.n = n; $f.x = x; $f.z = z; $f.z1 = z1; $f.z2 = z2; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.sqrt = function(x) { return this.$get().sqrt(x); };
	maxPow = function(b) {
		var _q, _tmp, _tmp$1, b, max$1, n, p;
		p = 0;
		n = 0;
		_tmp = b;
		_tmp$1 = 1;
		p = _tmp;
		n = _tmp$1;
		max$1 = (_q = 4294967295 / b, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		while (true) {
			if (!(p <= max$1)) { break; }
			p = $imul(p, (b)) >>> 0;
			n = n + (1) >> 0;
		}
		return [p, n];
	};
	pow = function(x, n) {
		var n, p, x;
		p = 0;
		p = 1;
		while (true) {
			if (!(n > 0)) { break; }
			if (!(((n & 1) === 0))) {
				p = $imul(p, (x)) >>> 0;
			}
			x = $imul(x, (x)) >>> 0;
			n = (n >> $min((1), 31)) >> 0;
		}
		return p;
	};
	nat.prototype.scan = function(r, base, fracOk) {
		var _1, _2, _3, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, b, b1, base, baseOk, bn, ch, count, d1, di, dp, err, fracOk, i, n, r, res, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; b = $f.b; b1 = $f.b1; base = $f.base; baseOk = $f.baseOk; bn = $f.bn; ch = $f.ch; count = $f.count; d1 = $f.d1; di = $f.di; dp = $f.dp; err = $f.err; fracOk = $f.fracOk; i = $f.i; n = $f.n; r = $f.r; res = $f.res; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		res = nat.nil;
		b = 0;
		count = 0;
		err = $ifaceNil;
		z = this;
		baseOk = (base === 0) || !fracOk && 2 <= base && base <= 36 || fracOk && ((base === 2) || (base === 10) || (base === 16));
		/* */ if (!baseOk) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!baseOk) { */ case 1:
			_r = fmt.Sprintf("illegal number base %d", new sliceType([new $Int(base)])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$panic(new $String(_r));
		/* } */ case 2:
		_r$1 = r.ReadByte(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		ch = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [res, b, count, err];
		}
		b = base;
		/* */ if (base === 0) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (base === 0) { */ case 5:
			b = 10;
			/* */ if (ch === 48) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (ch === 48) { */ case 7:
				count = 1;
					_r$2 = r.ReadByte(); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_tuple$1 = _r$2;
					ch = _tuple$1[0];
					err = _tuple$1[1];
					_1 = err;
					/* */ if ($interfaceIsEqual(_1, $ifaceNil)) { $s = 11; continue; }
					/* */ if ($interfaceIsEqual(_1, (io.EOF))) { $s = 12; continue; }
					/* */ $s = 13; continue;
					/* if ($interfaceIsEqual(_1, $ifaceNil)) { */ case 11:
						if (!fracOk) {
							b = 8;
						}
						_2 = ch;
						if ((_2 === (120)) || (_2 === (88))) {
							b = 16;
						} else if ((_2 === (98)) || (_2 === (66))) {
							b = 2;
						}
							_3 = b;
							/* */ if ((_3 === (16)) || (_3 === (2))) { $s = 16; continue; }
							/* */ if (_3 === (8)) { $s = 17; continue; }
							/* */ $s = 18; continue;
							/* if ((_3 === (16)) || (_3 === (2))) { */ case 16:
								count = 0;
								_r$3 = r.ReadByte(); /* */ $s = 19; case 19: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
								_tuple$2 = _r$3;
								ch = _tuple$2[0];
								err = _tuple$2[1];
								if (!($interfaceIsEqual(err, $ifaceNil))) {
									$s = -1; return [res, b, count, err];
								}
								$s = 18; continue;
							/* } else if (_3 === (8)) { */ case 17:
								count = 0;
							/* } */ case 18:
						case 15:
						$s = 14; continue;
					/* } else if ($interfaceIsEqual(_1, (io.EOF))) { */ case 12:
						res = $subslice(z, 0, 0);
						err = $ifaceNil;
						$s = -1; return [res, b, count, err];
					/* } else { */ case 13:
						$s = -1; return [res, b, count, err];
					/* } */ case 14:
				case 9:
			/* } */ case 8:
		/* } */ case 6:
		z = $subslice(z, 0, 0);
		b1 = ((b >>> 0));
		_tuple$3 = maxPow(b1);
		bn = _tuple$3[0];
		n = _tuple$3[1];
		di = 0;
		i = 0;
		dp = -1;
		/* while (true) { */ case 20:
			/* */ if (fracOk && (ch === 46)) { $s = 22; continue; }
			/* */ $s = 23; continue;
			/* if (fracOk && (ch === 46)) { */ case 22:
				fracOk = false;
				dp = count;
				_r$4 = r.ReadByte(); /* */ $s = 24; case 24: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				_tuple$4 = _r$4;
				ch = _tuple$4[0];
				err = _tuple$4[1];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					if ($interfaceIsEqual(err, io.EOF)) {
						err = $ifaceNil;
						/* break; */ $s = 21; continue;
					}
					$s = -1; return [res, b, count, err];
				}
			/* } */ case 23:
			d1 = 0;
			if (48 <= ch && ch <= 57) {
				d1 = (((ch - 48 << 24 >>> 24) >>> 0));
			} else if (97 <= ch && ch <= 122) {
				d1 = ((((ch - 97 << 24 >>> 24) + 10 << 24 >>> 24) >>> 0));
			} else if (65 <= ch && ch <= 90) {
				d1 = ((((ch - 65 << 24 >>> 24) + 10 << 24 >>> 24) >>> 0));
			} else {
				d1 = 37;
			}
			/* */ if (d1 >= b1) { $s = 25; continue; }
			/* */ $s = 26; continue;
			/* if (d1 >= b1) { */ case 25:
				_r$5 = r.UnreadByte(); /* */ $s = 27; case 27: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				_r$5;
				/* break; */ $s = 21; continue;
			/* } */ case 26:
			count = count + (1) >> 0;
			di = ($imul(di, b1) >>> 0) + d1 >>> 0;
			i = i + (1) >> 0;
			if (i === n) {
				z = z.mulAddWW(z, bn, di);
				di = 0;
				i = 0;
			}
			_r$6 = r.ReadByte(); /* */ $s = 28; case 28: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_tuple$5 = _r$6;
			ch = _tuple$5[0];
			err = _tuple$5[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				if ($interfaceIsEqual(err, io.EOF)) {
					err = $ifaceNil;
					/* break; */ $s = 21; continue;
				}
				$s = -1; return [res, b, count, err];
			}
		/* } */ $s = 20; continue; case 21:
		if (count === 0) {
			if ((base === 0) && (b === 8)) {
				count = 1;
				b = 10;
			} else if (!((base === 0)) || !((b === 8))) {
				err = errors.New("syntax error scanning number");
			}
			$s = -1; return [res, b, count, err];
		}
		if (i > 0) {
			z = z.mulAddWW(z, pow(b1, i), di);
		}
		res = z.norm();
		if (dp >= 0) {
			count = dp - count >> 0;
		}
		$s = -1; return [res, b, count, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.scan }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.b = b; $f.b1 = b1; $f.base = base; $f.baseOk = baseOk; $f.bn = bn; $f.ch = ch; $f.count = count; $f.d1 = d1; $f.di = di; $f.dp = dp; $f.err = err; $f.fracOk = fracOk; $f.i = i; $f.n = n; $f.r = r; $f.res = res; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.scan = function(r, base, fracOk) { return this.$get().scan(r, base, fracOk); };
	nat.prototype.utoa = function(base) {
		var _r, base, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; base = $f.base; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = this;
		_r = x.itoa(false, base); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.utoa }; } $f._r = _r; $f.base = base; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.utoa = function(base) { return this.$get().utoa(base); };
	nat.prototype.itoa = function(neg, base) {
		var _r, _tuple, b, base, bb, i, k, mask, nbits, ndigits, neg, q, s, shift, table, w, x, y, y$1, y$2, y$3, y$4, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; base = $f.base; bb = $f.bb; i = $f.i; k = $f.k; mask = $f.mask; nbits = $f.nbits; ndigits = $f.ndigits; neg = $f.neg; q = $f.q; s = $f.s; shift = $f.shift; table = $f.table; w = $f.w; x = $f.x; y = $f.y; y$1 = $f.y$1; y$2 = $f.y$2; y$3 = $f.y$3; y$4 = $f.y$4; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = this;
		if (base < 2 || base > 36) {
			$panic(new $String("invalid base"));
		}
		if (x.$length === 0) {
			$s = -1; return (new sliceType$1($stringToBytes("0")));
		}
		i = (((x.bitLen()) / math.Log2((base)) >> 0)) + 1 >> 0;
		if (neg) {
			i = i + (1) >> 0;
		}
		s = $makeSlice(sliceType$1, i);
		b = ((base >>> 0));
		/* */ if (b === ((b & (-b >>> 0)) >>> 0)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (b === ((b & (-b >>> 0)) >>> 0)) { */ case 1:
			shift = ((bits.TrailingZeros(((b >>> 0))) >>> 0));
			mask = ((((y = shift, y < 32 ? (1 << y) : 0) >>> 0) - 1 >>> 0));
			w = (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]);
			nbits = 32;
			k = 1;
			while (true) {
				if (!(k < x.$length)) { break; }
				while (true) {
					if (!(nbits >= shift)) { break; }
					i = i - (1) >> 0;
					((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((w & mask) >>> 0)));
					w = (y$1 = (shift), y$1 < 32 ? (w >>> y$1) : 0) >>> 0;
					nbits = nbits - (shift) >>> 0;
				}
				if (nbits === 0) {
					w = ((k < 0 || k >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + k]);
					nbits = 32;
				} else {
					w = (w | (((y$2 = nbits, y$2 < 32 ? (((k < 0 || k >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + k]) << y$2) : 0) >>> 0))) >>> 0;
					i = i - (1) >> 0;
					((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((w & mask) >>> 0)));
					w = (y$3 = ((shift - nbits >>> 0)), y$3 < 32 ? (((k < 0 || k >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + k]) >>> y$3) : 0) >>> 0;
					nbits = 32 - ((shift - nbits >>> 0)) >>> 0;
				}
				k = k + (1) >> 0;
			}
			while (true) {
				if (!(!((w === 0)))) { break; }
				i = i - (1) >> 0;
				((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((w & mask) >>> 0)));
				w = (y$4 = (shift), y$4 < 32 ? (w >>> y$4) : 0) >>> 0;
			}
			$s = 3; continue;
		/* } else { */ case 2:
			_tuple = maxPow(b);
			bb = _tuple[0];
			ndigits = _tuple[1];
			_r = divisors(x.$length, b, ndigits, bb); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			table = _r;
			q = (nat.nil).set(x);
			$r = q.convertWords(s, b, ndigits, bb, table); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i = 0;
			while (true) {
				if (!(((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) === 48)) { break; }
				i = i + (1) >> 0;
			}
		/* } */ case 3:
		if (neg) {
			i = i - (1) >> 0;
			((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i] = 45);
		}
		$s = -1; return $subslice(s, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.itoa }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.base = base; $f.bb = bb; $f.i = i; $f.k = k; $f.mask = mask; $f.nbits = nbits; $f.ndigits = ndigits; $f.neg = neg; $f.q = q; $f.s = s; $f.shift = shift; $f.table = table; $f.w = w; $f.x = x; $f.y = y; $f.y$1 = y$1; $f.y$2 = y$2; $f.y$3 = y$3; $f.y$4 = y$4; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.itoa = function(neg, base) { return this.$get().itoa(neg, base); };
	nat.prototype.convertWords = function(s, b, ndigits, bb, table) {
		var _q, _q$1, _r, _r$1, _tuple, _tuple$1, _tuple$2, b, bb, h, i, index, j, j$1, maxLength, minLength, ndigits, q, r, r$1, s, t, table, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _q$1 = $f._q$1; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; b = $f.b; bb = $f.bb; h = $f.h; i = $f.i; index = $f.index; j = $f.j; j$1 = $f.j$1; maxLength = $f.maxLength; minLength = $f.minLength; ndigits = $f.ndigits; q = $f.q; r = $f.r; r$1 = $f.r$1; s = $f.s; t = $f.t; table = $f.table; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		q = this;
		/* */ if (!(table === sliceType$3.nil)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(table === sliceType$3.nil)) { */ case 1:
			r = nat.nil;
			index = table.$length - 1 >> 0;
			/* while (true) { */ case 3:
				/* if (!(q.$length > leafSize)) { break; } */ if(!(q.$length > leafSize)) { $s = 4; continue; }
				maxLength = q.bitLen();
				minLength = maxLength >> 1 >> 0;
				while (true) {
					if (!(index > 0 && (x = index - 1 >> 0, ((x < 0 || x >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + x])).nbits > minLength)) { break; }
					index = index - (1) >> 0;
				}
				if (((index < 0 || index >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + index]).nbits >= maxLength && ((index < 0 || index >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + index]).bbb.cmp(q) >= 0) {
					index = index - (1) >> 0;
					if (index < 0) {
						$panic(new $String("internal inconsistency"));
					}
				}
				_r = q.div(r, q, ((index < 0 || index >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + index]).bbb); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				q = _tuple[0];
				r = _tuple[1];
				h = s.$length - ((index < 0 || index >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + index]).ndigits >> 0;
				$r = r.convertWords($subslice(s, h), b, ndigits, bb, $subslice(table, 0, index)); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				s = $subslice(s, 0, h);
			/* } */ $s = 3; continue; case 4:
		/* } */ case 2:
		i = s.$length;
		r$1 = 0;
		if (b === 10) {
			while (true) {
				if (!(q.$length > 0)) { break; }
				_tuple$1 = q.divW(q, bb);
				q = _tuple$1[0];
				r$1 = _tuple$1[1];
				j = 0;
				while (true) {
					if (!(j < ndigits && i > 0)) { break; }
					i = i - (1) >> 0;
					t = (_q = r$1 / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
					((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i] = (48 + (((r$1 - ($imul(t, 10) >>> 0) >>> 0) << 24 >>> 24)) << 24 >>> 24));
					r$1 = t;
					j = j + (1) >> 0;
				}
			}
		} else {
			while (true) {
				if (!(q.$length > 0)) { break; }
				_tuple$2 = q.divW(q, bb);
				q = _tuple$2[0];
				r$1 = _tuple$2[1];
				j$1 = 0;
				while (true) {
					if (!(j$1 < ndigits && i > 0)) { break; }
					i = i - (1) >> 0;
					((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt((_r$1 = r$1 % b, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"))));
					r$1 = (_q$1 = r$1 / (b), (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
					j$1 = j$1 + (1) >> 0;
				}
			}
		}
		while (true) {
			if (!(i > 0)) { break; }
			i = i - (1) >> 0;
			((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i] = 48);
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.convertWords }; } $f._q = _q; $f._q$1 = _q$1; $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.b = b; $f.bb = bb; $f.h = h; $f.i = i; $f.index = index; $f.j = j; $f.j$1 = j$1; $f.maxLength = maxLength; $f.minLength = minLength; $f.ndigits = ndigits; $f.q = q; $f.r = r; $f.r$1 = r$1; $f.s = s; $f.t = t; $f.table = table; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.convertWords = function(s, b, ndigits, bb, table) { return this.$get().convertWords(s, b, ndigits, bb, table); };
	nat.prototype.expWW = function(x, y) {
		var _r, x, y, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; x = $f.x; y = $f.y; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		_r = z.expNN((nat.nil).setWord(x), (nat.nil).setWord(y), nat.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.expWW }; } $f._r = _r; $f.x = x; $f.y = y; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.expWW = function(x, y) { return this.$get().expWW(x, y); };
	divisors = function(m, b, ndigits, bb) {
		var _r, b, bb, i, k, larger, m, ndigits, table, words, x, x$1, x$2, x$3, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; bb = $f.bb; i = $f.i; k = $f.k; larger = $f.larger; m = $f.m; ndigits = $f.ndigits; table = $f.table; words = $f.words; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if ((leafSize === 0) || m <= leafSize) {
			$s = -1; return sliceType$3.nil;
		}
		k = 1;
		words = leafSize;
		while (true) {
			if (!(words < (m >> 1 >> 0) && k < 64)) { break; }
			k = k + (1) >> 0;
			words = (y = (1), y < 32 ? (words << y) : 0) >> 0;
		}
		table = sliceType$3.nil;
		if (b === 10) {
			cacheBase10.Mutex.Lock();
			table = $subslice(new sliceType$3(cacheBase10.table), 0, k);
		} else {
			table = $makeSlice(sliceType$3, k);
		}
		/* */ if ((x = k - 1 >> 0, ((x < 0 || x >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + x])).ndigits === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((x = k - 1 >> 0, ((x < 0 || x >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + x])).ndigits === 0) { */ case 1:
			larger = nat.nil;
			i = 0;
			/* while (true) { */ case 3:
				/* if (!(i < k)) { break; } */ if(!(i < k)) { $s = 4; continue; }
				/* */ if (((i < 0 || i >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + i]).ndigits === 0) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (((i < 0 || i >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + i]).ndigits === 0) { */ case 5:
					/* */ if (i === 0) { $s = 7; continue; }
					/* */ $s = 8; continue;
					/* if (i === 0) { */ case 7:
						_r = (nat.nil).expWW(bb, ((leafSize >>> 0))); /* */ $s = 10; case 10: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						(0 >= table.$length ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + 0]).bbb = _r;
						(0 >= table.$length ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + 0]).ndigits = $imul(ndigits, leafSize);
						$s = 9; continue;
					/* } else { */ case 8:
						((i < 0 || i >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + i]).bbb = (nat.nil).mul((x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + x$1])).bbb, (x$2 = i - 1 >> 0, ((x$2 < 0 || x$2 >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + x$2])).bbb);
						((i < 0 || i >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + i]).ndigits = $imul(2, (x$3 = i - 1 >> 0, ((x$3 < 0 || x$3 >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + x$3])).ndigits);
					/* } */ case 9:
					larger = (nat.nil).set(((i < 0 || i >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + i]).bbb);
					while (true) {
						if (!(mulAddVWW($subslice(new sliceType$2(larger.$array), larger.$offset, larger.$offset + larger.$length), $subslice(new sliceType$2(larger.$array), larger.$offset, larger.$offset + larger.$length), b, 0) === 0)) { break; }
						((i < 0 || i >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + i]).bbb = ((i < 0 || i >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + i]).bbb.set(larger);
						((i < 0 || i >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + i]).ndigits = ((i < 0 || i >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + i]).ndigits + (1) >> 0;
					}
					((i < 0 || i >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + i]).nbits = ((i < 0 || i >= table.$length) ? ($throwRuntimeError("index out of range"), undefined) : table.$array[table.$offset + i]).bbb.bitLen();
				/* } */ case 6:
				i = i + (1) >> 0;
			/* } */ $s = 3; continue; case 4:
		/* } */ case 2:
		if (b === 10) {
			cacheBase10.Mutex.Unlock();
		}
		$s = -1; return table;
		/* */ } return; } if ($f === undefined) { $f = { $blk: divisors }; } $f._r = _r; $f.b = b; $f.bb = bb; $f.i = i; $f.k = k; $f.larger = larger; $f.m = m; $f.ndigits = ndigits; $f.table = table; $f.words = words; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.ptr.prototype.ProbablyPrime = function(n) {
		var _1, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _tmp, _tmp$1, _v, n, r, rA, rB, w, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _v = $f._v; n = $f.n; r = $f.r; rA = $f.rA; rB = $f.rB; w = $f.w; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = this;
		if (n < 0) {
			$panic(new $String("negative n for ProbablyPrime"));
		}
		if (x.neg || (x.abs.$length === 0)) {
			$s = -1; return false;
		}
		w = (x$1 = x.abs, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0]));
		if ((x.abs.$length === 1) && w < 64) {
			$s = -1; return !((x$2 = (x$3 = $shiftLeft64(new $Uint64(0, 1), w), new $Uint64(673221152 & x$3.$high, (2693408940 & x$3.$low) >>> 0)), (x$2.$high === 0 && x$2.$low === 0)));
		}
		if (((w & 1) >>> 0) === 0) {
			$s = -1; return false;
		}
		_tmp = 0;
		_tmp$1 = 0;
		rA = _tmp;
		rB = _tmp$1;
		_1 = 32;
		if (_1 === (32)) {
			rA = ((x.abs.modW(4127218095) >>> 0));
			rB = ((x.abs.modW(3948078067) >>> 0));
		} else if (_1 === (64)) {
			r = x.abs.modW(820596253);
			rA = (((_r = r % 4127218095, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) >>> 0));
			rB = (((_r$1 = r % 3948078067, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) >>> 0));
		} else {
			$panic(new $String("math/big: invalid word size"));
		}
		if (((_r$2 = rA % 3, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$3 = rA % 5, _r$3 === _r$3 ? _r$3 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$4 = rA % 7, _r$4 === _r$4 ? _r$4 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$5 = rA % 11, _r$5 === _r$5 ? _r$5 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$6 = rA % 13, _r$6 === _r$6 ? _r$6 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$7 = rA % 17, _r$7 === _r$7 ? _r$7 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$8 = rA % 19, _r$8 === _r$8 ? _r$8 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$9 = rA % 23, _r$9 === _r$9 ? _r$9 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$10 = rA % 37, _r$10 === _r$10 ? _r$10 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$11 = rB % 29, _r$11 === _r$11 ? _r$11 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$12 = rB % 31, _r$12 === _r$12 ? _r$12 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$13 = rB % 41, _r$13 === _r$13 ? _r$13 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$14 = rB % 43, _r$14 === _r$14 ? _r$14 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$15 = rB % 47, _r$15 === _r$15 ? _r$15 : $throwRuntimeError("integer divide by zero")) === 0) || ((_r$16 = rB % 53, _r$16 === _r$16 ? _r$16 : $throwRuntimeError("integer divide by zero")) === 0)) {
			$s = -1; return false;
		}
		_r$17 = x.abs.probablyPrimeMillerRabin(n + 1 >> 0, true); /* */ $s = 2; case 2: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
		if (!(_r$17)) { _v = false; $s = 1; continue s; }
		_r$18 = x.abs.probablyPrimeLucas(); /* */ $s = 3; case 3: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
		_v = _r$18; case 1:
		$s = -1; return _v;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int.ptr.prototype.ProbablyPrime }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._v = _v; $f.n = n; $f.r = r; $f.rA = rA; $f.rB = rB; $f.w = w; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Int.prototype.ProbablyPrime = function(n) { return this.$val.ProbablyPrime(n); };
	nat.prototype.probablyPrimeMillerRabin = function(reps, force2) {
		var _r, _r$1, _r$2, _tmp, _tmp$1, _tmp$2, _tuple, force2, i, j, k, n, nm1, nm3, nm3Len, q, quotient, rand$1, reps, x, x$1, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tuple = $f._tuple; force2 = $f.force2; i = $f.i; j = $f.j; k = $f.k; n = $f.n; nm1 = $f.nm1; nm3 = $f.nm3; nm3Len = $f.nm3Len; q = $f.q; quotient = $f.quotient; rand$1 = $f.rand$1; reps = $f.reps; x = $f.x; x$1 = $f.x$1; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = this;
		nm1 = (nat.nil).sub(n, natOne);
		k = nm1.trailingZeroBits();
		q = (nat.nil).shr(nm1, k);
		nm3 = (nat.nil).sub(nm1, natTwo);
		rand$1 = rand.New(rand.NewSource(((x = (0 >= n.$length ? ($throwRuntimeError("index out of range"), undefined) : n.$array[n.$offset + 0]), new $Int64(0, x.constructor === Number ? x : 1)))));
		_tmp = nat.nil;
		_tmp$1 = nat.nil;
		_tmp$2 = nat.nil;
		x$1 = _tmp;
		y = _tmp$1;
		quotient = _tmp$2;
		nm3Len = nm3.bitLen();
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < reps)) { break; } */ if(!(i < reps)) { $s = 2; continue; }
			/* */ if ((i === (reps - 1 >> 0)) && force2) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if ((i === (reps - 1 >> 0)) && force2) { */ case 3:
				x$1 = x$1.set(natTwo);
				$s = 5; continue;
			/* } else { */ case 4:
				_r = x$1.random(rand$1, nm3, nm3Len); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				x$1 = _r;
				x$1 = x$1.add(x$1, natTwo);
			/* } */ case 5:
			_r$1 = y.expNN(x$1, q, n); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			y = _r$1;
			/* */ if ((y.cmp(natOne) === 0) || (y.cmp(nm1) === 0)) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if ((y.cmp(natOne) === 0) || (y.cmp(nm1) === 0)) { */ case 8:
				i = i + (1) >> 0;
				/* continue; */ $s = 1; continue;
			/* } */ case 9:
			j = 1;
			/* while (true) { */ case 10:
				/* if (!(j < k)) { break; } */ if(!(j < k)) { $s = 11; continue; }
				y = y.mul(y, y);
				_r$2 = quotient.div(y, y, n); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_tuple = _r$2;
				quotient = _tuple[0];
				y = _tuple[1];
				if (y.cmp(nm1) === 0) {
					i = i + (1) >> 0;
					/* continue NextRandom; */ $s = 1; continue s;
				}
				if (y.cmp(natOne) === 0) {
					$s = -1; return false;
				}
				j = j + (1) >>> 0;
			/* } */ $s = 10; continue; case 11:
			$s = -1; return false;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.probablyPrimeMillerRabin }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tuple = _tuple; $f.force2 = force2; $f.i = i; $f.j = j; $f.k = k; $f.n = n; $f.nm1 = nm1; $f.nm3 = nm3; $f.nm3Len = nm3Len; $f.q = q; $f.quotient = quotient; $f.rand$1 = rand$1; $f.reps = reps; $f.x = x; $f.x$1 = x$1; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.probablyPrimeMillerRabin = function(reps, force2) { return this.$get().probablyPrimeMillerRabin(reps, force2); };
	nat.prototype.probablyPrimeLucas = function() {
		var _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _tmp, _tmp$1, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, d, i, intD, intN, j, n, natP, nm2, p, r, s, t, t1, t1$1, t2, t2$1, t3, vk, vk1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; d = $f.d; i = $f.i; intD = $f.intD; intN = $f.intN; j = $f.j; n = $f.n; natP = $f.natP; nm2 = $f.nm2; p = $f.p; r = $f.r; s = $f.s; t = $f.t; t1 = $f.t1; t1$1 = $f.t1$1; t2 = $f.t2; t2$1 = $f.t2$1; t3 = $f.t3; vk = $f.vk; vk1 = $f.vk1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = this;
		if ((n.$length === 0) || (n.cmp(natOne) === 0)) {
			$s = -1; return false;
		}
		if ((((0 >= n.$length ? ($throwRuntimeError("index out of range"), undefined) : n.$array[n.$offset + 0]) & 1) >>> 0) === 0) {
			$s = -1; return n.cmp(natTwo) === 0;
		}
		p = 3;
		d = new nat([1]);
		t1 = (nat.nil);
		intD = new Int.ptr(false, d);
		intN = new Int.ptr(false, n);
		/* while (true) { */ case 1:
			/* */ if (p > 10000) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (p > 10000) { */ case 3:
				_r = intN.String(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$panic(new $String("math/big: internal error: cannot find (D/n) = -1 for " + _r));
			/* } */ case 4:
			(0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0] = (($imul(p, p) >>> 0) - 4 >>> 0));
			_r$1 = Jacobi(intD, intN); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			j = _r$1;
			if (j === -1) {
				/* break; */ $s = 2; continue;
			}
			if (j === 0) {
				$s = -1; return (n.$length === 1) && ((0 >= n.$length ? ($throwRuntimeError("index out of range"), undefined) : n.$array[n.$offset + 0]) === (p + 2 >>> 0));
			}
			/* */ if (p === 40) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (p === 40) { */ case 7:
				_r$2 = t1.sqrt(n); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				t1 = _r$2;
				t1 = t1.mul(t1, t1);
				if (t1.cmp(n) === 0) {
					$s = -1; return false;
				}
			/* } */ case 8:
			p = p + (1) >>> 0;
		/* } */ $s = 1; continue; case 2:
		s = (nat.nil).add(n, natOne);
		r = ((s.trailingZeroBits() >> 0));
		s = s.shr(s, ((r >>> 0)));
		nm2 = (nat.nil).sub(n, natTwo);
		natP = (nat.nil).setWord(p);
		vk = (nat.nil).setWord(2);
		vk1 = (nat.nil).setWord(p);
		t2 = (nat.nil);
		i = (s.bitLen());
		/* while (true) { */ case 10:
			/* if (!(i >= 0)) { break; } */ if(!(i >= 0)) { $s = 11; continue; }
			/* */ if (!((s.bit(((i >>> 0))) === 0))) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if (!((s.bit(((i >>> 0))) === 0))) { */ case 12:
				t1 = t1.mul(vk, vk1);
				t1 = t1.add(t1, n);
				t1 = t1.sub(t1, natP);
				_r$3 = t2.div(vk, t1, n); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				_tuple = _r$3;
				t2 = _tuple[0];
				vk = _tuple[1];
				t1 = t1.mul(vk1, vk1);
				t1 = t1.add(t1, nm2);
				_r$4 = t2.div(vk1, t1, n); /* */ $s = 16; case 16: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				_tuple$1 = _r$4;
				t2 = _tuple$1[0];
				vk1 = _tuple$1[1];
				$s = 14; continue;
			/* } else { */ case 13:
				t1 = t1.mul(vk, vk1);
				t1 = t1.add(t1, n);
				t1 = t1.sub(t1, natP);
				_r$5 = t2.div(vk1, t1, n); /* */ $s = 17; case 17: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				_tuple$2 = _r$5;
				t2 = _tuple$2[0];
				vk1 = _tuple$2[1];
				t1 = t1.mul(vk, vk);
				t1 = t1.add(t1, nm2);
				_r$6 = t2.div(vk, t1, n); /* */ $s = 18; case 18: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_tuple$3 = _r$6;
				t2 = _tuple$3[0];
				vk = _tuple$3[1];
			/* } */ case 14:
			i = i - (1) >> 0;
		/* } */ $s = 10; continue; case 11:
		/* */ if ((vk.cmp(natTwo) === 0) || (vk.cmp(nm2) === 0)) { $s = 19; continue; }
		/* */ $s = 20; continue;
		/* if ((vk.cmp(natTwo) === 0) || (vk.cmp(nm2) === 0)) { */ case 19:
			t1$1 = t1.mul(vk, natP);
			t2$1 = t2.shl(vk1, 1);
			if (t1$1.cmp(t2$1) < 0) {
				_tmp = t2$1;
				_tmp$1 = t1$1;
				t1$1 = _tmp;
				t2$1 = _tmp$1;
			}
			t1$1 = t1$1.sub(t1$1, t2$1);
			t3 = vk1;
			vk1 = nat.nil;
			$unused(vk1);
			_r$7 = t2$1.div(t3, t1$1, n); /* */ $s = 21; case 21: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_tuple$4 = _r$7;
			t2$1 = _tuple$4[0];
			t3 = _tuple$4[1];
			if (t3.$length === 0) {
				$s = -1; return true;
			}
		/* } */ case 20:
		t = 0;
		/* while (true) { */ case 22:
			/* if (!(t < (r - 1 >> 0))) { break; } */ if(!(t < (r - 1 >> 0))) { $s = 23; continue; }
			if (vk.$length === 0) {
				$s = -1; return true;
			}
			if ((vk.$length === 1) && ((0 >= vk.$length ? ($throwRuntimeError("index out of range"), undefined) : vk.$array[vk.$offset + 0]) === 2)) {
				$s = -1; return false;
			}
			t1 = t1.mul(vk, vk);
			t1 = t1.sub(t1, natTwo);
			_r$8 = t2.div(vk, t1, n); /* */ $s = 24; case 24: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			_tuple$5 = _r$8;
			t2 = _tuple$5[0];
			vk = _tuple$5[1];
			t = t + (1) >> 0;
		/* } */ $s = 22; continue; case 23:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: nat.prototype.probablyPrimeLucas }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.d = d; $f.i = i; $f.intD = intD; $f.intN = intN; $f.j = j; $f.n = n; $f.natP = natP; $f.nm2 = nm2; $f.p = p; $f.r = r; $f.s = s; $f.t = t; $f.t1 = t1; $f.t1$1 = t1$1; $f.t2 = t2; $f.t2$1 = t2$1; $f.t3 = t3; $f.vk = vk; $f.vk1 = vk1; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(nat).prototype.probablyPrimeLucas = function() { return this.$get().probablyPrimeLucas(); };
	ptrType$1.methods = [{prop: "Sign", name: "Sign", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "SetInt64", name: "SetInt64", pkg: "", typ: $funcType([$Int64], [ptrType$1], false)}, {prop: "SetUint64", name: "SetUint64", pkg: "", typ: $funcType([$Uint64], [ptrType$1], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([ptrType$1], [ptrType$1], false)}, {prop: "Bits", name: "Bits", pkg: "", typ: $funcType([], [sliceType$2], false)}, {prop: "SetBits", name: "SetBits", pkg: "", typ: $funcType([sliceType$2], [ptrType$1], false)}, {prop: "Abs", name: "Abs", pkg: "", typ: $funcType([ptrType$1], [ptrType$1], false)}, {prop: "Neg", name: "Neg", pkg: "", typ: $funcType([ptrType$1], [ptrType$1], false)}, {prop: "Add", name: "Add", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "Sub", name: "Sub", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "Mul", name: "Mul", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "MulRange", name: "MulRange", pkg: "", typ: $funcType([$Int64, $Int64], [ptrType$1], false)}, {prop: "Binomial", name: "Binomial", pkg: "", typ: $funcType([$Int64, $Int64], [ptrType$1], false)}, {prop: "Quo", name: "Quo", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "Rem", name: "Rem", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "QuoRem", name: "QuoRem", pkg: "", typ: $funcType([ptrType$1, ptrType$1, ptrType$1], [ptrType$1, ptrType$1], false)}, {prop: "Div", name: "Div", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "Mod", name: "Mod", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "DivMod", name: "DivMod", pkg: "", typ: $funcType([ptrType$1, ptrType$1, ptrType$1], [ptrType$1, ptrType$1], false)}, {prop: "Cmp", name: "Cmp", pkg: "", typ: $funcType([ptrType$1], [$Int], false)}, {prop: "Int64", name: "Int64", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}, {prop: "IsInt64", name: "IsInt64", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "IsUint64", name: "IsUint64", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "SetString", name: "SetString", pkg: "", typ: $funcType([$String, $Int], [ptrType$1, $Bool], false)}, {prop: "SetBytes", name: "SetBytes", pkg: "", typ: $funcType([sliceType$1], [ptrType$1], false)}, {prop: "Bytes", name: "Bytes", pkg: "", typ: $funcType([], [sliceType$1], false)}, {prop: "BitLen", name: "BitLen", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Exp", name: "Exp", pkg: "", typ: $funcType([ptrType$1, ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "GCD", name: "GCD", pkg: "", typ: $funcType([ptrType$1, ptrType$1, ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "binaryGCD", name: "binaryGCD", pkg: "math/big", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "Rand", name: "Rand", pkg: "", typ: $funcType([ptrType$6, ptrType$1], [ptrType$1], false)}, {prop: "ModInverse", name: "ModInverse", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "modSqrt3Mod4Prime", name: "modSqrt3Mod4Prime", pkg: "math/big", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "modSqrtTonelliShanks", name: "modSqrtTonelliShanks", pkg: "math/big", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "ModSqrt", name: "ModSqrt", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "Lsh", name: "Lsh", pkg: "", typ: $funcType([ptrType$1, $Uint], [ptrType$1], false)}, {prop: "Rsh", name: "Rsh", pkg: "", typ: $funcType([ptrType$1, $Uint], [ptrType$1], false)}, {prop: "Bit", name: "Bit", pkg: "", typ: $funcType([$Int], [$Uint], false)}, {prop: "SetBit", name: "SetBit", pkg: "", typ: $funcType([ptrType$1, $Int, $Uint], [ptrType$1], false)}, {prop: "And", name: "And", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "AndNot", name: "AndNot", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "Or", name: "Or", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "Xor", name: "Xor", pkg: "", typ: $funcType([ptrType$1, ptrType$1], [ptrType$1], false)}, {prop: "Not", name: "Not", pkg: "", typ: $funcType([ptrType$1], [ptrType$1], false)}, {prop: "Sqrt", name: "Sqrt", pkg: "", typ: $funcType([ptrType$1], [ptrType$1], false)}, {prop: "Text", name: "Text", pkg: "", typ: $funcType([$Int], [$String], false)}, {prop: "Append", name: "Append", pkg: "", typ: $funcType([sliceType$1, $Int], [sliceType$1], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Format", name: "Format", pkg: "", typ: $funcType([fmt.State, $Int32], [], false)}, {prop: "scan", name: "scan", pkg: "math/big", typ: $funcType([io.ByteScanner, $Int], [ptrType$1, $Int, $error], false)}, {prop: "Scan", name: "Scan", pkg: "", typ: $funcType([fmt.ScanState, $Int32], [$error], false)}, {prop: "GobEncode", name: "GobEncode", pkg: "", typ: $funcType([], [sliceType$1, $error], false)}, {prop: "GobDecode", name: "GobDecode", pkg: "", typ: $funcType([sliceType$1], [$error], false)}, {prop: "MarshalText", name: "MarshalText", pkg: "", typ: $funcType([], [sliceType$1, $error], false)}, {prop: "UnmarshalText", name: "UnmarshalText", pkg: "", typ: $funcType([sliceType$1], [$error], false)}, {prop: "MarshalJSON", name: "MarshalJSON", pkg: "", typ: $funcType([], [sliceType$1, $error], false)}, {prop: "UnmarshalJSON", name: "UnmarshalJSON", pkg: "", typ: $funcType([sliceType$1], [$error], false)}, {prop: "ProbablyPrime", name: "ProbablyPrime", pkg: "", typ: $funcType([$Int], [$Bool], false)}];
	byteReader.methods = [{prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}];
	nat.methods = [{prop: "clear", name: "clear", pkg: "math/big", typ: $funcType([], [], false)}, {prop: "norm", name: "norm", pkg: "math/big", typ: $funcType([], [nat], false)}, {prop: "make", name: "make", pkg: "math/big", typ: $funcType([$Int], [nat], false)}, {prop: "setWord", name: "setWord", pkg: "math/big", typ: $funcType([Word], [nat], false)}, {prop: "setUint64", name: "setUint64", pkg: "math/big", typ: $funcType([$Uint64], [nat], false)}, {prop: "set", name: "set", pkg: "math/big", typ: $funcType([nat], [nat], false)}, {prop: "add", name: "add", pkg: "math/big", typ: $funcType([nat, nat], [nat], false)}, {prop: "sub", name: "sub", pkg: "math/big", typ: $funcType([nat, nat], [nat], false)}, {prop: "cmp", name: "cmp", pkg: "math/big", typ: $funcType([nat], [$Int], false)}, {prop: "mulAddWW", name: "mulAddWW", pkg: "math/big", typ: $funcType([nat, Word, Word], [nat], false)}, {prop: "montgomery", name: "montgomery", pkg: "math/big", typ: $funcType([nat, nat, nat, Word, $Int], [nat], false)}, {prop: "mul", name: "mul", pkg: "math/big", typ: $funcType([nat, nat], [nat], false)}, {prop: "mulRange", name: "mulRange", pkg: "math/big", typ: $funcType([$Uint64, $Uint64], [nat], false)}, {prop: "divW", name: "divW", pkg: "math/big", typ: $funcType([nat, Word], [nat, Word], false)}, {prop: "div", name: "div", pkg: "math/big", typ: $funcType([nat, nat, nat], [nat, nat], false)}, {prop: "divLarge", name: "divLarge", pkg: "math/big", typ: $funcType([nat, nat, nat], [nat, nat], false)}, {prop: "bitLen", name: "bitLen", pkg: "math/big", typ: $funcType([], [$Int], false)}, {prop: "trailingZeroBits", name: "trailingZeroBits", pkg: "math/big", typ: $funcType([], [$Uint], false)}, {prop: "shl", name: "shl", pkg: "math/big", typ: $funcType([nat, $Uint], [nat], false)}, {prop: "shr", name: "shr", pkg: "math/big", typ: $funcType([nat, $Uint], [nat], false)}, {prop: "setBit", name: "setBit", pkg: "math/big", typ: $funcType([nat, $Uint, $Uint], [nat], false)}, {prop: "bit", name: "bit", pkg: "math/big", typ: $funcType([$Uint], [$Uint], false)}, {prop: "sticky", name: "sticky", pkg: "math/big", typ: $funcType([$Uint], [$Uint], false)}, {prop: "and", name: "and", pkg: "math/big", typ: $funcType([nat, nat], [nat], false)}, {prop: "andNot", name: "andNot", pkg: "math/big", typ: $funcType([nat, nat], [nat], false)}, {prop: "or", name: "or", pkg: "math/big", typ: $funcType([nat, nat], [nat], false)}, {prop: "xor", name: "xor", pkg: "math/big", typ: $funcType([nat, nat], [nat], false)}, {prop: "modW", name: "modW", pkg: "math/big", typ: $funcType([Word], [Word], false)}, {prop: "random", name: "random", pkg: "math/big", typ: $funcType([ptrType$6, nat, $Int], [nat], false)}, {prop: "expNN", name: "expNN", pkg: "math/big", typ: $funcType([nat, nat, nat], [nat], false)}, {prop: "expNNWindowed", name: "expNNWindowed", pkg: "math/big", typ: $funcType([nat, nat, nat], [nat], false)}, {prop: "expNNMontgomery", name: "expNNMontgomery", pkg: "math/big", typ: $funcType([nat, nat, nat], [nat], false)}, {prop: "bytes", name: "bytes", pkg: "math/big", typ: $funcType([sliceType$1], [$Int], false)}, {prop: "setBytes", name: "setBytes", pkg: "math/big", typ: $funcType([sliceType$1], [nat], false)}, {prop: "sqrt", name: "sqrt", pkg: "math/big", typ: $funcType([nat], [nat], false)}, {prop: "scan", name: "scan", pkg: "math/big", typ: $funcType([io.ByteScanner, $Int, $Bool], [nat, $Int, $Int, $error], false)}, {prop: "utoa", name: "utoa", pkg: "math/big", typ: $funcType([$Int], [sliceType$1], false)}, {prop: "itoa", name: "itoa", pkg: "math/big", typ: $funcType([$Bool, $Int], [sliceType$1], false)}, {prop: "convertWords", name: "convertWords", pkg: "math/big", typ: $funcType([sliceType$1, Word, $Int, Word, sliceType$3], [], false)}, {prop: "expWW", name: "expWW", pkg: "math/big", typ: $funcType([Word, Word], [nat], false)}, {prop: "probablyPrimeMillerRabin", name: "probablyPrimeMillerRabin", pkg: "math/big", typ: $funcType([$Int, $Bool], [$Bool], false)}, {prop: "probablyPrimeLucas", name: "probablyPrimeLucas", pkg: "math/big", typ: $funcType([], [$Bool], false)}];
	Int.init("math/big", [{prop: "neg", name: "neg", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "abs", name: "abs", anonymous: false, exported: false, typ: nat, tag: ""}]);
	byteReader.init("", [{prop: "ScanState", name: "ScanState", anonymous: true, exported: true, typ: fmt.ScanState, tag: ""}]);
	nat.init(Word);
	divisor.init("math/big", [{prop: "bbb", name: "bbb", anonymous: false, exported: false, typ: nat, tag: ""}, {prop: "nbits", name: "nbits", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "ndigits", name: "ndigits", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = binary.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmt.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = nosync.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bits.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = rand.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		natPool = new nosync.Pool.ptr(sliceType.nil, $throwNilPointerError);
		cacheBase10 = new structType.ptr(new nosync.Mutex.ptr(false), arrayType.zero());
		natOne = new nat([1]);
		intOne = new Int.ptr(false, natOne);
		natTwo = new nat([2]);
		karatsubaThreshold = 40;
		leafSize = 8;
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["regexp/syntax"] = (function() {
	var $pkg = {}, $init, bytes, sort, strconv, strings, unicode, utf8, patchList, frag, compiler, Error, ErrorCode, Flags, parser, charGroup, ranges, Prog, InstOp, EmptyOp, Inst, Regexp, Op, sliceType, sliceType$1, sliceType$2, sliceType$3, ptrType, sliceType$4, ptrType$1, sliceType$5, arrayType, arrayType$1, ptrType$2, ptrType$3, sliceType$6, arrayType$2, ptrType$4, ptrType$5, ptrType$6, ptrType$7, anyRuneNotNL, anyRune, anyTable, code1, code2, code3, perlGroup, code4, code5, code6, code7, code8, code9, code10, code11, code12, code13, code14, code15, code16, code17, posixGroup, instOpNames, Compile, minFoldRune, repeatIsValid, cleanAlt, literalRegexp, Parse, isValidCaptureName, isCharClass, matchRune, mergeCharClass, unicodeTable, cleanClass, appendLiteral, appendRange, appendFoldedRange, appendClass, appendFoldedClass, appendNegatedClass, appendTable, appendNegatedTable, negateClass, checkUTF8, nextRune, isalnum, unhex, EmptyOpContext, IsWordChar, wordRune, bw, dumpProg, u32, dumpInst, writeRegexp, escape, simplify1;
	bytes = $packages["bytes"];
	sort = $packages["sort"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	patchList = $pkg.patchList = $newType(4, $kindUint32, "syntax.patchList", true, "regexp/syntax", false, null);
	frag = $pkg.frag = $newType(0, $kindStruct, "syntax.frag", true, "regexp/syntax", false, function(i_, out_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.i = 0;
			this.out = 0;
			return;
		}
		this.i = i_;
		this.out = out_;
	});
	compiler = $pkg.compiler = $newType(0, $kindStruct, "syntax.compiler", true, "regexp/syntax", false, function(p_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.p = ptrType.nil;
			return;
		}
		this.p = p_;
	});
	Error = $pkg.Error = $newType(0, $kindStruct, "syntax.Error", true, "regexp/syntax", true, function(Code_, Expr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Code = "";
			this.Expr = "";
			return;
		}
		this.Code = Code_;
		this.Expr = Expr_;
	});
	ErrorCode = $pkg.ErrorCode = $newType(8, $kindString, "syntax.ErrorCode", true, "regexp/syntax", true, null);
	Flags = $pkg.Flags = $newType(2, $kindUint16, "syntax.Flags", true, "regexp/syntax", true, null);
	parser = $pkg.parser = $newType(0, $kindStruct, "syntax.parser", true, "regexp/syntax", false, function(flags_, stack_, free_, numCap_, wholeRegexp_, tmpClass_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.flags = 0;
			this.stack = sliceType$5.nil;
			this.free = ptrType$1.nil;
			this.numCap = 0;
			this.wholeRegexp = "";
			this.tmpClass = sliceType.nil;
			return;
		}
		this.flags = flags_;
		this.stack = stack_;
		this.free = free_;
		this.numCap = numCap_;
		this.wholeRegexp = wholeRegexp_;
		this.tmpClass = tmpClass_;
	});
	charGroup = $pkg.charGroup = $newType(0, $kindStruct, "syntax.charGroup", true, "regexp/syntax", false, function(sign_, class$1_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.sign = 0;
			this.class$1 = sliceType.nil;
			return;
		}
		this.sign = sign_;
		this.class$1 = class$1_;
	});
	ranges = $pkg.ranges = $newType(0, $kindStruct, "syntax.ranges", true, "regexp/syntax", false, function(p_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.p = ptrType$2.nil;
			return;
		}
		this.p = p_;
	});
	Prog = $pkg.Prog = $newType(0, $kindStruct, "syntax.Prog", true, "regexp/syntax", true, function(Inst_, Start_, NumCap_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Inst = sliceType$4.nil;
			this.Start = 0;
			this.NumCap = 0;
			return;
		}
		this.Inst = Inst_;
		this.Start = Start_;
		this.NumCap = NumCap_;
	});
	InstOp = $pkg.InstOp = $newType(1, $kindUint8, "syntax.InstOp", true, "regexp/syntax", true, null);
	EmptyOp = $pkg.EmptyOp = $newType(1, $kindUint8, "syntax.EmptyOp", true, "regexp/syntax", true, null);
	Inst = $pkg.Inst = $newType(0, $kindStruct, "syntax.Inst", true, "regexp/syntax", true, function(Op_, Out_, Arg_, Rune_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Op = 0;
			this.Out = 0;
			this.Arg = 0;
			this.Rune = sliceType.nil;
			return;
		}
		this.Op = Op_;
		this.Out = Out_;
		this.Arg = Arg_;
		this.Rune = Rune_;
	});
	Regexp = $pkg.Regexp = $newType(0, $kindStruct, "syntax.Regexp", true, "regexp/syntax", true, function(Op_, Flags_, Sub_, Sub0_, Rune_, Rune0_, Min_, Max_, Cap_, Name_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Op = 0;
			this.Flags = 0;
			this.Sub = sliceType$5.nil;
			this.Sub0 = arrayType.zero();
			this.Rune = sliceType.nil;
			this.Rune0 = arrayType$1.zero();
			this.Min = 0;
			this.Max = 0;
			this.Cap = 0;
			this.Name = "";
			return;
		}
		this.Op = Op_;
		this.Flags = Flags_;
		this.Sub = Sub_;
		this.Sub0 = Sub0_;
		this.Rune = Rune_;
		this.Rune0 = Rune0_;
		this.Min = Min_;
		this.Max = Max_;
		this.Cap = Cap_;
		this.Name = Name_;
	});
	Op = $pkg.Op = $newType(1, $kindUint8, "syntax.Op", true, "regexp/syntax", true, null);
	sliceType = $sliceType($Int32);
	sliceType$1 = $sliceType(unicode.Range16);
	sliceType$2 = $sliceType(unicode.Range32);
	sliceType$3 = $sliceType($String);
	ptrType = $ptrType(Prog);
	sliceType$4 = $sliceType(Inst);
	ptrType$1 = $ptrType(Regexp);
	sliceType$5 = $sliceType(ptrType$1);
	arrayType = $arrayType(ptrType$1, 1);
	arrayType$1 = $arrayType($Int32, 2);
	ptrType$2 = $ptrType(sliceType);
	ptrType$3 = $ptrType(unicode.RangeTable);
	sliceType$6 = $sliceType($Uint8);
	arrayType$2 = $arrayType($Uint8, 64);
	ptrType$4 = $ptrType(compiler);
	ptrType$5 = $ptrType(Error);
	ptrType$6 = $ptrType(parser);
	ptrType$7 = $ptrType(Inst);
	patchList.prototype.next = function(p) {
		var i, l, p, x, x$1;
		l = this.$val;
		i = (x = p.Inst, x$1 = l >>> 1 >>> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (((l & 1) >>> 0) === 0) {
			return ((i.Out >>> 0));
		}
		return ((i.Arg >>> 0));
	};
	$ptrType(patchList).prototype.next = function(p) { return new patchList(this.$get()).next(p); };
	patchList.prototype.patch = function(p, val) {
		var i, l, p, val, x, x$1;
		l = this.$val;
		while (true) {
			if (!(!((l === 0)))) { break; }
			i = (x = p.Inst, x$1 = l >>> 1 >>> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			if (((l & 1) >>> 0) === 0) {
				l = ((i.Out >>> 0));
				i.Out = val;
			} else {
				l = ((i.Arg >>> 0));
				i.Arg = val;
			}
		}
	};
	$ptrType(patchList).prototype.patch = function(p, val) { return new patchList(this.$get()).patch(p, val); };
	patchList.prototype.append = function(p, l2) {
		var i, l1, l2, last, next, p, x, x$1;
		l1 = this.$val;
		if (l1 === 0) {
			return l2;
		}
		if (l2 === 0) {
			return l1;
		}
		last = l1;
		while (true) {
			next = new patchList(last).next(p);
			if (next === 0) {
				break;
			}
			last = next;
		}
		i = (x = p.Inst, x$1 = last >>> 1 >>> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (((last & 1) >>> 0) === 0) {
			i.Out = ((l2 >>> 0));
		} else {
			i.Arg = ((l2 >>> 0));
		}
		return l1;
	};
	$ptrType(patchList).prototype.append = function(p, l2) { return new patchList(this.$get()).append(p, l2); };
	Compile = function(re) {
		var c, f, re;
		c = new compiler.ptr(ptrType.nil);
		c.init();
		f = $clone(c.compile(re), frag);
		new patchList(f.out).patch(c.p, c.inst(4).i);
		c.p.Start = ((f.i >> 0));
		return [c.p, $ifaceNil];
	};
	$pkg.Compile = Compile;
	compiler.ptr.prototype.init = function() {
		var c;
		c = this;
		c.p = new Prog.ptr(sliceType$4.nil, 0, 0);
		c.p.NumCap = 2;
		c.inst(5);
	};
	compiler.prototype.init = function() { return this.$val.init(); };
	compiler.ptr.prototype.compile = function(re) {
		var _1, _i, _i$1, _i$2, _ref, _ref$1, _ref$2, bra, c, f, f$1, f$2, f1, i, j, ket, re, sub, sub$1, sub$2, x, x$1, x$2, x$3;
		c = this;
		_1 = re.Op;
		if (_1 === (1)) {
			return c.fail();
		} else if (_1 === (2)) {
			return c.nop();
		} else if (_1 === (3)) {
			if (re.Rune.$length === 0) {
				return c.nop();
			}
			f = new frag.ptr(0, 0);
			_ref = re.Rune;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				j = _i;
				f1 = $clone(c.rune($subslice(re.Rune, j, (j + 1 >> 0)), re.Flags), frag);
				if (j === 0) {
					frag.copy(f, f1);
				} else {
					frag.copy(f, c.cat($clone(f, frag), $clone(f1, frag)));
				}
				_i++;
			}
			return f;
		} else if (_1 === (4)) {
			return c.rune(re.Rune, re.Flags);
		} else if (_1 === (5)) {
			return c.rune(anyRuneNotNL, 0);
		} else if (_1 === (6)) {
			return c.rune(anyRune, 0);
		} else if (_1 === (7)) {
			return c.empty(1);
		} else if (_1 === (8)) {
			return c.empty(2);
		} else if (_1 === (9)) {
			return c.empty(4);
		} else if (_1 === (10)) {
			return c.empty(8);
		} else if (_1 === (11)) {
			return c.empty(16);
		} else if (_1 === (12)) {
			return c.empty(32);
		} else if (_1 === (13)) {
			bra = $clone(c.cap((((re.Cap << 1 >> 0) >>> 0))), frag);
			sub = $clone(c.compile((x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]))), frag);
			ket = $clone(c.cap(((((re.Cap << 1 >> 0) | 1) >>> 0))), frag);
			return c.cat($clone(c.cat($clone(bra, frag), $clone(sub, frag)), frag), $clone(ket, frag));
		} else if (_1 === (14)) {
			return c.star($clone(c.compile((x$1 = re.Sub, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0]))), frag), !((((re.Flags & 32) >>> 0) === 0)));
		} else if (_1 === (15)) {
			return c.plus($clone(c.compile((x$2 = re.Sub, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0]))), frag), !((((re.Flags & 32) >>> 0) === 0)));
		} else if (_1 === (16)) {
			return c.quest($clone(c.compile((x$3 = re.Sub, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0]))), frag), !((((re.Flags & 32) >>> 0) === 0)));
		} else if (_1 === (18)) {
			if (re.Sub.$length === 0) {
				return c.nop();
			}
			f$1 = new frag.ptr(0, 0);
			_ref$1 = re.Sub;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$1.$length)) { break; }
				i = _i$1;
				sub$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
				if (i === 0) {
					frag.copy(f$1, c.compile(sub$1));
				} else {
					frag.copy(f$1, c.cat($clone(f$1, frag), $clone(c.compile(sub$1), frag)));
				}
				_i$1++;
			}
			return f$1;
		} else if (_1 === (19)) {
			f$2 = new frag.ptr(0, 0);
			_ref$2 = re.Sub;
			_i$2 = 0;
			while (true) {
				if (!(_i$2 < _ref$2.$length)) { break; }
				sub$2 = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
				frag.copy(f$2, c.alt($clone(f$2, frag), $clone(c.compile(sub$2), frag)));
				_i$2++;
			}
			return f$2;
		}
		$panic(new $String("regexp: unhandled case in compile"));
	};
	compiler.prototype.compile = function(re) { return this.$val.compile(re); };
	compiler.ptr.prototype.inst = function(op) {
		var c, f, op;
		c = this;
		f = new frag.ptr(((c.p.Inst.$length >>> 0)), 0);
		c.p.Inst = $append(c.p.Inst, new Inst.ptr(op, 0, 0, sliceType.nil));
		return f;
	};
	compiler.prototype.inst = function(op) { return this.$val.inst(op); };
	compiler.ptr.prototype.nop = function() {
		var c, f;
		c = this;
		f = $clone(c.inst(6), frag);
		f.out = (((f.i << 1 >>> 0) >>> 0));
		return f;
	};
	compiler.prototype.nop = function() { return this.$val.nop(); };
	compiler.ptr.prototype.fail = function() {
		var c;
		c = this;
		return new frag.ptr(0, 0);
	};
	compiler.prototype.fail = function() { return this.$val.fail(); };
	compiler.ptr.prototype.cap = function(arg) {
		var arg, c, f, x, x$1;
		c = this;
		f = $clone(c.inst(2), frag);
		f.out = (((f.i << 1 >>> 0) >>> 0));
		(x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Arg = arg;
		if (c.p.NumCap < (((arg >> 0)) + 1 >> 0)) {
			c.p.NumCap = ((arg >> 0)) + 1 >> 0;
		}
		return f;
	};
	compiler.prototype.cap = function(arg) { return this.$val.cap(arg); };
	compiler.ptr.prototype.cat = function(f1, f2) {
		var c, f1, f2;
		c = this;
		if ((f1.i === 0) || (f2.i === 0)) {
			return new frag.ptr(0, 0);
		}
		new patchList(f1.out).patch(c.p, f2.i);
		return new frag.ptr(f1.i, f2.out);
	};
	compiler.prototype.cat = function(f1, f2) { return this.$val.cat(f1, f2); };
	compiler.ptr.prototype.alt = function(f1, f2) {
		var c, f, f1, f2, i, x, x$1;
		c = this;
		if (f1.i === 0) {
			return f2;
		}
		if (f2.i === 0) {
			return f1;
		}
		f = $clone(c.inst(0), frag);
		i = (x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		i.Out = f1.i;
		i.Arg = f2.i;
		f.out = new patchList(f1.out).append(c.p, f2.out);
		return f;
	};
	compiler.prototype.alt = function(f1, f2) { return this.$val.alt(f1, f2); };
	compiler.ptr.prototype.quest = function(f1, nongreedy) {
		var c, f, f1, i, nongreedy, x, x$1;
		c = this;
		f = $clone(c.inst(0), frag);
		i = (x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (nongreedy) {
			i.Arg = f1.i;
			f.out = (((f.i << 1 >>> 0) >>> 0));
		} else {
			i.Out = f1.i;
			f.out = (((((f.i << 1 >>> 0) | 1) >>> 0) >>> 0));
		}
		f.out = new patchList(f.out).append(c.p, f1.out);
		return f;
	};
	compiler.prototype.quest = function(f1, nongreedy) { return this.$val.quest(f1, nongreedy); };
	compiler.ptr.prototype.star = function(f1, nongreedy) {
		var c, f, f1, i, nongreedy, x, x$1;
		c = this;
		f = $clone(c.inst(0), frag);
		i = (x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (nongreedy) {
			i.Arg = f1.i;
			f.out = (((f.i << 1 >>> 0) >>> 0));
		} else {
			i.Out = f1.i;
			f.out = (((((f.i << 1 >>> 0) | 1) >>> 0) >>> 0));
		}
		new patchList(f1.out).patch(c.p, f.i);
		return f;
	};
	compiler.prototype.star = function(f1, nongreedy) { return this.$val.star(f1, nongreedy); };
	compiler.ptr.prototype.plus = function(f1, nongreedy) {
		var c, f1, nongreedy;
		c = this;
		return new frag.ptr(f1.i, c.star($clone(f1, frag), nongreedy).out);
	};
	compiler.prototype.plus = function(f1, nongreedy) { return this.$val.plus(f1, nongreedy); };
	compiler.ptr.prototype.empty = function(op) {
		var c, f, op, x, x$1;
		c = this;
		f = $clone(c.inst(3), frag);
		(x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Arg = ((op >>> 0));
		f.out = (((f.i << 1 >>> 0) >>> 0));
		return f;
	};
	compiler.prototype.empty = function(op) { return this.$val.empty(op); };
	compiler.ptr.prototype.rune = function(r, flags) {
		var c, f, flags, i, r, x, x$1;
		c = this;
		f = $clone(c.inst(7), frag);
		i = (x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		i.Rune = r;
		flags = (flags & (1)) >>> 0;
		if (!((r.$length === 1)) || (unicode.SimpleFold((0 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 0])) === (0 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 0]))) {
			flags = (flags & ~(1)) << 16 >>> 16;
		}
		i.Arg = ((flags >>> 0));
		f.out = (((f.i << 1 >>> 0) >>> 0));
		if ((((flags & 1) >>> 0) === 0) && ((r.$length === 1) || (r.$length === 2) && ((0 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 0]) === (1 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 1])))) {
			i.Op = 8;
		} else if ((r.$length === 2) && ((0 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 0]) === 0) && ((1 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 1]) === 1114111)) {
			i.Op = 9;
		} else if ((r.$length === 4) && ((0 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 0]) === 0) && ((1 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 1]) === 9) && ((2 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 2]) === 11) && ((3 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 3]) === 1114111)) {
			i.Op = 10;
		}
		return f;
	};
	compiler.prototype.rune = function(r, flags) { return this.$val.rune(r, flags); };
	Error.ptr.prototype.Error = function() {
		var e;
		e = this;
		return "error parsing regexp: " + new ErrorCode(e.Code).String() + ": `" + e.Expr + "`";
	};
	Error.prototype.Error = function() { return this.$val.Error(); };
	ErrorCode.prototype.String = function() {
		var e;
		e = this.$val;
		return (e);
	};
	$ptrType(ErrorCode).prototype.String = function() { return new ErrorCode(this.$get()).String(); };
	parser.ptr.prototype.newRegexp = function(op) {
		var op, p, re;
		p = this;
		re = p.free;
		if (!(re === ptrType$1.nil)) {
			p.free = re.Sub0[0];
			Regexp.copy(re, new Regexp.ptr(0, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, ""));
		} else {
			re = new Regexp.ptr(0, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
		}
		re.Op = op;
		return re;
	};
	parser.prototype.newRegexp = function(op) { return this.$val.newRegexp(op); };
	parser.ptr.prototype.reuse = function(re) {
		var p, re;
		p = this;
		re.Sub0[0] = p.free;
		p.free = re;
	};
	parser.prototype.reuse = function(re) { return this.$val.reuse(re); };
	parser.ptr.prototype.push = function(re) {
		var p, re, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		p = this;
		if ((re.Op === 4) && (re.Rune.$length === 2) && ((x = re.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) === (x$1 = re.Rune, (1 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 1])))) {
			if (p.maybeConcat((x$16 = re.Rune, (0 >= x$16.$length ? ($throwRuntimeError("index out of range"), undefined) : x$16.$array[x$16.$offset + 0])), (p.flags & ~1) << 16 >>> 16)) {
				return ptrType$1.nil;
			}
			re.Op = 3;
			re.Rune = $subslice(re.Rune, 0, 1);
			re.Flags = (p.flags & ~1) << 16 >>> 16;
		} else if ((re.Op === 4) && (re.Rune.$length === 4) && ((x$2 = re.Rune, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0])) === (x$3 = re.Rune, (1 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 1]))) && ((x$4 = re.Rune, (2 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 2])) === (x$5 = re.Rune, (3 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 3]))) && (unicode.SimpleFold((x$6 = re.Rune, (0 >= x$6.$length ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + 0]))) === (x$7 = re.Rune, (2 >= x$7.$length ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + 2]))) && (unicode.SimpleFold((x$8 = re.Rune, (2 >= x$8.$length ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + 2]))) === (x$9 = re.Rune, (0 >= x$9.$length ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + 0]))) || (re.Op === 4) && (re.Rune.$length === 2) && (((x$10 = re.Rune, (0 >= x$10.$length ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + 0])) + 1 >> 0) === (x$11 = re.Rune, (1 >= x$11.$length ? ($throwRuntimeError("index out of range"), undefined) : x$11.$array[x$11.$offset + 1]))) && (unicode.SimpleFold((x$12 = re.Rune, (0 >= x$12.$length ? ($throwRuntimeError("index out of range"), undefined) : x$12.$array[x$12.$offset + 0]))) === (x$13 = re.Rune, (1 >= x$13.$length ? ($throwRuntimeError("index out of range"), undefined) : x$13.$array[x$13.$offset + 1]))) && (unicode.SimpleFold((x$14 = re.Rune, (1 >= x$14.$length ? ($throwRuntimeError("index out of range"), undefined) : x$14.$array[x$14.$offset + 1]))) === (x$15 = re.Rune, (0 >= x$15.$length ? ($throwRuntimeError("index out of range"), undefined) : x$15.$array[x$15.$offset + 0])))) {
			if (p.maybeConcat((x$17 = re.Rune, (0 >= x$17.$length ? ($throwRuntimeError("index out of range"), undefined) : x$17.$array[x$17.$offset + 0])), (p.flags | 1) >>> 0)) {
				return ptrType$1.nil;
			}
			re.Op = 3;
			re.Rune = $subslice(re.Rune, 0, 1);
			re.Flags = (p.flags | 1) >>> 0;
		} else {
			p.maybeConcat(-1, 0);
		}
		p.stack = $append(p.stack, re);
		return re;
	};
	parser.prototype.push = function(re) { return this.$val.push(re); };
	parser.ptr.prototype.maybeConcat = function(r, flags) {
		var flags, n, p, r, re1, re2, x, x$1, x$2, x$3, x$4;
		p = this;
		n = p.stack.$length;
		if (n < 2) {
			return false;
		}
		re1 = (x = p.stack, x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		re2 = (x$2 = p.stack, x$3 = n - 2 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]));
		if (!((re1.Op === 3)) || !((re2.Op === 3)) || !((((re1.Flags & 1) >>> 0) === ((re2.Flags & 1) >>> 0)))) {
			return false;
		}
		re2.Rune = $appendSlice(re2.Rune, re1.Rune);
		if (r >= 0) {
			re1.Rune = $subslice(new sliceType(re1.Rune0), 0, 1);
			(x$4 = re1.Rune, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0] = r));
			re1.Flags = flags;
			return true;
		}
		p.stack = $subslice(p.stack, 0, (n - 1 >> 0));
		p.reuse(re1);
		return false;
	};
	parser.prototype.maybeConcat = function(r, flags) { return this.$val.maybeConcat(r, flags); };
	parser.ptr.prototype.newLiteral = function(r, flags) {
		var flags, p, r, re;
		p = this;
		re = p.newRegexp(3);
		re.Flags = flags;
		if (!((((flags & 1) >>> 0) === 0))) {
			r = minFoldRune(r);
		}
		re.Rune0[0] = r;
		re.Rune = $subslice(new sliceType(re.Rune0), 0, 1);
		return re;
	};
	parser.prototype.newLiteral = function(r, flags) { return this.$val.newLiteral(r, flags); };
	minFoldRune = function(r) {
		var min, r, r0;
		if (r < 65 || r > 125251) {
			return r;
		}
		min = r;
		r0 = r;
		r = unicode.SimpleFold(r);
		while (true) {
			if (!(!((r === r0)))) { break; }
			if (min > r) {
				min = r;
			}
			r = unicode.SimpleFold(r);
		}
		return min;
	};
	parser.ptr.prototype.literal = function(r) {
		var p, r;
		p = this;
		p.push(p.newLiteral(r, p.flags));
	};
	parser.prototype.literal = function(r) { return this.$val.literal(r); };
	parser.ptr.prototype.op = function(op) {
		var op, p, re;
		p = this;
		re = p.newRegexp(op);
		re.Flags = p.flags;
		return p.push(re);
	};
	parser.prototype.op = function(op) { return this.$val.op(op); };
	parser.ptr.prototype.repeat = function(op, min, max, before, after, lastRepeat) {
		var after, before, flags, lastRepeat, max, min, n, op, p, re, sub, x, x$1, x$2, x$3, x$4;
		p = this;
		flags = p.flags;
		if (!((((p.flags & 64) >>> 0) === 0))) {
			if (after.length > 0 && (after.charCodeAt(0) === 63)) {
				after = $substring(after, 1);
				flags = (flags ^ (32)) << 16 >>> 16;
			}
			if (!(lastRepeat === "")) {
				return ["", new Error.ptr("invalid nested repetition operator", $substring(lastRepeat, 0, (lastRepeat.length - after.length >> 0)))];
			}
		}
		n = p.stack.$length;
		if (n === 0) {
			return ["", new Error.ptr("missing argument to repetition operator", $substring(before, 0, (before.length - after.length >> 0)))];
		}
		sub = (x = p.stack, x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (sub.Op >= 128) {
			return ["", new Error.ptr("missing argument to repetition operator", $substring(before, 0, (before.length - after.length >> 0)))];
		}
		re = p.newRegexp(op);
		re.Min = min;
		re.Max = max;
		re.Flags = flags;
		re.Sub = $subslice(new sliceType$5(re.Sub0), 0, 1);
		(x$2 = re.Sub, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0] = sub));
		(x$3 = p.stack, x$4 = n - 1 >> 0, ((x$4 < 0 || x$4 >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + x$4] = re));
		if ((op === 17) && (min >= 2 || max >= 2) && !repeatIsValid(re, 1000)) {
			return ["", new Error.ptr("invalid repeat count", $substring(before, 0, (before.length - after.length >> 0)))];
		}
		return [after, $ifaceNil];
	};
	parser.prototype.repeat = function(op, min, max, before, after, lastRepeat) { return this.$val.repeat(op, min, max, before, after, lastRepeat); };
	repeatIsValid = function(re, n) {
		var _i, _q, _ref, m, n, re, sub;
		if (re.Op === 17) {
			m = re.Max;
			if (m === 0) {
				return true;
			}
			if (m < 0) {
				m = re.Min;
			}
			if (m > n) {
				return false;
			}
			if (m > 0) {
				n = (_q = n / (m), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
			}
		}
		_ref = re.Sub;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			sub = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!repeatIsValid(sub, n)) {
				return false;
			}
			_i++;
		}
		return true;
	};
	parser.ptr.prototype.concat = function() {
		var _r, _r$1, i, p, subs, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; i = $f.i; p = $f.p; subs = $f.subs; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		p.maybeConcat(-1, 0);
		i = p.stack.$length;
		while (true) {
			if (!(i > 0 && (x = p.stack, x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Op < 128)) { break; }
			i = i - (1) >> 0;
		}
		subs = $subslice(p.stack, i);
		p.stack = $subslice(p.stack, 0, i);
		if (subs.$length === 0) {
			$s = -1; return p.push(p.newRegexp(2));
		}
		_r = p.collapse(subs, 18); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = p.push(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.concat }; } $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.p = p; $f.subs = subs; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.concat = function() { return this.$val.concat(); };
	parser.ptr.prototype.alternate = function() {
		var _r, _r$1, i, p, subs, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; i = $f.i; p = $f.p; subs = $f.subs; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		i = p.stack.$length;
		while (true) {
			if (!(i > 0 && (x = p.stack, x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Op < 128)) { break; }
			i = i - (1) >> 0;
		}
		subs = $subslice(p.stack, i);
		p.stack = $subslice(p.stack, 0, i);
		/* */ if (subs.$length > 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (subs.$length > 0) { */ case 1:
			$r = cleanAlt((x$2 = subs.$length - 1 >> 0, ((x$2 < 0 || x$2 >= subs.$length) ? ($throwRuntimeError("index out of range"), undefined) : subs.$array[subs.$offset + x$2]))); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		if (subs.$length === 0) {
			$s = -1; return p.push(p.newRegexp(1));
		}
		_r = p.collapse(subs, 19); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = p.push(_r); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.alternate }; } $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.p = p; $f.subs = subs; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.alternate = function() { return this.$val.alternate(); };
	cleanAlt = function(re) {
		var _1, _r, re, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; re = $f.re; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = re.Op;
			/* */ if (_1 === (4)) { $s = 2; continue; }
			/* */ $s = 3; continue;
			/* if (_1 === (4)) { */ case 2:
				_r = cleanClass((re.$ptr_Rune || (re.$ptr_Rune = new ptrType$2(function() { return this.$target.Rune; }, function($v) { this.$target.Rune = $v; }, re)))); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				re.Rune = _r;
				if ((re.Rune.$length === 2) && ((x = re.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) === 0) && ((x$1 = re.Rune, (1 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 1])) === 1114111)) {
					re.Rune = sliceType.nil;
					re.Op = 6;
					$s = -1; return;
				}
				if ((re.Rune.$length === 4) && ((x$2 = re.Rune, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0])) === 0) && ((x$3 = re.Rune, (1 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 1])) === 9) && ((x$4 = re.Rune, (2 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 2])) === 11) && ((x$5 = re.Rune, (3 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 3])) === 1114111)) {
					re.Rune = sliceType.nil;
					re.Op = 5;
					$s = -1; return;
				}
				if ((re.Rune.$capacity - re.Rune.$length >> 0) > 100) {
					re.Rune = $appendSlice($subslice(new sliceType(re.Rune0), 0, 0), re.Rune);
				}
			/* } */ case 3:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cleanAlt }; } $f._1 = _1; $f._r = _r; $f.re = re; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.ptr.prototype.collapse = function(subs, op) {
		var _i, _r, _ref, old, op, p, re, sub, subs, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; old = $f.old; op = $f.op; p = $f.p; re = $f.re; sub = $f.sub; subs = $f.subs; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (subs.$length === 1) {
			$s = -1; return (0 >= subs.$length ? ($throwRuntimeError("index out of range"), undefined) : subs.$array[subs.$offset + 0]);
		}
		re = p.newRegexp(op);
		re.Sub = $subslice(new sliceType$5(re.Sub0), 0, 0);
		_ref = subs;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			sub = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (sub.Op === op) {
				re.Sub = $appendSlice(re.Sub, sub.Sub);
				p.reuse(sub);
			} else {
				re.Sub = $append(re.Sub, sub);
			}
			_i++;
		}
		/* */ if (op === 19) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (op === 19) { */ case 1:
			_r = p.factor(re.Sub); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			re.Sub = _r;
			if (re.Sub.$length === 1) {
				old = re;
				re = (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
				p.reuse(old);
			}
		/* } */ case 2:
		$s = -1; return re;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.collapse }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.old = old; $f.op = op; $f.p = p; $f.re = re; $f.sub = sub; $f.subs = subs; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.collapse = function(subs, op) { return this.$val.collapse(subs, op); };
	parser.ptr.prototype.factor = function(sub) {
		var _i, _r, _r$1, _ref, _tmp, _tmp$1, _tuple, first, i, i$1, i$2, i$3, ifirst, iflags, istr, j, j$1, j$2, j$3, max, out, p, prefix, prefix$1, re, re$1, reuse, same, start, str, strflags, sub, suffix, suffix$1, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; first = $f.first; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; ifirst = $f.ifirst; iflags = $f.iflags; istr = $f.istr; j = $f.j; j$1 = $f.j$1; j$2 = $f.j$2; j$3 = $f.j$3; max = $f.max; out = $f.out; p = $f.p; prefix = $f.prefix; prefix$1 = $f.prefix$1; re = $f.re; re$1 = $f.re$1; reuse = $f.reuse; same = $f.same; start = $f.start; str = $f.str; strflags = $f.strflags; sub = $f.sub; suffix = $f.suffix; suffix$1 = $f.suffix$1; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (sub.$length < 2) {
			$s = -1; return sub;
		}
		str = sliceType.nil;
		strflags = 0;
		start = 0;
		out = $subslice(sub, 0, 0);
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i <= sub.$length)) { break; } */ if(!(i <= sub.$length)) { $s = 2; continue; }
			istr = sliceType.nil;
			iflags = 0;
			/* */ if (i < sub.$length) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (i < sub.$length) { */ case 3:
				_tuple = p.leadingString(((i < 0 || i >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i]));
				istr = _tuple[0];
				iflags = _tuple[1];
				if (iflags === strflags) {
					same = 0;
					while (true) {
						if (!(same < str.$length && same < istr.$length && (((same < 0 || same >= str.$length) ? ($throwRuntimeError("index out of range"), undefined) : str.$array[str.$offset + same]) === ((same < 0 || same >= istr.$length) ? ($throwRuntimeError("index out of range"), undefined) : istr.$array[istr.$offset + same])))) { break; }
						same = same + (1) >> 0;
					}
					if (same > 0) {
						str = $subslice(str, 0, same);
						i = i + (1) >> 0;
						/* continue; */ $s = 1; continue;
					}
				}
			/* } */ case 4:
			/* */ if (i === start) { $s = 5; continue; }
			/* */ if (i === (start + 1 >> 0)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (i === start) { */ case 5:
				$s = 8; continue;
			/* } else if (i === (start + 1 >> 0)) { */ case 6:
				out = $append(out, ((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]));
				$s = 8; continue;
			/* } else { */ case 7:
				prefix = p.newRegexp(3);
				prefix.Flags = strflags;
				prefix.Rune = $appendSlice($subslice(prefix.Rune, 0, 0), str);
				j = start;
				while (true) {
					if (!(j < i)) { break; }
					((j < 0 || j >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j] = p.removeLeadingString(((j < 0 || j >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j]), str.$length));
					j = j + (1) >> 0;
				}
				_r = p.collapse($subslice(sub, start, i), 19); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				suffix = _r;
				re = p.newRegexp(18);
				re.Sub = $append($subslice(re.Sub, 0, 0), prefix, suffix);
				out = $append(out, re);
			/* } */ case 8:
			start = i;
			str = istr;
			strflags = iflags;
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		sub = out;
		start = 0;
		out = $subslice(sub, 0, 0);
		first = ptrType$1.nil;
		i$1 = 0;
		/* while (true) { */ case 10:
			/* if (!(i$1 <= sub.$length)) { break; } */ if(!(i$1 <= sub.$length)) { $s = 11; continue; }
			ifirst = ptrType$1.nil;
			/* */ if (i$1 < sub.$length) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if (i$1 < sub.$length) { */ case 12:
				ifirst = p.leadingRegexp(((i$1 < 0 || i$1 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$1]));
				if (!(first === ptrType$1.nil) && first.Equal(ifirst) && (isCharClass(first) || ((first.Op === 17) && (first.Min === first.Max) && isCharClass((x = first.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])))))) {
					i$1 = i$1 + (1) >> 0;
					/* continue; */ $s = 10; continue;
				}
			/* } */ case 13:
			/* */ if (i$1 === start) { $s = 14; continue; }
			/* */ if (i$1 === (start + 1 >> 0)) { $s = 15; continue; }
			/* */ $s = 16; continue;
			/* if (i$1 === start) { */ case 14:
				$s = 17; continue;
			/* } else if (i$1 === (start + 1 >> 0)) { */ case 15:
				out = $append(out, ((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]));
				$s = 17; continue;
			/* } else { */ case 16:
				prefix$1 = first;
				j$1 = start;
				while (true) {
					if (!(j$1 < i$1)) { break; }
					reuse = !((j$1 === start));
					((j$1 < 0 || j$1 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$1] = p.removeLeadingRegexp(((j$1 < 0 || j$1 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$1]), reuse));
					j$1 = j$1 + (1) >> 0;
				}
				_r$1 = p.collapse($subslice(sub, start, i$1), 19); /* */ $s = 18; case 18: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				suffix$1 = _r$1;
				re$1 = p.newRegexp(18);
				re$1.Sub = $append($subslice(re$1.Sub, 0, 0), prefix$1, suffix$1);
				out = $append(out, re$1);
			/* } */ case 17:
			start = i$1;
			first = ifirst;
			i$1 = i$1 + (1) >> 0;
		/* } */ $s = 10; continue; case 11:
		sub = out;
		start = 0;
		out = $subslice(sub, 0, 0);
		i$2 = 0;
		/* while (true) { */ case 19:
			/* if (!(i$2 <= sub.$length)) { break; } */ if(!(i$2 <= sub.$length)) { $s = 20; continue; }
			/* */ if (i$2 < sub.$length && isCharClass(((i$2 < 0 || i$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$2]))) { $s = 21; continue; }
			/* */ $s = 22; continue;
			/* if (i$2 < sub.$length && isCharClass(((i$2 < 0 || i$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$2]))) { */ case 21:
				i$2 = i$2 + (1) >> 0;
				/* continue; */ $s = 19; continue;
			/* } */ case 22:
			/* */ if (i$2 === start) { $s = 23; continue; }
			/* */ if (i$2 === (start + 1 >> 0)) { $s = 24; continue; }
			/* */ $s = 25; continue;
			/* if (i$2 === start) { */ case 23:
				$s = 26; continue;
			/* } else if (i$2 === (start + 1 >> 0)) { */ case 24:
				out = $append(out, ((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]));
				$s = 26; continue;
			/* } else { */ case 25:
				max = start;
				j$2 = start + 1 >> 0;
				while (true) {
					if (!(j$2 < i$2)) { break; }
					if (((max < 0 || max >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + max]).Op < ((j$2 < 0 || j$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$2]).Op || (((max < 0 || max >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + max]).Op === ((j$2 < 0 || j$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$2]).Op) && ((max < 0 || max >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + max]).Rune.$length < ((j$2 < 0 || j$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$2]).Rune.$length) {
						max = j$2;
					}
					j$2 = j$2 + (1) >> 0;
				}
				_tmp = ((max < 0 || max >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + max]);
				_tmp$1 = ((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]);
				((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start] = _tmp);
				((max < 0 || max >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + max] = _tmp$1);
				j$3 = start + 1 >> 0;
				while (true) {
					if (!(j$3 < i$2)) { break; }
					mergeCharClass(((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]), ((j$3 < 0 || j$3 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$3]));
					p.reuse(((j$3 < 0 || j$3 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$3]));
					j$3 = j$3 + (1) >> 0;
				}
				$r = cleanAlt(((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start])); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				out = $append(out, ((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]));
			/* } */ case 26:
			if (i$2 < sub.$length) {
				out = $append(out, ((i$2 < 0 || i$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$2]));
			}
			start = i$2 + 1 >> 0;
			i$2 = i$2 + (1) >> 0;
		/* } */ $s = 19; continue; case 20:
		sub = out;
		start = 0;
		out = $subslice(sub, 0, 0);
		_ref = sub;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i$3 = _i;
			if ((i$3 + 1 >> 0) < sub.$length && (((i$3 < 0 || i$3 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$3]).Op === 2) && ((x$1 = i$3 + 1 >> 0, ((x$1 < 0 || x$1 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + x$1])).Op === 2)) {
				_i++;
				continue;
			}
			out = $append(out, ((i$3 < 0 || i$3 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$3]));
			_i++;
		}
		sub = out;
		$s = -1; return sub;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.factor }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.first = first; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.ifirst = ifirst; $f.iflags = iflags; $f.istr = istr; $f.j = j; $f.j$1 = j$1; $f.j$2 = j$2; $f.j$3 = j$3; $f.max = max; $f.out = out; $f.p = p; $f.prefix = prefix; $f.prefix$1 = prefix$1; $f.re = re; $f.re$1 = re$1; $f.reuse = reuse; $f.same = same; $f.start = start; $f.str = str; $f.strflags = strflags; $f.sub = sub; $f.suffix = suffix; $f.suffix$1 = suffix$1; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.factor = function(sub) { return this.$val.factor(sub); };
	parser.ptr.prototype.leadingString = function(re) {
		var p, re, x;
		p = this;
		if ((re.Op === 18) && re.Sub.$length > 0) {
			re = (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
		}
		if (!((re.Op === 3))) {
			return [sliceType.nil, 0];
		}
		return [re.Rune, (re.Flags & 1) >>> 0];
	};
	parser.prototype.leadingString = function(re) { return this.$val.leadingString(re); };
	parser.ptr.prototype.removeLeadingString = function(re, n) {
		var _1, n, old, p, re, sub, x, x$1, x$2;
		p = this;
		if ((re.Op === 18) && re.Sub.$length > 0) {
			sub = (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
			sub = p.removeLeadingString(sub, n);
			(x$1 = re.Sub, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0] = sub));
			if (sub.Op === 2) {
				p.reuse(sub);
				_1 = re.Sub.$length;
				if ((_1 === (0)) || (_1 === (1))) {
					re.Op = 2;
					re.Sub = sliceType$5.nil;
				} else if (_1 === (2)) {
					old = re;
					re = (x$2 = re.Sub, (1 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 1]));
					p.reuse(old);
				} else {
					$copySlice(re.Sub, $subslice(re.Sub, 1));
					re.Sub = $subslice(re.Sub, 0, (re.Sub.$length - 1 >> 0));
				}
			}
			return re;
		}
		if (re.Op === 3) {
			re.Rune = $subslice(re.Rune, 0, $copySlice(re.Rune, $subslice(re.Rune, n)));
			if (re.Rune.$length === 0) {
				re.Op = 2;
			}
		}
		return re;
	};
	parser.prototype.removeLeadingString = function(re, n) { return this.$val.removeLeadingString(re, n); };
	parser.ptr.prototype.leadingRegexp = function(re) {
		var p, re, sub, x;
		p = this;
		if (re.Op === 2) {
			return ptrType$1.nil;
		}
		if ((re.Op === 18) && re.Sub.$length > 0) {
			sub = (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
			if (sub.Op === 2) {
				return ptrType$1.nil;
			}
			return sub;
		}
		return re;
	};
	parser.prototype.leadingRegexp = function(re) { return this.$val.leadingRegexp(re); };
	parser.ptr.prototype.removeLeadingRegexp = function(re, reuse) {
		var _1, old, p, re, reuse, x, x$1;
		p = this;
		if ((re.Op === 18) && re.Sub.$length > 0) {
			if (reuse) {
				p.reuse((x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])));
			}
			re.Sub = $subslice(re.Sub, 0, $copySlice(re.Sub, $subslice(re.Sub, 1)));
			_1 = re.Sub.$length;
			if (_1 === (0)) {
				re.Op = 2;
				re.Sub = sliceType$5.nil;
			} else if (_1 === (1)) {
				old = re;
				re = (x$1 = re.Sub, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0]));
				p.reuse(old);
			}
			return re;
		}
		if (reuse) {
			p.reuse(re);
		}
		return p.newRegexp(2);
	};
	parser.prototype.removeLeadingRegexp = function(re, reuse) { return this.$val.removeLeadingRegexp(re, reuse); };
	literalRegexp = function(s, flags) {
		var _i, _ref, _rune, c, flags, re, s;
		re = new Regexp.ptr(3, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
		re.Flags = flags;
		re.Rune = $subslice(new sliceType(re.Rune0), 0, 0);
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			c = _rune[0];
			if (re.Rune.$length >= re.Rune.$capacity) {
				re.Rune = (new sliceType($stringToRunes(s)));
				break;
			}
			re.Rune = $append(re.Rune, c);
			_i += _rune[1];
		}
		return re;
	};
	Parse = function(s, flags) {
		var _1, _2, _3, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _struct, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, after, after$1, before, before$1, c, c$1, err, err$1, err$2, err$3, flags, i, lastRepeat, lit, max, min, n, ok, op, p, r, r$1, re, repeat, rest, rest$1, rest$2, s, t, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _struct = $f._struct; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; _tuple$8 = $f._tuple$8; _tuple$9 = $f._tuple$9; after = $f.after; after$1 = $f.after$1; before = $f.before; before$1 = $f.before$1; c = $f.c; c$1 = $f.c$1; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; flags = $f.flags; i = $f.i; lastRepeat = $f.lastRepeat; lit = $f.lit; max = $f.max; min = $f.min; n = $f.n; ok = $f.ok; op = $f.op; p = $f.p; r = $f.r; r$1 = $f.r$1; re = $f.re; repeat = $f.repeat; rest = $f.rest; rest$1 = $f.rest$1; rest$2 = $f.rest$2; s = $f.s; t = $f.t; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (!((((flags & 2) >>> 0) === 0))) {
			err = checkUTF8(s);
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return [ptrType$1.nil, err];
			}
			$s = -1; return [literalRegexp(s, flags), $ifaceNil];
		}
		p = new parser.ptr(0, sliceType$5.nil, ptrType$1.nil, 0, "", sliceType.nil);
		err$1 = $ifaceNil;
		c = 0;
		op = 0;
		lastRepeat = "";
		p.flags = flags;
		p.wholeRegexp = s;
		t = s;
		/* while (true) { */ case 1:
			/* if (!(!(t === ""))) { break; } */ if(!(!(t === ""))) { $s = 2; continue; }
			repeat = "";
				_1 = t.charCodeAt(0);
				/* */ if (_1 === (40)) { $s = 4; continue; }
				/* */ if (_1 === (124)) { $s = 5; continue; }
				/* */ if (_1 === (41)) { $s = 6; continue; }
				/* */ if (_1 === (94)) { $s = 7; continue; }
				/* */ if (_1 === (36)) { $s = 8; continue; }
				/* */ if (_1 === (46)) { $s = 9; continue; }
				/* */ if (_1 === (91)) { $s = 10; continue; }
				/* */ if ((_1 === (42)) || (_1 === (43)) || (_1 === (63))) { $s = 11; continue; }
				/* */ if (_1 === (123)) { $s = 12; continue; }
				/* */ if (_1 === (92)) { $s = 13; continue; }
				/* */ $s = 14; continue;
				/* if (_1 === (40)) { */ case 4:
					if (!((((p.flags & 64) >>> 0) === 0)) && t.length >= 2 && (t.charCodeAt(1) === 63)) {
						_tuple = p.parsePerlFlags(t);
						t = _tuple[0];
						err$1 = _tuple[1];
						if (!($interfaceIsEqual(err$1, $ifaceNil))) {
							$s = -1; return [ptrType$1.nil, err$1];
						}
						/* break; */ $s = 3; continue;
					}
					p.numCap = p.numCap + (1) >> 0;
					p.op(128).Cap = p.numCap;
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (124)) { */ case 5:
					_r = p.parseVerticalBar(); /* */ $s = 16; case 16: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					err$1 = _r;
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (41)) { */ case 6:
					_r$1 = p.parseRightParen(); /* */ $s = 17; case 17: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					err$1 = _r$1;
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (94)) { */ case 7:
					if (!((((p.flags & 16) >>> 0) === 0))) {
						p.op(9);
					} else {
						p.op(7);
					}
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (36)) { */ case 8:
					if (!((((p.flags & 16) >>> 0) === 0))) {
						_struct = p.op(10);
						_struct.Flags = (_struct.Flags | (256)) >>> 0;
					} else {
						p.op(8);
					}
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (46)) { */ case 9:
					if (!((((p.flags & 8) >>> 0) === 0))) {
						p.op(6);
					} else {
						p.op(5);
					}
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (91)) { */ case 10:
					_r$2 = p.parseClass(t); /* */ $s = 18; case 18: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_tuple$1 = _r$2;
					t = _tuple$1[0];
					err$1 = _tuple$1[1];
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					$s = 15; continue;
				/* } else if ((_1 === (42)) || (_1 === (43)) || (_1 === (63))) { */ case 11:
					before = t;
					_2 = t.charCodeAt(0);
					if (_2 === (42)) {
						op = 14;
					} else if (_2 === (43)) {
						op = 15;
					} else if (_2 === (63)) {
						op = 16;
					}
					after = $substring(t, 1);
					_tuple$2 = p.repeat(op, 0, 0, before, after, lastRepeat);
					after = _tuple$2[0];
					err$1 = _tuple$2[1];
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					repeat = before;
					t = after;
					$s = 15; continue;
				/* } else if (_1 === (123)) { */ case 12:
					op = 17;
					before$1 = t;
					_tuple$3 = p.parseRepeat(t);
					min = _tuple$3[0];
					max = _tuple$3[1];
					after$1 = _tuple$3[2];
					ok = _tuple$3[3];
					if (!ok) {
						p.literal(123);
						t = $substring(t, 1);
						/* break; */ $s = 3; continue;
					}
					if (min < 0 || min > 1000 || max > 1000 || max >= 0 && min > max) {
						$s = -1; return [ptrType$1.nil, new Error.ptr("invalid repeat count", $substring(before$1, 0, (before$1.length - after$1.length >> 0)))];
					}
					_tuple$4 = p.repeat(op, min, max, before$1, after$1, lastRepeat);
					after$1 = _tuple$4[0];
					err$1 = _tuple$4[1];
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					repeat = before$1;
					t = after$1;
					$s = 15; continue;
				/* } else if (_1 === (92)) { */ case 13:
					if (!((((p.flags & 64) >>> 0) === 0)) && t.length >= 2) {
						_3 = t.charCodeAt(1);
						if (_3 === (65)) {
							p.op(9);
							t = $substring(t, 2);
							/* break BigSwitch; */ $s = 3; continue s;
						} else if (_3 === (98)) {
							p.op(11);
							t = $substring(t, 2);
							/* break BigSwitch; */ $s = 3; continue s;
						} else if (_3 === (66)) {
							p.op(12);
							t = $substring(t, 2);
							/* break BigSwitch; */ $s = 3; continue s;
						} else if (_3 === (67)) {
							$s = -1; return [ptrType$1.nil, new Error.ptr("invalid escape sequence", $substring(t, 0, 2))];
						} else if (_3 === (81)) {
							lit = "";
							i = strings.Index(t, "\\E");
							if (i < 0) {
								lit = $substring(t, 2);
								t = "";
							} else {
								lit = $substring(t, 2, i);
								t = $substring(t, (i + 2 >> 0));
							}
							while (true) {
								if (!(!(lit === ""))) { break; }
								_tuple$5 = nextRune(lit);
								c$1 = _tuple$5[0];
								rest = _tuple$5[1];
								err$2 = _tuple$5[2];
								if (!($interfaceIsEqual(err$2, $ifaceNil))) {
									$s = -1; return [ptrType$1.nil, err$2];
								}
								p.literal(c$1);
								lit = rest;
							}
							/* break BigSwitch; */ $s = 3; continue s;
						} else if (_3 === (122)) {
							p.op(10);
							t = $substring(t, 2);
							/* break BigSwitch; */ $s = 3; continue s;
						}
					}
					re = p.newRegexp(4);
					re.Flags = p.flags;
					/* */ if (t.length >= 2 && ((t.charCodeAt(1) === 112) || (t.charCodeAt(1) === 80))) { $s = 19; continue; }
					/* */ $s = 20; continue;
					/* if (t.length >= 2 && ((t.charCodeAt(1) === 112) || (t.charCodeAt(1) === 80))) { */ case 19:
						_r$3 = p.parseUnicodeClass(t, $subslice(new sliceType(re.Rune0), 0, 0)); /* */ $s = 21; case 21: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						_tuple$6 = _r$3;
						r = _tuple$6[0];
						rest$1 = _tuple$6[1];
						err$3 = _tuple$6[2];
						if (!($interfaceIsEqual(err$3, $ifaceNil))) {
							$s = -1; return [ptrType$1.nil, err$3];
						}
						if (!(r === sliceType.nil)) {
							re.Rune = r;
							t = rest$1;
							p.push(re);
							/* break BigSwitch; */ $s = 3; continue s;
						}
					/* } */ case 20:
					_r$4 = p.parsePerlClassEscape(t, $subslice(new sliceType(re.Rune0), 0, 0)); /* */ $s = 22; case 22: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					_tuple$7 = _r$4;
					r$1 = _tuple$7[0];
					rest$2 = _tuple$7[1];
					if (!(r$1 === sliceType.nil)) {
						re.Rune = r$1;
						t = rest$2;
						p.push(re);
						/* break BigSwitch; */ $s = 3; continue s;
					}
					p.reuse(re);
					_tuple$8 = p.parseEscape(t);
					c = _tuple$8[0];
					t = _tuple$8[1];
					err$1 = _tuple$8[2];
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					p.literal(c);
					$s = 15; continue;
				/* } else { */ case 14:
					_tuple$9 = nextRune(t);
					c = _tuple$9[0];
					t = _tuple$9[1];
					err$1 = _tuple$9[2];
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					p.literal(c);
				/* } */ case 15:
			case 3:
			lastRepeat = repeat;
		/* } */ $s = 1; continue; case 2:
		_r$5 = p.concat(); /* */ $s = 23; case 23: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_r$5;
		_r$6 = p.swapVerticalBar(); /* */ $s = 26; case 26: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		/* */ if (_r$6) { $s = 24; continue; }
		/* */ $s = 25; continue;
		/* if (_r$6) { */ case 24:
			p.stack = $subslice(p.stack, 0, (p.stack.$length - 1 >> 0));
		/* } */ case 25:
		_r$7 = p.alternate(); /* */ $s = 27; case 27: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_r$7;
		n = p.stack.$length;
		if (!((n === 1))) {
			$s = -1; return [ptrType$1.nil, new Error.ptr("missing closing )", s)];
		}
		$s = -1; return [(x = p.stack, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Parse }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._struct = _struct; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f._tuple$8 = _tuple$8; $f._tuple$9 = _tuple$9; $f.after = after; $f.after$1 = after$1; $f.before = before; $f.before$1 = before$1; $f.c = c; $f.c$1 = c$1; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.flags = flags; $f.i = i; $f.lastRepeat = lastRepeat; $f.lit = lit; $f.max = max; $f.min = min; $f.n = n; $f.ok = ok; $f.op = op; $f.p = p; $f.r = r; $f.r$1 = r$1; $f.re = re; $f.repeat = repeat; $f.rest = rest; $f.rest$1 = rest$1; $f.rest$2 = rest$2; $f.s = s; $f.t = t; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Parse = Parse;
	parser.ptr.prototype.parseRepeat = function(s) {
		var _tuple, _tuple$1, max, min, ok, ok1, p, rest, s;
		min = 0;
		max = 0;
		rest = "";
		ok = false;
		p = this;
		if (s === "" || !((s.charCodeAt(0) === 123))) {
			return [min, max, rest, ok];
		}
		s = $substring(s, 1);
		ok1 = false;
		_tuple = p.parseInt(s);
		min = _tuple[0];
		s = _tuple[1];
		ok1 = _tuple[2];
		if (!ok1) {
			return [min, max, rest, ok];
		}
		if (s === "") {
			return [min, max, rest, ok];
		}
		if (!((s.charCodeAt(0) === 44))) {
			max = min;
		} else {
			s = $substring(s, 1);
			if (s === "") {
				return [min, max, rest, ok];
			}
			if (s.charCodeAt(0) === 125) {
				max = -1;
			} else {
				_tuple$1 = p.parseInt(s);
				max = _tuple$1[0];
				s = _tuple$1[1];
				ok1 = _tuple$1[2];
				if (!ok1) {
					return [min, max, rest, ok];
				} else if (max < 0) {
					min = -1;
				}
			}
		}
		if (s === "" || !((s.charCodeAt(0) === 125))) {
			return [min, max, rest, ok];
		}
		rest = $substring(s, 1);
		ok = true;
		return [min, max, rest, ok];
	};
	parser.prototype.parseRepeat = function(s) { return this.$val.parseRepeat(s); };
	parser.ptr.prototype.parsePerlFlags = function(s) {
		var _1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, c, capture, end, err, flags, name, p, re, rest, s, sawFlag, sign, t;
		rest = "";
		err = $ifaceNil;
		p = this;
		t = s;
		if (t.length > 4 && (t.charCodeAt(2) === 80) && (t.charCodeAt(3) === 60)) {
			end = strings.IndexRune(t, 62);
			if (end < 0) {
				err = checkUTF8(t);
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					_tmp = "";
					_tmp$1 = err;
					rest = _tmp;
					err = _tmp$1;
					return [rest, err];
				}
				_tmp$2 = "";
				_tmp$3 = new Error.ptr("invalid named capture", s);
				rest = _tmp$2;
				err = _tmp$3;
				return [rest, err];
			}
			capture = $substring(t, 0, (end + 1 >> 0));
			name = $substring(t, 4, end);
			err = checkUTF8(name);
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp$4 = "";
				_tmp$5 = err;
				rest = _tmp$4;
				err = _tmp$5;
				return [rest, err];
			}
			if (!isValidCaptureName(name)) {
				_tmp$6 = "";
				_tmp$7 = new Error.ptr("invalid named capture", capture);
				rest = _tmp$6;
				err = _tmp$7;
				return [rest, err];
			}
			p.numCap = p.numCap + (1) >> 0;
			re = p.op(128);
			re.Cap = p.numCap;
			re.Name = name;
			_tmp$8 = $substring(t, (end + 1 >> 0));
			_tmp$9 = $ifaceNil;
			rest = _tmp$8;
			err = _tmp$9;
			return [rest, err];
		}
		c = 0;
		t = $substring(t, 2);
		flags = p.flags;
		sign = 1;
		sawFlag = false;
		Loop:
		while (true) {
			if (!(!(t === ""))) { break; }
			_tuple = nextRune(t);
			c = _tuple[0];
			t = _tuple[1];
			err = _tuple[2];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp$10 = "";
				_tmp$11 = err;
				rest = _tmp$10;
				err = _tmp$11;
				return [rest, err];
			}
			_1 = c;
			if (_1 === (105)) {
				flags = (flags | (1)) >>> 0;
				sawFlag = true;
			} else if (_1 === (109)) {
				flags = (flags & ~(16)) << 16 >>> 16;
				sawFlag = true;
			} else if (_1 === (115)) {
				flags = (flags | (8)) >>> 0;
				sawFlag = true;
			} else if (_1 === (85)) {
				flags = (flags | (32)) >>> 0;
				sawFlag = true;
			} else if (_1 === (45)) {
				if (sign < 0) {
					break Loop;
				}
				sign = -1;
				flags = ~flags << 16 >>> 16;
				sawFlag = false;
			} else if ((_1 === (58)) || (_1 === (41))) {
				if (sign < 0) {
					if (!sawFlag) {
						break Loop;
					}
					flags = ~flags << 16 >>> 16;
				}
				if (c === 58) {
					p.op(128);
				}
				p.flags = flags;
				_tmp$12 = t;
				_tmp$13 = $ifaceNil;
				rest = _tmp$12;
				err = _tmp$13;
				return [rest, err];
			} else {
				break Loop;
			}
		}
		_tmp$14 = "";
		_tmp$15 = new Error.ptr("invalid or unsupported Perl syntax", $substring(s, 0, (s.length - t.length >> 0)));
		rest = _tmp$14;
		err = _tmp$15;
		return [rest, err];
	};
	parser.prototype.parsePerlFlags = function(s) { return this.$val.parsePerlFlags(s); };
	isValidCaptureName = function(name) {
		var _i, _ref, _rune, c, name;
		if (name === "") {
			return false;
		}
		_ref = name;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			c = _rune[0];
			if (!((c === 95)) && !isalnum(c)) {
				return false;
			}
			_i += _rune[1];
		}
		return true;
	};
	parser.ptr.prototype.parseInt = function(s) {
		var i, n, ok, p, rest, s, t;
		n = 0;
		rest = "";
		ok = false;
		p = this;
		if (s === "" || s.charCodeAt(0) < 48 || 57 < s.charCodeAt(0)) {
			return [n, rest, ok];
		}
		if (s.length >= 2 && (s.charCodeAt(0) === 48) && 48 <= s.charCodeAt(1) && s.charCodeAt(1) <= 57) {
			return [n, rest, ok];
		}
		t = s;
		while (true) {
			if (!(!(s === "") && 48 <= s.charCodeAt(0) && s.charCodeAt(0) <= 57)) { break; }
			s = $substring(s, 1);
		}
		rest = s;
		ok = true;
		t = $substring(t, 0, (t.length - s.length >> 0));
		i = 0;
		while (true) {
			if (!(i < t.length)) { break; }
			if (n >= 100000000) {
				n = -1;
				break;
			}
			n = (($imul(n, 10)) + ((t.charCodeAt(i) >> 0)) >> 0) - 48 >> 0;
			i = i + (1) >> 0;
		}
		return [n, rest, ok];
	};
	parser.prototype.parseInt = function(s) { return this.$val.parseInt(s); };
	isCharClass = function(re) {
		var re;
		return (re.Op === 3) && (re.Rune.$length === 1) || (re.Op === 4) || (re.Op === 5) || (re.Op === 6);
	};
	matchRune = function(re, r) {
		var _1, i, r, re, x, x$1, x$2, x$3;
		_1 = re.Op;
		if (_1 === (3)) {
			return (re.Rune.$length === 1) && ((x = re.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) === r);
		} else if (_1 === (4)) {
			i = 0;
			while (true) {
				if (!(i < re.Rune.$length)) { break; }
				if ((x$1 = re.Rune, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])) <= r && r <= (x$2 = re.Rune, x$3 = i + 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]))) {
					return true;
				}
				i = i + (2) >> 0;
			}
			return false;
		} else if (_1 === (5)) {
			return !((r === 10));
		} else if (_1 === (6)) {
			return true;
		}
		return false;
	};
	parser.ptr.prototype.parseVerticalBar = function() {
		var _r, _r$1, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_r = p.concat(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		_r$1 = p.swapVerticalBar(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (!_r$1) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!_r$1) { */ case 2:
			p.op(129);
		/* } */ case 3:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseVerticalBar }; } $f._r = _r; $f._r$1 = _r$1; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseVerticalBar = function() { return this.$val.parseVerticalBar(); };
	mergeCharClass = function(dst, src) {
		var _1, dst, src, x, x$1, x$2, x$3, x$4;
		switch (0) { default:
			_1 = dst.Op;
			if (_1 === (6)) {
			} else if (_1 === (5)) {
				if (matchRune(src, 10)) {
					dst.Op = 6;
				}
			} else if (_1 === (4)) {
				if (src.Op === 3) {
					dst.Rune = appendLiteral(dst.Rune, (x = src.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])), src.Flags);
				} else {
					dst.Rune = appendClass(dst.Rune, src.Rune);
				}
			} else if (_1 === (3)) {
				if (((x$1 = src.Rune, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])) === (x$2 = dst.Rune, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0]))) && (src.Flags === dst.Flags)) {
					break;
				}
				dst.Op = 4;
				dst.Rune = appendLiteral($subslice(dst.Rune, 0, 0), (x$3 = dst.Rune, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])), dst.Flags);
				dst.Rune = appendLiteral(dst.Rune, (x$4 = src.Rune, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0])), src.Flags);
			}
		}
	};
	parser.ptr.prototype.swapVerticalBar = function() {
		var _tmp, _tmp$1, n, p, re1, re1$1, re2, re3, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; n = $f.n; p = $f.p; re1 = $f.re1; re1$1 = $f.re1$1; re2 = $f.re2; re3 = $f.re3; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$15 = $f.x$15; x$16 = $f.x$16; x$17 = $f.x$17; x$18 = $f.x$18; x$19 = $f.x$19; x$2 = $f.x$2; x$20 = $f.x$20; x$21 = $f.x$21; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		n = p.stack.$length;
		if (n >= 3 && ((x = p.stack, x$1 = n - 2 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Op === 129) && isCharClass((x$2 = p.stack, x$3 = n - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]))) && isCharClass((x$4 = p.stack, x$5 = n - 3 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])))) {
			re1 = (x$6 = p.stack, x$7 = n - 1 >> 0, ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7]));
			re3 = (x$8 = p.stack, x$9 = n - 3 >> 0, ((x$9 < 0 || x$9 >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + x$9]));
			if (re1.Op > re3.Op) {
				_tmp = re3;
				_tmp$1 = re1;
				re1 = _tmp;
				re3 = _tmp$1;
				(x$10 = p.stack, x$11 = n - 3 >> 0, ((x$11 < 0 || x$11 >= x$10.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + x$11] = re3));
			}
			mergeCharClass(re3, re1);
			p.reuse(re1);
			p.stack = $subslice(p.stack, 0, (n - 1 >> 0));
			$s = -1; return true;
		}
		/* */ if (n >= 2) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (n >= 2) { */ case 1:
			re1$1 = (x$12 = p.stack, x$13 = n - 1 >> 0, ((x$13 < 0 || x$13 >= x$12.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$12.$array[x$12.$offset + x$13]));
			re2 = (x$14 = p.stack, x$15 = n - 2 >> 0, ((x$15 < 0 || x$15 >= x$14.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$14.$array[x$14.$offset + x$15]));
			/* */ if (re2.Op === 129) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (re2.Op === 129) { */ case 3:
				/* */ if (n >= 3) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (n >= 3) { */ case 5:
					$r = cleanAlt((x$16 = p.stack, x$17 = n - 3 >> 0, ((x$17 < 0 || x$17 >= x$16.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$16.$array[x$16.$offset + x$17]))); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 6:
				(x$18 = p.stack, x$19 = n - 2 >> 0, ((x$19 < 0 || x$19 >= x$18.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$18.$array[x$18.$offset + x$19] = re1$1));
				(x$20 = p.stack, x$21 = n - 1 >> 0, ((x$21 < 0 || x$21 >= x$20.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$20.$array[x$20.$offset + x$21] = re2));
				$s = -1; return true;
			/* } */ case 4:
		/* } */ case 2:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.swapVerticalBar }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.n = n; $f.p = p; $f.re1 = re1; $f.re1$1 = re1$1; $f.re2 = re2; $f.re3 = re3; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$15 = x$15; $f.x$16 = x$16; $f.x$17 = x$17; $f.x$18 = x$18; $f.x$19 = x$19; $f.x$2 = x$2; $f.x$20 = x$20; $f.x$21 = x$21; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.swapVerticalBar = function() { return this.$val.swapVerticalBar(); };
	parser.ptr.prototype.parseRightParen = function() {
		var _r, _r$1, _r$2, n, p, re1, re2, x, x$1, x$2, x$3, x$4, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; n = $f.n; p = $f.p; re1 = $f.re1; re2 = $f.re2; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_r = p.concat(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		_r$1 = p.swapVerticalBar(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (_r$1) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (_r$1) { */ case 2:
			p.stack = $subslice(p.stack, 0, (p.stack.$length - 1 >> 0));
		/* } */ case 3:
		_r$2 = p.alternate(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		n = p.stack.$length;
		if (n < 2) {
			$s = -1; return new Error.ptr("unexpected )", p.wholeRegexp);
		}
		re1 = (x = p.stack, x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		re2 = (x$2 = p.stack, x$3 = n - 2 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]));
		p.stack = $subslice(p.stack, 0, (n - 2 >> 0));
		if (!((re2.Op === 128))) {
			$s = -1; return new Error.ptr("unexpected )", p.wholeRegexp);
		}
		p.flags = re2.Flags;
		if (re2.Cap === 0) {
			p.push(re1);
		} else {
			re2.Op = 13;
			re2.Sub = $subslice(new sliceType$5(re2.Sub0), 0, 1);
			(x$4 = re2.Sub, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0] = re1));
			p.push(re2);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseRightParen }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.n = n; $f.p = p; $f.re1 = re1; $f.re2 = re2; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseRightParen = function() { return this.$val.parseRightParen(); };
	parser.ptr.prototype.parseEscape = function(s) {
		var _1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, _tmp$27, _tmp$28, _tmp$29, _tmp$3, _tmp$30, _tmp$31, _tmp$32, _tmp$33, _tmp$34, _tmp$35, _tmp$36, _tmp$37, _tmp$38, _tmp$39, _tmp$4, _tmp$40, _tmp$41, _tmp$42, _tmp$43, _tmp$44, _tmp$45, _tmp$46, _tmp$47, _tmp$48, _tmp$49, _tmp$5, _tmp$50, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, c, err, i, nhex, p, r, rest, s, t, v, x, y;
		r = 0;
		rest = "";
		err = $ifaceNil;
		p = this;
		t = $substring(s, 1);
		if (t === "") {
			_tmp = 0;
			_tmp$1 = "";
			_tmp$2 = new Error.ptr("trailing backslash at end of expression", "");
			r = _tmp;
			rest = _tmp$1;
			err = _tmp$2;
			return [r, rest, err];
		}
		_tuple = nextRune(t);
		c = _tuple[0];
		t = _tuple[1];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			_tmp$3 = 0;
			_tmp$4 = "";
			_tmp$5 = err;
			r = _tmp$3;
			rest = _tmp$4;
			err = _tmp$5;
			return [r, rest, err];
		}
		Switch:
		switch (0) { default:
			_1 = c;
			if ((_1 === (49)) || (_1 === (50)) || (_1 === (51)) || (_1 === (52)) || (_1 === (53)) || (_1 === (54)) || (_1 === (55))) {
				if (t === "" || t.charCodeAt(0) < 48 || t.charCodeAt(0) > 55) {
					break;
				}
				r = c - 48 >> 0;
				i = 1;
				while (true) {
					if (!(i < 3)) { break; }
					if (t === "" || t.charCodeAt(0) < 48 || t.charCodeAt(0) > 55) {
						break;
					}
					r = (($imul(r, 8)) + ((t.charCodeAt(0) >> 0)) >> 0) - 48 >> 0;
					t = $substring(t, 1);
					i = i + (1) >> 0;
				}
				_tmp$6 = r;
				_tmp$7 = t;
				_tmp$8 = $ifaceNil;
				r = _tmp$6;
				rest = _tmp$7;
				err = _tmp$8;
				return [r, rest, err];
			} else if (_1 === (48)) {
				r = c - 48 >> 0;
				i = 1;
				while (true) {
					if (!(i < 3)) { break; }
					if (t === "" || t.charCodeAt(0) < 48 || t.charCodeAt(0) > 55) {
						break;
					}
					r = (($imul(r, 8)) + ((t.charCodeAt(0) >> 0)) >> 0) - 48 >> 0;
					t = $substring(t, 1);
					i = i + (1) >> 0;
				}
				_tmp$9 = r;
				_tmp$10 = t;
				_tmp$11 = $ifaceNil;
				r = _tmp$9;
				rest = _tmp$10;
				err = _tmp$11;
				return [r, rest, err];
			} else if (_1 === (120)) {
				if (t === "") {
					break;
				}
				_tuple$1 = nextRune(t);
				c = _tuple$1[0];
				t = _tuple$1[1];
				err = _tuple$1[2];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					_tmp$12 = 0;
					_tmp$13 = "";
					_tmp$14 = err;
					r = _tmp$12;
					rest = _tmp$13;
					err = _tmp$14;
					return [r, rest, err];
				}
				if (c === 123) {
					nhex = 0;
					r = 0;
					while (true) {
						if (t === "") {
							break Switch;
						}
						_tuple$2 = nextRune(t);
						c = _tuple$2[0];
						t = _tuple$2[1];
						err = _tuple$2[2];
						if (!($interfaceIsEqual(err, $ifaceNil))) {
							_tmp$15 = 0;
							_tmp$16 = "";
							_tmp$17 = err;
							r = _tmp$15;
							rest = _tmp$16;
							err = _tmp$17;
							return [r, rest, err];
						}
						if (c === 125) {
							break;
						}
						v = unhex(c);
						if (v < 0) {
							break Switch;
						}
						r = ($imul(r, 16)) + v >> 0;
						if (r > 1114111) {
							break Switch;
						}
						nhex = nhex + (1) >> 0;
					}
					if (nhex === 0) {
						break Switch;
					}
					_tmp$18 = r;
					_tmp$19 = t;
					_tmp$20 = $ifaceNil;
					r = _tmp$18;
					rest = _tmp$19;
					err = _tmp$20;
					return [r, rest, err];
				}
				x = unhex(c);
				_tuple$3 = nextRune(t);
				c = _tuple$3[0];
				t = _tuple$3[1];
				err = _tuple$3[2];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					_tmp$21 = 0;
					_tmp$22 = "";
					_tmp$23 = err;
					r = _tmp$21;
					rest = _tmp$22;
					err = _tmp$23;
					return [r, rest, err];
				}
				y = unhex(c);
				if (x < 0 || y < 0) {
					break;
				}
				_tmp$24 = ($imul(x, 16)) + y >> 0;
				_tmp$25 = t;
				_tmp$26 = $ifaceNil;
				r = _tmp$24;
				rest = _tmp$25;
				err = _tmp$26;
				return [r, rest, err];
			} else if (_1 === (97)) {
				_tmp$27 = 7;
				_tmp$28 = t;
				_tmp$29 = err;
				r = _tmp$27;
				rest = _tmp$28;
				err = _tmp$29;
				return [r, rest, err];
			} else if (_1 === (102)) {
				_tmp$30 = 12;
				_tmp$31 = t;
				_tmp$32 = err;
				r = _tmp$30;
				rest = _tmp$31;
				err = _tmp$32;
				return [r, rest, err];
			} else if (_1 === (110)) {
				_tmp$33 = 10;
				_tmp$34 = t;
				_tmp$35 = err;
				r = _tmp$33;
				rest = _tmp$34;
				err = _tmp$35;
				return [r, rest, err];
			} else if (_1 === (114)) {
				_tmp$36 = 13;
				_tmp$37 = t;
				_tmp$38 = err;
				r = _tmp$36;
				rest = _tmp$37;
				err = _tmp$38;
				return [r, rest, err];
			} else if (_1 === (116)) {
				_tmp$39 = 9;
				_tmp$40 = t;
				_tmp$41 = err;
				r = _tmp$39;
				rest = _tmp$40;
				err = _tmp$41;
				return [r, rest, err];
			} else if (_1 === (118)) {
				_tmp$42 = 11;
				_tmp$43 = t;
				_tmp$44 = err;
				r = _tmp$42;
				rest = _tmp$43;
				err = _tmp$44;
				return [r, rest, err];
			} else if (c < 128 && !isalnum(c)) {
				_tmp$45 = c;
				_tmp$46 = t;
				_tmp$47 = $ifaceNil;
				r = _tmp$45;
				rest = _tmp$46;
				err = _tmp$47;
				return [r, rest, err];
			}
		}
		_tmp$48 = 0;
		_tmp$49 = "";
		_tmp$50 = new Error.ptr("invalid escape sequence", $substring(s, 0, (s.length - t.length >> 0)));
		r = _tmp$48;
		rest = _tmp$49;
		err = _tmp$50;
		return [r, rest, err];
	};
	parser.prototype.parseEscape = function(s) { return this.$val.parseEscape(s); };
	parser.ptr.prototype.parseClassChar = function(s, wholeClass) {
		var _tmp, _tmp$1, _tmp$2, _tuple, _tuple$1, err, p, r, rest, s, wholeClass;
		r = 0;
		rest = "";
		err = $ifaceNil;
		p = this;
		if (s === "") {
			_tmp = 0;
			_tmp$1 = "";
			_tmp$2 = new Error.ptr("missing closing ]", wholeClass);
			r = _tmp;
			rest = _tmp$1;
			err = _tmp$2;
			return [r, rest, err];
		}
		if (s.charCodeAt(0) === 92) {
			_tuple = p.parseEscape(s);
			r = _tuple[0];
			rest = _tuple[1];
			err = _tuple[2];
			return [r, rest, err];
		}
		_tuple$1 = nextRune(s);
		r = _tuple$1[0];
		rest = _tuple$1[1];
		err = _tuple$1[2];
		return [r, rest, err];
	};
	parser.prototype.parseClassChar = function(s, wholeClass) { return this.$val.parseClassChar(s, wholeClass); };
	parser.ptr.prototype.parsePerlClassEscape = function(s, r) {
		var _entry, _r, _tmp, _tmp$1, g, out, p, r, rest, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; g = $f.g; out = $f.out; p = $f.p; r = $f.r; rest = $f.rest; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		out = sliceType.nil;
		rest = "";
		p = this;
		if ((((p.flags & 64) >>> 0) === 0) || s.length < 2 || !((s.charCodeAt(0) === 92))) {
			$s = -1; return [out, rest];
		}
		g = $clone((_entry = perlGroup[$String.keyFor($substring(s, 0, 2))], _entry !== undefined ? _entry.v : new charGroup.ptr(0, sliceType.nil)), charGroup);
		if (g.sign === 0) {
			$s = -1; return [out, rest];
		}
		_r = p.appendGroup(r, $clone(g, charGroup)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tmp = _r;
		_tmp$1 = $substring(s, 2);
		out = _tmp;
		rest = _tmp$1;
		$s = -1; return [out, rest];
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parsePerlClassEscape }; } $f._entry = _entry; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.g = g; $f.out = out; $f.p = p; $f.r = r; $f.rest = rest; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parsePerlClassEscape = function(s, r) { return this.$val.parsePerlClassEscape(s, r); };
	parser.ptr.prototype.parseNamedClass = function(s, r) {
		var _entry, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, err, g, i, name, out, p, r, rest, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; err = $f.err; g = $f.g; i = $f.i; name = $f.name; out = $f.out; p = $f.p; r = $f.r; rest = $f.rest; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		out = sliceType.nil;
		rest = "";
		err = $ifaceNil;
		p = this;
		if (s.length < 2 || !((s.charCodeAt(0) === 91)) || !((s.charCodeAt(1) === 58))) {
			$s = -1; return [out, rest, err];
		}
		i = strings.Index($substring(s, 2), ":]");
		if (i < 0) {
			$s = -1; return [out, rest, err];
		}
		i = i + (2) >> 0;
		_tmp = $substring(s, 0, (i + 2 >> 0));
		_tmp$1 = $substring(s, (i + 2 >> 0));
		name = _tmp;
		s = _tmp$1;
		g = $clone((_entry = posixGroup[$String.keyFor(name)], _entry !== undefined ? _entry.v : new charGroup.ptr(0, sliceType.nil)), charGroup);
		if (g.sign === 0) {
			_tmp$2 = sliceType.nil;
			_tmp$3 = "";
			_tmp$4 = new Error.ptr("invalid character class range", name);
			out = _tmp$2;
			rest = _tmp$3;
			err = _tmp$4;
			$s = -1; return [out, rest, err];
		}
		_r = p.appendGroup(r, $clone(g, charGroup)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tmp$5 = _r;
		_tmp$6 = s;
		_tmp$7 = $ifaceNil;
		out = _tmp$5;
		rest = _tmp$6;
		err = _tmp$7;
		$s = -1; return [out, rest, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseNamedClass }; } $f._entry = _entry; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f.err = err; $f.g = g; $f.i = i; $f.name = name; $f.out = out; $f.p = p; $f.r = r; $f.rest = rest; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseNamedClass = function(s, r) { return this.$val.parseNamedClass(s, r); };
	parser.ptr.prototype.appendGroup = function(r, g) {
		var _r, g, p, r, tmp, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; g = $f.g; p = $f.p; r = $f.r; tmp = $f.tmp; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (((p.flags & 1) >>> 0) === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (((p.flags & 1) >>> 0) === 0) { */ case 1:
			if (g.sign < 0) {
				r = appendNegatedClass(r, g.class$1);
			} else {
				r = appendClass(r, g.class$1);
			}
			$s = 3; continue;
		/* } else { */ case 2:
			tmp = $subslice(p.tmpClass, 0, 0);
			tmp = appendFoldedClass(tmp, g.class$1);
			p.tmpClass = tmp;
			_r = cleanClass((p.$ptr_tmpClass || (p.$ptr_tmpClass = new ptrType$2(function() { return this.$target.tmpClass; }, function($v) { this.$target.tmpClass = $v; }, p)))); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			tmp = _r;
			if (g.sign < 0) {
				r = appendNegatedClass(r, tmp);
			} else {
				r = appendClass(r, tmp);
			}
		/* } */ case 3:
		$s = -1; return r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.appendGroup }; } $f._r = _r; $f.g = g; $f.p = p; $f.r = r; $f.tmp = tmp; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.appendGroup = function(r, g) { return this.$val.appendGroup(r, g); };
	unicodeTable = function(name) {
		var _entry, _entry$1, _entry$2, _entry$3, name, t, t$1;
		if (name === "Any") {
			return [anyTable, anyTable];
		}
		t = (_entry = unicode.Categories[$String.keyFor(name)], _entry !== undefined ? _entry.v : ptrType$3.nil);
		if (!(t === ptrType$3.nil)) {
			return [t, (_entry$1 = unicode.FoldCategory[$String.keyFor(name)], _entry$1 !== undefined ? _entry$1.v : ptrType$3.nil)];
		}
		t$1 = (_entry$2 = unicode.Scripts[$String.keyFor(name)], _entry$2 !== undefined ? _entry$2.v : ptrType$3.nil);
		if (!(t$1 === ptrType$3.nil)) {
			return [t$1, (_entry$3 = unicode.FoldScript[$String.keyFor(name)], _entry$3 !== undefined ? _entry$3.v : ptrType$3.nil)];
		}
		return [ptrType$3.nil, ptrType$3.nil];
	};
	parser.ptr.prototype.parseUnicodeClass = function(s, r) {
		var _r, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, c, end, err, fold, name, out, p, r, rest, s, seq, sign, t, tab, tmp, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; c = $f.c; end = $f.end; err = $f.err; fold = $f.fold; name = $f.name; out = $f.out; p = $f.p; r = $f.r; rest = $f.rest; s = $f.s; seq = $f.seq; sign = $f.sign; t = $f.t; tab = $f.tab; tmp = $f.tmp; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		out = sliceType.nil;
		rest = "";
		err = $ifaceNil;
		p = this;
		if ((((p.flags & 128) >>> 0) === 0) || s.length < 2 || !((s.charCodeAt(0) === 92)) || !((s.charCodeAt(1) === 112)) && !((s.charCodeAt(1) === 80))) {
			$s = -1; return [out, rest, err];
		}
		sign = 1;
		if (s.charCodeAt(1) === 80) {
			sign = -1;
		}
		t = $substring(s, 2);
		_tuple = nextRune(t);
		c = _tuple[0];
		t = _tuple[1];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [out, rest, err];
		}
		_tmp = "";
		_tmp$1 = "";
		seq = _tmp;
		name = _tmp$1;
		if (!((c === 123))) {
			seq = $substring(s, 0, (s.length - t.length >> 0));
			name = $substring(seq, 2);
		} else {
			end = strings.IndexRune(s, 125);
			if (end < 0) {
				err = checkUTF8(s);
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					$s = -1; return [out, rest, err];
				}
				_tmp$2 = sliceType.nil;
				_tmp$3 = "";
				_tmp$4 = new Error.ptr("invalid character class range", s);
				out = _tmp$2;
				rest = _tmp$3;
				err = _tmp$4;
				$s = -1; return [out, rest, err];
			}
			_tmp$5 = $substring(s, 0, (end + 1 >> 0));
			_tmp$6 = $substring(s, (end + 1 >> 0));
			seq = _tmp$5;
			t = _tmp$6;
			name = $substring(s, 3, end);
			err = checkUTF8(name);
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return [out, rest, err];
			}
		}
		if (!(name === "") && (name.charCodeAt(0) === 94)) {
			sign = -sign;
			name = $substring(name, 1);
		}
		_tuple$1 = unicodeTable(name);
		tab = _tuple$1[0];
		fold = _tuple$1[1];
		if (tab === ptrType$3.nil) {
			_tmp$7 = sliceType.nil;
			_tmp$8 = "";
			_tmp$9 = new Error.ptr("invalid character class range", seq);
			out = _tmp$7;
			rest = _tmp$8;
			err = _tmp$9;
			$s = -1; return [out, rest, err];
		}
		/* */ if ((((p.flags & 1) >>> 0) === 0) || fold === ptrType$3.nil) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((((p.flags & 1) >>> 0) === 0) || fold === ptrType$3.nil) { */ case 1:
			if (sign > 0) {
				r = appendTable(r, tab);
			} else {
				r = appendNegatedTable(r, tab);
			}
			$s = 3; continue;
		/* } else { */ case 2:
			tmp = $subslice(p.tmpClass, 0, 0);
			tmp = appendTable(tmp, tab);
			tmp = appendTable(tmp, fold);
			p.tmpClass = tmp;
			_r = cleanClass((p.$ptr_tmpClass || (p.$ptr_tmpClass = new ptrType$2(function() { return this.$target.tmpClass; }, function($v) { this.$target.tmpClass = $v; }, p)))); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			tmp = _r;
			if (sign > 0) {
				r = appendClass(r, tmp);
			} else {
				r = appendNegatedClass(r, tmp);
			}
		/* } */ case 3:
		_tmp$10 = r;
		_tmp$11 = t;
		_tmp$12 = $ifaceNil;
		out = _tmp$10;
		rest = _tmp$11;
		err = _tmp$12;
		$s = -1; return [out, rest, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseUnicodeClass }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.c = c; $f.end = end; $f.err = err; $f.fold = fold; $f.name = name; $f.out = out; $f.p = p; $f.r = r; $f.rest = rest; $f.s = s; $f.seq = seq; $f.sign = sign; $f.t = t; $f.tab = tab; $f.tmp = tmp; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseUnicodeClass = function(s, r) { return this.$val.parseUnicodeClass(s, r); };
	parser.ptr.prototype.parseClass = function(s) {
		var _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, class$1, err, err$1, err$2, first, hi, lo, nclass, nclass$1, nclass$2, nt, nt$1, nt$2, p, re, rest, rng, s, sign, size, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$17 = $f._tmp$17; _tmp$18 = $f._tmp$18; _tmp$19 = $f._tmp$19; _tmp$2 = $f._tmp$2; _tmp$20 = $f._tmp$20; _tmp$21 = $f._tmp$21; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; class$1 = $f.class$1; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; first = $f.first; hi = $f.hi; lo = $f.lo; nclass = $f.nclass; nclass$1 = $f.nclass$1; nclass$2 = $f.nclass$2; nt = $f.nt; nt$1 = $f.nt$1; nt$2 = $f.nt$2; p = $f.p; re = $f.re; rest = $f.rest; rng = $f.rng; s = $f.s; sign = $f.sign; size = $f.size; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		rest = "";
		err = $ifaceNil;
		p = this;
		t = $substring(s, 1);
		re = p.newRegexp(4);
		re.Flags = p.flags;
		re.Rune = $subslice(new sliceType(re.Rune0), 0, 0);
		sign = 1;
		if (!(t === "") && (t.charCodeAt(0) === 94)) {
			sign = -1;
			t = $substring(t, 1);
			if (((p.flags & 4) >>> 0) === 0) {
				re.Rune = $append(re.Rune, 10, 10);
			}
		}
		class$1 = re.Rune;
		first = true;
		/* while (true) { */ case 1:
			/* if (!(t === "" || !((t.charCodeAt(0) === 93)) || first)) { break; } */ if(!(t === "" || !((t.charCodeAt(0) === 93)) || first)) { $s = 2; continue; }
			if (!(t === "") && (t.charCodeAt(0) === 45) && (((p.flags & 64) >>> 0) === 0) && !first && ((t.length === 1) || !((t.charCodeAt(1) === 93)))) {
				_tuple = utf8.DecodeRuneInString($substring(t, 1));
				size = _tuple[1];
				_tmp = "";
				_tmp$1 = new Error.ptr("invalid character class range", $substring(t, 0, (1 + size >> 0)));
				rest = _tmp;
				err = _tmp$1;
				$s = -1; return [rest, err];
			}
			first = false;
			/* */ if (t.length > 2 && (t.charCodeAt(0) === 91) && (t.charCodeAt(1) === 58)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (t.length > 2 && (t.charCodeAt(0) === 91) && (t.charCodeAt(1) === 58)) { */ case 3:
				_r = p.parseNamedClass(t, class$1); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple$1 = _r;
				nclass = _tuple$1[0];
				nt = _tuple$1[1];
				err$1 = _tuple$1[2];
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					_tmp$2 = "";
					_tmp$3 = err$1;
					rest = _tmp$2;
					err = _tmp$3;
					$s = -1; return [rest, err];
				}
				if (!(nclass === sliceType.nil)) {
					_tmp$4 = nclass;
					_tmp$5 = nt;
					class$1 = _tmp$4;
					t = _tmp$5;
					/* continue; */ $s = 1; continue;
				}
			/* } */ case 4:
			_r$1 = p.parseUnicodeClass(t, class$1); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$2 = _r$1;
			nclass$1 = _tuple$2[0];
			nt$1 = _tuple$2[1];
			err$2 = _tuple$2[2];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				_tmp$6 = "";
				_tmp$7 = err$2;
				rest = _tmp$6;
				err = _tmp$7;
				$s = -1; return [rest, err];
			}
			/* */ if (!(nclass$1 === sliceType.nil)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!(nclass$1 === sliceType.nil)) { */ case 7:
				_tmp$8 = nclass$1;
				_tmp$9 = nt$1;
				class$1 = _tmp$8;
				t = _tmp$9;
				/* continue; */ $s = 1; continue;
			/* } */ case 8:
			_r$2 = p.parsePerlClassEscape(t, class$1); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_tuple$3 = _r$2;
			nclass$2 = _tuple$3[0];
			nt$2 = _tuple$3[1];
			if (!(nclass$2 === sliceType.nil)) {
				_tmp$10 = nclass$2;
				_tmp$11 = nt$2;
				class$1 = _tmp$10;
				t = _tmp$11;
				/* continue; */ $s = 1; continue;
			}
			rng = t;
			_tmp$12 = 0;
			_tmp$13 = 0;
			lo = _tmp$12;
			hi = _tmp$13;
			_tuple$4 = p.parseClassChar(t, s);
			lo = _tuple$4[0];
			t = _tuple$4[1];
			err$2 = _tuple$4[2];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				_tmp$14 = "";
				_tmp$15 = err$2;
				rest = _tmp$14;
				err = _tmp$15;
				$s = -1; return [rest, err];
			}
			hi = lo;
			if (t.length >= 2 && (t.charCodeAt(0) === 45) && !((t.charCodeAt(1) === 93))) {
				t = $substring(t, 1);
				_tuple$5 = p.parseClassChar(t, s);
				hi = _tuple$5[0];
				t = _tuple$5[1];
				err$2 = _tuple$5[2];
				if (!($interfaceIsEqual(err$2, $ifaceNil))) {
					_tmp$16 = "";
					_tmp$17 = err$2;
					rest = _tmp$16;
					err = _tmp$17;
					$s = -1; return [rest, err];
				}
				if (hi < lo) {
					rng = $substring(rng, 0, (rng.length - t.length >> 0));
					_tmp$18 = "";
					_tmp$19 = new Error.ptr("invalid character class range", rng);
					rest = _tmp$18;
					err = _tmp$19;
					$s = -1; return [rest, err];
				}
			}
			if (((p.flags & 1) >>> 0) === 0) {
				class$1 = appendRange(class$1, lo, hi);
			} else {
				class$1 = appendFoldedRange(class$1, lo, hi);
			}
		/* } */ $s = 1; continue; case 2:
		t = $substring(t, 1);
		re.Rune = class$1;
		_r$3 = cleanClass((re.$ptr_Rune || (re.$ptr_Rune = new ptrType$2(function() { return this.$target.Rune; }, function($v) { this.$target.Rune = $v; }, re)))); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		class$1 = _r$3;
		if (sign < 0) {
			class$1 = negateClass(class$1);
		}
		re.Rune = class$1;
		p.push(re);
		_tmp$20 = t;
		_tmp$21 = $ifaceNil;
		rest = _tmp$20;
		err = _tmp$21;
		$s = -1; return [rest, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseClass }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$17 = _tmp$17; $f._tmp$18 = _tmp$18; $f._tmp$19 = _tmp$19; $f._tmp$2 = _tmp$2; $f._tmp$20 = _tmp$20; $f._tmp$21 = _tmp$21; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.class$1 = class$1; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.first = first; $f.hi = hi; $f.lo = lo; $f.nclass = nclass; $f.nclass$1 = nclass$1; $f.nclass$2 = nclass$2; $f.nt = nt; $f.nt$1 = nt$1; $f.nt$2 = nt$2; $f.p = p; $f.re = re; $f.rest = rest; $f.rng = rng; $f.s = s; $f.sign = sign; $f.size = size; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseClass = function(s) { return this.$val.parseClass(s); };
	cleanClass = function(rp) {
		var _tmp, _tmp$1, hi, i, lo, r, rp, w, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; hi = $f.hi; i = $f.i; lo = $f.lo; r = $f.r; rp = $f.rp; w = $f.w; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = sort.Sort((x = new ranges.ptr(rp), new x.constructor.elem(x))); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		r = rp.$get();
		if (r.$length < 2) {
			$s = -1; return r;
		}
		w = 2;
		i = 2;
		while (true) {
			if (!(i < r.$length)) { break; }
			_tmp = ((i < 0 || i >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + i]);
			_tmp$1 = (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$1]));
			lo = _tmp;
			hi = _tmp$1;
			if (lo <= ((x$2 = w - 1 >> 0, ((x$2 < 0 || x$2 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$2])) + 1 >> 0)) {
				if (hi > (x$3 = w - 1 >> 0, ((x$3 < 0 || x$3 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$3]))) {
					(x$4 = w - 1 >> 0, ((x$4 < 0 || x$4 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$4] = hi));
				}
				i = i + (2) >> 0;
				continue;
			}
			((w < 0 || w >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + w] = lo);
			(x$5 = w + 1 >> 0, ((x$5 < 0 || x$5 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$5] = hi));
			w = w + (2) >> 0;
			i = i + (2) >> 0;
		}
		$s = -1; return $subslice(r, 0, w);
		/* */ } return; } if ($f === undefined) { $f = { $blk: cleanClass }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.hi = hi; $f.i = i; $f.lo = lo; $f.r = r; $f.rp = rp; $f.w = w; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	appendLiteral = function(r, x, flags) {
		var flags, r, x;
		if (!((((flags & 1) >>> 0) === 0))) {
			return appendFoldedRange(r, x, x);
		}
		return appendRange(r, x, x);
	};
	appendRange = function(r, lo, hi) {
		var _tmp, _tmp$1, hi, i, lo, n, r, rhi, rlo, x, x$1, x$2, x$3;
		n = r.$length;
		i = 2;
		while (true) {
			if (!(i <= 4)) { break; }
			if (n >= i) {
				_tmp = (x = n - i >> 0, ((x < 0 || x >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x]));
				_tmp$1 = (x$1 = (n - i >> 0) + 1 >> 0, ((x$1 < 0 || x$1 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$1]));
				rlo = _tmp;
				rhi = _tmp$1;
				if (lo <= (rhi + 1 >> 0) && rlo <= (hi + 1 >> 0)) {
					if (lo < rlo) {
						(x$2 = n - i >> 0, ((x$2 < 0 || x$2 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$2] = lo));
					}
					if (hi > rhi) {
						(x$3 = (n - i >> 0) + 1 >> 0, ((x$3 < 0 || x$3 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$3] = hi));
					}
					return r;
				}
			}
			i = i + (2) >> 0;
		}
		return $append(r, lo, hi);
	};
	appendFoldedRange = function(r, lo, hi) {
		var c, f, hi, lo, r;
		if (lo <= 65 && hi >= 125251) {
			return appendRange(r, lo, hi);
		}
		if (hi < 65 || lo > 125251) {
			return appendRange(r, lo, hi);
		}
		if (lo < 65) {
			r = appendRange(r, lo, 64);
			lo = 65;
		}
		if (hi > 125251) {
			r = appendRange(r, 125252, hi);
			hi = 125251;
		}
		c = lo;
		while (true) {
			if (!(c <= hi)) { break; }
			r = appendRange(r, c, c);
			f = unicode.SimpleFold(c);
			while (true) {
				if (!(!((f === c)))) { break; }
				r = appendRange(r, f, f);
				f = unicode.SimpleFold(f);
			}
			c = c + (1) >> 0;
		}
		return r;
	};
	appendClass = function(r, x) {
		var i, r, x, x$1;
		i = 0;
		while (true) {
			if (!(i < x.$length)) { break; }
			r = appendRange(r, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])));
			i = i + (2) >> 0;
		}
		return r;
	};
	appendFoldedClass = function(r, x) {
		var i, r, x, x$1;
		i = 0;
		while (true) {
			if (!(i < x.$length)) { break; }
			r = appendFoldedRange(r, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])));
			i = i + (2) >> 0;
		}
		return r;
	};
	appendNegatedClass = function(r, x) {
		var _tmp, _tmp$1, hi, i, lo, nextLo, r, x, x$1;
		nextLo = 0;
		i = 0;
		while (true) {
			if (!(i < x.$length)) { break; }
			_tmp = ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]);
			_tmp$1 = (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			lo = _tmp;
			hi = _tmp$1;
			if (nextLo <= (lo - 1 >> 0)) {
				r = appendRange(r, nextLo, lo - 1 >> 0);
			}
			nextLo = hi + 1 >> 0;
			i = i + (2) >> 0;
		}
		if (nextLo <= 1114111) {
			r = appendRange(r, nextLo, 1114111);
		}
		return r;
	};
	appendTable = function(r, x) {
		var _i, _i$1, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, c, c$1, hi, hi$1, lo, lo$1, r, stride, stride$1, x, xr, xr$1;
		_ref = x.R16;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			xr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), unicode.Range16);
			_tmp = ((xr.Lo >> 0));
			_tmp$1 = ((xr.Hi >> 0));
			_tmp$2 = ((xr.Stride >> 0));
			lo = _tmp;
			hi = _tmp$1;
			stride = _tmp$2;
			if (stride === 1) {
				r = appendRange(r, lo, hi);
				_i++;
				continue;
			}
			c = lo;
			while (true) {
				if (!(c <= hi)) { break; }
				r = appendRange(r, c, c);
				c = c + (stride) >> 0;
			}
			_i++;
		}
		_ref$1 = x.R32;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			xr$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), unicode.Range32);
			_tmp$3 = ((xr$1.Lo >> 0));
			_tmp$4 = ((xr$1.Hi >> 0));
			_tmp$5 = ((xr$1.Stride >> 0));
			lo$1 = _tmp$3;
			hi$1 = _tmp$4;
			stride$1 = _tmp$5;
			if (stride$1 === 1) {
				r = appendRange(r, lo$1, hi$1);
				_i$1++;
				continue;
			}
			c$1 = lo$1;
			while (true) {
				if (!(c$1 <= hi$1)) { break; }
				r = appendRange(r, c$1, c$1);
				c$1 = c$1 + (stride$1) >> 0;
			}
			_i$1++;
		}
		return r;
	};
	appendNegatedTable = function(r, x) {
		var _i, _i$1, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, c, c$1, hi, hi$1, lo, lo$1, nextLo, r, stride, stride$1, x, xr, xr$1;
		nextLo = 0;
		_ref = x.R16;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			xr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), unicode.Range16);
			_tmp = ((xr.Lo >> 0));
			_tmp$1 = ((xr.Hi >> 0));
			_tmp$2 = ((xr.Stride >> 0));
			lo = _tmp;
			hi = _tmp$1;
			stride = _tmp$2;
			if (stride === 1) {
				if (nextLo <= (lo - 1 >> 0)) {
					r = appendRange(r, nextLo, lo - 1 >> 0);
				}
				nextLo = hi + 1 >> 0;
				_i++;
				continue;
			}
			c = lo;
			while (true) {
				if (!(c <= hi)) { break; }
				if (nextLo <= (c - 1 >> 0)) {
					r = appendRange(r, nextLo, c - 1 >> 0);
				}
				nextLo = c + 1 >> 0;
				c = c + (stride) >> 0;
			}
			_i++;
		}
		_ref$1 = x.R32;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			xr$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), unicode.Range32);
			_tmp$3 = ((xr$1.Lo >> 0));
			_tmp$4 = ((xr$1.Hi >> 0));
			_tmp$5 = ((xr$1.Stride >> 0));
			lo$1 = _tmp$3;
			hi$1 = _tmp$4;
			stride$1 = _tmp$5;
			if (stride$1 === 1) {
				if (nextLo <= (lo$1 - 1 >> 0)) {
					r = appendRange(r, nextLo, lo$1 - 1 >> 0);
				}
				nextLo = hi$1 + 1 >> 0;
				_i$1++;
				continue;
			}
			c$1 = lo$1;
			while (true) {
				if (!(c$1 <= hi$1)) { break; }
				if (nextLo <= (c$1 - 1 >> 0)) {
					r = appendRange(r, nextLo, c$1 - 1 >> 0);
				}
				nextLo = c$1 + 1 >> 0;
				c$1 = c$1 + (stride$1) >> 0;
			}
			_i$1++;
		}
		if (nextLo <= 1114111) {
			r = appendRange(r, nextLo, 1114111);
		}
		return r;
	};
	negateClass = function(r) {
		var _tmp, _tmp$1, hi, i, lo, nextLo, r, w, x, x$1;
		nextLo = 0;
		w = 0;
		i = 0;
		while (true) {
			if (!(i < r.$length)) { break; }
			_tmp = ((i < 0 || i >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + i]);
			_tmp$1 = (x = i + 1 >> 0, ((x < 0 || x >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x]));
			lo = _tmp;
			hi = _tmp$1;
			if (nextLo <= (lo - 1 >> 0)) {
				((w < 0 || w >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + w] = nextLo);
				(x$1 = w + 1 >> 0, ((x$1 < 0 || x$1 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$1] = (lo - 1 >> 0)));
				w = w + (2) >> 0;
			}
			nextLo = hi + 1 >> 0;
			i = i + (2) >> 0;
		}
		r = $subslice(r, 0, w);
		if (nextLo <= 1114111) {
			r = $append(r, nextLo, 1114111);
		}
		return r;
	};
	ranges.ptr.prototype.Less = function(i, j) {
		var i, j, p, ra, x, x$1;
		ra = this;
		p = ra.p.$get();
		i = $imul(i, (2));
		j = $imul(j, (2));
		return ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]) < ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j]) || (((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]) === ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j])) && (x = i + 1 >> 0, ((x < 0 || x >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x])) > (x$1 = j + 1 >> 0, ((x$1 < 0 || x$1 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$1]));
	};
	ranges.prototype.Less = function(i, j) { return this.$val.Less(i, j); };
	ranges.ptr.prototype.Len = function() {
		var _q, ra;
		ra = this;
		return (_q = ra.p.$get().$length / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
	};
	ranges.prototype.Len = function() { return this.$val.Len(); };
	ranges.ptr.prototype.Swap = function(i, j) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, i, j, p, ra, x, x$1, x$2, x$3;
		ra = this;
		p = ra.p.$get();
		i = $imul(i, (2));
		j = $imul(j, (2));
		_tmp = ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j]);
		_tmp$1 = (x = j + 1 >> 0, ((x < 0 || x >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x]));
		_tmp$2 = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]);
		_tmp$3 = (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$1]));
		((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i] = _tmp);
		(x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$2] = _tmp$1));
		((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j] = _tmp$2);
		(x$3 = j + 1 >> 0, ((x$3 < 0 || x$3 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$3] = _tmp$3));
	};
	ranges.prototype.Swap = function(i, j) { return this.$val.Swap(i, j); };
	checkUTF8 = function(s) {
		var _tuple, rune, s, size;
		while (true) {
			if (!(!(s === ""))) { break; }
			_tuple = utf8.DecodeRuneInString(s);
			rune = _tuple[0];
			size = _tuple[1];
			if ((rune === 65533) && (size === 1)) {
				return new Error.ptr("invalid UTF-8", s);
			}
			s = $substring(s, size);
		}
		return $ifaceNil;
	};
	nextRune = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, c, err, s, size, t;
		c = 0;
		t = "";
		err = $ifaceNil;
		_tuple = utf8.DecodeRuneInString(s);
		c = _tuple[0];
		size = _tuple[1];
		if ((c === 65533) && (size === 1)) {
			_tmp = 0;
			_tmp$1 = "";
			_tmp$2 = new Error.ptr("invalid UTF-8", s);
			c = _tmp;
			t = _tmp$1;
			err = _tmp$2;
			return [c, t, err];
		}
		_tmp$3 = c;
		_tmp$4 = $substring(s, size);
		_tmp$5 = $ifaceNil;
		c = _tmp$3;
		t = _tmp$4;
		err = _tmp$5;
		return [c, t, err];
	};
	isalnum = function(c) {
		var c;
		return 48 <= c && c <= 57 || 65 <= c && c <= 90 || 97 <= c && c <= 122;
	};
	unhex = function(c) {
		var c;
		if (48 <= c && c <= 57) {
			return c - 48 >> 0;
		}
		if (97 <= c && c <= 102) {
			return (c - 97 >> 0) + 10 >> 0;
		}
		if (65 <= c && c <= 70) {
			return (c - 65 >> 0) + 10 >> 0;
		}
		return -1;
	};
	InstOp.prototype.String = function() {
		var i;
		i = this.$val;
		if (((i >>> 0)) >= ((instOpNames.$length >>> 0))) {
			return "";
		}
		return ((i < 0 || i >= instOpNames.$length) ? ($throwRuntimeError("index out of range"), undefined) : instOpNames.$array[instOpNames.$offset + i]);
	};
	$ptrType(InstOp).prototype.String = function() { return new InstOp(this.$get()).String(); };
	EmptyOpContext = function(r1, r2) {
		var boundary, op, r1, r2;
		op = 32;
		boundary = 0;
		if (IsWordChar(r1)) {
			boundary = 1;
		} else if ((r1 === 10)) {
			op = (op | (1)) >>> 0;
		} else if (r1 < 0) {
			op = (op | (5)) >>> 0;
		}
		if (IsWordChar(r2)) {
			boundary = (boundary ^ (1)) << 24 >>> 24;
		} else if ((r2 === 10)) {
			op = (op | (2)) >>> 0;
		} else if (r2 < 0) {
			op = (op | (10)) >>> 0;
		}
		if (!((boundary === 0))) {
			op = (op ^ (48)) << 24 >>> 24;
		}
		return op;
	};
	$pkg.EmptyOpContext = EmptyOpContext;
	IsWordChar = function(r) {
		var r;
		return 65 <= r && r <= 90 || 97 <= r && r <= 122 || 48 <= r && r <= 57 || (r === 95);
	};
	$pkg.IsWordChar = IsWordChar;
	Prog.ptr.prototype.String = function() {
		var b, p;
		p = this;
		b = new bytes.Buffer.ptr(sliceType$6.nil, 0, 0, arrayType$2.zero());
		dumpProg(b, p);
		return b.String();
	};
	Prog.prototype.String = function() { return this.$val.String(); };
	Prog.ptr.prototype.skipNop = function(pc) {
		var i, p, pc, x, x$1;
		p = this;
		i = (x = p.Inst, ((pc < 0 || pc >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pc]));
		while (true) {
			if (!((i.Op === 6) || (i.Op === 2))) { break; }
			pc = i.Out;
			i = (x$1 = p.Inst, ((pc < 0 || pc >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + pc]));
		}
		return [i, pc];
	};
	Prog.prototype.skipNop = function(pc) { return this.$val.skipNop(pc); };
	Inst.ptr.prototype.op = function() {
		var _1, i, op;
		i = this;
		op = i.Op;
		_1 = op;
		if ((_1 === (8)) || (_1 === (9)) || (_1 === (10))) {
			op = 7;
		}
		return op;
	};
	Inst.prototype.op = function() { return this.$val.op(); };
	Prog.ptr.prototype.Prefix = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _tuple$1, buf, complete, i, p, prefix, x;
		prefix = "";
		complete = false;
		p = this;
		_tuple = p.skipNop(((p.Start >>> 0)));
		i = _tuple[0];
		if (!((i.op() === 7)) || !((i.Rune.$length === 1))) {
			_tmp = "";
			_tmp$1 = i.Op === 4;
			prefix = _tmp;
			complete = _tmp$1;
			return [prefix, complete];
		}
		buf = new bytes.Buffer.ptr(sliceType$6.nil, 0, 0, arrayType$2.zero());
		while (true) {
			if (!((i.op() === 7) && (i.Rune.$length === 1) && (((((i.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { break; }
			buf.WriteRune((x = i.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])));
			_tuple$1 = p.skipNop(i.Out);
			i = _tuple$1[0];
		}
		_tmp$2 = buf.String();
		_tmp$3 = i.Op === 4;
		prefix = _tmp$2;
		complete = _tmp$3;
		return [prefix, complete];
	};
	Prog.prototype.Prefix = function() { return this.$val.Prefix(); };
	Prog.ptr.prototype.StartCond = function() {
		var _1, flag, i, p, pc, x, x$1;
		p = this;
		flag = 0;
		pc = ((p.Start >>> 0));
		i = (x = p.Inst, ((pc < 0 || pc >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pc]));
		Loop:
		while (true) {
			_1 = i.Op;
			if (_1 === (3)) {
				flag = (flag | (((i.Arg << 24 >>> 24)))) >>> 0;
			} else if (_1 === (5)) {
				return 255;
			} else if ((_1 === (2)) || (_1 === (6))) {
			} else {
				break Loop;
			}
			pc = i.Out;
			i = (x$1 = p.Inst, ((pc < 0 || pc >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + pc]));
		}
		return flag;
	};
	Prog.prototype.StartCond = function() { return this.$val.StartCond(); };
	Inst.ptr.prototype.MatchRune = function(r) {
		var i, r;
		i = this;
		return !((i.MatchRunePos(r) === -1));
	};
	Inst.prototype.MatchRune = function(r) { return this.$val.MatchRune(r); };
	Inst.ptr.prototype.MatchRunePos = function(r) {
		var _q, _q$1, _q$2, c, hi, i, j, lo, m, r, r0, r1, rune, x, x$1, x$2;
		i = this;
		rune = i.Rune;
		if (rune.$length === 1) {
			r0 = (0 >= rune.$length ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + 0]);
			if (r === r0) {
				return 0;
			}
			if (!((((((i.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) {
				r1 = unicode.SimpleFold(r0);
				while (true) {
					if (!(!((r1 === r0)))) { break; }
					if (r === r1) {
						return 0;
					}
					r1 = unicode.SimpleFold(r1);
				}
			}
			return -1;
		}
		j = 0;
		while (true) {
			if (!(j < rune.$length && j <= 8)) { break; }
			if (r < ((j < 0 || j >= rune.$length) ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + j])) {
				return -1;
			}
			if (r <= (x = j + 1 >> 0, ((x < 0 || x >= rune.$length) ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + x]))) {
				return (_q = j / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
			}
			j = j + (2) >> 0;
		}
		lo = 0;
		hi = (_q$1 = rune.$length / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"));
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q$2 = ((hi - lo >> 0)) / 2, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			c = (x$1 = $imul(2, m), ((x$1 < 0 || x$1 >= rune.$length) ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + x$1]));
			if (c <= r) {
				if (r <= (x$2 = ($imul(2, m)) + 1 >> 0, ((x$2 < 0 || x$2 >= rune.$length) ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + x$2]))) {
					return m;
				}
				lo = m + 1 >> 0;
			} else {
				hi = m;
			}
		}
		return -1;
	};
	Inst.prototype.MatchRunePos = function(r) { return this.$val.MatchRunePos(r); };
	wordRune = function(r) {
		var r;
		return (r === 95) || (65 <= r && r <= 90) || (97 <= r && r <= 122) || (48 <= r && r <= 57);
	};
	Inst.ptr.prototype.MatchEmptyWidth = function(before, after) {
		var _1, after, before, i;
		i = this;
		_1 = ((i.Arg << 24 >>> 24));
		if (_1 === (1)) {
			return (before === 10) || (before === -1);
		} else if (_1 === (2)) {
			return (after === 10) || (after === -1);
		} else if (_1 === (4)) {
			return before === -1;
		} else if (_1 === (8)) {
			return after === -1;
		} else if (_1 === (16)) {
			return !(wordRune(before) === wordRune(after));
		} else if (_1 === (32)) {
			return wordRune(before) === wordRune(after);
		}
		$panic(new $String("unknown empty width arg"));
	};
	Inst.prototype.MatchEmptyWidth = function(before, after) { return this.$val.MatchEmptyWidth(before, after); };
	Inst.ptr.prototype.String = function() {
		var b, i;
		i = this;
		b = new bytes.Buffer.ptr(sliceType$6.nil, 0, 0, arrayType$2.zero());
		dumpInst(b, i);
		return b.String();
	};
	Inst.prototype.String = function() { return this.$val.String(); };
	bw = function(b, args) {
		var _i, _ref, args, b, s;
		_ref = args;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			s = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			b.WriteString(s);
			_i++;
		}
	};
	dumpProg = function(b, p) {
		var _i, _ref, b, i, j, p, pc, x;
		_ref = p.Inst;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			j = _i;
			i = (x = p.Inst, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]));
			pc = strconv.Itoa(j);
			if (pc.length < 3) {
				b.WriteString($substring("   ", pc.length));
			}
			if (j === p.Start) {
				pc = pc + ("*");
			}
			bw(b, new sliceType$3([pc, "\t"]));
			dumpInst(b, i);
			bw(b, new sliceType$3(["\n"]));
			_i++;
		}
	};
	u32 = function(i) {
		var i;
		return strconv.FormatUint((new $Uint64(0, i)), 10);
	};
	dumpInst = function(b, i) {
		var _1, b, i;
		_1 = i.Op;
		if (_1 === (0)) {
			bw(b, new sliceType$3(["alt -> ", u32(i.Out), ", ", u32(i.Arg)]));
		} else if (_1 === (1)) {
			bw(b, new sliceType$3(["altmatch -> ", u32(i.Out), ", ", u32(i.Arg)]));
		} else if (_1 === (2)) {
			bw(b, new sliceType$3(["cap ", u32(i.Arg), " -> ", u32(i.Out)]));
		} else if (_1 === (3)) {
			bw(b, new sliceType$3(["empty ", u32(i.Arg), " -> ", u32(i.Out)]));
		} else if (_1 === (4)) {
			bw(b, new sliceType$3(["match"]));
		} else if (_1 === (5)) {
			bw(b, new sliceType$3(["fail"]));
		} else if (_1 === (6)) {
			bw(b, new sliceType$3(["nop -> ", u32(i.Out)]));
		} else if (_1 === (7)) {
			if (i.Rune === sliceType.nil) {
				bw(b, new sliceType$3(["rune <nil>"]));
			}
			bw(b, new sliceType$3(["rune ", strconv.QuoteToASCII(($runesToString(i.Rune)))]));
			if (!((((((i.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) {
				bw(b, new sliceType$3(["/i"]));
			}
			bw(b, new sliceType$3([" -> ", u32(i.Out)]));
		} else if (_1 === (8)) {
			bw(b, new sliceType$3(["rune1 ", strconv.QuoteToASCII(($runesToString(i.Rune))), " -> ", u32(i.Out)]));
		} else if (_1 === (9)) {
			bw(b, new sliceType$3(["any -> ", u32(i.Out)]));
		} else if (_1 === (10)) {
			bw(b, new sliceType$3(["anynotnl -> ", u32(i.Out)]));
		}
	};
	Regexp.ptr.prototype.Equal = function(y) {
		var _1, _i, _i$1, _ref, _ref$1, i, i$1, r, sub, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, y;
		x = this;
		if (x === ptrType$1.nil || y === ptrType$1.nil) {
			return x === y;
		}
		if (!((x.Op === y.Op))) {
			return false;
		}
		_1 = x.Op;
		if (_1 === (10)) {
			if (!((((x.Flags & 256) >>> 0) === ((y.Flags & 256) >>> 0)))) {
				return false;
			}
		} else if ((_1 === (3)) || (_1 === (4))) {
			if (!((x.Rune.$length === y.Rune.$length))) {
				return false;
			}
			_ref = x.Rune;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				r = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (!((r === (x$1 = y.Rune, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]))))) {
					return false;
				}
				_i++;
			}
		} else if ((_1 === (19)) || (_1 === (18))) {
			if (!((x.Sub.$length === y.Sub.$length))) {
				return false;
			}
			_ref$1 = x.Sub;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$1.$length)) { break; }
				i$1 = _i$1;
				sub = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
				if (!sub.Equal((x$2 = y.Sub, ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1])))) {
					return false;
				}
				_i$1++;
			}
		} else if ((_1 === (14)) || (_1 === (15)) || (_1 === (16))) {
			if (!((((x.Flags & 32) >>> 0) === ((y.Flags & 32) >>> 0))) || !(x$3 = x.Sub, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])).Equal((x$4 = y.Sub, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0])))) {
				return false;
			}
		} else if (_1 === (17)) {
			if (!((((x.Flags & 32) >>> 0) === ((y.Flags & 32) >>> 0))) || !((x.Min === y.Min)) || !((x.Max === y.Max)) || !(x$5 = x.Sub, (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0])).Equal((x$6 = y.Sub, (0 >= x$6.$length ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + 0])))) {
				return false;
			}
		} else if (_1 === (13)) {
			if (!((x.Cap === y.Cap)) || !(x.Name === y.Name) || !(x$7 = x.Sub, (0 >= x$7.$length ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + 0])).Equal((x$8 = y.Sub, (0 >= x$8.$length ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + 0])))) {
				return false;
			}
		}
		return true;
	};
	Regexp.prototype.Equal = function(y) { return this.$val.Equal(y); };
	writeRegexp = function(b, re) {
		var _1, _2, _i, _i$1, _i$2, _r, _ref, _ref$1, _ref$2, _tmp, _tmp$1, _tmp$2, _tmp$3, b, hi, hi$1, i, i$1, i$2, lo, lo$1, r, re, sub, sub$1, sub$2, x, x$1, x$10, x$11, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		switch (0) { default:
			_1 = re.Op;
			if (_1 === (1)) {
				b.WriteString("[^\\x00-\\x{10FFFF}]");
			} else if (_1 === (2)) {
				b.WriteString("(?:)");
			} else if (_1 === (3)) {
				if (!((((re.Flags & 1) >>> 0) === 0))) {
					b.WriteString("(?i:");
				}
				_ref = re.Rune;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					r = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
					escape(b, r, false);
					_i++;
				}
				if (!((((re.Flags & 1) >>> 0) === 0))) {
					b.WriteString(")");
				}
			} else if (_1 === (4)) {
				if (!(((_r = re.Rune.$length % 2, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0))) {
					b.WriteString("[invalid char class]");
					break;
				}
				b.WriteRune(91);
				if (re.Rune.$length === 0) {
					b.WriteString("^\\x00-\\x{10FFFF}");
				} else if (((x = re.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) === 0) && ((x$1 = re.Rune, x$2 = re.Rune.$length - 1 >> 0, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2])) === 1114111)) {
					b.WriteRune(94);
					i = 1;
					while (true) {
						if (!(i < (re.Rune.$length - 1 >> 0))) { break; }
						_tmp = (x$3 = re.Rune, ((i < 0 || i >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i])) + 1 >> 0;
						_tmp$1 = (x$4 = re.Rune, x$5 = i + 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])) - 1 >> 0;
						lo = _tmp;
						hi = _tmp$1;
						escape(b, lo, lo === 45);
						if (!((lo === hi))) {
							b.WriteRune(45);
							escape(b, hi, hi === 45);
						}
						i = i + (2) >> 0;
					}
				} else {
					i$1 = 0;
					while (true) {
						if (!(i$1 < re.Rune.$length)) { break; }
						_tmp$2 = (x$6 = re.Rune, ((i$1 < 0 || i$1 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + i$1]));
						_tmp$3 = (x$7 = re.Rune, x$8 = i$1 + 1 >> 0, ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8]));
						lo$1 = _tmp$2;
						hi$1 = _tmp$3;
						escape(b, lo$1, lo$1 === 45);
						if (!((lo$1 === hi$1))) {
							b.WriteRune(45);
							escape(b, hi$1, hi$1 === 45);
						}
						i$1 = i$1 + (2) >> 0;
					}
				}
				b.WriteRune(93);
			} else if (_1 === (5)) {
				b.WriteString("(?-s:.)");
			} else if (_1 === (6)) {
				b.WriteString("(?s:.)");
			} else if (_1 === (7)) {
				b.WriteString("(?m:^)");
			} else if (_1 === (8)) {
				b.WriteString("(?m:$)");
			} else if (_1 === (9)) {
				b.WriteString("\\A");
			} else if (_1 === (10)) {
				if (!((((re.Flags & 256) >>> 0) === 0))) {
					b.WriteString("(?-m:$)");
				} else {
					b.WriteString("\\z");
				}
			} else if (_1 === (11)) {
				b.WriteString("\\b");
			} else if (_1 === (12)) {
				b.WriteString("\\B");
			} else if (_1 === (13)) {
				if (!(re.Name === "")) {
					b.WriteString("(?P<");
					b.WriteString(re.Name);
					b.WriteRune(62);
				} else {
					b.WriteRune(40);
				}
				if (!(((x$9 = re.Sub, (0 >= x$9.$length ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + 0])).Op === 2))) {
					writeRegexp(b, (x$10 = re.Sub, (0 >= x$10.$length ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + 0])));
				}
				b.WriteRune(41);
			} else if ((_1 === (14)) || (_1 === (15)) || (_1 === (16)) || (_1 === (17))) {
				sub = (x$11 = re.Sub, (0 >= x$11.$length ? ($throwRuntimeError("index out of range"), undefined) : x$11.$array[x$11.$offset + 0]));
				if (sub.Op > 13 || (sub.Op === 3) && sub.Rune.$length > 1) {
					b.WriteString("(?:");
					writeRegexp(b, sub);
					b.WriteString(")");
				} else {
					writeRegexp(b, sub);
				}
				_2 = re.Op;
				if (_2 === (14)) {
					b.WriteRune(42);
				} else if (_2 === (15)) {
					b.WriteRune(43);
				} else if (_2 === (16)) {
					b.WriteRune(63);
				} else if (_2 === (17)) {
					b.WriteRune(123);
					b.WriteString(strconv.Itoa(re.Min));
					if (!((re.Max === re.Min))) {
						b.WriteRune(44);
						if (re.Max >= 0) {
							b.WriteString(strconv.Itoa(re.Max));
						}
					}
					b.WriteRune(125);
				}
				if (!((((re.Flags & 32) >>> 0) === 0))) {
					b.WriteRune(63);
				}
			} else if (_1 === (18)) {
				_ref$1 = re.Sub;
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					sub$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
					if (sub$1.Op === 19) {
						b.WriteString("(?:");
						writeRegexp(b, sub$1);
						b.WriteString(")");
					} else {
						writeRegexp(b, sub$1);
					}
					_i$1++;
				}
			} else if (_1 === (19)) {
				_ref$2 = re.Sub;
				_i$2 = 0;
				while (true) {
					if (!(_i$2 < _ref$2.$length)) { break; }
					i$2 = _i$2;
					sub$2 = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
					if (i$2 > 0) {
						b.WriteRune(124);
					}
					writeRegexp(b, sub$2);
					_i$2++;
				}
			} else {
				b.WriteString("<invalid op" + strconv.Itoa(((re.Op >> 0))) + ">");
			}
		}
	};
	Regexp.ptr.prototype.String = function() {
		var b, re;
		re = this;
		b = new bytes.Buffer.ptr(sliceType$6.nil, 0, 0, arrayType$2.zero());
		writeRegexp(b, re);
		return b.String();
	};
	Regexp.prototype.String = function() { return this.$val.String(); };
	escape = function(b, r, force) {
		var _1, b, force, r, s;
		if (unicode.IsPrint(r)) {
			if (strings.ContainsRune("\\.+*?()|[]{}^$", r) || force) {
				b.WriteRune(92);
			}
			b.WriteRune(r);
			return;
		}
		switch (0) { default:
			_1 = r;
			if (_1 === (7)) {
				b.WriteString("\\a");
			} else if (_1 === (12)) {
				b.WriteString("\\f");
			} else if (_1 === (10)) {
				b.WriteString("\\n");
			} else if (_1 === (13)) {
				b.WriteString("\\r");
			} else if (_1 === (9)) {
				b.WriteString("\\t");
			} else if (_1 === (11)) {
				b.WriteString("\\v");
			} else {
				if (r < 256) {
					b.WriteString("\\x");
					s = strconv.FormatInt((new $Int64(0, r)), 16);
					if (s.length === 1) {
						b.WriteRune(48);
					}
					b.WriteString(s);
					break;
				}
				b.WriteString("\\x{");
				b.WriteString(strconv.FormatInt((new $Int64(0, r)), 16));
				b.WriteString("}");
			}
		}
	};
	Regexp.ptr.prototype.MaxCap = function() {
		var _i, _ref, m, n, re, sub;
		re = this;
		m = 0;
		if (re.Op === 13) {
			m = re.Cap;
		}
		_ref = re.Sub;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			sub = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			n = sub.MaxCap();
			if (m < n) {
				m = n;
			}
			_i++;
		}
		return m;
	};
	Regexp.prototype.MaxCap = function() { return this.$val.MaxCap(); };
	Regexp.ptr.prototype.CapNames = function() {
		var names, re;
		re = this;
		names = $makeSlice(sliceType$3, (re.MaxCap() + 1 >> 0));
		re.capNames(names);
		return names;
	};
	Regexp.prototype.CapNames = function() { return this.$val.CapNames(); };
	Regexp.ptr.prototype.capNames = function(names) {
		var _i, _ref, names, re, sub, x;
		re = this;
		if (re.Op === 13) {
			(x = re.Cap, ((x < 0 || x >= names.$length) ? ($throwRuntimeError("index out of range"), undefined) : names.$array[names.$offset + x] = re.Name));
		}
		_ref = re.Sub;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			sub = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			sub.capNames(names);
			_i++;
		}
	};
	Regexp.prototype.capNames = function(names) { return this.$val.capNames(names); };
	Regexp.ptr.prototype.Simplify = function() {
		var _1, _i, _ref, i, i$1, i$2, i$3, nre, nre$1, nre2, nsub, prefix, re, sub, sub$1, sub$2, suffix, x, x$1;
		re = this;
		if (re === ptrType$1.nil) {
			return ptrType$1.nil;
		}
		_1 = re.Op;
		if ((_1 === (13)) || (_1 === (18)) || (_1 === (19))) {
			nre = re;
			_ref = re.Sub;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				sub = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				nsub = sub.Simplify();
				if (nre === re && !(nsub === sub)) {
					nre = new Regexp.ptr(0, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
					Regexp.copy(nre, re);
					nre.Rune = sliceType.nil;
					nre.Sub = $appendSlice($subslice(new sliceType$5(nre.Sub0), 0, 0), $subslice(re.Sub, 0, i));
				}
				if (!(nre === re)) {
					nre.Sub = $append(nre.Sub, nsub);
				}
				_i++;
			}
			return nre;
		} else if ((_1 === (14)) || (_1 === (15)) || (_1 === (16))) {
			sub$1 = (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])).Simplify();
			return simplify1(re.Op, re.Flags, sub$1, re);
		} else if (_1 === (17)) {
			if ((re.Min === 0) && (re.Max === 0)) {
				return new Regexp.ptr(2, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
			}
			sub$2 = (x$1 = re.Sub, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])).Simplify();
			if (re.Max === -1) {
				if (re.Min === 0) {
					return simplify1(14, re.Flags, sub$2, ptrType$1.nil);
				}
				if (re.Min === 1) {
					return simplify1(15, re.Flags, sub$2, ptrType$1.nil);
				}
				nre$1 = new Regexp.ptr(18, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
				nre$1.Sub = $subslice(new sliceType$5(nre$1.Sub0), 0, 0);
				i$1 = 0;
				while (true) {
					if (!(i$1 < (re.Min - 1 >> 0))) { break; }
					nre$1.Sub = $append(nre$1.Sub, sub$2);
					i$1 = i$1 + (1) >> 0;
				}
				nre$1.Sub = $append(nre$1.Sub, simplify1(15, re.Flags, sub$2, ptrType$1.nil));
				return nre$1;
			}
			if ((re.Min === 1) && (re.Max === 1)) {
				return sub$2;
			}
			prefix = ptrType$1.nil;
			if (re.Min > 0) {
				prefix = new Regexp.ptr(18, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
				prefix.Sub = $subslice(new sliceType$5(prefix.Sub0), 0, 0);
				i$2 = 0;
				while (true) {
					if (!(i$2 < re.Min)) { break; }
					prefix.Sub = $append(prefix.Sub, sub$2);
					i$2 = i$2 + (1) >> 0;
				}
			}
			if (re.Max > re.Min) {
				suffix = simplify1(16, re.Flags, sub$2, ptrType$1.nil);
				i$3 = re.Min + 1 >> 0;
				while (true) {
					if (!(i$3 < re.Max)) { break; }
					nre2 = new Regexp.ptr(18, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
					nre2.Sub = $append($subslice(new sliceType$5(nre2.Sub0), 0, 0), sub$2, suffix);
					suffix = simplify1(16, re.Flags, nre2, ptrType$1.nil);
					i$3 = i$3 + (1) >> 0;
				}
				if (prefix === ptrType$1.nil) {
					return suffix;
				}
				prefix.Sub = $append(prefix.Sub, suffix);
			}
			if (!(prefix === ptrType$1.nil)) {
				return prefix;
			}
			return new Regexp.ptr(1, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
		}
		return re;
	};
	Regexp.prototype.Simplify = function() { return this.$val.Simplify(); };
	simplify1 = function(op, flags, sub, re) {
		var flags, op, re, sub, x;
		if (sub.Op === 2) {
			return sub;
		}
		if ((op === sub.Op) && (((flags & 32) >>> 0) === ((sub.Flags & 32) >>> 0))) {
			return sub;
		}
		if (!(re === ptrType$1.nil) && (re.Op === op) && (((re.Flags & 32) >>> 0) === ((flags & 32) >>> 0)) && sub === (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]))) {
			return re;
		}
		re = new Regexp.ptr(op, flags, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
		re.Sub = $append($subslice(new sliceType$5(re.Sub0), 0, 0), sub);
		return re;
	};
	patchList.methods = [{prop: "next", name: "next", pkg: "regexp/syntax", typ: $funcType([ptrType], [patchList], false)}, {prop: "patch", name: "patch", pkg: "regexp/syntax", typ: $funcType([ptrType, $Uint32], [], false)}, {prop: "append", name: "append", pkg: "regexp/syntax", typ: $funcType([ptrType, patchList], [patchList], false)}];
	ptrType$4.methods = [{prop: "init", name: "init", pkg: "regexp/syntax", typ: $funcType([], [], false)}, {prop: "compile", name: "compile", pkg: "regexp/syntax", typ: $funcType([ptrType$1], [frag], false)}, {prop: "inst", name: "inst", pkg: "regexp/syntax", typ: $funcType([InstOp], [frag], false)}, {prop: "nop", name: "nop", pkg: "regexp/syntax", typ: $funcType([], [frag], false)}, {prop: "fail", name: "fail", pkg: "regexp/syntax", typ: $funcType([], [frag], false)}, {prop: "cap", name: "cap", pkg: "regexp/syntax", typ: $funcType([$Uint32], [frag], false)}, {prop: "cat", name: "cat", pkg: "regexp/syntax", typ: $funcType([frag, frag], [frag], false)}, {prop: "alt", name: "alt", pkg: "regexp/syntax", typ: $funcType([frag, frag], [frag], false)}, {prop: "quest", name: "quest", pkg: "regexp/syntax", typ: $funcType([frag, $Bool], [frag], false)}, {prop: "star", name: "star", pkg: "regexp/syntax", typ: $funcType([frag, $Bool], [frag], false)}, {prop: "plus", name: "plus", pkg: "regexp/syntax", typ: $funcType([frag, $Bool], [frag], false)}, {prop: "empty", name: "empty", pkg: "regexp/syntax", typ: $funcType([EmptyOp], [frag], false)}, {prop: "rune", name: "rune", pkg: "regexp/syntax", typ: $funcType([sliceType, Flags], [frag], false)}];
	ptrType$5.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ErrorCode.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$6.methods = [{prop: "newRegexp", name: "newRegexp", pkg: "regexp/syntax", typ: $funcType([Op], [ptrType$1], false)}, {prop: "reuse", name: "reuse", pkg: "regexp/syntax", typ: $funcType([ptrType$1], [], false)}, {prop: "push", name: "push", pkg: "regexp/syntax", typ: $funcType([ptrType$1], [ptrType$1], false)}, {prop: "maybeConcat", name: "maybeConcat", pkg: "regexp/syntax", typ: $funcType([$Int32, Flags], [$Bool], false)}, {prop: "newLiteral", name: "newLiteral", pkg: "regexp/syntax", typ: $funcType([$Int32, Flags], [ptrType$1], false)}, {prop: "literal", name: "literal", pkg: "regexp/syntax", typ: $funcType([$Int32], [], false)}, {prop: "op", name: "op", pkg: "regexp/syntax", typ: $funcType([Op], [ptrType$1], false)}, {prop: "repeat", name: "repeat", pkg: "regexp/syntax", typ: $funcType([Op, $Int, $Int, $String, $String, $String], [$String, $error], false)}, {prop: "concat", name: "concat", pkg: "regexp/syntax", typ: $funcType([], [ptrType$1], false)}, {prop: "alternate", name: "alternate", pkg: "regexp/syntax", typ: $funcType([], [ptrType$1], false)}, {prop: "collapse", name: "collapse", pkg: "regexp/syntax", typ: $funcType([sliceType$5, Op], [ptrType$1], false)}, {prop: "factor", name: "factor", pkg: "regexp/syntax", typ: $funcType([sliceType$5], [sliceType$5], false)}, {prop: "leadingString", name: "leadingString", pkg: "regexp/syntax", typ: $funcType([ptrType$1], [sliceType, Flags], false)}, {prop: "removeLeadingString", name: "removeLeadingString", pkg: "regexp/syntax", typ: $funcType([ptrType$1, $Int], [ptrType$1], false)}, {prop: "leadingRegexp", name: "leadingRegexp", pkg: "regexp/syntax", typ: $funcType([ptrType$1], [ptrType$1], false)}, {prop: "removeLeadingRegexp", name: "removeLeadingRegexp", pkg: "regexp/syntax", typ: $funcType([ptrType$1, $Bool], [ptrType$1], false)}, {prop: "parseRepeat", name: "parseRepeat", pkg: "regexp/syntax", typ: $funcType([$String], [$Int, $Int, $String, $Bool], false)}, {prop: "parsePerlFlags", name: "parsePerlFlags", pkg: "regexp/syntax", typ: $funcType([$String], [$String, $error], false)}, {prop: "parseInt", name: "parseInt", pkg: "regexp/syntax", typ: $funcType([$String], [$Int, $String, $Bool], false)}, {prop: "parseVerticalBar", name: "parseVerticalBar", pkg: "regexp/syntax", typ: $funcType([], [$error], false)}, {prop: "swapVerticalBar", name: "swapVerticalBar", pkg: "regexp/syntax", typ: $funcType([], [$Bool], false)}, {prop: "parseRightParen", name: "parseRightParen", pkg: "regexp/syntax", typ: $funcType([], [$error], false)}, {prop: "parseEscape", name: "parseEscape", pkg: "regexp/syntax", typ: $funcType([$String], [$Int32, $String, $error], false)}, {prop: "parseClassChar", name: "parseClassChar", pkg: "regexp/syntax", typ: $funcType([$String, $String], [$Int32, $String, $error], false)}, {prop: "parsePerlClassEscape", name: "parsePerlClassEscape", pkg: "regexp/syntax", typ: $funcType([$String, sliceType], [sliceType, $String], false)}, {prop: "parseNamedClass", name: "parseNamedClass", pkg: "regexp/syntax", typ: $funcType([$String, sliceType], [sliceType, $String, $error], false)}, {prop: "appendGroup", name: "appendGroup", pkg: "regexp/syntax", typ: $funcType([sliceType, charGroup], [sliceType], false)}, {prop: "parseUnicodeClass", name: "parseUnicodeClass", pkg: "regexp/syntax", typ: $funcType([$String, sliceType], [sliceType, $String, $error], false)}, {prop: "parseClass", name: "parseClass", pkg: "regexp/syntax", typ: $funcType([$String], [$String, $error], false)}];
	ranges.methods = [{prop: "Less", name: "Less", pkg: "", typ: $funcType([$Int, $Int], [$Bool], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Swap", name: "Swap", pkg: "", typ: $funcType([$Int, $Int], [], false)}];
	ptrType.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "skipNop", name: "skipNop", pkg: "regexp/syntax", typ: $funcType([$Uint32], [ptrType$7, $Uint32], false)}, {prop: "Prefix", name: "Prefix", pkg: "", typ: $funcType([], [$String, $Bool], false)}, {prop: "StartCond", name: "StartCond", pkg: "", typ: $funcType([], [EmptyOp], false)}];
	InstOp.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$7.methods = [{prop: "op", name: "op", pkg: "regexp/syntax", typ: $funcType([], [InstOp], false)}, {prop: "MatchRune", name: "MatchRune", pkg: "", typ: $funcType([$Int32], [$Bool], false)}, {prop: "MatchRunePos", name: "MatchRunePos", pkg: "", typ: $funcType([$Int32], [$Int], false)}, {prop: "MatchEmptyWidth", name: "MatchEmptyWidth", pkg: "", typ: $funcType([$Int32, $Int32], [$Bool], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$1.methods = [{prop: "Equal", name: "Equal", pkg: "", typ: $funcType([ptrType$1], [$Bool], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "MaxCap", name: "MaxCap", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "CapNames", name: "CapNames", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "capNames", name: "capNames", pkg: "regexp/syntax", typ: $funcType([sliceType$3], [], false)}, {prop: "Simplify", name: "Simplify", pkg: "", typ: $funcType([], [ptrType$1], false)}];
	frag.init("regexp/syntax", [{prop: "i", name: "i", anonymous: false, exported: false, typ: $Uint32, tag: ""}, {prop: "out", name: "out", anonymous: false, exported: false, typ: patchList, tag: ""}]);
	compiler.init("regexp/syntax", [{prop: "p", name: "p", anonymous: false, exported: false, typ: ptrType, tag: ""}]);
	Error.init("", [{prop: "Code", name: "Code", anonymous: false, exported: true, typ: ErrorCode, tag: ""}, {prop: "Expr", name: "Expr", anonymous: false, exported: true, typ: $String, tag: ""}]);
	parser.init("regexp/syntax", [{prop: "flags", name: "flags", anonymous: false, exported: false, typ: Flags, tag: ""}, {prop: "stack", name: "stack", anonymous: false, exported: false, typ: sliceType$5, tag: ""}, {prop: "free", name: "free", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "numCap", name: "numCap", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "wholeRegexp", name: "wholeRegexp", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "tmpClass", name: "tmpClass", anonymous: false, exported: false, typ: sliceType, tag: ""}]);
	charGroup.init("regexp/syntax", [{prop: "sign", name: "sign", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "class$1", name: "class", anonymous: false, exported: false, typ: sliceType, tag: ""}]);
	ranges.init("regexp/syntax", [{prop: "p", name: "p", anonymous: false, exported: false, typ: ptrType$2, tag: ""}]);
	Prog.init("", [{prop: "Inst", name: "Inst", anonymous: false, exported: true, typ: sliceType$4, tag: ""}, {prop: "Start", name: "Start", anonymous: false, exported: true, typ: $Int, tag: ""}, {prop: "NumCap", name: "NumCap", anonymous: false, exported: true, typ: $Int, tag: ""}]);
	Inst.init("", [{prop: "Op", name: "Op", anonymous: false, exported: true, typ: InstOp, tag: ""}, {prop: "Out", name: "Out", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Arg", name: "Arg", anonymous: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Rune", name: "Rune", anonymous: false, exported: true, typ: sliceType, tag: ""}]);
	Regexp.init("", [{prop: "Op", name: "Op", anonymous: false, exported: true, typ: Op, tag: ""}, {prop: "Flags", name: "Flags", anonymous: false, exported: true, typ: Flags, tag: ""}, {prop: "Sub", name: "Sub", anonymous: false, exported: true, typ: sliceType$5, tag: ""}, {prop: "Sub0", name: "Sub0", anonymous: false, exported: true, typ: arrayType, tag: ""}, {prop: "Rune", name: "Rune", anonymous: false, exported: true, typ: sliceType, tag: ""}, {prop: "Rune0", name: "Rune0", anonymous: false, exported: true, typ: arrayType$1, tag: ""}, {prop: "Min", name: "Min", anonymous: false, exported: true, typ: $Int, tag: ""}, {prop: "Max", name: "Max", anonymous: false, exported: true, typ: $Int, tag: ""}, {prop: "Cap", name: "Cap", anonymous: false, exported: true, typ: $Int, tag: ""}, {prop: "Name", name: "Name", anonymous: false, exported: true, typ: $String, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sort.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		anyRuneNotNL = new sliceType([0, 9, 11, 1114111]);
		anyRune = new sliceType([0, 1114111]);
		anyTable = new unicode.RangeTable.ptr(new sliceType$1([new unicode.Range16.ptr(0, 65535, 1)]), new sliceType$2([new unicode.Range32.ptr(65536, 1114111, 1)]), 0);
		code1 = new sliceType([48, 57]);
		code2 = new sliceType([9, 10, 12, 13, 32, 32]);
		code3 = new sliceType([48, 57, 65, 90, 95, 95, 97, 122]);
		perlGroup = $makeMap($String.keyFor, [{ k: "\\d", v: new charGroup.ptr(1, code1) }, { k: "\\D", v: new charGroup.ptr(-1, code1) }, { k: "\\s", v: new charGroup.ptr(1, code2) }, { k: "\\S", v: new charGroup.ptr(-1, code2) }, { k: "\\w", v: new charGroup.ptr(1, code3) }, { k: "\\W", v: new charGroup.ptr(-1, code3) }]);
		code4 = new sliceType([48, 57, 65, 90, 97, 122]);
		code5 = new sliceType([65, 90, 97, 122]);
		code6 = new sliceType([0, 127]);
		code7 = new sliceType([9, 9, 32, 32]);
		code8 = new sliceType([0, 31, 127, 127]);
		code9 = new sliceType([48, 57]);
		code10 = new sliceType([33, 126]);
		code11 = new sliceType([97, 122]);
		code12 = new sliceType([32, 126]);
		code13 = new sliceType([33, 47, 58, 64, 91, 96, 123, 126]);
		code14 = new sliceType([9, 13, 32, 32]);
		code15 = new sliceType([65, 90]);
		code16 = new sliceType([48, 57, 65, 90, 95, 95, 97, 122]);
		code17 = new sliceType([48, 57, 65, 70, 97, 102]);
		posixGroup = $makeMap($String.keyFor, [{ k: "[:alnum:]", v: new charGroup.ptr(1, code4) }, { k: "[:^alnum:]", v: new charGroup.ptr(-1, code4) }, { k: "[:alpha:]", v: new charGroup.ptr(1, code5) }, { k: "[:^alpha:]", v: new charGroup.ptr(-1, code5) }, { k: "[:ascii:]", v: new charGroup.ptr(1, code6) }, { k: "[:^ascii:]", v: new charGroup.ptr(-1, code6) }, { k: "[:blank:]", v: new charGroup.ptr(1, code7) }, { k: "[:^blank:]", v: new charGroup.ptr(-1, code7) }, { k: "[:cntrl:]", v: new charGroup.ptr(1, code8) }, { k: "[:^cntrl:]", v: new charGroup.ptr(-1, code8) }, { k: "[:digit:]", v: new charGroup.ptr(1, code9) }, { k: "[:^digit:]", v: new charGroup.ptr(-1, code9) }, { k: "[:graph:]", v: new charGroup.ptr(1, code10) }, { k: "[:^graph:]", v: new charGroup.ptr(-1, code10) }, { k: "[:lower:]", v: new charGroup.ptr(1, code11) }, { k: "[:^lower:]", v: new charGroup.ptr(-1, code11) }, { k: "[:print:]", v: new charGroup.ptr(1, code12) }, { k: "[:^print:]", v: new charGroup.ptr(-1, code12) }, { k: "[:punct:]", v: new charGroup.ptr(1, code13) }, { k: "[:^punct:]", v: new charGroup.ptr(-1, code13) }, { k: "[:space:]", v: new charGroup.ptr(1, code14) }, { k: "[:^space:]", v: new charGroup.ptr(-1, code14) }, { k: "[:upper:]", v: new charGroup.ptr(1, code15) }, { k: "[:^upper:]", v: new charGroup.ptr(-1, code15) }, { k: "[:word:]", v: new charGroup.ptr(1, code16) }, { k: "[:^word:]", v: new charGroup.ptr(-1, code16) }, { k: "[:xdigit:]", v: new charGroup.ptr(1, code17) }, { k: "[:^xdigit:]", v: new charGroup.ptr(-1, code17) }]);
		instOpNames = new sliceType$3(["InstAlt", "InstAltMatch", "InstCapture", "InstEmptyWidth", "InstMatch", "InstFail", "InstNop", "InstRune", "InstRune1", "InstRuneAny", "InstRuneAnyNotNL"]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["regexp"] = (function() {
	var $pkg = {}, $init, bytes, nosync, io, syntax, sort, strconv, strings, unicode, utf8, job, bitState, queue, entry, thread, machine, onePassProg, onePassInst, queueOnePass, runeSlice, Regexp, regexpRO, input, inputString, inputBytes, inputReader, arrayType, arrayType$1, ptrType, sliceType, sliceType$1, ptrType$1, ptrType$2, sliceType$2, sliceType$3, ptrType$3, sliceType$4, ptrType$4, sliceType$5, sliceType$6, ptrType$5, ptrType$6, arrayType$2, ptrType$7, sliceType$7, ptrType$8, sliceType$8, ptrType$9, sliceType$9, sliceType$10, ptrType$10, sliceType$11, arrayType$3, arrayType$4, sliceType$12, sliceType$13, sliceType$14, sliceType$15, ptrType$11, funcType, funcType$1, funcType$2, funcType$3, ptrType$12, ptrType$13, ptrType$14, notBacktrack, arrayNoInts, noRune, noNext, anyRuneNotNL, anyRune, notOnePass, specialBytes, maxBitStateLen, newBitState, shouldBacktrack, progMachine, onePassPrefix, onePassNext, iop, newQueue, mergeRuneSets, cleanupOnePass, onePassCopy, makeOnePass, compileOnePass, Compile, compile, MustCompile, quote, init, extract;
	bytes = $packages["bytes"];
	nosync = $packages["github.com/gopherjs/gopherjs/nosync"];
	io = $packages["io"];
	syntax = $packages["regexp/syntax"];
	sort = $packages["sort"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	job = $pkg.job = $newType(0, $kindStruct, "regexp.job", true, "regexp", false, function(pc_, arg_, pos_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.pc = 0;
			this.arg = 0;
			this.pos = 0;
			return;
		}
		this.pc = pc_;
		this.arg = arg_;
		this.pos = pos_;
	});
	bitState = $pkg.bitState = $newType(0, $kindStruct, "regexp.bitState", true, "regexp", false, function(prog_, end_, cap_, jobs_, visited_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.prog = ptrType$2.nil;
			this.end = 0;
			this.cap = sliceType$2.nil;
			this.jobs = sliceType$3.nil;
			this.visited = sliceType$1.nil;
			return;
		}
		this.prog = prog_;
		this.end = end_;
		this.cap = cap_;
		this.jobs = jobs_;
		this.visited = visited_;
	});
	queue = $pkg.queue = $newType(0, $kindStruct, "regexp.queue", true, "regexp", false, function(sparse_, dense_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.sparse = sliceType$1.nil;
			this.dense = sliceType$4.nil;
			return;
		}
		this.sparse = sparse_;
		this.dense = dense_;
	});
	entry = $pkg.entry = $newType(0, $kindStruct, "regexp.entry", true, "regexp", false, function(pc_, t_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.pc = 0;
			this.t = ptrType$4.nil;
			return;
		}
		this.pc = pc_;
		this.t = t_;
	});
	thread = $pkg.thread = $newType(0, $kindStruct, "regexp.thread", true, "regexp", false, function(inst_, cap_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.inst = ptrType$5.nil;
			this.cap = sliceType$2.nil;
			return;
		}
		this.inst = inst_;
		this.cap = cap_;
	});
	machine = $pkg.machine = $newType(0, $kindStruct, "regexp.machine", true, "regexp", false, function(re_, p_, op_, maxBitStateLen_, b_, q0_, q1_, pool_, matched_, matchcap_, inputBytes_, inputString_, inputReader_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.re = ptrType$3.nil;
			this.p = ptrType$2.nil;
			this.op = ptrType$1.nil;
			this.maxBitStateLen = 0;
			this.b = ptrType.nil;
			this.q0 = new queue.ptr(sliceType$1.nil, sliceType$4.nil);
			this.q1 = new queue.ptr(sliceType$1.nil, sliceType$4.nil);
			this.pool = sliceType$5.nil;
			this.matched = false;
			this.matchcap = sliceType$2.nil;
			this.inputBytes = new inputBytes.ptr(sliceType$6.nil);
			this.inputString = new inputString.ptr("");
			this.inputReader = new inputReader.ptr($ifaceNil, false, 0);
			return;
		}
		this.re = re_;
		this.p = p_;
		this.op = op_;
		this.maxBitStateLen = maxBitStateLen_;
		this.b = b_;
		this.q0 = q0_;
		this.q1 = q1_;
		this.pool = pool_;
		this.matched = matched_;
		this.matchcap = matchcap_;
		this.inputBytes = inputBytes_;
		this.inputString = inputString_;
		this.inputReader = inputReader_;
	});
	onePassProg = $pkg.onePassProg = $newType(0, $kindStruct, "regexp.onePassProg", true, "regexp", false, function(Inst_, Start_, NumCap_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Inst = sliceType$7.nil;
			this.Start = 0;
			this.NumCap = 0;
			return;
		}
		this.Inst = Inst_;
		this.Start = Start_;
		this.NumCap = NumCap_;
	});
	onePassInst = $pkg.onePassInst = $newType(0, $kindStruct, "regexp.onePassInst", true, "regexp", false, function(Inst_, Next_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Inst = new syntax.Inst.ptr(0, 0, 0, sliceType.nil);
			this.Next = sliceType$1.nil;
			return;
		}
		this.Inst = Inst_;
		this.Next = Next_;
	});
	queueOnePass = $pkg.queueOnePass = $newType(0, $kindStruct, "regexp.queueOnePass", true, "regexp", false, function(sparse_, dense_, size_, nextIndex_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.sparse = sliceType$1.nil;
			this.dense = sliceType$1.nil;
			this.size = 0;
			this.nextIndex = 0;
			return;
		}
		this.sparse = sparse_;
		this.dense = dense_;
		this.size = size_;
		this.nextIndex = nextIndex_;
	});
	runeSlice = $pkg.runeSlice = $newType(12, $kindSlice, "regexp.runeSlice", true, "regexp", false, null);
	Regexp = $pkg.Regexp = $newType(0, $kindStruct, "regexp.Regexp", true, "regexp", true, function(regexpRO_, mu_, machine_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.regexpRO = new regexpRO.ptr("", ptrType$2.nil, ptrType$1.nil, "", sliceType$6.nil, false, 0, 0, 0, 0, sliceType$10.nil, false);
			this.mu = new nosync.Mutex.ptr(false);
			this.machine = sliceType$11.nil;
			return;
		}
		this.regexpRO = regexpRO_;
		this.mu = mu_;
		this.machine = machine_;
	});
	regexpRO = $pkg.regexpRO = $newType(0, $kindStruct, "regexp.regexpRO", true, "regexp", false, function(expr_, prog_, onepass_, prefix_, prefixBytes_, prefixComplete_, prefixRune_, prefixEnd_, cond_, numSubexp_, subexpNames_, longest_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.expr = "";
			this.prog = ptrType$2.nil;
			this.onepass = ptrType$1.nil;
			this.prefix = "";
			this.prefixBytes = sliceType$6.nil;
			this.prefixComplete = false;
			this.prefixRune = 0;
			this.prefixEnd = 0;
			this.cond = 0;
			this.numSubexp = 0;
			this.subexpNames = sliceType$10.nil;
			this.longest = false;
			return;
		}
		this.expr = expr_;
		this.prog = prog_;
		this.onepass = onepass_;
		this.prefix = prefix_;
		this.prefixBytes = prefixBytes_;
		this.prefixComplete = prefixComplete_;
		this.prefixRune = prefixRune_;
		this.prefixEnd = prefixEnd_;
		this.cond = cond_;
		this.numSubexp = numSubexp_;
		this.subexpNames = subexpNames_;
		this.longest = longest_;
	});
	input = $pkg.input = $newType(8, $kindInterface, "regexp.input", true, "regexp", false, null);
	inputString = $pkg.inputString = $newType(0, $kindStruct, "regexp.inputString", true, "regexp", false, function(str_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.str = "";
			return;
		}
		this.str = str_;
	});
	inputBytes = $pkg.inputBytes = $newType(0, $kindStruct, "regexp.inputBytes", true, "regexp", false, function(str_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.str = sliceType$6.nil;
			return;
		}
		this.str = str_;
	});
	inputReader = $pkg.inputReader = $newType(0, $kindStruct, "regexp.inputReader", true, "regexp", false, function(r_, atEOT_, pos_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.r = $ifaceNil;
			this.atEOT = false;
			this.pos = 0;
			return;
		}
		this.r = r_;
		this.atEOT = atEOT_;
		this.pos = pos_;
	});
	arrayType = $arrayType($Int, 0);
	arrayType$1 = $arrayType($Uint8, 16);
	ptrType = $ptrType(bitState);
	sliceType = $sliceType($Int32);
	sliceType$1 = $sliceType($Uint32);
	ptrType$1 = $ptrType(onePassProg);
	ptrType$2 = $ptrType(syntax.Prog);
	sliceType$2 = $sliceType($Int);
	sliceType$3 = $sliceType(job);
	ptrType$3 = $ptrType(Regexp);
	sliceType$4 = $sliceType(entry);
	ptrType$4 = $ptrType(thread);
	sliceType$5 = $sliceType(ptrType$4);
	sliceType$6 = $sliceType($Uint8);
	ptrType$5 = $ptrType(syntax.Inst);
	ptrType$6 = $ptrType($Int);
	arrayType$2 = $arrayType($Uint8, 64);
	ptrType$7 = $ptrType(queueOnePass);
	sliceType$7 = $sliceType(onePassInst);
	ptrType$8 = $ptrType($Uint32);
	sliceType$8 = $sliceType(sliceType);
	ptrType$9 = $ptrType(sliceType);
	sliceType$9 = $sliceType($Bool);
	sliceType$10 = $sliceType($String);
	ptrType$10 = $ptrType(machine);
	sliceType$11 = $sliceType(ptrType$10);
	arrayType$3 = $arrayType($Int, 2);
	arrayType$4 = $arrayType($Int, 4);
	sliceType$12 = $sliceType(sliceType$6);
	sliceType$13 = $sliceType(sliceType$2);
	sliceType$14 = $sliceType(sliceType$12);
	sliceType$15 = $sliceType(sliceType$10);
	ptrType$11 = $ptrType(queue);
	funcType = $funcType([$String], [$String], false);
	funcType$1 = $funcType([sliceType$6, sliceType$2], [sliceType$6], false);
	funcType$2 = $funcType([sliceType$6], [sliceType$6], false);
	funcType$3 = $funcType([sliceType$2], [], false);
	ptrType$12 = $ptrType(inputString);
	ptrType$13 = $ptrType(inputBytes);
	ptrType$14 = $ptrType(inputReader);
	maxBitStateLen = function(prog) {
		var _q, prog;
		if (!shouldBacktrack(prog)) {
			return 0;
		}
		return (_q = 262144 / prog.Inst.$length, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
	};
	newBitState = function(prog) {
		var prog;
		if (!shouldBacktrack(prog)) {
			return notBacktrack;
		}
		return new bitState.ptr(prog, 0, sliceType$2.nil, sliceType$3.nil, sliceType$1.nil);
	};
	shouldBacktrack = function(prog) {
		var prog;
		return prog.Inst.$length <= 500;
	};
	bitState.ptr.prototype.reset = function(end, ncap) {
		var _i, _i$1, _q, _ref, _ref$1, b, end, i, i$1, ncap, visitedSize, x, x$1;
		b = this;
		b.end = end;
		if (b.jobs.$capacity === 0) {
			b.jobs = $makeSlice(sliceType$3, 0, 256);
		} else {
			b.jobs = $subslice(b.jobs, 0, 0);
		}
		visitedSize = (_q = (((($imul(b.prog.Inst.$length, ((end + 1 >> 0)))) + 32 >> 0) - 1 >> 0)) / 32, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		if (b.visited.$capacity < visitedSize) {
			b.visited = $makeSlice(sliceType$1, visitedSize, 8192);
		} else {
			b.visited = $subslice(b.visited, 0, visitedSize);
			_ref = b.visited;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				(x = b.visited, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i] = 0));
				_i++;
			}
		}
		if (b.cap.$capacity < ncap) {
			b.cap = $makeSlice(sliceType$2, ncap);
		} else {
			b.cap = $subslice(b.cap, 0, ncap);
		}
		_ref$1 = b.cap;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			(x$1 = b.cap, ((i$1 < 0 || i$1 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i$1] = -1));
			_i$1++;
		}
	};
	bitState.prototype.reset = function(end, ncap) { return this.$val.reset(end, ncap); };
	bitState.ptr.prototype.shouldVisit = function(pc, pos) {
		var _index, _q, _q$1, b, n, pc, pos, x, x$1, x$2, x$3, y, y$1;
		b = this;
		n = (((($imul(((pc >> 0)), ((b.end + 1 >> 0)))) + pos >> 0) >>> 0));
		if (!(((((x = b.visited, x$1 = (_q = n / 32, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero")), ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])) & (((y = (((n & 31) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0) === 0))) {
			return false;
		}
		_index = (_q$1 = n / 32, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
		(x$3 = b.visited, ((_index < 0 || _index >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + _index] = (((x$2 = b.visited, ((_index < 0 || _index >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + _index])) | (((y$1 = (((n & 31) >>> 0)), y$1 < 32 ? (1 << y$1) : 0) >>> 0))) >>> 0)));
		return true;
	};
	bitState.prototype.shouldVisit = function(pc, pos) { return this.$val.shouldVisit(pc, pos); };
	bitState.ptr.prototype.push = function(pc, pos, arg) {
		var arg, b, pc, pos, x;
		b = this;
		if ((x = b.prog.Inst, ((pc < 0 || pc >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pc])).Op === 5) {
			return;
		}
		if ((arg === 0) && !b.shouldVisit(pc, pos)) {
			return;
		}
		b.jobs = $append(b.jobs, new job.ptr(pc, arg, pos));
	};
	bitState.prototype.push = function(pc, pos, arg) { return this.$val.push(pc, pos, arg); };
	machine.ptr.prototype.tryBacktrack = function(b, i, pc, pos) {
		var _1, _2, _3, _4, _r, _r$1, _r$2, _r$3, _r$4, _tuple, _tuple$1, _tuple$2, _tuple$3, arg, b, i, inst, l, longest, m, pc, pc$1, pos, pos$1, r, r$1, r$2, r$3, width, width$1, width$2, width$3, x, x$1, x$10, x$11, x$12, x$13, x$14, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; arg = $f.arg; b = $f.b; i = $f.i; inst = $f.inst; l = $f.l; longest = $f.longest; m = $f.m; pc = $f.pc; pc$1 = $f.pc$1; pos = $f.pos; pos$1 = $f.pos$1; r = $f.r; r$1 = $f.r$1; r$2 = $f.r$2; r$3 = $f.r$3; width = $f.width; width$1 = $f.width$1; width$2 = $f.width$2; width$3 = $f.width$3; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		longest = m.re.regexpRO.longest;
		m.matched = false;
		b.push(pc, pos, 0);
		/* while (true) { */ case 1:
			/* if (!(b.jobs.$length > 0)) { break; } */ if(!(b.jobs.$length > 0)) { $s = 2; continue; }
			l = b.jobs.$length - 1 >> 0;
			pc$1 = (x = b.jobs, ((l < 0 || l >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + l])).pc;
			pos$1 = (x$1 = b.jobs, ((l < 0 || l >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + l])).pos;
			arg = (x$2 = b.jobs, ((l < 0 || l >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + l])).arg;
			b.jobs = $subslice(b.jobs, 0, l);
			/* goto Skip */ $s = 3; continue;
			/* CheckAndLoop: */ case 4:
			if (!b.shouldVisit(pc$1, pos$1)) {
				/* continue; */ $s = 1; continue;
			}
			/* Skip: */ case 3:
			inst = $clone((x$3 = b.prog.Inst, ((pc$1 < 0 || pc$1 >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + pc$1])), syntax.Inst);
				_1 = inst.Op;
				/* */ if (_1 === (5)) { $s = 6; continue; }
				/* */ if (_1 === (0)) { $s = 7; continue; }
				/* */ if (_1 === (1)) { $s = 8; continue; }
				/* */ if (_1 === (7)) { $s = 9; continue; }
				/* */ if (_1 === (8)) { $s = 10; continue; }
				/* */ if (_1 === (10)) { $s = 11; continue; }
				/* */ if (_1 === (9)) { $s = 12; continue; }
				/* */ if (_1 === (2)) { $s = 13; continue; }
				/* */ if (_1 === (3)) { $s = 14; continue; }
				/* */ if (_1 === (6)) { $s = 15; continue; }
				/* */ if (_1 === (4)) { $s = 16; continue; }
				/* */ $s = 17; continue;
				/* if (_1 === (5)) { */ case 6:
					$panic(new $String("unexpected InstFail"));
					$s = 18; continue;
				/* } else if (_1 === (0)) { */ case 7:
						_2 = arg;
						/* */ if (_2 === (0)) { $s = 20; continue; }
						/* */ if (_2 === (1)) { $s = 21; continue; }
						/* */ $s = 22; continue;
						/* if (_2 === (0)) { */ case 20:
							b.push(pc$1, pos$1, 1);
							pc$1 = inst.Out;
							/* goto CheckAndLoop */ $s = 4; continue;
							$s = 22; continue;
						/* } else if (_2 === (1)) { */ case 21:
							arg = 0;
							pc$1 = inst.Arg;
							/* goto CheckAndLoop */ $s = 4; continue;
						/* } */ case 22:
					case 19:
					$panic(new $String("bad arg in InstAlt"));
					$s = 18; continue;
				/* } else if (_1 === (1)) { */ case 8:
						_3 = (x$4 = b.prog.Inst, x$5 = inst.Out, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])).Op;
						/* */ if ((_3 === (7)) || (_3 === (8)) || (_3 === (9)) || (_3 === (10))) { $s = 24; continue; }
						/* */ $s = 25; continue;
						/* if ((_3 === (7)) || (_3 === (8)) || (_3 === (9)) || (_3 === (10))) { */ case 24:
							b.push(inst.Arg, pos$1, 0);
							pc$1 = inst.Arg;
							pos$1 = b.end;
							/* goto CheckAndLoop */ $s = 4; continue;
						/* } */ case 25:
					case 23:
					b.push(inst.Out, b.end, 0);
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (7)) { */ case 9:
					_r = i.step(pos$1); /* */ $s = 26; case 26: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					_tuple = _r;
					r = _tuple[0];
					width = _tuple[1];
					/* */ if (!inst.MatchRune(r)) { $s = 27; continue; }
					/* */ $s = 28; continue;
					/* if (!inst.MatchRune(r)) { */ case 27:
						/* continue; */ $s = 1; continue;
					/* } */ case 28:
					pos$1 = pos$1 + (width) >> 0;
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (8)) { */ case 10:
					_r$1 = i.step(pos$1); /* */ $s = 29; case 29: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_tuple$1 = _r$1;
					r$1 = _tuple$1[0];
					width$1 = _tuple$1[1];
					/* */ if (!((r$1 === (x$6 = inst.Rune, (0 >= x$6.$length ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + 0]))))) { $s = 30; continue; }
					/* */ $s = 31; continue;
					/* if (!((r$1 === (x$6 = inst.Rune, (0 >= x$6.$length ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + 0]))))) { */ case 30:
						/* continue; */ $s = 1; continue;
					/* } */ case 31:
					pos$1 = pos$1 + (width$1) >> 0;
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (10)) { */ case 11:
					_r$2 = i.step(pos$1); /* */ $s = 32; case 32: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_tuple$2 = _r$2;
					r$2 = _tuple$2[0];
					width$2 = _tuple$2[1];
					/* */ if ((r$2 === 10) || (r$2 === -1)) { $s = 33; continue; }
					/* */ $s = 34; continue;
					/* if ((r$2 === 10) || (r$2 === -1)) { */ case 33:
						/* continue; */ $s = 1; continue;
					/* } */ case 34:
					pos$1 = pos$1 + (width$2) >> 0;
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (9)) { */ case 12:
					_r$3 = i.step(pos$1); /* */ $s = 35; case 35: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					_tuple$3 = _r$3;
					r$3 = _tuple$3[0];
					width$3 = _tuple$3[1];
					/* */ if (r$3 === -1) { $s = 36; continue; }
					/* */ $s = 37; continue;
					/* if (r$3 === -1) { */ case 36:
						/* continue; */ $s = 1; continue;
					/* } */ case 37:
					pos$1 = pos$1 + (width$3) >> 0;
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (2)) { */ case 13:
						_4 = arg;
						/* */ if (_4 === (0)) { $s = 39; continue; }
						/* */ if (_4 === (1)) { $s = 40; continue; }
						/* */ $s = 41; continue;
						/* if (_4 === (0)) { */ case 39:
							if (0 <= inst.Arg && inst.Arg < ((b.cap.$length >>> 0))) {
								b.push(pc$1, (x$7 = b.cap, x$8 = inst.Arg, ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8])), 1);
								(x$9 = b.cap, x$10 = inst.Arg, ((x$10 < 0 || x$10 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + x$10] = pos$1));
							}
							pc$1 = inst.Out;
							/* goto CheckAndLoop */ $s = 4; continue;
							$s = 41; continue;
						/* } else if (_4 === (1)) { */ case 40:
							(x$11 = b.cap, x$12 = inst.Arg, ((x$12 < 0 || x$12 >= x$11.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$11.$array[x$11.$offset + x$12] = pos$1));
							/* continue; */ $s = 1; continue;
						/* } */ case 41:
					case 38:
					$panic(new $String("bad arg in InstCapture"));
					$s = 18; continue;
				/* } else if (_1 === (3)) { */ case 14:
					_r$4 = i.context(pos$1); /* */ $s = 44; case 44: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					/* */ if (!((((((inst.Arg << 24 >>> 24)) & ~_r$4) << 24 >>> 24) === 0))) { $s = 42; continue; }
					/* */ $s = 43; continue;
					/* if (!((((((inst.Arg << 24 >>> 24)) & ~_r$4) << 24 >>> 24) === 0))) { */ case 42:
						/* continue; */ $s = 1; continue;
					/* } */ case 43:
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (6)) { */ case 15:
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (4)) { */ case 16:
					if (b.cap.$length === 0) {
						m.matched = true;
						$s = -1; return m.matched;
					}
					if (b.cap.$length > 1) {
						(x$13 = b.cap, (1 >= x$13.$length ? ($throwRuntimeError("index out of range"), undefined) : x$13.$array[x$13.$offset + 1] = pos$1));
					}
					if (!m.matched || (longest && pos$1 > 0 && pos$1 > (x$14 = m.matchcap, (1 >= x$14.$length ? ($throwRuntimeError("index out of range"), undefined) : x$14.$array[x$14.$offset + 1])))) {
						$copySlice(m.matchcap, b.cap);
					}
					m.matched = true;
					if (!longest) {
						$s = -1; return m.matched;
					}
					if (pos$1 === b.end) {
						$s = -1; return m.matched;
					}
					/* continue; */ $s = 1; continue;
					$s = 18; continue;
				/* } else { */ case 17:
					$panic(new $String("bad inst"));
				/* } */ case 18:
			case 5:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return m.matched;
		/* */ } return; } if ($f === undefined) { $f = { $blk: machine.ptr.prototype.tryBacktrack }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.arg = arg; $f.b = b; $f.i = i; $f.inst = inst; $f.l = l; $f.longest = longest; $f.m = m; $f.pc = pc; $f.pc$1 = pc$1; $f.pos = pos; $f.pos$1 = pos$1; $f.r = r; $f.r$1 = r$1; $f.r$2 = r$2; $f.r$3 = r$3; $f.width = width; $f.width$1 = width$1; $f.width$2 = width$2; $f.width$3 = width$3; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	machine.prototype.tryBacktrack = function(b, i, pc, pos) { return this.$val.tryBacktrack(b, i, pc, pos); };
	machine.ptr.prototype.backtrack = function(i, pos, end, ncap) {
		var _i, _r, _r$1, _r$2, _r$3, _r$4, _ref, _tuple, advance, b, end, i, i$1, m, ncap, pos, startCond, width, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; _tuple = $f._tuple; advance = $f.advance; b = $f.b; end = $f.end; i = $f.i; i$1 = $f.i$1; m = $f.m; ncap = $f.ncap; pos = $f.pos; startCond = $f.startCond; width = $f.width; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		_r = i.canCheckPrefix(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!_r) { */ case 1:
			$panic(new $String("backtrack called for a RuneReader"));
		/* } */ case 2:
		startCond = m.re.regexpRO.cond;
		if (startCond === 255) {
			$s = -1; return false;
		}
		if (!((((startCond & 4) >>> 0) === 0)) && !((pos === 0))) {
			$s = -1; return false;
		}
		b = m.b;
		b.reset(end, ncap);
		m.matchcap = $subslice(m.matchcap, 0, ncap);
		_ref = m.matchcap;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i$1 = _i;
			(x = m.matchcap, ((i$1 < 0 || i$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i$1] = -1));
			_i++;
		}
		/* */ if (!((((startCond & 4) >>> 0) === 0))) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!((((startCond & 4) >>> 0) === 0))) { */ case 4:
			if (b.cap.$length > 0) {
				(x$1 = b.cap, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0] = pos));
			}
			_r$1 = m.tryBacktrack(b, i, ((m.p.Start >>> 0)), pos); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
		/* } */ case 5:
		width = -1;
		/* while (true) { */ case 7:
			/* if (!(pos <= end && !((width === 0)))) { break; } */ if(!(pos <= end && !((width === 0)))) { $s = 8; continue; }
			/* */ if (m.re.regexpRO.prefix.length > 0) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (m.re.regexpRO.prefix.length > 0) { */ case 9:
				_r$2 = i.index(m.re, pos); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				advance = _r$2;
				if (advance < 0) {
					$s = -1; return false;
				}
				pos = pos + (advance) >> 0;
			/* } */ case 10:
			if (b.cap.$length > 0) {
				(x$2 = b.cap, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0] = pos));
			}
			_r$3 = m.tryBacktrack(b, i, ((m.p.Start >>> 0)), pos); /* */ $s = 14; case 14: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			/* */ if (_r$3) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if (_r$3) { */ case 12:
				$s = -1; return true;
			/* } */ case 13:
			_r$4 = i.step(pos); /* */ $s = 15; case 15: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			_tuple = _r$4;
			width = _tuple[1];
			pos = pos + (width) >> 0;
		/* } */ $s = 7; continue; case 8:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: machine.ptr.prototype.backtrack }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f._tuple = _tuple; $f.advance = advance; $f.b = b; $f.end = end; $f.i = i; $f.i$1 = i$1; $f.m = m; $f.ncap = ncap; $f.pos = pos; $f.startCond = startCond; $f.width = width; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	machine.prototype.backtrack = function(i, pos, end, ncap) { return this.$val.backtrack(i, pos, end, ncap); };
	machine.ptr.prototype.newInputBytes = function(b) {
		var b, m;
		m = this;
		m.inputBytes.str = b;
		return m.inputBytes;
	};
	machine.prototype.newInputBytes = function(b) { return this.$val.newInputBytes(b); };
	machine.ptr.prototype.newInputString = function(s) {
		var m, s;
		m = this;
		m.inputString.str = s;
		return m.inputString;
	};
	machine.prototype.newInputString = function(s) { return this.$val.newInputString(s); };
	machine.ptr.prototype.newInputReader = function(r) {
		var m, r;
		m = this;
		m.inputReader.r = r;
		m.inputReader.atEOT = false;
		m.inputReader.pos = 0;
		return m.inputReader;
	};
	machine.prototype.newInputReader = function(r) { return this.$val.newInputReader(r); };
	progMachine = function(p, op) {
		var m, n, ncap, op, p;
		m = new machine.ptr(ptrType$3.nil, p, op, 0, ptrType.nil, new queue.ptr(sliceType$1.nil, sliceType$4.nil), new queue.ptr(sliceType$1.nil, sliceType$4.nil), sliceType$5.nil, false, sliceType$2.nil, new inputBytes.ptr(sliceType$6.nil), new inputString.ptr(""), new inputReader.ptr($ifaceNil, false, 0));
		n = m.p.Inst.$length;
		queue.copy(m.q0, new queue.ptr($makeSlice(sliceType$1, n), $makeSlice(sliceType$4, 0, n)));
		queue.copy(m.q1, new queue.ptr($makeSlice(sliceType$1, n), $makeSlice(sliceType$4, 0, n)));
		ncap = p.NumCap;
		if (ncap < 2) {
			ncap = 2;
		}
		if (op === notOnePass) {
			m.maxBitStateLen = maxBitStateLen(p);
		}
		m.matchcap = $makeSlice(sliceType$2, ncap);
		return m;
	};
	machine.ptr.prototype.init = function(ncap) {
		var _i, _ref, m, ncap, t;
		m = this;
		_ref = m.pool;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			t = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			t.cap = $subslice(t.cap, 0, ncap);
			_i++;
		}
		m.matchcap = $subslice(m.matchcap, 0, ncap);
	};
	machine.prototype.init = function(ncap) { return this.$val.init(ncap); };
	machine.ptr.prototype.alloc = function(i) {
		var i, m, n, t, x, x$1;
		m = this;
		t = ptrType$4.nil;
		n = m.pool.$length;
		if (n > 0) {
			t = (x = m.pool, x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			m.pool = $subslice(m.pool, 0, (n - 1 >> 0));
		} else {
			t = new thread.ptr(ptrType$5.nil, sliceType$2.nil);
			t.cap = $makeSlice(sliceType$2, m.matchcap.$length, m.matchcap.$capacity);
		}
		t.inst = i;
		return t;
	};
	machine.prototype.alloc = function(i) { return this.$val.alloc(i); };
	machine.ptr.prototype.match = function(i, pos) {
		var _i, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _v, advance, flag, i, i$1, m, nextq, pos, r, r1, runq, startCond, width, width1, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _v = $f._v; advance = $f.advance; flag = $f.flag; i = $f.i; i$1 = $f.i$1; m = $f.m; nextq = $f.nextq; pos = $f.pos; r = $f.r; r1 = $f.r1; runq = $f.runq; startCond = $f.startCond; width = $f.width; width1 = $f.width1; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		startCond = m.re.regexpRO.cond;
		if (startCond === 255) {
			$s = -1; return false;
		}
		m.matched = false;
		_ref = m.matchcap;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i$1 = _i;
			(x = m.matchcap, ((i$1 < 0 || i$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i$1] = -1));
			_i++;
		}
		_tmp = m.q0;
		_tmp$1 = m.q1;
		runq = _tmp;
		nextq = _tmp$1;
		_tmp$2 = -1;
		_tmp$3 = -1;
		r = _tmp$2;
		r1 = _tmp$3;
		_tmp$4 = 0;
		_tmp$5 = 0;
		width = _tmp$4;
		width1 = _tmp$5;
		_r = i.step(pos); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		width = _tuple[1];
		/* */ if (!((r === -1))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((r === -1))) { */ case 2:
			_r$1 = i.step(pos + width >> 0); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			r1 = _tuple$1[0];
			width1 = _tuple$1[1];
		/* } */ case 3:
		flag = 0;
		/* */ if (pos === 0) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (pos === 0) { */ case 5:
			flag = syntax.EmptyOpContext(-1, r);
			$s = 7; continue;
		/* } else { */ case 6:
			_r$2 = i.context(pos); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			flag = _r$2;
		/* } */ case 7:
		/* while (true) { */ case 9:
			/* */ if (runq.dense.$length === 0) { $s = 11; continue; }
			/* */ $s = 12; continue;
			/* if (runq.dense.$length === 0) { */ case 11:
				if (!((((startCond & 4) >>> 0) === 0)) && !((pos === 0))) {
					/* break; */ $s = 10; continue;
				}
				if (m.matched) {
					/* break; */ $s = 10; continue;
				}
				if (!(m.re.regexpRO.prefix.length > 0 && !((r1 === m.re.regexpRO.prefixRune)))) { _v = false; $s = 15; continue s; }
				_r$3 = i.canCheckPrefix(); /* */ $s = 16; case 16: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				_v = _r$3; case 15:
				/* */ if (_v) { $s = 13; continue; }
				/* */ $s = 14; continue;
				/* if (_v) { */ case 13:
					_r$4 = i.index(m.re, pos); /* */ $s = 17; case 17: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					advance = _r$4;
					if (advance < 0) {
						/* break; */ $s = 10; continue;
					}
					pos = pos + (advance) >> 0;
					_r$5 = i.step(pos); /* */ $s = 18; case 18: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
					_tuple$2 = _r$5;
					r = _tuple$2[0];
					width = _tuple$2[1];
					_r$6 = i.step(pos + width >> 0); /* */ $s = 19; case 19: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
					_tuple$3 = _r$6;
					r1 = _tuple$3[0];
					width1 = _tuple$3[1];
				/* } */ case 14:
			/* } */ case 12:
			if (!m.matched) {
				if (m.matchcap.$length > 0) {
					(x$1 = m.matchcap, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0] = pos));
				}
				m.add(runq, ((m.p.Start >>> 0)), pos, m.matchcap, flag, ptrType$4.nil);
			}
			flag = syntax.EmptyOpContext(r, r1);
			m.step(runq, nextq, pos, pos + width >> 0, r, flag);
			if (width === 0) {
				/* break; */ $s = 10; continue;
			}
			if ((m.matchcap.$length === 0) && m.matched) {
				/* break; */ $s = 10; continue;
			}
			pos = pos + (width) >> 0;
			_tmp$6 = r1;
			_tmp$7 = width1;
			r = _tmp$6;
			width = _tmp$7;
			/* */ if (!((r === -1))) { $s = 20; continue; }
			/* */ $s = 21; continue;
			/* if (!((r === -1))) { */ case 20:
				_r$7 = i.step(pos + width >> 0); /* */ $s = 22; case 22: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				_tuple$4 = _r$7;
				r1 = _tuple$4[0];
				width1 = _tuple$4[1];
			/* } */ case 21:
			_tmp$8 = nextq;
			_tmp$9 = runq;
			runq = _tmp$8;
			nextq = _tmp$9;
		/* } */ $s = 9; continue; case 10:
		m.clear(nextq);
		$s = -1; return m.matched;
		/* */ } return; } if ($f === undefined) { $f = { $blk: machine.ptr.prototype.match }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._v = _v; $f.advance = advance; $f.flag = flag; $f.i = i; $f.i$1 = i$1; $f.m = m; $f.nextq = nextq; $f.pos = pos; $f.r = r; $f.r1 = r1; $f.runq = runq; $f.startCond = startCond; $f.width = width; $f.width1 = width1; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	machine.prototype.match = function(i, pos) { return this.$val.match(i, pos); };
	machine.ptr.prototype.clear = function(q) {
		var _i, _ref, d, m, q;
		m = this;
		_ref = q.dense;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			d = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), entry);
			if (!(d.t === ptrType$4.nil)) {
				m.pool = $append(m.pool, d.t);
			}
			_i++;
		}
		q.dense = $subslice(q.dense, 0, 0);
	};
	machine.prototype.clear = function(q) { return this.$val.clear(q); };
	machine.ptr.prototype.step = function(runq, nextq, pos, nextPos, c, nextCond) {
		var _1, _i, _ref, add, c, d, d$1, i, j, longest, m, nextCond, nextPos, nextq, pos, runq, t, x, x$1, x$2, x$3, x$4, x$5;
		m = this;
		longest = m.re.regexpRO.longest;
		j = 0;
		while (true) {
			if (!(j < runq.dense.$length)) { break; }
			d = (x = runq.dense, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]));
			t = d.t;
			if (t === ptrType$4.nil) {
				j = j + (1) >> 0;
				continue;
			}
			if (longest && m.matched && t.cap.$length > 0 && (x$1 = m.matchcap, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])) < (x$2 = t.cap, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0]))) {
				m.pool = $append(m.pool, t);
				j = j + (1) >> 0;
				continue;
			}
			i = t.inst;
			add = false;
			_1 = i.Op;
			if (_1 === (4)) {
				if (t.cap.$length > 0 && (!longest || !m.matched || (x$3 = m.matchcap, (1 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 1])) < pos)) {
					(x$4 = t.cap, (1 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 1] = pos));
					$copySlice(m.matchcap, t.cap);
				}
				if (!longest) {
					_ref = $subslice(runq.dense, (j + 1 >> 0));
					_i = 0;
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						d$1 = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), entry);
						if (!(d$1.t === ptrType$4.nil)) {
							m.pool = $append(m.pool, d$1.t);
						}
						_i++;
					}
					runq.dense = $subslice(runq.dense, 0, 0);
				}
				m.matched = true;
			} else if (_1 === (7)) {
				add = i.MatchRune(c);
			} else if (_1 === (8)) {
				add = c === (x$5 = i.Rune, (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0]));
			} else if (_1 === (9)) {
				add = true;
			} else if (_1 === (10)) {
				add = !((c === 10));
			} else {
				$panic(new $String("bad inst"));
			}
			if (add) {
				t = m.add(nextq, i.Out, nextPos, t.cap, nextCond, t);
			}
			if (!(t === ptrType$4.nil)) {
				m.pool = $append(m.pool, t);
			}
			j = j + (1) >> 0;
		}
		runq.dense = $subslice(runq.dense, 0, 0);
	};
	machine.prototype.step = function(runq, nextq, pos, nextPos, c, nextCond) { return this.$val.step(runq, nextq, pos, nextPos, c, nextCond); };
	machine.ptr.prototype.add = function(q, pc, pos, cap, cond, t) {
		var _1, cap, cond, d, i, j, j$1, m, opos, pc, pos, q, t, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8;
		m = this;
		if (pc === 0) {
			return t;
		}
		j = (x = q.sparse, ((pc < 0 || pc >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pc]));
		if (j < ((q.dense.$length >>> 0)) && ((x$1 = q.dense, ((j < 0 || j >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + j])).pc === pc)) {
			return t;
		}
		j$1 = q.dense.$length;
		q.dense = $subslice(q.dense, 0, (j$1 + 1 >> 0));
		d = (x$2 = q.dense, ((j$1 < 0 || j$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + j$1]));
		d.t = ptrType$4.nil;
		d.pc = pc;
		(x$3 = q.sparse, ((pc < 0 || pc >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + pc] = ((j$1 >>> 0))));
		i = (x$4 = m.p.Inst, ((pc < 0 || pc >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + pc]));
		_1 = i.Op;
		if (_1 === (5)) {
		} else if ((_1 === (0)) || (_1 === (1))) {
			t = m.add(q, i.Out, pos, cap, cond, t);
			t = m.add(q, i.Arg, pos, cap, cond, t);
		} else if (_1 === (3)) {
			if (((((i.Arg << 24 >>> 24)) & ~cond) << 24 >>> 24) === 0) {
				t = m.add(q, i.Out, pos, cap, cond, t);
			}
		} else if (_1 === (6)) {
			t = m.add(q, i.Out, pos, cap, cond, t);
		} else if (_1 === (2)) {
			if (((i.Arg >> 0)) < cap.$length) {
				opos = (x$5 = i.Arg, ((x$5 < 0 || x$5 >= cap.$length) ? ($throwRuntimeError("index out of range"), undefined) : cap.$array[cap.$offset + x$5]));
				(x$6 = i.Arg, ((x$6 < 0 || x$6 >= cap.$length) ? ($throwRuntimeError("index out of range"), undefined) : cap.$array[cap.$offset + x$6] = pos));
				m.add(q, i.Out, pos, cap, cond, ptrType$4.nil);
				(x$7 = i.Arg, ((x$7 < 0 || x$7 >= cap.$length) ? ($throwRuntimeError("index out of range"), undefined) : cap.$array[cap.$offset + x$7] = opos));
			} else {
				t = m.add(q, i.Out, pos, cap, cond, t);
			}
		} else if ((_1 === (4)) || (_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10))) {
			if (t === ptrType$4.nil) {
				t = m.alloc(i);
			} else {
				t.inst = i;
			}
			if (cap.$length > 0 && !((x$8 = t.cap, $indexPtr(x$8.$array, x$8.$offset + 0, ptrType$6)) === $indexPtr(cap.$array, cap.$offset + 0, ptrType$6))) {
				$copySlice(t.cap, cap);
			}
			d.t = t;
			t = ptrType$4.nil;
		} else {
			$panic(new $String("unhandled"));
		}
		return t;
	};
	machine.prototype.add = function(q, pc, pos, cap, cond, t) { return this.$val.add(q, pc, pos, cap, cond, t); };
	machine.ptr.prototype.onepass = function(i, pos, ncap) {
		var _1, _i, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _v, flag, i, i$1, inst, m, ncap, pc, pos, r, r1, startCond, width, width1, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _v = $f._v; flag = $f.flag; i = $f.i; i$1 = $f.i$1; inst = $f.inst; m = $f.m; ncap = $f.ncap; pc = $f.pc; pos = $f.pos; r = $f.r; r1 = $f.r1; startCond = $f.startCond; width = $f.width; width1 = $f.width1; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		inst = [inst];
		m = this;
		startCond = m.re.regexpRO.cond;
		if (startCond === 255) {
			$s = -1; return false;
		}
		m.matched = false;
		m.matchcap = $subslice(m.matchcap, 0, ncap);
		_ref = m.matchcap;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i$1 = _i;
			(x = m.matchcap, ((i$1 < 0 || i$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i$1] = -1));
			_i++;
		}
		_tmp = -1;
		_tmp$1 = -1;
		r = _tmp;
		r1 = _tmp$1;
		_tmp$2 = 0;
		_tmp$3 = 0;
		width = _tmp$2;
		width1 = _tmp$3;
		_r = i.step(pos); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		width = _tuple[1];
		/* */ if (!((r === -1))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((r === -1))) { */ case 2:
			_r$1 = i.step(pos + width >> 0); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			r1 = _tuple$1[0];
			width1 = _tuple$1[1];
		/* } */ case 3:
		flag = 0;
		/* */ if (pos === 0) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (pos === 0) { */ case 5:
			flag = syntax.EmptyOpContext(-1, r);
			$s = 7; continue;
		/* } else { */ case 6:
			_r$2 = i.context(pos); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			flag = _r$2;
		/* } */ case 7:
		pc = m.op.Start;
		inst[0] = $clone((x$1 = m.op.Inst, ((pc < 0 || pc >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + pc])), onePassInst);
		if (!((pos === 0) && (((((inst[0].Inst.Arg << 24 >>> 24)) & ~flag) << 24 >>> 24) === 0) && m.re.regexpRO.prefix.length > 0)) { _v = false; $s = 11; continue s; }
		_r$3 = i.canCheckPrefix(); /* */ $s = 12; case 12: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_v = _r$3; case 11:
		/* */ if (_v) { $s = 9; continue; }
		/* */ $s = 10; continue;
		/* if (_v) { */ case 9:
			_r$4 = i.hasPrefix(m.re); /* */ $s = 16; case 16: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			/* */ if (_r$4) { $s = 13; continue; }
			/* */ $s = 14; continue;
			/* if (_r$4) { */ case 13:
				pos = pos + (m.re.regexpRO.prefix.length) >> 0;
				_r$5 = i.step(pos); /* */ $s = 17; case 17: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				_tuple$2 = _r$5;
				r = _tuple$2[0];
				width = _tuple$2[1];
				_r$6 = i.step(pos + width >> 0); /* */ $s = 18; case 18: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_tuple$3 = _r$6;
				r1 = _tuple$3[0];
				width1 = _tuple$3[1];
				_r$7 = i.context(pos); /* */ $s = 19; case 19: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				flag = _r$7;
				pc = ((m.re.regexpRO.prefixEnd >> 0));
				$s = 15; continue;
			/* } else { */ case 14:
				$s = -1; return m.matched;
			/* } */ case 15:
		/* } */ case 10:
		/* while (true) { */ case 20:
			onePassInst.copy(inst[0], (x$2 = m.op.Inst, ((pc < 0 || pc >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + pc])));
			pc = ((inst[0].Inst.Out >> 0));
				_1 = inst[0].Inst.Op;
				/* */ if (_1 === (4)) { $s = 23; continue; }
				/* */ if (_1 === (7)) { $s = 24; continue; }
				/* */ if (_1 === (8)) { $s = 25; continue; }
				/* */ if (_1 === (9)) { $s = 26; continue; }
				/* */ if (_1 === (10)) { $s = 27; continue; }
				/* */ if ((_1 === (0)) || (_1 === (1))) { $s = 28; continue; }
				/* */ if (_1 === (5)) { $s = 29; continue; }
				/* */ if (_1 === (6)) { $s = 30; continue; }
				/* */ if (_1 === (3)) { $s = 31; continue; }
				/* */ if (_1 === (2)) { $s = 32; continue; }
				/* */ $s = 33; continue;
				/* if (_1 === (4)) { */ case 23:
					m.matched = true;
					if (m.matchcap.$length > 0) {
						(x$3 = m.matchcap, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0] = 0));
						(x$4 = m.matchcap, (1 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 1] = pos));
					}
					$s = -1; return m.matched;
				/* } else if (_1 === (7)) { */ case 24:
					if (!inst[0].Inst.MatchRune(r)) {
						$s = -1; return m.matched;
					}
					$s = 34; continue;
				/* } else if (_1 === (8)) { */ case 25:
					if (!((r === (x$5 = inst[0].Inst.Rune, (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0]))))) {
						$s = -1; return m.matched;
					}
					$s = 34; continue;
				/* } else if (_1 === (9)) { */ case 26:
					$s = 34; continue;
				/* } else if (_1 === (10)) { */ case 27:
					if (r === 10) {
						$s = -1; return m.matched;
					}
					$s = 34; continue;
				/* } else if ((_1 === (0)) || (_1 === (1))) { */ case 28:
					pc = ((onePassNext(inst[0], r) >> 0));
					/* continue; */ $s = 20; continue;
					$s = 34; continue;
				/* } else if (_1 === (5)) { */ case 29:
					$s = -1; return m.matched;
				/* } else if (_1 === (6)) { */ case 30:
					/* continue; */ $s = 20; continue;
					$s = 34; continue;
				/* } else if (_1 === (3)) { */ case 31:
					if (!((((((inst[0].Inst.Arg << 24 >>> 24)) & ~flag) << 24 >>> 24) === 0))) {
						$s = -1; return m.matched;
					}
					/* continue; */ $s = 20; continue;
					$s = 34; continue;
				/* } else if (_1 === (2)) { */ case 32:
					if (((inst[0].Inst.Arg >> 0)) < m.matchcap.$length) {
						(x$6 = m.matchcap, x$7 = inst[0].Inst.Arg, ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7] = pos));
					}
					/* continue; */ $s = 20; continue;
					$s = 34; continue;
				/* } else { */ case 33:
					$panic(new $String("bad inst"));
				/* } */ case 34:
			case 22:
			if (width === 0) {
				/* break; */ $s = 21; continue;
			}
			flag = syntax.EmptyOpContext(r, r1);
			pos = pos + (width) >> 0;
			_tmp$4 = r1;
			_tmp$5 = width1;
			r = _tmp$4;
			width = _tmp$5;
			/* */ if (!((r === -1))) { $s = 35; continue; }
			/* */ $s = 36; continue;
			/* if (!((r === -1))) { */ case 35:
				_r$8 = i.step(pos + width >> 0); /* */ $s = 37; case 37: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				_tuple$4 = _r$8;
				r1 = _tuple$4[0];
				width1 = _tuple$4[1];
			/* } */ case 36:
		/* } */ $s = 20; continue; case 21:
		$s = -1; return m.matched;
		/* */ } return; } if ($f === undefined) { $f = { $blk: machine.ptr.prototype.onepass }; } $f._1 = _1; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._v = _v; $f.flag = flag; $f.i = i; $f.i$1 = i$1; $f.inst = inst; $f.m = m; $f.ncap = ncap; $f.pc = pc; $f.pos = pos; $f.r = r; $f.r1 = r1; $f.startCond = startCond; $f.width = width; $f.width1 = width1; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.$s = $s; $f.$r = $r; return $f;
	};
	machine.prototype.onepass = function(i, pos, ncap) { return this.$val.onepass(i, pos, ncap); };
	Regexp.ptr.prototype.doMatch = function(r, b, s) {
		var _r, b, r, re, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; r = $f.r; re = $f.re; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doExecute(r, b, s, 0, 0, sliceType$2.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return !(_r === sliceType$2.nil);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.doMatch }; } $f._r = _r; $f.b = b; $f.r = r; $f.re = re; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.doMatch = function(r, b, s) { return this.$val.doMatch(r, b, s); };
	Regexp.ptr.prototype.doExecute = function(r, b, s, pos, ncap, dstCap) {
		var _r, _r$1, _r$2, b, dstCap, i, m, ncap, pos, r, re, s, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; b = $f.b; dstCap = $f.dstCap; i = $f.i; m = $f.m; ncap = $f.ncap; pos = $f.pos; r = $f.r; re = $f.re; s = $f.s; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		m = re.get();
		i = $ifaceNil;
		size = 0;
		if (!($interfaceIsEqual(r, $ifaceNil))) {
			i = m.newInputReader(r);
		} else if (!(b === sliceType$6.nil)) {
			i = m.newInputBytes(b);
			size = b.$length;
		} else {
			i = m.newInputString(s);
			size = s.length;
		}
		/* */ if (!(m.op === notOnePass)) { $s = 1; continue; }
		/* */ if (size < m.maxBitStateLen && $interfaceIsEqual(r, $ifaceNil)) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!(m.op === notOnePass)) { */ case 1:
			_r = m.onepass(i, pos, ncap); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (!_r) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (!_r) { */ case 5:
				re.put(m);
				$s = -1; return sliceType$2.nil;
			/* } */ case 6:
			$s = 4; continue;
		/* } else if (size < m.maxBitStateLen && $interfaceIsEqual(r, $ifaceNil)) { */ case 2:
			if (m.b === ptrType.nil) {
				m.b = newBitState(m.p);
			}
			_r$1 = m.backtrack(i, pos, size, ncap); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (!_r$1) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (!_r$1) { */ case 8:
				re.put(m);
				$s = -1; return sliceType$2.nil;
			/* } */ case 9:
			$s = 4; continue;
		/* } else { */ case 3:
			m.init(ncap);
			_r$2 = m.match(i, pos); /* */ $s = 13; case 13: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			/* */ if (!_r$2) { $s = 11; continue; }
			/* */ $s = 12; continue;
			/* if (!_r$2) { */ case 11:
				re.put(m);
				$s = -1; return sliceType$2.nil;
			/* } */ case 12:
		/* } */ case 4:
		dstCap = $appendSlice(dstCap, m.matchcap);
		if (dstCap === sliceType$2.nil) {
			dstCap = $subslice(new sliceType$2(arrayNoInts), 0, 0);
		}
		re.put(m);
		$s = -1; return dstCap;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.doExecute }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.b = b; $f.dstCap = dstCap; $f.i = i; $f.m = m; $f.ncap = ncap; $f.pos = pos; $f.r = r; $f.re = re; $f.s = s; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.doExecute = function(r, b, s, pos, ncap, dstCap) { return this.$val.doExecute(r, b, s, pos, ncap, dstCap); };
	onePassPrefix = function(p) {
		var _tmp, _tmp$1, _tmp$10, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, buf, complete, i, p, pc, prefix, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8;
		prefix = "";
		complete = false;
		pc = 0;
		i = (x = p.Inst, x$1 = p.Start, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (!((i.Op === 3)) || ((((((i.Arg << 24 >>> 24))) & 4) >>> 0) === 0)) {
			_tmp = "";
			_tmp$1 = i.Op === 4;
			_tmp$2 = ((p.Start >>> 0));
			prefix = _tmp;
			complete = _tmp$1;
			pc = _tmp$2;
			return [prefix, complete, pc];
		}
		pc = i.Out;
		i = (x$2 = p.Inst, ((pc < 0 || pc >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + pc]));
		while (true) {
			if (!(i.Op === 6)) { break; }
			pc = i.Out;
			i = (x$3 = p.Inst, ((pc < 0 || pc >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + pc]));
		}
		if (!((iop(i) === 7)) || !((i.Rune.$length === 1))) {
			_tmp$3 = "";
			_tmp$4 = i.Op === 4;
			_tmp$5 = ((p.Start >>> 0));
			prefix = _tmp$3;
			complete = _tmp$4;
			pc = _tmp$5;
			return [prefix, complete, pc];
		}
		buf = new bytes.Buffer.ptr(sliceType$6.nil, 0, 0, arrayType$2.zero());
		while (true) {
			if (!((iop(i) === 7) && (i.Rune.$length === 1) && (((((i.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { break; }
			buf.WriteRune((x$4 = i.Rune, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0])));
			_tmp$6 = i.Out;
			_tmp$7 = (x$5 = p.Inst, x$6 = i.Out, ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6]));
			pc = _tmp$6;
			i = _tmp$7;
		}
		if ((i.Op === 3) && !((((((i.Arg << 24 >>> 24)) & 8) >>> 0) === 0)) && ((x$7 = p.Inst, x$8 = i.Out, ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8])).Op === 4)) {
			complete = true;
		}
		_tmp$8 = buf.String();
		_tmp$9 = complete;
		_tmp$10 = pc;
		prefix = _tmp$8;
		complete = _tmp$9;
		pc = _tmp$10;
		return [prefix, complete, pc];
	};
	onePassNext = function(i, r) {
		var i, next, r, x;
		next = i.Inst.MatchRunePos(r);
		if (next >= 0) {
			return (x = i.Next, ((next < 0 || next >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + next]));
		}
		if (i.Inst.Op === 1) {
			return i.Inst.Out;
		}
		return 0;
	};
	iop = function(i) {
		var _1, i, op;
		op = i.Op;
		_1 = op;
		if ((_1 === (8)) || (_1 === (9)) || (_1 === (10))) {
			op = 7;
		}
		return op;
	};
	queueOnePass.ptr.prototype.empty = function() {
		var q;
		q = this;
		return q.nextIndex >= q.size;
	};
	queueOnePass.prototype.empty = function() { return this.$val.empty(); };
	queueOnePass.ptr.prototype.next = function() {
		var n, q, x, x$1;
		n = 0;
		q = this;
		n = (x = q.dense, x$1 = q.nextIndex, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		q.nextIndex = q.nextIndex + (1) >>> 0;
		return n;
	};
	queueOnePass.prototype.next = function() { return this.$val.next(); };
	queueOnePass.ptr.prototype.clear = function() {
		var q;
		q = this;
		q.size = 0;
		q.nextIndex = 0;
	};
	queueOnePass.prototype.clear = function() { return this.$val.clear(); };
	queueOnePass.ptr.prototype.contains = function(u) {
		var q, u, x, x$1, x$2, x$3;
		q = this;
		if (u >= ((q.sparse.$length >>> 0))) {
			return false;
		}
		return (x = q.sparse, ((u < 0 || u >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + u])) < q.size && ((x$1 = q.dense, x$2 = (x$3 = q.sparse, ((u < 0 || u >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + u])), ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2])) === u);
	};
	queueOnePass.prototype.contains = function(u) { return this.$val.contains(u); };
	queueOnePass.ptr.prototype.insert = function(u) {
		var q, u;
		q = this;
		if (!q.contains(u)) {
			q.insertNew(u);
		}
	};
	queueOnePass.prototype.insert = function(u) { return this.$val.insert(u); };
	queueOnePass.ptr.prototype.insertNew = function(u) {
		var q, u, x, x$1, x$2;
		q = this;
		if (u >= ((q.sparse.$length >>> 0))) {
			return;
		}
		(x = q.sparse, ((u < 0 || u >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + u] = q.size));
		(x$1 = q.dense, x$2 = q.size, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2] = u));
		q.size = q.size + (1) >>> 0;
	};
	queueOnePass.prototype.insertNew = function(u) { return this.$val.insertNew(u); };
	newQueue = function(size) {
		var q, size;
		q = ptrType$7.nil;
		q = new queueOnePass.ptr($makeSlice(sliceType$1, size), $makeSlice(sliceType$1, size), 0, 0);
		return q;
	};
	mergeRuneSets = function(leftRunes, rightRunes, leftPC, rightPC) {
		var _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, extend, ix, leftLen, leftPC, leftRunes, lx, merged, next, ok, rightLen, rightPC, rightRunes, rx, x, x$1, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; extend = $f.extend; ix = $f.ix; leftLen = $f.leftLen; leftPC = $f.leftPC; leftRunes = $f.leftRunes; lx = $f.lx; merged = $f.merged; next = $f.next; ok = $f.ok; rightLen = $f.rightLen; rightPC = $f.rightPC; rightRunes = $f.rightRunes; rx = $f.rx; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		ix = [ix];
		lx = [lx];
		merged = [merged];
		next = [next];
		ok = [ok];
		rx = [rx];
		leftLen = leftRunes.$get().$length;
		rightLen = rightRunes.$get().$length;
		if (!(((leftLen & 1) === 0)) || !(((rightLen & 1) === 0))) {
			$panic(new $String("mergeRuneSets odd length []rune"));
		}
		_tmp = 0;
		_tmp$1 = 0;
		lx[0] = _tmp;
		rx[0] = _tmp$1;
		merged[0] = $makeSlice(sliceType, 0);
		next[0] = $makeSlice(sliceType$1, 0);
		ok[0] = true;
		$deferred.push([(function(ix, lx, merged, next, ok, rx) { return function() {
			if (!ok[0]) {
				merged[0] = sliceType.nil;
				next[0] = sliceType$1.nil;
			}
		}; })(ix, lx, merged, next, ok, rx), []]);
		ix[0] = -1;
		extend = (function(ix, lx, merged, next, ok, rx) { return function(newLow, newArray, pc) {
			var newArray, newLow, pc, x, x$1, x$2, x$3, x$4, x$5;
			if (ix[0] > 0 && (x = newArray.$get(), x$1 = newLow.$get(), ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])) <= ((ix[0] < 0 || ix[0] >= merged[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : merged[0].$array[merged[0].$offset + ix[0]])) {
				return false;
			}
			merged[0] = $append(merged[0], (x$2 = newArray.$get(), x$3 = newLow.$get(), ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])), (x$4 = newArray.$get(), x$5 = newLow.$get() + 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])));
			newLow.$set(newLow.$get() + (2) >> 0);
			ix[0] = ix[0] + (2) >> 0;
			next[0] = $append(next[0], pc);
			return true;
		}; })(ix, lx, merged, next, ok, rx);
		/* while (true) { */ case 1:
			/* if (!(lx[0] < leftLen || rx[0] < rightLen)) { break; } */ if(!(lx[0] < leftLen || rx[0] < rightLen)) { $s = 2; continue; }
				/* */ if (rx[0] >= rightLen) { $s = 4; continue; }
				/* */ if (lx[0] >= leftLen) { $s = 5; continue; }
				/* */ if ((x = rightRunes.$get(), ((rx[0] < 0 || rx[0] >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + rx[0]])) < (x$1 = leftRunes.$get(), ((lx[0] < 0 || lx[0] >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + lx[0]]))) { $s = 6; continue; }
				/* */ $s = 7; continue;
				/* if (rx[0] >= rightLen) { */ case 4:
					_r = extend((lx.$ptr || (lx.$ptr = new ptrType$6(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, lx))), leftRunes, leftPC); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					ok[0] = _r;
					$s = 8; continue;
				/* } else if (lx[0] >= leftLen) { */ case 5:
					_r$1 = extend((rx.$ptr || (rx.$ptr = new ptrType$6(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, rx))), rightRunes, rightPC); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					ok[0] = _r$1;
					$s = 8; continue;
				/* } else if ((x = rightRunes.$get(), ((rx[0] < 0 || rx[0] >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + rx[0]])) < (x$1 = leftRunes.$get(), ((lx[0] < 0 || lx[0] >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + lx[0]]))) { */ case 6:
					_r$2 = extend((rx.$ptr || (rx.$ptr = new ptrType$6(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, rx))), rightRunes, rightPC); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					ok[0] = _r$2;
					$s = 8; continue;
				/* } else { */ case 7:
					_r$3 = extend((lx.$ptr || (lx.$ptr = new ptrType$6(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, lx))), leftRunes, leftPC); /* */ $s = 12; case 12: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					ok[0] = _r$3;
				/* } */ case 8:
			case 3:
			if (!ok[0]) {
				$s = -1; return [noRune, noNext];
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [merged[0], next[0]];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [sliceType.nil, sliceType$1.nil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: mergeRuneSets }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.extend = extend; $f.ix = ix; $f.leftLen = leftLen; $f.leftPC = leftPC; $f.leftRunes = leftRunes; $f.lx = lx; $f.merged = merged; $f.next = next; $f.ok = ok; $f.rightLen = rightLen; $f.rightPC = rightPC; $f.rightRunes = rightRunes; $f.rx = rx; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	cleanupOnePass = function(prog, original) {
		var _1, _i, _ref, instOriginal, ix, original, prog, x, x$1, x$2;
		_ref = original.Inst;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			ix = _i;
			instOriginal = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), syntax.Inst);
			_1 = instOriginal.Op;
			if ((_1 === (0)) || (_1 === (1)) || (_1 === (7))) {
			} else if ((_1 === (2)) || (_1 === (3)) || (_1 === (6)) || (_1 === (4)) || (_1 === (5))) {
				(x = prog.Inst, ((ix < 0 || ix >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + ix])).Next = sliceType$1.nil;
			} else if ((_1 === (8)) || (_1 === (9)) || (_1 === (10))) {
				(x$1 = prog.Inst, ((ix < 0 || ix >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + ix])).Next = sliceType$1.nil;
				onePassInst.copy((x$2 = prog.Inst, ((ix < 0 || ix >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + ix])), new onePassInst.ptr($clone(instOriginal, syntax.Inst), sliceType$1.nil));
			}
			_i++;
		}
	};
	onePassCopy = function(prog) {
		var _1, _i, _i$1, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, i, inst, instAlt, instOther, p, p_A_Alt, p_A_Other, p_B_Alt, p_B_Other, patch, pc, prog, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		p = new onePassProg.ptr($makeSlice(sliceType$7, prog.Inst.$length), prog.Start, prog.NumCap);
		_ref = prog.Inst;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			inst = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), syntax.Inst);
			onePassInst.copy((x = p.Inst, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])), new onePassInst.ptr($clone(inst, syntax.Inst), sliceType$1.nil));
			_i++;
		}
		_ref$1 = p.Inst;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			pc = _i$1;
			_1 = (x$1 = p.Inst, ((pc < 0 || pc >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + pc])).Inst.Op;
			if ((_1 === (0)) || (_1 === (1))) {
				p_A_Other = (x$2 = (x$3 = p.Inst, ((pc < 0 || pc >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + pc])), (x$2.$ptr_Out || (x$2.$ptr_Out = new ptrType$8(function() { return this.$target.Inst.Out; }, function($v) { this.$target.Inst.Out = $v; }, x$2))));
				p_A_Alt = (x$4 = (x$5 = p.Inst, ((pc < 0 || pc >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + pc])), (x$4.$ptr_Arg || (x$4.$ptr_Arg = new ptrType$8(function() { return this.$target.Inst.Arg; }, function($v) { this.$target.Inst.Arg = $v; }, x$4))));
				instAlt = $clone((x$6 = p.Inst, x$7 = p_A_Alt.$get(), ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7])), onePassInst);
				if (!((instAlt.Inst.Op === 0) || (instAlt.Inst.Op === 1))) {
					_tmp = p_A_Other;
					_tmp$1 = p_A_Alt;
					p_A_Alt = _tmp;
					p_A_Other = _tmp$1;
					onePassInst.copy(instAlt, (x$8 = p.Inst, x$9 = p_A_Alt.$get(), ((x$9 < 0 || x$9 >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + x$9])));
					if (!((instAlt.Inst.Op === 0) || (instAlt.Inst.Op === 1))) {
						_i$1++;
						continue;
					}
				}
				instOther = $clone((x$10 = p.Inst, x$11 = p_A_Other.$get(), ((x$11 < 0 || x$11 >= x$10.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + x$11])), onePassInst);
				if ((instOther.Inst.Op === 0) || (instOther.Inst.Op === 1)) {
					_i$1++;
					continue;
				}
				p_B_Alt = (x$12 = (x$13 = p.Inst, x$14 = p_A_Alt.$get(), ((x$14 < 0 || x$14 >= x$13.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$13.$array[x$13.$offset + x$14])), (x$12.$ptr_Out || (x$12.$ptr_Out = new ptrType$8(function() { return this.$target.Inst.Out; }, function($v) { this.$target.Inst.Out = $v; }, x$12))));
				p_B_Other = (x$15 = (x$16 = p.Inst, x$17 = p_A_Alt.$get(), ((x$17 < 0 || x$17 >= x$16.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$16.$array[x$16.$offset + x$17])), (x$15.$ptr_Arg || (x$15.$ptr_Arg = new ptrType$8(function() { return this.$target.Inst.Arg; }, function($v) { this.$target.Inst.Arg = $v; }, x$15))));
				patch = false;
				if (instAlt.Inst.Out === ((pc >>> 0))) {
					patch = true;
				} else if (instAlt.Inst.Arg === ((pc >>> 0))) {
					patch = true;
					_tmp$2 = p_B_Other;
					_tmp$3 = p_B_Alt;
					p_B_Alt = _tmp$2;
					p_B_Other = _tmp$3;
				}
				if (patch) {
					p_B_Alt.$set(p_A_Other.$get());
				}
				if (p_A_Other.$get() === p_B_Alt.$get()) {
					p_A_Alt.$set(p_B_Other.$get());
				}
			} else {
				_i$1++;
				continue;
			}
			_i$1++;
		}
		return p;
	};
	runeSlice.prototype.Len = function() {
		var p;
		p = this;
		return p.$length;
	};
	$ptrType(runeSlice).prototype.Len = function() { return this.$get().Len(); };
	runeSlice.prototype.Less = function(i, j) {
		var i, j, p;
		p = this;
		return ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]) < ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j]);
	};
	$ptrType(runeSlice).prototype.Less = function(i, j) { return this.$get().Less(i, j); };
	runeSlice.prototype.Swap = function(i, j) {
		var _tmp, _tmp$1, i, j, p;
		p = this;
		_tmp = ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j]);
		_tmp$1 = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]);
		((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i] = _tmp);
		((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j] = _tmp$1);
	};
	$ptrType(runeSlice).prototype.Swap = function(i, j) { return this.$get().Swap(i, j); };
	makeOnePass = function(p) {
		var _i, _r, _ref, check, i, instQueue, m, onePassRunes, p, pc, visitQueue, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; check = $f.check; i = $f.i; instQueue = $f.instQueue; m = $f.m; onePassRunes = $f.onePassRunes; p = $f.p; pc = $f.pc; visitQueue = $f.visitQueue; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		check = [check];
		instQueue = [instQueue];
		onePassRunes = [onePassRunes];
		p = [p];
		visitQueue = [visitQueue];
		if (p[0].Inst.$length >= 1000) {
			$s = -1; return notOnePass;
		}
		instQueue[0] = newQueue(p[0].Inst.$length);
		visitQueue[0] = newQueue(p[0].Inst.$length);
		check[0] = $throwNilPointerError;
		onePassRunes[0] = $makeSlice(sliceType$8, p[0].Inst.$length);
		check[0] = (function(check, instQueue, onePassRunes, p, visitQueue) { return function $b(pc, m) {
			var _1, _i, _i$1, _i$2, _i$3, _i$4, _q, _q$1, _q$2, _q$3, _q$4, _r, _r$1, _r$2, _r$3, _r$4, _ref, _ref$1, _ref$2, _ref$3, _ref$4, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _v, i, i$1, i$2, i$3, i$4, inst, m, matchArg, matchOut, ok, pc, r0, r0$1, r1, r1$1, runes, runes$1, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _i$3 = $f._i$3; _i$4 = $f._i$4; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _q$3 = $f._q$3; _q$4 = $f._q$4; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _ref$3 = $f._ref$3; _ref$4 = $f._ref$4; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; _v = $f._v; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; i$4 = $f.i$4; inst = $f.inst; m = $f.m; matchArg = $f.matchArg; matchOut = $f.matchOut; ok = $f.ok; pc = $f.pc; r0 = $f.r0; r0$1 = $f.r0$1; r1 = $f.r1; r1$1 = $f.r1$1; runes = $f.runes; runes$1 = $f.runes$1; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$15 = $f.x$15; x$16 = $f.x$16; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			ok = false;
			ok = true;
			inst = (x = p[0].Inst, ((pc < 0 || pc >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pc]));
			if (visitQueue[0].contains(pc)) {
				$s = -1; return ok;
			}
			visitQueue[0].insert(pc);
				_1 = inst.Inst.Op;
				/* */ if ((_1 === (0)) || (_1 === (1))) { $s = 2; continue; }
				/* */ if ((_1 === (2)) || (_1 === (6))) { $s = 3; continue; }
				/* */ if (_1 === (3)) { $s = 4; continue; }
				/* */ if ((_1 === (4)) || (_1 === (5))) { $s = 5; continue; }
				/* */ if (_1 === (7)) { $s = 6; continue; }
				/* */ if (_1 === (8)) { $s = 7; continue; }
				/* */ if (_1 === (9)) { $s = 8; continue; }
				/* */ if (_1 === (10)) { $s = 9; continue; }
				/* */ $s = 10; continue;
				/* if ((_1 === (0)) || (_1 === (1))) { */ case 2:
					_r = check[0](inst.Inst.Out, m); /* */ $s = 12; case 12: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					if (!(_r)) { _v = false; $s = 11; continue s; }
					_r$1 = check[0](inst.Inst.Arg, m); /* */ $s = 13; case 13: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_v = _r$1; case 11:
					ok = _v;
					matchOut = (x$1 = inst.Inst.Out, ((x$1 < 0 || x$1 >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + x$1]));
					matchArg = (x$2 = inst.Inst.Arg, ((x$2 < 0 || x$2 >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + x$2]));
					if (matchOut && matchArg) {
						ok = false;
						/* break; */ $s = 1; continue;
					}
					if (matchArg) {
						_tmp = inst.Inst.Arg;
						_tmp$1 = inst.Inst.Out;
						inst.Inst.Out = _tmp;
						inst.Inst.Arg = _tmp$1;
						_tmp$2 = matchArg;
						_tmp$3 = matchOut;
						matchOut = _tmp$2;
						matchArg = _tmp$3;
					}
					if (matchOut) {
						((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = true);
						inst.Inst.Op = 1;
					}
					_r$2 = mergeRuneSets($indexPtr(onePassRunes[0].$array, onePassRunes[0].$offset + inst.Inst.Out, ptrType$9), $indexPtr(onePassRunes[0].$array, onePassRunes[0].$offset + inst.Inst.Arg, ptrType$9), inst.Inst.Out, inst.Inst.Arg); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_tuple = _r$2;
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = _tuple[0]);
					inst.Next = _tuple[1];
					if (inst.Next.$length > 0 && ((x$3 = inst.Next, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])) === 4294967295)) {
						ok = false;
						/* break; */ $s = 1; continue;
					}
					$s = 10; continue;
				/* } else if ((_1 === (2)) || (_1 === (6))) { */ case 3:
					_r$3 = check[0](inst.Inst.Out, m); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					ok = _r$3;
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = (x$4 = inst.Inst.Out, ((x$4 < 0 || x$4 >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + x$4])));
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = $appendSlice(new sliceType([]), (x$5 = inst.Inst.Out, ((x$5 < 0 || x$5 >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + x$5]))));
					inst.Next = $makeSlice(sliceType$1, ((_q = ((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc]).$length / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0));
					_ref = inst.Next;
					_i = 0;
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						i = _i;
						(x$6 = inst.Next, ((i < 0 || i >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + i] = inst.Inst.Out));
						_i++;
					}
					$s = 10; continue;
				/* } else if (_1 === (3)) { */ case 4:
					_r$4 = check[0](inst.Inst.Out, m); /* */ $s = 16; case 16: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					ok = _r$4;
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = (x$7 = inst.Inst.Out, ((x$7 < 0 || x$7 >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + x$7])));
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = $appendSlice(new sliceType([]), (x$8 = inst.Inst.Out, ((x$8 < 0 || x$8 >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + x$8]))));
					inst.Next = $makeSlice(sliceType$1, ((_q$1 = ((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc]).$length / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0));
					_ref$1 = inst.Next;
					_i$1 = 0;
					while (true) {
						if (!(_i$1 < _ref$1.$length)) { break; }
						i$1 = _i$1;
						(x$9 = inst.Next, ((i$1 < 0 || i$1 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + i$1] = inst.Inst.Out));
						_i$1++;
					}
					$s = 10; continue;
				/* } else if ((_1 === (4)) || (_1 === (5))) { */ case 5:
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = (inst.Inst.Op === 4));
					$s = 10; continue;
				/* } else if (_1 === (7)) { */ case 6:
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = false);
					if (inst.Next.$length > 0) {
						/* break; */ $s = 1; continue;
					}
					instQueue[0].insert(inst.Inst.Out);
					if (inst.Inst.Rune.$length === 0) {
						((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = new sliceType([]));
						inst.Next = new sliceType$1([inst.Inst.Out]);
						/* break; */ $s = 1; continue;
					}
					runes = $makeSlice(sliceType, 0);
					/* */ if ((inst.Inst.Rune.$length === 1) && !((((((inst.Inst.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { $s = 17; continue; }
					/* */ $s = 18; continue;
					/* if ((inst.Inst.Rune.$length === 1) && !((((((inst.Inst.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { */ case 17:
						r0 = (x$10 = inst.Inst.Rune, (0 >= x$10.$length ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + 0]));
						runes = $append(runes, r0, r0);
						r1 = unicode.SimpleFold(r0);
						while (true) {
							if (!(!((r1 === r0)))) { break; }
							runes = $append(runes, r1, r1);
							r1 = unicode.SimpleFold(r1);
						}
						$r = sort.Sort(($subslice(new runeSlice(runes.$array), runes.$offset, runes.$offset + runes.$length))); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = 19; continue;
					/* } else { */ case 18:
						runes = $appendSlice(runes, inst.Inst.Rune);
					/* } */ case 19:
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = runes);
					inst.Next = $makeSlice(sliceType$1, ((_q$2 = ((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc]).$length / 2, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0));
					_ref$2 = inst.Next;
					_i$2 = 0;
					while (true) {
						if (!(_i$2 < _ref$2.$length)) { break; }
						i$2 = _i$2;
						(x$11 = inst.Next, ((i$2 < 0 || i$2 >= x$11.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$11.$array[x$11.$offset + i$2] = inst.Inst.Out));
						_i$2++;
					}
					inst.Inst.Op = 7;
					$s = 10; continue;
				/* } else if (_1 === (8)) { */ case 7:
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = false);
					if (inst.Next.$length > 0) {
						/* break; */ $s = 1; continue;
					}
					instQueue[0].insert(inst.Inst.Out);
					runes$1 = new sliceType([]);
					/* */ if (!((((((inst.Inst.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { $s = 21; continue; }
					/* */ $s = 22; continue;
					/* if (!((((((inst.Inst.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { */ case 21:
						r0$1 = (x$12 = inst.Inst.Rune, (0 >= x$12.$length ? ($throwRuntimeError("index out of range"), undefined) : x$12.$array[x$12.$offset + 0]));
						runes$1 = $append(runes$1, r0$1, r0$1);
						r1$1 = unicode.SimpleFold(r0$1);
						while (true) {
							if (!(!((r1$1 === r0$1)))) { break; }
							runes$1 = $append(runes$1, r1$1, r1$1);
							r1$1 = unicode.SimpleFold(r1$1);
						}
						$r = sort.Sort(($subslice(new runeSlice(runes$1.$array), runes$1.$offset, runes$1.$offset + runes$1.$length))); /* */ $s = 24; case 24: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = 23; continue;
					/* } else { */ case 22:
						runes$1 = $append(runes$1, (x$13 = inst.Inst.Rune, (0 >= x$13.$length ? ($throwRuntimeError("index out of range"), undefined) : x$13.$array[x$13.$offset + 0])), (x$14 = inst.Inst.Rune, (0 >= x$14.$length ? ($throwRuntimeError("index out of range"), undefined) : x$14.$array[x$14.$offset + 0])));
					/* } */ case 23:
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = runes$1);
					inst.Next = $makeSlice(sliceType$1, ((_q$3 = ((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc]).$length / 2, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0));
					_ref$3 = inst.Next;
					_i$3 = 0;
					while (true) {
						if (!(_i$3 < _ref$3.$length)) { break; }
						i$3 = _i$3;
						(x$15 = inst.Next, ((i$3 < 0 || i$3 >= x$15.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$15.$array[x$15.$offset + i$3] = inst.Inst.Out));
						_i$3++;
					}
					inst.Inst.Op = 7;
					$s = 10; continue;
				/* } else if (_1 === (9)) { */ case 8:
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = false);
					if (inst.Next.$length > 0) {
						/* break; */ $s = 1; continue;
					}
					instQueue[0].insert(inst.Inst.Out);
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = $appendSlice(new sliceType([]), anyRune));
					inst.Next = new sliceType$1([inst.Inst.Out]);
					$s = 10; continue;
				/* } else if (_1 === (10)) { */ case 9:
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = false);
					if (inst.Next.$length > 0) {
						/* break; */ $s = 1; continue;
					}
					instQueue[0].insert(inst.Inst.Out);
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = $appendSlice(new sliceType([]), anyRuneNotNL));
					inst.Next = $makeSlice(sliceType$1, ((_q$4 = ((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc]).$length / 2, (_q$4 === _q$4 && _q$4 !== 1/0 && _q$4 !== -1/0) ? _q$4 >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0));
					_ref$4 = inst.Next;
					_i$4 = 0;
					while (true) {
						if (!(_i$4 < _ref$4.$length)) { break; }
						i$4 = _i$4;
						(x$16 = inst.Next, ((i$4 < 0 || i$4 >= x$16.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$16.$array[x$16.$offset + i$4] = inst.Inst.Out));
						_i$4++;
					}
				/* } */ case 10:
			case 1:
			$s = -1; return ok;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._1 = _1; $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._i$3 = _i$3; $f._i$4 = _i$4; $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._q$3 = _q$3; $f._q$4 = _q$4; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._ref$3 = _ref$3; $f._ref$4 = _ref$4; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f._v = _v; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.i$4 = i$4; $f.inst = inst; $f.m = m; $f.matchArg = matchArg; $f.matchOut = matchOut; $f.ok = ok; $f.pc = pc; $f.r0 = r0; $f.r0$1 = r0$1; $f.r1 = r1; $f.r1$1 = r1$1; $f.runes = runes; $f.runes$1 = runes$1; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$15 = x$15; $f.x$16 = x$16; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
		}; })(check, instQueue, onePassRunes, p, visitQueue);
		instQueue[0].clear();
		instQueue[0].insert(((p[0].Start >>> 0)));
		m = $makeSlice(sliceType$9, p[0].Inst.$length);
		/* while (true) { */ case 1:
			/* if (!(!instQueue[0].empty())) { break; } */ if(!(!instQueue[0].empty())) { $s = 2; continue; }
			visitQueue[0].clear();
			pc = instQueue[0].next();
			_r = check[0](pc, m); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (!_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!_r) { */ case 3:
				p[0] = notOnePass;
				/* break; */ $s = 2; continue;
			/* } */ case 4:
		/* } */ $s = 1; continue; case 2:
		if (!(p[0] === notOnePass)) {
			_ref = p[0].Inst;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				(x = p[0].Inst, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).Inst.Rune = ((i < 0 || i >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + i]);
				_i++;
			}
		}
		$s = -1; return p[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeOnePass }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.check = check; $f.i = i; $f.instQueue = instQueue; $f.m = m; $f.onePassRunes = onePassRunes; $f.p = p; $f.pc = pc; $f.visitQueue = visitQueue; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	compileOnePass = function(prog) {
		var _1, _i, _r, _ref, inst, opOut, p, prog, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _r = $f._r; _ref = $f._ref; inst = $f.inst; opOut = $f.opOut; p = $f.p; prog = $f.prog; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = ptrType$1.nil;
		if (prog.Start === 0) {
			p = notOnePass;
			$s = -1; return p;
		}
		if (!(((x = prog.Inst, x$1 = prog.Start, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Op === 3)) || !(((((((x$2 = prog.Inst, x$3 = prog.Start, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])).Arg << 24 >>> 24)) & 4) >>> 0) === 4))) {
			p = notOnePass;
			$s = -1; return p;
		}
		_ref = prog.Inst;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			inst = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), syntax.Inst);
			opOut = (x$4 = prog.Inst, x$5 = inst.Out, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])).Op;
			_1 = inst.Op;
			if ((_1 === (0)) || (_1 === (1))) {
				if ((opOut === 4) || ((x$6 = prog.Inst, x$7 = inst.Arg, ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7])).Op === 4)) {
					p = notOnePass;
					$s = -1; return p;
				}
			} else if (_1 === (3)) {
				if (opOut === 4) {
					if (((((inst.Arg << 24 >>> 24)) & 8) >>> 0) === 8) {
						_i++;
						/* continue; */ $s = 1; continue;
					}
					p = notOnePass;
					$s = -1; return p;
				}
			} else if (opOut === 4) {
				p = notOnePass;
				$s = -1; return p;
			}
			_i++;
		/* } */ $s = 1; continue; case 2:
		p = onePassCopy(prog);
		_r = makeOnePass(p); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = _r;
		if (!(p === notOnePass)) {
			cleanupOnePass(p, prog);
		}
		p = p;
		$s = -1; return p;
		/* */ } return; } if ($f === undefined) { $f = { $blk: compileOnePass }; } $f._1 = _1; $f._i = _i; $f._r = _r; $f._ref = _ref; $f.inst = inst; $f.opOut = opOut; $f.p = p; $f.prog = prog; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.ptr.prototype.String = function() {
		var re;
		re = this;
		return re.regexpRO.expr;
	};
	Regexp.prototype.String = function() { return this.$val.String(); };
	Regexp.ptr.prototype.Copy = function() {
		var re;
		re = this;
		return new Regexp.ptr($clone(re.regexpRO, regexpRO), new nosync.Mutex.ptr(false), sliceType$11.nil);
	};
	Regexp.prototype.Copy = function() { return this.$val.Copy(); };
	Compile = function(expr) {
		var _r, expr, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; expr = $f.expr; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = compile(expr, 212, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Compile }; } $f._r = _r; $f.expr = expr; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Compile = Compile;
	Regexp.ptr.prototype.Longest = function() {
		var re;
		re = this;
		re.regexpRO.longest = true;
	};
	Regexp.prototype.Longest = function() { return this.$val.Longest(); };
	compile = function(expr, mode, longest) {
		var _r, _r$1, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, capNames, err, expr, longest, maxCap, mode, prog, re, regexp, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; capNames = $f.capNames; err = $f.err; expr = $f.expr; longest = $f.longest; maxCap = $f.maxCap; mode = $f.mode; prog = $f.prog; re = $f.re; regexp = $f.regexp; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = syntax.Parse(expr, mode); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		re = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [ptrType$3.nil, err];
		}
		maxCap = re.MaxCap();
		capNames = re.CapNames();
		re = re.Simplify();
		_tuple$1 = syntax.Compile(re);
		prog = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [ptrType$3.nil, err];
		}
		_r$1 = compileOnePass(prog); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		regexp = new Regexp.ptr(new regexpRO.ptr(expr, prog, _r$1, "", sliceType$6.nil, false, 0, 0, prog.StartCond(), maxCap, capNames, longest), new nosync.Mutex.ptr(false), sliceType$11.nil);
		if (regexp.regexpRO.onepass === notOnePass) {
			_tuple$2 = prog.Prefix();
			regexp.regexpRO.prefix = _tuple$2[0];
			regexp.regexpRO.prefixComplete = _tuple$2[1];
		} else {
			_tuple$3 = onePassPrefix(prog);
			regexp.regexpRO.prefix = _tuple$3[0];
			regexp.regexpRO.prefixComplete = _tuple$3[1];
			regexp.regexpRO.prefixEnd = _tuple$3[2];
		}
		if (!(regexp.regexpRO.prefix === "")) {
			regexp.regexpRO.prefixBytes = (new sliceType$6($stringToBytes(regexp.regexpRO.prefix)));
			_tuple$4 = utf8.DecodeRuneInString(regexp.regexpRO.prefix);
			regexp.regexpRO.prefixRune = _tuple$4[0];
		}
		$s = -1; return [regexp, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: compile }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f.capNames = capNames; $f.err = err; $f.expr = expr; $f.longest = longest; $f.maxCap = maxCap; $f.mode = mode; $f.prog = prog; $f.re = re; $f.regexp = regexp; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.ptr.prototype.get = function() {
		var n, re, x, x$1, z, z$1;
		re = this;
		re.mu.Lock();
		n = re.machine.$length;
		if (n > 0) {
			z = (x = re.machine, x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			re.machine = $subslice(re.machine, 0, (n - 1 >> 0));
			re.mu.Unlock();
			return z;
		}
		re.mu.Unlock();
		z$1 = progMachine(re.regexpRO.prog, re.regexpRO.onepass);
		z$1.re = re;
		return z$1;
	};
	Regexp.prototype.get = function() { return this.$val.get(); };
	Regexp.ptr.prototype.put = function(z) {
		var re, z;
		re = this;
		re.mu.Lock();
		re.machine = $append(re.machine, z);
		re.mu.Unlock();
	};
	Regexp.prototype.put = function(z) { return this.$val.put(z); };
	MustCompile = function(str) {
		var _r, _r$1, _tuple, error, regexp, str, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; error = $f.error; regexp = $f.regexp; str = $f.str; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = Compile(str); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		regexp = _tuple[0];
		error = _tuple[1];
		/* */ if (!($interfaceIsEqual(error, $ifaceNil))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!($interfaceIsEqual(error, $ifaceNil))) { */ case 2:
			_r$1 = error.Error(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$panic(new $String("regexp: Compile(" + quote(str) + "): " + _r$1));
		/* } */ case 3:
		$s = -1; return regexp;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MustCompile }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.error = error; $f.regexp = regexp; $f.str = str; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MustCompile = MustCompile;
	quote = function(s) {
		var s;
		if (strconv.CanBackquote(s)) {
			return "`" + s + "`";
		}
		return strconv.Quote(s);
	};
	Regexp.ptr.prototype.NumSubexp = function() {
		var re;
		re = this;
		return re.regexpRO.numSubexp;
	};
	Regexp.prototype.NumSubexp = function() { return this.$val.NumSubexp(); };
	Regexp.ptr.prototype.SubexpNames = function() {
		var re;
		re = this;
		return re.regexpRO.subexpNames;
	};
	Regexp.prototype.SubexpNames = function() { return this.$val.SubexpNames(); };
	inputString.ptr.prototype.step = function(pos) {
		var c, i, pos;
		i = this;
		if (pos < i.str.length) {
			c = i.str.charCodeAt(pos);
			if (c < 128) {
				return [((c >> 0)), 1];
			}
			return utf8.DecodeRuneInString($substring(i.str, pos));
		}
		return [-1, 0];
	};
	inputString.prototype.step = function(pos) { return this.$val.step(pos); };
	inputString.ptr.prototype.canCheckPrefix = function() {
		var i;
		i = this;
		return true;
	};
	inputString.prototype.canCheckPrefix = function() { return this.$val.canCheckPrefix(); };
	inputString.ptr.prototype.hasPrefix = function(re) {
		var i, re;
		i = this;
		return strings.HasPrefix(i.str, re.regexpRO.prefix);
	};
	inputString.prototype.hasPrefix = function(re) { return this.$val.hasPrefix(re); };
	inputString.ptr.prototype.index = function(re, pos) {
		var i, pos, re;
		i = this;
		return strings.Index($substring(i.str, pos), re.regexpRO.prefix);
	};
	inputString.prototype.index = function(re, pos) { return this.$val.index(re, pos); };
	inputString.ptr.prototype.context = function(pos) {
		var _tmp, _tmp$1, _tuple, _tuple$1, i, pos, r1, r2;
		i = this;
		_tmp = -1;
		_tmp$1 = -1;
		r1 = _tmp;
		r2 = _tmp$1;
		if ((((pos - 1 >> 0) >>> 0)) < ((i.str.length >>> 0))) {
			r1 = ((i.str.charCodeAt((pos - 1 >> 0)) >> 0));
			if (r1 >= 128) {
				_tuple = utf8.DecodeLastRuneInString($substring(i.str, 0, pos));
				r1 = _tuple[0];
			}
		}
		if (((pos >>> 0)) < ((i.str.length >>> 0))) {
			r2 = ((i.str.charCodeAt(pos) >> 0));
			if (r2 >= 128) {
				_tuple$1 = utf8.DecodeRuneInString($substring(i.str, pos));
				r2 = _tuple$1[0];
			}
		}
		return syntax.EmptyOpContext(r1, r2);
	};
	inputString.prototype.context = function(pos) { return this.$val.context(pos); };
	inputBytes.ptr.prototype.step = function(pos) {
		var c, i, pos, x;
		i = this;
		if (pos < i.str.$length) {
			c = (x = i.str, ((pos < 0 || pos >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pos]));
			if (c < 128) {
				return [((c >> 0)), 1];
			}
			return utf8.DecodeRune($subslice(i.str, pos));
		}
		return [-1, 0];
	};
	inputBytes.prototype.step = function(pos) { return this.$val.step(pos); };
	inputBytes.ptr.prototype.canCheckPrefix = function() {
		var i;
		i = this;
		return true;
	};
	inputBytes.prototype.canCheckPrefix = function() { return this.$val.canCheckPrefix(); };
	inputBytes.ptr.prototype.hasPrefix = function(re) {
		var i, re;
		i = this;
		return bytes.HasPrefix(i.str, re.regexpRO.prefixBytes);
	};
	inputBytes.prototype.hasPrefix = function(re) { return this.$val.hasPrefix(re); };
	inputBytes.ptr.prototype.index = function(re, pos) {
		var i, pos, re;
		i = this;
		return bytes.Index($subslice(i.str, pos), re.regexpRO.prefixBytes);
	};
	inputBytes.prototype.index = function(re, pos) { return this.$val.index(re, pos); };
	inputBytes.ptr.prototype.context = function(pos) {
		var _tmp, _tmp$1, _tuple, _tuple$1, i, pos, r1, r2, x, x$1, x$2;
		i = this;
		_tmp = -1;
		_tmp$1 = -1;
		r1 = _tmp;
		r2 = _tmp$1;
		if ((((pos - 1 >> 0) >>> 0)) < ((i.str.$length >>> 0))) {
			r1 = (((x = i.str, x$1 = pos - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])) >> 0));
			if (r1 >= 128) {
				_tuple = utf8.DecodeLastRune($subslice(i.str, 0, pos));
				r1 = _tuple[0];
			}
		}
		if (((pos >>> 0)) < ((i.str.$length >>> 0))) {
			r2 = (((x$2 = i.str, ((pos < 0 || pos >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + pos])) >> 0));
			if (r2 >= 128) {
				_tuple$1 = utf8.DecodeRune($subslice(i.str, pos));
				r2 = _tuple$1[0];
			}
		}
		return syntax.EmptyOpContext(r1, r2);
	};
	inputBytes.prototype.context = function(pos) { return this.$val.context(pos); };
	inputReader.ptr.prototype.step = function(pos) {
		var _r, _tuple, err, i, pos, r, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; i = $f.i; pos = $f.pos; r = $f.r; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (!i.atEOT && !((pos === i.pos))) {
			$s = -1; return [-1, 0];
		}
		_r = i.r.ReadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		w = _tuple[1];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			i.atEOT = true;
			$s = -1; return [-1, 0];
		}
		i.pos = i.pos + (w) >> 0;
		$s = -1; return [r, w];
		/* */ } return; } if ($f === undefined) { $f = { $blk: inputReader.ptr.prototype.step }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.i = i; $f.pos = pos; $f.r = r; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	inputReader.prototype.step = function(pos) { return this.$val.step(pos); };
	inputReader.ptr.prototype.canCheckPrefix = function() {
		var i;
		i = this;
		return false;
	};
	inputReader.prototype.canCheckPrefix = function() { return this.$val.canCheckPrefix(); };
	inputReader.ptr.prototype.hasPrefix = function(re) {
		var i, re;
		i = this;
		return false;
	};
	inputReader.prototype.hasPrefix = function(re) { return this.$val.hasPrefix(re); };
	inputReader.ptr.prototype.index = function(re, pos) {
		var i, pos, re;
		i = this;
		return -1;
	};
	inputReader.prototype.index = function(re, pos) { return this.$val.index(re, pos); };
	inputReader.ptr.prototype.context = function(pos) {
		var i, pos;
		i = this;
		return 0;
	};
	inputReader.prototype.context = function(pos) { return this.$val.context(pos); };
	Regexp.ptr.prototype.LiteralPrefix = function() {
		var _tmp, _tmp$1, complete, prefix, re;
		prefix = "";
		complete = false;
		re = this;
		_tmp = re.regexpRO.prefix;
		_tmp$1 = re.regexpRO.prefixComplete;
		prefix = _tmp;
		complete = _tmp$1;
		return [prefix, complete];
	};
	Regexp.prototype.LiteralPrefix = function() { return this.$val.LiteralPrefix(); };
	Regexp.ptr.prototype.MatchReader = function(r) {
		var _r, r, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doMatch(r, sliceType$6.nil, ""); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.MatchReader }; } $f._r = _r; $f.r = r; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.MatchReader = function(r) { return this.$val.MatchReader(r); };
	Regexp.ptr.prototype.MatchString = function(s) {
		var _r, re, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; re = $f.re; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doMatch($ifaceNil, sliceType$6.nil, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.MatchString }; } $f._r = _r; $f.re = re; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.MatchString = function(s) { return this.$val.MatchString(s); };
	Regexp.ptr.prototype.Match = function(b) {
		var _r, b, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doMatch($ifaceNil, b, ""); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.Match }; } $f._r = _r; $f.b = b; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.Match = function(b) { return this.$val.Match(b); };
	Regexp.ptr.prototype.ReplaceAllString = function(src, repl) {
		var _r, b, n, re, repl, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; n = $f.n; re = $f.re; repl = $f.repl; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = [re];
		repl = [repl];
		src = [src];
		re[0] = this;
		n = 2;
		if (strings.Contains(repl[0], "$")) {
			n = $imul(2, ((re[0].regexpRO.numSubexp + 1 >> 0)));
		}
		_r = re[0].replaceAll(sliceType$6.nil, src[0], n, (function(re, repl, src) { return function(dst, match) {
			var dst, match;
			return re[0].expand(dst, repl[0], sliceType$6.nil, src[0], match);
		}; })(re, repl, src)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		b = _r;
		$s = -1; return ($bytesToString(b));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAllString }; } $f._r = _r; $f.b = b; $f.n = n; $f.re = re; $f.repl = repl; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAllString = function(src, repl) { return this.$val.ReplaceAllString(src, repl); };
	Regexp.ptr.prototype.ReplaceAllLiteralString = function(src, repl) {
		var _r, re, repl, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; re = $f.re; repl = $f.repl; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		repl = [repl];
		re = this;
		_r = re.replaceAll(sliceType$6.nil, src, 2, (function(repl) { return function(dst, match) {
			var dst, match;
			return $appendSlice(dst, repl[0]);
		}; })(repl)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return ($bytesToString(_r));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAllLiteralString }; } $f._r = _r; $f.re = re; $f.repl = repl; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAllLiteralString = function(src, repl) { return this.$val.ReplaceAllLiteralString(src, repl); };
	Regexp.ptr.prototype.ReplaceAllStringFunc = function(src, repl) {
		var _r, b, re, repl, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; re = $f.re; repl = $f.repl; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		repl = [repl];
		src = [src];
		re = this;
		_r = re.replaceAll(sliceType$6.nil, src[0], 2, (function(repl, src) { return function $b(dst, match) {
			var _arg, _arg$1, _r, dst, match, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; dst = $f.dst; match = $f.match; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_arg = dst;
			_r = repl[0]($substring(src[0], (0 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 0]), (1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1]))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_arg$1 = _r;
			$s = -1; return $appendSlice(_arg, _arg$1);
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f.dst = dst; $f.match = match; $f.$s = $s; $f.$r = $r; return $f;
		}; })(repl, src)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		b = _r;
		$s = -1; return ($bytesToString(b));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAllStringFunc }; } $f._r = _r; $f.b = b; $f.re = re; $f.repl = repl; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAllStringFunc = function(src, repl) { return this.$val.ReplaceAllStringFunc(src, repl); };
	Regexp.ptr.prototype.replaceAll = function(bsrc, src, nmatch, repl) {
		var _r, _r$1, _tuple, _tuple$1, a, bsrc, buf, dstCap, endPos, lastMatchEnd, nmatch, re, repl, searchPos, src, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; bsrc = $f.bsrc; buf = $f.buf; dstCap = $f.dstCap; endPos = $f.endPos; lastMatchEnd = $f.lastMatchEnd; nmatch = $f.nmatch; re = $f.re; repl = $f.repl; searchPos = $f.searchPos; src = $f.src; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		lastMatchEnd = 0;
		searchPos = 0;
		buf = sliceType$6.nil;
		endPos = 0;
		if (!(bsrc === sliceType$6.nil)) {
			endPos = bsrc.$length;
		} else {
			endPos = src.length;
		}
		if (nmatch > re.regexpRO.prog.NumCap) {
			nmatch = re.regexpRO.prog.NumCap;
		}
		dstCap = arrayType$3.zero();
		/* while (true) { */ case 1:
			/* if (!(searchPos <= endPos)) { break; } */ if(!(searchPos <= endPos)) { $s = 2; continue; }
			_r = re.doExecute($ifaceNil, bsrc, src, searchPos, nmatch, $subslice(new sliceType$2(dstCap), 0, 0)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			a = _r;
			if (a.$length === 0) {
				/* break; */ $s = 2; continue;
			}
			if (!(bsrc === sliceType$6.nil)) {
				buf = $appendSlice(buf, $subslice(bsrc, lastMatchEnd, (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0])));
			} else {
				buf = $appendSlice(buf, $substring(src, lastMatchEnd, (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0])));
			}
			/* */ if ((1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]) > lastMatchEnd || ((0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]) === 0)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if ((1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]) > lastMatchEnd || ((0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]) === 0)) { */ case 4:
				_r$1 = repl(buf, a); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				buf = _r$1;
			/* } */ case 5:
			lastMatchEnd = (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]);
			width = 0;
			if (!(bsrc === sliceType$6.nil)) {
				_tuple = utf8.DecodeRune($subslice(bsrc, searchPos));
				width = _tuple[1];
			} else {
				_tuple$1 = utf8.DecodeRuneInString($substring(src, searchPos));
				width = _tuple$1[1];
			}
			if ((searchPos + width >> 0) > (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1])) {
				searchPos = searchPos + (width) >> 0;
			} else if ((searchPos + 1 >> 0) > (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1])) {
				searchPos = searchPos + (1) >> 0;
			} else {
				searchPos = (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]);
			}
		/* } */ $s = 1; continue; case 2:
		if (!(bsrc === sliceType$6.nil)) {
			buf = $appendSlice(buf, $subslice(bsrc, lastMatchEnd));
		} else {
			buf = $appendSlice(buf, $substring(src, lastMatchEnd));
		}
		$s = -1; return buf;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.replaceAll }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.bsrc = bsrc; $f.buf = buf; $f.dstCap = dstCap; $f.endPos = endPos; $f.lastMatchEnd = lastMatchEnd; $f.nmatch = nmatch; $f.re = re; $f.repl = repl; $f.searchPos = searchPos; $f.src = src; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.replaceAll = function(bsrc, src, nmatch, repl) { return this.$val.replaceAll(bsrc, src, nmatch, repl); };
	Regexp.ptr.prototype.ReplaceAll = function(src, repl) {
		var _r, b, n, re, repl, src, srepl, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; n = $f.n; re = $f.re; repl = $f.repl; src = $f.src; srepl = $f.srepl; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = [re];
		repl = [repl];
		src = [src];
		srepl = [srepl];
		re[0] = this;
		n = 2;
		if (bytes.IndexByte(repl[0], 36) >= 0) {
			n = $imul(2, ((re[0].regexpRO.numSubexp + 1 >> 0)));
		}
		srepl[0] = "";
		_r = re[0].replaceAll(src[0], "", n, (function(re, repl, src, srepl) { return function(dst, match) {
			var dst, match;
			if (!((srepl[0].length === repl[0].$length))) {
				srepl[0] = ($bytesToString(repl[0]));
			}
			return re[0].expand(dst, srepl[0], src[0], "", match);
		}; })(re, repl, src, srepl)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		b = _r;
		$s = -1; return b;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAll }; } $f._r = _r; $f.b = b; $f.n = n; $f.re = re; $f.repl = repl; $f.src = src; $f.srepl = srepl; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAll = function(src, repl) { return this.$val.ReplaceAll(src, repl); };
	Regexp.ptr.prototype.ReplaceAllLiteral = function(src, repl) {
		var _r, re, repl, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; re = $f.re; repl = $f.repl; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		repl = [repl];
		re = this;
		_r = re.replaceAll(src, "", 2, (function(repl) { return function(dst, match) {
			var dst, match;
			return $appendSlice(dst, repl[0]);
		}; })(repl)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAllLiteral }; } $f._r = _r; $f.re = re; $f.repl = repl; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAllLiteral = function(src, repl) { return this.$val.ReplaceAllLiteral(src, repl); };
	Regexp.ptr.prototype.ReplaceAllFunc = function(src, repl) {
		var _r, re, repl, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; re = $f.re; repl = $f.repl; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		repl = [repl];
		src = [src];
		re = this;
		_r = re.replaceAll(src[0], "", 2, (function(repl, src) { return function $b(dst, match) {
			var _arg, _arg$1, _r, dst, match, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; dst = $f.dst; match = $f.match; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_arg = dst;
			_r = repl[0]($subslice(src[0], (0 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 0]), (1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1]))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_arg$1 = _r;
			$s = -1; return $appendSlice(_arg, _arg$1);
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f.dst = dst; $f.match = match; $f.$s = $s; $f.$r = $r; return $f;
		}; })(repl, src)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAllFunc }; } $f._r = _r; $f.re = re; $f.repl = repl; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAllFunc = function(src, repl) { return this.$val.ReplaceAllFunc(src, repl); };
	init = function() {
		var _i, _index, _q, _r, _ref, b, y;
		_ref = (new sliceType$6($stringToBytes("\\.+*?()|[]{}^$")));
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_index = (_r = b % 16, _r === _r ? _r : $throwRuntimeError("integer divide by zero"));
			((_index < 0 || _index >= specialBytes.length) ? ($throwRuntimeError("index out of range"), undefined) : specialBytes[_index] = ((((_index < 0 || _index >= specialBytes.length) ? ($throwRuntimeError("index out of range"), undefined) : specialBytes[_index]) | (((y = ((_q = b / 16, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"))), y < 32 ? (1 << y) : 0) << 24 >>> 24))) >>> 0));
			_i++;
		}
	};
	Regexp.ptr.prototype.pad = function(a) {
		var a, n, re;
		re = this;
		if (a === sliceType$2.nil) {
			return sliceType$2.nil;
		}
		n = $imul(((1 + re.regexpRO.numSubexp >> 0)), 2);
		while (true) {
			if (!(a.$length < n)) { break; }
			a = $append(a, -1);
		}
		return a;
	};
	Regexp.prototype.pad = function(a) { return this.$val.pad(a); };
	Regexp.ptr.prototype.allMatches = function(s, b, n, deliver) {
		var _r, _tmp, _tmp$1, _tmp$2, _tuple, _tuple$1, accept, b, deliver, end, i, matches, n, pos, prevMatchEnd, re, s, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; accept = $f.accept; b = $f.b; deliver = $f.deliver; end = $f.end; i = $f.i; matches = $f.matches; n = $f.n; pos = $f.pos; prevMatchEnd = $f.prevMatchEnd; re = $f.re; s = $f.s; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		end = 0;
		if (b === sliceType$6.nil) {
			end = s.length;
		} else {
			end = b.$length;
		}
		_tmp = 0;
		_tmp$1 = 0;
		_tmp$2 = -1;
		pos = _tmp;
		i = _tmp$1;
		prevMatchEnd = _tmp$2;
		/* while (true) { */ case 1:
			/* if (!(i < n && pos <= end)) { break; } */ if(!(i < n && pos <= end)) { $s = 2; continue; }
			_r = re.doExecute($ifaceNil, b, s, pos, re.regexpRO.prog.NumCap, sliceType$2.nil); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			matches = _r;
			if (matches.$length === 0) {
				/* break; */ $s = 2; continue;
			}
			accept = true;
			if ((1 >= matches.$length ? ($throwRuntimeError("index out of range"), undefined) : matches.$array[matches.$offset + 1]) === pos) {
				if ((0 >= matches.$length ? ($throwRuntimeError("index out of range"), undefined) : matches.$array[matches.$offset + 0]) === prevMatchEnd) {
					accept = false;
				}
				width = 0;
				if (b === sliceType$6.nil) {
					_tuple = utf8.DecodeRuneInString($substring(s, pos, end));
					width = _tuple[1];
				} else {
					_tuple$1 = utf8.DecodeRune($subslice(b, pos, end));
					width = _tuple$1[1];
				}
				if (width > 0) {
					pos = pos + (width) >> 0;
				} else {
					pos = end + 1 >> 0;
				}
			} else {
				pos = (1 >= matches.$length ? ($throwRuntimeError("index out of range"), undefined) : matches.$array[matches.$offset + 1]);
			}
			prevMatchEnd = (1 >= matches.$length ? ($throwRuntimeError("index out of range"), undefined) : matches.$array[matches.$offset + 1]);
			/* */ if (accept) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (accept) { */ case 4:
				$r = deliver(re.pad(matches)); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				i = i + (1) >> 0;
			/* } */ case 5:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.allMatches }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.accept = accept; $f.b = b; $f.deliver = deliver; $f.end = end; $f.i = i; $f.matches = matches; $f.n = n; $f.pos = pos; $f.prevMatchEnd = prevMatchEnd; $f.re = re; $f.s = s; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.allMatches = function(s, b, n, deliver) { return this.$val.allMatches(s, b, n, deliver); };
	Regexp.ptr.prototype.Find = function(b) {
		var _r, a, b, dstCap, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; b = $f.b; dstCap = $f.dstCap; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		dstCap = arrayType$3.zero();
		_r = re.doExecute($ifaceNil, b, "", 0, 2, $subslice(new sliceType$2(dstCap), 0, 0)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$2.nil) {
			$s = -1; return sliceType$6.nil;
		}
		$s = -1; return $subslice(b, (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]), (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.Find }; } $f._r = _r; $f.a = a; $f.b = b; $f.dstCap = dstCap; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.Find = function(b) { return this.$val.Find(b); };
	Regexp.ptr.prototype.FindIndex = function(b) {
		var _r, a, b, loc, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; b = $f.b; loc = $f.loc; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		loc = sliceType$2.nil;
		re = this;
		_r = re.doExecute($ifaceNil, b, "", 0, 2, sliceType$2.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$2.nil) {
			loc = sliceType$2.nil;
			$s = -1; return loc;
		}
		loc = $subslice(a, 0, 2);
		$s = -1; return loc;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindIndex }; } $f._r = _r; $f.a = a; $f.b = b; $f.loc = loc; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindIndex = function(b) { return this.$val.FindIndex(b); };
	Regexp.ptr.prototype.FindString = function(s) {
		var _r, a, dstCap, re, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; dstCap = $f.dstCap; re = $f.re; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		dstCap = arrayType$3.zero();
		_r = re.doExecute($ifaceNil, sliceType$6.nil, s, 0, 2, $subslice(new sliceType$2(dstCap), 0, 0)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$2.nil) {
			$s = -1; return "";
		}
		$s = -1; return $substring(s, (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]), (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindString }; } $f._r = _r; $f.a = a; $f.dstCap = dstCap; $f.re = re; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindString = function(s) { return this.$val.FindString(s); };
	Regexp.ptr.prototype.FindStringIndex = function(s) {
		var _r, a, loc, re, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; loc = $f.loc; re = $f.re; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		loc = sliceType$2.nil;
		re = this;
		_r = re.doExecute($ifaceNil, sliceType$6.nil, s, 0, 2, sliceType$2.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$2.nil) {
			loc = sliceType$2.nil;
			$s = -1; return loc;
		}
		loc = $subslice(a, 0, 2);
		$s = -1; return loc;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindStringIndex }; } $f._r = _r; $f.a = a; $f.loc = loc; $f.re = re; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindStringIndex = function(s) { return this.$val.FindStringIndex(s); };
	Regexp.ptr.prototype.FindReaderIndex = function(r) {
		var _r, a, loc, r, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; loc = $f.loc; r = $f.r; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		loc = sliceType$2.nil;
		re = this;
		_r = re.doExecute(r, sliceType$6.nil, "", 0, 2, sliceType$2.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$2.nil) {
			loc = sliceType$2.nil;
			$s = -1; return loc;
		}
		loc = $subslice(a, 0, 2);
		$s = -1; return loc;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindReaderIndex }; } $f._r = _r; $f.a = a; $f.loc = loc; $f.r = r; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindReaderIndex = function(r) { return this.$val.FindReaderIndex(r); };
	Regexp.ptr.prototype.FindSubmatch = function(b) {
		var _i, _r, _ref, a, b, dstCap, i, re, ret, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; a = $f.a; b = $f.b; dstCap = $f.dstCap; i = $f.i; re = $f.re; ret = $f.ret; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		dstCap = arrayType$4.zero();
		_r = re.doExecute($ifaceNil, b, "", 0, re.regexpRO.prog.NumCap, $subslice(new sliceType$2(dstCap), 0, 0)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$2.nil) {
			$s = -1; return sliceType$12.nil;
		}
		ret = $makeSlice(sliceType$12, (1 + re.regexpRO.numSubexp >> 0));
		_ref = ret;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			if (($imul(2, i)) < a.$length && (x = $imul(2, i), ((x < 0 || x >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x])) >= 0) {
				((i < 0 || i >= ret.$length) ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + i] = $subslice(b, (x$1 = $imul(2, i), ((x$1 < 0 || x$1 >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x$1])), (x$2 = ($imul(2, i)) + 1 >> 0, ((x$2 < 0 || x$2 >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x$2]))));
			}
			_i++;
		}
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindSubmatch }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.a = a; $f.b = b; $f.dstCap = dstCap; $f.i = i; $f.re = re; $f.ret = ret; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindSubmatch = function(b) { return this.$val.FindSubmatch(b); };
	Regexp.ptr.prototype.Expand = function(dst, template, src, match) {
		var dst, match, re, src, template;
		re = this;
		return re.expand(dst, ($bytesToString(template)), src, "", match);
	};
	Regexp.prototype.Expand = function(dst, template, src, match) { return this.$val.Expand(dst, template, src, match); };
	Regexp.ptr.prototype.ExpandString = function(dst, template, src, match) {
		var dst, match, re, src, template;
		re = this;
		return re.expand(dst, template, sliceType$6.nil, src, match);
	};
	Regexp.prototype.ExpandString = function(dst, template, src, match) { return this.$val.ExpandString(dst, template, src, match); };
	Regexp.ptr.prototype.expand = function(dst, template, bsrc, src, match) {
		var _i, _ref, _tuple, bsrc, dst, i, i$1, match, name, namei, num, ok, re, rest, src, template, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		re = this;
		while (true) {
			if (!(template.length > 0)) { break; }
			i = strings.Index(template, "$");
			if (i < 0) {
				break;
			}
			dst = $appendSlice(dst, $substring(template, 0, i));
			template = $substring(template, i);
			if (template.length > 1 && (template.charCodeAt(1) === 36)) {
				dst = $append(dst, 36);
				template = $substring(template, 2);
				continue;
			}
			_tuple = extract(template);
			name = _tuple[0];
			num = _tuple[1];
			rest = _tuple[2];
			ok = _tuple[3];
			if (!ok) {
				dst = $append(dst, 36);
				template = $substring(template, 1);
				continue;
			}
			template = rest;
			if (num >= 0) {
				if ((($imul(2, num)) + 1 >> 0) < match.$length && (x = $imul(2, num), ((x < 0 || x >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x])) >= 0) {
					if (!(bsrc === sliceType$6.nil)) {
						dst = $appendSlice(dst, $subslice(bsrc, (x$1 = $imul(2, num), ((x$1 < 0 || x$1 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$1])), (x$2 = ($imul(2, num)) + 1 >> 0, ((x$2 < 0 || x$2 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$2]))));
					} else {
						dst = $appendSlice(dst, $substring(src, (x$3 = $imul(2, num), ((x$3 < 0 || x$3 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$3])), (x$4 = ($imul(2, num)) + 1 >> 0, ((x$4 < 0 || x$4 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$4]))));
					}
				}
			} else {
				_ref = re.regexpRO.subexpNames;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					i$1 = _i;
					namei = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
					if (name === namei && (($imul(2, i$1)) + 1 >> 0) < match.$length && (x$5 = $imul(2, i$1), ((x$5 < 0 || x$5 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$5])) >= 0) {
						if (!(bsrc === sliceType$6.nil)) {
							dst = $appendSlice(dst, $subslice(bsrc, (x$6 = $imul(2, i$1), ((x$6 < 0 || x$6 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$6])), (x$7 = ($imul(2, i$1)) + 1 >> 0, ((x$7 < 0 || x$7 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$7]))));
						} else {
							dst = $appendSlice(dst, $substring(src, (x$8 = $imul(2, i$1), ((x$8 < 0 || x$8 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$8])), (x$9 = ($imul(2, i$1)) + 1 >> 0, ((x$9 < 0 || x$9 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$9]))));
						}
						break;
					}
					_i++;
				}
			}
		}
		dst = $appendSlice(dst, template);
		return dst;
	};
	Regexp.prototype.expand = function(dst, template, bsrc, src, match) { return this.$val.expand(dst, template, bsrc, src, match); };
	extract = function(str) {
		var _tuple, brace, i, i$1, name, num, ok, rest, rune, size, str;
		name = "";
		num = 0;
		rest = "";
		ok = false;
		if (str.length < 2 || !((str.charCodeAt(0) === 36))) {
			return [name, num, rest, ok];
		}
		brace = false;
		if (str.charCodeAt(1) === 123) {
			brace = true;
			str = $substring(str, 2);
		} else {
			str = $substring(str, 1);
		}
		i = 0;
		while (true) {
			if (!(i < str.length)) { break; }
			_tuple = utf8.DecodeRuneInString($substring(str, i));
			rune = _tuple[0];
			size = _tuple[1];
			if (!unicode.IsLetter(rune) && !unicode.IsDigit(rune) && !((rune === 95))) {
				break;
			}
			i = i + (size) >> 0;
		}
		if (i === 0) {
			return [name, num, rest, ok];
		}
		name = $substring(str, 0, i);
		if (brace) {
			if (i >= str.length || !((str.charCodeAt(i) === 125))) {
				return [name, num, rest, ok];
			}
			i = i + (1) >> 0;
		}
		num = 0;
		i$1 = 0;
		while (true) {
			if (!(i$1 < name.length)) { break; }
			if (name.charCodeAt(i$1) < 48 || 57 < name.charCodeAt(i$1) || num >= 100000000) {
				num = -1;
				break;
			}
			num = (($imul(num, 10)) + ((name.charCodeAt(i$1) >> 0)) >> 0) - 48 >> 0;
			i$1 = i$1 + (1) >> 0;
		}
		if ((name.charCodeAt(0) === 48) && name.length > 1) {
			num = -1;
		}
		rest = $substring(str, i);
		ok = true;
		return [name, num, rest, ok];
	};
	Regexp.ptr.prototype.FindSubmatchIndex = function(b) {
		var _r, _r$1, b, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; b = $f.b; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doExecute($ifaceNil, b, "", 0, re.regexpRO.prog.NumCap, sliceType$2.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = re.pad(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindSubmatchIndex }; } $f._r = _r; $f._r$1 = _r$1; $f.b = b; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindSubmatchIndex = function(b) { return this.$val.FindSubmatchIndex(b); };
	Regexp.ptr.prototype.FindStringSubmatch = function(s) {
		var _i, _r, _ref, a, dstCap, i, re, ret, s, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; a = $f.a; dstCap = $f.dstCap; i = $f.i; re = $f.re; ret = $f.ret; s = $f.s; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		dstCap = arrayType$4.zero();
		_r = re.doExecute($ifaceNil, sliceType$6.nil, s, 0, re.regexpRO.prog.NumCap, $subslice(new sliceType$2(dstCap), 0, 0)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$2.nil) {
			$s = -1; return sliceType$10.nil;
		}
		ret = $makeSlice(sliceType$10, (1 + re.regexpRO.numSubexp >> 0));
		_ref = ret;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			if (($imul(2, i)) < a.$length && (x = $imul(2, i), ((x < 0 || x >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x])) >= 0) {
				((i < 0 || i >= ret.$length) ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + i] = $substring(s, (x$1 = $imul(2, i), ((x$1 < 0 || x$1 >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x$1])), (x$2 = ($imul(2, i)) + 1 >> 0, ((x$2 < 0 || x$2 >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x$2]))));
			}
			_i++;
		}
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindStringSubmatch }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.a = a; $f.dstCap = dstCap; $f.i = i; $f.re = re; $f.ret = ret; $f.s = s; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindStringSubmatch = function(s) { return this.$val.FindStringSubmatch(s); };
	Regexp.ptr.prototype.FindStringSubmatchIndex = function(s) {
		var _r, _r$1, re, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; re = $f.re; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doExecute($ifaceNil, sliceType$6.nil, s, 0, re.regexpRO.prog.NumCap, sliceType$2.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = re.pad(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindStringSubmatchIndex }; } $f._r = _r; $f._r$1 = _r$1; $f.re = re; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindStringSubmatchIndex = function(s) { return this.$val.FindStringSubmatchIndex(s); };
	Regexp.ptr.prototype.FindReaderSubmatchIndex = function(r) {
		var _r, _r$1, r, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; r = $f.r; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doExecute(r, sliceType$6.nil, "", 0, re.regexpRO.prog.NumCap, sliceType$2.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = re.pad(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindReaderSubmatchIndex }; } $f._r = _r; $f._r$1 = _r$1; $f.r = r; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindReaderSubmatchIndex = function(r) { return this.$val.FindReaderSubmatchIndex(r); };
	Regexp.ptr.prototype.FindAll = function(b, n) {
		var b, n, re, result, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; n = $f.n; re = $f.re; result = $f.result; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = [b];
		result = [result];
		re = this;
		if (n < 0) {
			n = b[0].$length + 1 >> 0;
		}
		result[0] = $makeSlice(sliceType$12, 0, 10);
		$r = re.allMatches("", b[0], n, (function(b, result) { return function(match) {
			var match;
			result[0] = $append(result[0], $subslice(b[0], (0 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 0]), (1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1])));
		}; })(b, result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (result[0].$length === 0) {
			$s = -1; return sliceType$12.nil;
		}
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAll }; } $f.b = b; $f.n = n; $f.re = re; $f.result = result; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAll = function(b, n) { return this.$val.FindAll(b, n); };
	Regexp.ptr.prototype.FindAllIndex = function(b, n) {
		var b, n, re, result, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; n = $f.n; re = $f.re; result = $f.result; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		re = this;
		if (n < 0) {
			n = b.$length + 1 >> 0;
		}
		result[0] = $makeSlice(sliceType$13, 0, 10);
		$r = re.allMatches("", b, n, (function(result) { return function(match) {
			var match;
			result[0] = $append(result[0], $subslice(match, 0, 2));
		}; })(result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (result[0].$length === 0) {
			$s = -1; return sliceType$13.nil;
		}
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllIndex }; } $f.b = b; $f.n = n; $f.re = re; $f.result = result; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllIndex = function(b, n) { return this.$val.FindAllIndex(b, n); };
	Regexp.ptr.prototype.FindAllString = function(s, n) {
		var n, re, result, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; n = $f.n; re = $f.re; result = $f.result; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		s = [s];
		re = this;
		if (n < 0) {
			n = s[0].length + 1 >> 0;
		}
		result[0] = $makeSlice(sliceType$10, 0, 10);
		$r = re.allMatches(s[0], sliceType$6.nil, n, (function(result, s) { return function(match) {
			var match;
			result[0] = $append(result[0], $substring(s[0], (0 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 0]), (1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1])));
		}; })(result, s)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (result[0].$length === 0) {
			$s = -1; return sliceType$10.nil;
		}
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllString }; } $f.n = n; $f.re = re; $f.result = result; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllString = function(s, n) { return this.$val.FindAllString(s, n); };
	Regexp.ptr.prototype.FindAllStringIndex = function(s, n) {
		var n, re, result, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; n = $f.n; re = $f.re; result = $f.result; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		re = this;
		if (n < 0) {
			n = s.length + 1 >> 0;
		}
		result[0] = $makeSlice(sliceType$13, 0, 10);
		$r = re.allMatches(s, sliceType$6.nil, n, (function(result) { return function(match) {
			var match;
			result[0] = $append(result[0], $subslice(match, 0, 2));
		}; })(result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (result[0].$length === 0) {
			$s = -1; return sliceType$13.nil;
		}
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllStringIndex }; } $f.n = n; $f.re = re; $f.result = result; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllStringIndex = function(s, n) { return this.$val.FindAllStringIndex(s, n); };
	Regexp.ptr.prototype.FindAllSubmatch = function(b, n) {
		var b, n, re, result, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; n = $f.n; re = $f.re; result = $f.result; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = [b];
		result = [result];
		re = this;
		if (n < 0) {
			n = b[0].$length + 1 >> 0;
		}
		result[0] = $makeSlice(sliceType$14, 0, 10);
		$r = re.allMatches("", b[0], n, (function(b, result) { return function(match) {
			var _i, _q, _ref, j, match, slice, x, x$1, x$2;
			slice = $makeSlice(sliceType$12, (_q = match.$length / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")));
			_ref = slice;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				j = _i;
				if ((x = $imul(2, j), ((x < 0 || x >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x])) >= 0) {
					((j < 0 || j >= slice.$length) ? ($throwRuntimeError("index out of range"), undefined) : slice.$array[slice.$offset + j] = $subslice(b[0], (x$1 = $imul(2, j), ((x$1 < 0 || x$1 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$1])), (x$2 = ($imul(2, j)) + 1 >> 0, ((x$2 < 0 || x$2 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$2]))));
				}
				_i++;
			}
			result[0] = $append(result[0], slice);
		}; })(b, result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (result[0].$length === 0) {
			$s = -1; return sliceType$14.nil;
		}
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllSubmatch }; } $f.b = b; $f.n = n; $f.re = re; $f.result = result; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllSubmatch = function(b, n) { return this.$val.FindAllSubmatch(b, n); };
	Regexp.ptr.prototype.FindAllSubmatchIndex = function(b, n) {
		var b, n, re, result, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; n = $f.n; re = $f.re; result = $f.result; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		re = this;
		if (n < 0) {
			n = b.$length + 1 >> 0;
		}
		result[0] = $makeSlice(sliceType$13, 0, 10);
		$r = re.allMatches("", b, n, (function(result) { return function(match) {
			var match;
			result[0] = $append(result[0], match);
		}; })(result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (result[0].$length === 0) {
			$s = -1; return sliceType$13.nil;
		}
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllSubmatchIndex }; } $f.b = b; $f.n = n; $f.re = re; $f.result = result; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllSubmatchIndex = function(b, n) { return this.$val.FindAllSubmatchIndex(b, n); };
	Regexp.ptr.prototype.FindAllStringSubmatch = function(s, n) {
		var n, re, result, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; n = $f.n; re = $f.re; result = $f.result; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		s = [s];
		re = this;
		if (n < 0) {
			n = s[0].length + 1 >> 0;
		}
		result[0] = $makeSlice(sliceType$15, 0, 10);
		$r = re.allMatches(s[0], sliceType$6.nil, n, (function(result, s) { return function(match) {
			var _i, _q, _ref, j, match, slice, x, x$1, x$2;
			slice = $makeSlice(sliceType$10, (_q = match.$length / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")));
			_ref = slice;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				j = _i;
				if ((x = $imul(2, j), ((x < 0 || x >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x])) >= 0) {
					((j < 0 || j >= slice.$length) ? ($throwRuntimeError("index out of range"), undefined) : slice.$array[slice.$offset + j] = $substring(s[0], (x$1 = $imul(2, j), ((x$1 < 0 || x$1 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$1])), (x$2 = ($imul(2, j)) + 1 >> 0, ((x$2 < 0 || x$2 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$2]))));
				}
				_i++;
			}
			result[0] = $append(result[0], slice);
		}; })(result, s)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (result[0].$length === 0) {
			$s = -1; return sliceType$15.nil;
		}
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllStringSubmatch }; } $f.n = n; $f.re = re; $f.result = result; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllStringSubmatch = function(s, n) { return this.$val.FindAllStringSubmatch(s, n); };
	Regexp.ptr.prototype.FindAllStringSubmatchIndex = function(s, n) {
		var n, re, result, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; n = $f.n; re = $f.re; result = $f.result; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		re = this;
		if (n < 0) {
			n = s.length + 1 >> 0;
		}
		result[0] = $makeSlice(sliceType$13, 0, 10);
		$r = re.allMatches(s, sliceType$6.nil, n, (function(result) { return function(match) {
			var match;
			result[0] = $append(result[0], match);
		}; })(result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (result[0].$length === 0) {
			$s = -1; return sliceType$13.nil;
		}
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllStringSubmatchIndex }; } $f.n = n; $f.re = re; $f.result = result; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllStringSubmatchIndex = function(s, n) { return this.$val.FindAllStringSubmatchIndex(s, n); };
	Regexp.ptr.prototype.Split = function(s, n) {
		var _i, _r, _ref, beg, end, match, matches, n, re, s, strings$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; beg = $f.beg; end = $f.end; match = $f.match; matches = $f.matches; n = $f.n; re = $f.re; s = $f.s; strings$1 = $f.strings$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		if (n === 0) {
			$s = -1; return sliceType$10.nil;
		}
		if (re.regexpRO.expr.length > 0 && (s.length === 0)) {
			$s = -1; return new sliceType$10([""]);
		}
		_r = re.FindAllStringIndex(s, n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		matches = _r;
		strings$1 = $makeSlice(sliceType$10, 0, matches.$length);
		beg = 0;
		end = 0;
		_ref = matches;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			match = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (n > 0 && strings$1.$length >= (n - 1 >> 0)) {
				break;
			}
			end = (0 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 0]);
			if (!(((1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1]) === 0))) {
				strings$1 = $append(strings$1, $substring(s, beg, end));
			}
			beg = (1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1]);
			_i++;
		}
		if (!((end === s.length))) {
			strings$1 = $append(strings$1, $substring(s, beg));
		}
		$s = -1; return strings$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.Split }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.beg = beg; $f.end = end; $f.match = match; $f.matches = matches; $f.n = n; $f.re = re; $f.s = s; $f.strings$1 = strings$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.Split = function(s, n) { return this.$val.Split(s, n); };
	ptrType.methods = [{prop: "reset", name: "reset", pkg: "regexp", typ: $funcType([$Int, $Int], [], false)}, {prop: "shouldVisit", name: "shouldVisit", pkg: "regexp", typ: $funcType([$Uint32, $Int], [$Bool], false)}, {prop: "push", name: "push", pkg: "regexp", typ: $funcType([$Uint32, $Int, $Int], [], false)}];
	ptrType$10.methods = [{prop: "tryBacktrack", name: "tryBacktrack", pkg: "regexp", typ: $funcType([ptrType, input, $Uint32, $Int], [$Bool], false)}, {prop: "backtrack", name: "backtrack", pkg: "regexp", typ: $funcType([input, $Int, $Int, $Int], [$Bool], false)}, {prop: "newInputBytes", name: "newInputBytes", pkg: "regexp", typ: $funcType([sliceType$6], [input], false)}, {prop: "newInputString", name: "newInputString", pkg: "regexp", typ: $funcType([$String], [input], false)}, {prop: "newInputReader", name: "newInputReader", pkg: "regexp", typ: $funcType([io.RuneReader], [input], false)}, {prop: "init", name: "init", pkg: "regexp", typ: $funcType([$Int], [], false)}, {prop: "alloc", name: "alloc", pkg: "regexp", typ: $funcType([ptrType$5], [ptrType$4], false)}, {prop: "match", name: "match", pkg: "regexp", typ: $funcType([input, $Int], [$Bool], false)}, {prop: "clear", name: "clear", pkg: "regexp", typ: $funcType([ptrType$11], [], false)}, {prop: "step", name: "step", pkg: "regexp", typ: $funcType([ptrType$11, ptrType$11, $Int, $Int, $Int32, syntax.EmptyOp], [], false)}, {prop: "add", name: "add", pkg: "regexp", typ: $funcType([ptrType$11, $Uint32, $Int, sliceType$2, syntax.EmptyOp, ptrType$4], [ptrType$4], false)}, {prop: "onepass", name: "onepass", pkg: "regexp", typ: $funcType([input, $Int, $Int], [$Bool], false)}];
	ptrType$7.methods = [{prop: "empty", name: "empty", pkg: "regexp", typ: $funcType([], [$Bool], false)}, {prop: "next", name: "next", pkg: "regexp", typ: $funcType([], [$Uint32], false)}, {prop: "clear", name: "clear", pkg: "regexp", typ: $funcType([], [], false)}, {prop: "contains", name: "contains", pkg: "regexp", typ: $funcType([$Uint32], [$Bool], false)}, {prop: "insert", name: "insert", pkg: "regexp", typ: $funcType([$Uint32], [], false)}, {prop: "insertNew", name: "insertNew", pkg: "regexp", typ: $funcType([$Uint32], [], false)}];
	runeSlice.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Less", name: "Less", pkg: "", typ: $funcType([$Int, $Int], [$Bool], false)}, {prop: "Swap", name: "Swap", pkg: "", typ: $funcType([$Int, $Int], [], false)}];
	ptrType$3.methods = [{prop: "doMatch", name: "doMatch", pkg: "regexp", typ: $funcType([io.RuneReader, sliceType$6, $String], [$Bool], false)}, {prop: "doExecute", name: "doExecute", pkg: "regexp", typ: $funcType([io.RuneReader, sliceType$6, $String, $Int, $Int, sliceType$2], [sliceType$2], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Copy", name: "Copy", pkg: "", typ: $funcType([], [ptrType$3], false)}, {prop: "Longest", name: "Longest", pkg: "", typ: $funcType([], [], false)}, {prop: "get", name: "get", pkg: "regexp", typ: $funcType([], [ptrType$10], false)}, {prop: "put", name: "put", pkg: "regexp", typ: $funcType([ptrType$10], [], false)}, {prop: "NumSubexp", name: "NumSubexp", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "SubexpNames", name: "SubexpNames", pkg: "", typ: $funcType([], [sliceType$10], false)}, {prop: "LiteralPrefix", name: "LiteralPrefix", pkg: "", typ: $funcType([], [$String, $Bool], false)}, {prop: "MatchReader", name: "MatchReader", pkg: "", typ: $funcType([io.RuneReader], [$Bool], false)}, {prop: "MatchString", name: "MatchString", pkg: "", typ: $funcType([$String], [$Bool], false)}, {prop: "Match", name: "Match", pkg: "", typ: $funcType([sliceType$6], [$Bool], false)}, {prop: "ReplaceAllString", name: "ReplaceAllString", pkg: "", typ: $funcType([$String, $String], [$String], false)}, {prop: "ReplaceAllLiteralString", name: "ReplaceAllLiteralString", pkg: "", typ: $funcType([$String, $String], [$String], false)}, {prop: "ReplaceAllStringFunc", name: "ReplaceAllStringFunc", pkg: "", typ: $funcType([$String, funcType], [$String], false)}, {prop: "replaceAll", name: "replaceAll", pkg: "regexp", typ: $funcType([sliceType$6, $String, $Int, funcType$1], [sliceType$6], false)}, {prop: "ReplaceAll", name: "ReplaceAll", pkg: "", typ: $funcType([sliceType$6, sliceType$6], [sliceType$6], false)}, {prop: "ReplaceAllLiteral", name: "ReplaceAllLiteral", pkg: "", typ: $funcType([sliceType$6, sliceType$6], [sliceType$6], false)}, {prop: "ReplaceAllFunc", name: "ReplaceAllFunc", pkg: "", typ: $funcType([sliceType$6, funcType$2], [sliceType$6], false)}, {prop: "pad", name: "pad", pkg: "regexp", typ: $funcType([sliceType$2], [sliceType$2], false)}, {prop: "allMatches", name: "allMatches", pkg: "regexp", typ: $funcType([$String, sliceType$6, $Int, funcType$3], [], false)}, {prop: "Find", name: "Find", pkg: "", typ: $funcType([sliceType$6], [sliceType$6], false)}, {prop: "FindIndex", name: "FindIndex", pkg: "", typ: $funcType([sliceType$6], [sliceType$2], false)}, {prop: "FindString", name: "FindString", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "FindStringIndex", name: "FindStringIndex", pkg: "", typ: $funcType([$String], [sliceType$2], false)}, {prop: "FindReaderIndex", name: "FindReaderIndex", pkg: "", typ: $funcType([io.RuneReader], [sliceType$2], false)}, {prop: "FindSubmatch", name: "FindSubmatch", pkg: "", typ: $funcType([sliceType$6], [sliceType$12], false)}, {prop: "Expand", name: "Expand", pkg: "", typ: $funcType([sliceType$6, sliceType$6, sliceType$6, sliceType$2], [sliceType$6], false)}, {prop: "ExpandString", name: "ExpandString", pkg: "", typ: $funcType([sliceType$6, $String, $String, sliceType$2], [sliceType$6], false)}, {prop: "expand", name: "expand", pkg: "regexp", typ: $funcType([sliceType$6, $String, sliceType$6, $String, sliceType$2], [sliceType$6], false)}, {prop: "FindSubmatchIndex", name: "FindSubmatchIndex", pkg: "", typ: $funcType([sliceType$6], [sliceType$2], false)}, {prop: "FindStringSubmatch", name: "FindStringSubmatch", pkg: "", typ: $funcType([$String], [sliceType$10], false)}, {prop: "FindStringSubmatchIndex", name: "FindStringSubmatchIndex", pkg: "", typ: $funcType([$String], [sliceType$2], false)}, {prop: "FindReaderSubmatchIndex", name: "FindReaderSubmatchIndex", pkg: "", typ: $funcType([io.RuneReader], [sliceType$2], false)}, {prop: "FindAll", name: "FindAll", pkg: "", typ: $funcType([sliceType$6, $Int], [sliceType$12], false)}, {prop: "FindAllIndex", name: "FindAllIndex", pkg: "", typ: $funcType([sliceType$6, $Int], [sliceType$13], false)}, {prop: "FindAllString", name: "FindAllString", pkg: "", typ: $funcType([$String, $Int], [sliceType$10], false)}, {prop: "FindAllStringIndex", name: "FindAllStringIndex", pkg: "", typ: $funcType([$String, $Int], [sliceType$13], false)}, {prop: "FindAllSubmatch", name: "FindAllSubmatch", pkg: "", typ: $funcType([sliceType$6, $Int], [sliceType$14], false)}, {prop: "FindAllSubmatchIndex", name: "FindAllSubmatchIndex", pkg: "", typ: $funcType([sliceType$6, $Int], [sliceType$13], false)}, {prop: "FindAllStringSubmatch", name: "FindAllStringSubmatch", pkg: "", typ: $funcType([$String, $Int], [sliceType$15], false)}, {prop: "FindAllStringSubmatchIndex", name: "FindAllStringSubmatchIndex", pkg: "", typ: $funcType([$String, $Int], [sliceType$13], false)}, {prop: "Split", name: "Split", pkg: "", typ: $funcType([$String, $Int], [sliceType$10], false)}];
	ptrType$12.methods = [{prop: "step", name: "step", pkg: "regexp", typ: $funcType([$Int], [$Int32, $Int], false)}, {prop: "canCheckPrefix", name: "canCheckPrefix", pkg: "regexp", typ: $funcType([], [$Bool], false)}, {prop: "hasPrefix", name: "hasPrefix", pkg: "regexp", typ: $funcType([ptrType$3], [$Bool], false)}, {prop: "index", name: "index", pkg: "regexp", typ: $funcType([ptrType$3, $Int], [$Int], false)}, {prop: "context", name: "context", pkg: "regexp", typ: $funcType([$Int], [syntax.EmptyOp], false)}];
	ptrType$13.methods = [{prop: "step", name: "step", pkg: "regexp", typ: $funcType([$Int], [$Int32, $Int], false)}, {prop: "canCheckPrefix", name: "canCheckPrefix", pkg: "regexp", typ: $funcType([], [$Bool], false)}, {prop: "hasPrefix", name: "hasPrefix", pkg: "regexp", typ: $funcType([ptrType$3], [$Bool], false)}, {prop: "index", name: "index", pkg: "regexp", typ: $funcType([ptrType$3, $Int], [$Int], false)}, {prop: "context", name: "context", pkg: "regexp", typ: $funcType([$Int], [syntax.EmptyOp], false)}];
	ptrType$14.methods = [{prop: "step", name: "step", pkg: "regexp", typ: $funcType([$Int], [$Int32, $Int], false)}, {prop: "canCheckPrefix", name: "canCheckPrefix", pkg: "regexp", typ: $funcType([], [$Bool], false)}, {prop: "hasPrefix", name: "hasPrefix", pkg: "regexp", typ: $funcType([ptrType$3], [$Bool], false)}, {prop: "index", name: "index", pkg: "regexp", typ: $funcType([ptrType$3, $Int], [$Int], false)}, {prop: "context", name: "context", pkg: "regexp", typ: $funcType([$Int], [syntax.EmptyOp], false)}];
	job.init("regexp", [{prop: "pc", name: "pc", anonymous: false, exported: false, typ: $Uint32, tag: ""}, {prop: "arg", name: "arg", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "pos", name: "pos", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	bitState.init("regexp", [{prop: "prog", name: "prog", anonymous: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "end", name: "end", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "cap", name: "cap", anonymous: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "jobs", name: "jobs", anonymous: false, exported: false, typ: sliceType$3, tag: ""}, {prop: "visited", name: "visited", anonymous: false, exported: false, typ: sliceType$1, tag: ""}]);
	queue.init("regexp", [{prop: "sparse", name: "sparse", anonymous: false, exported: false, typ: sliceType$1, tag: ""}, {prop: "dense", name: "dense", anonymous: false, exported: false, typ: sliceType$4, tag: ""}]);
	entry.init("regexp", [{prop: "pc", name: "pc", anonymous: false, exported: false, typ: $Uint32, tag: ""}, {prop: "t", name: "t", anonymous: false, exported: false, typ: ptrType$4, tag: ""}]);
	thread.init("regexp", [{prop: "inst", name: "inst", anonymous: false, exported: false, typ: ptrType$5, tag: ""}, {prop: "cap", name: "cap", anonymous: false, exported: false, typ: sliceType$2, tag: ""}]);
	machine.init("regexp", [{prop: "re", name: "re", anonymous: false, exported: false, typ: ptrType$3, tag: ""}, {prop: "p", name: "p", anonymous: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "op", name: "op", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "maxBitStateLen", name: "maxBitStateLen", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "b", name: "b", anonymous: false, exported: false, typ: ptrType, tag: ""}, {prop: "q0", name: "q0", anonymous: false, exported: false, typ: queue, tag: ""}, {prop: "q1", name: "q1", anonymous: false, exported: false, typ: queue, tag: ""}, {prop: "pool", name: "pool", anonymous: false, exported: false, typ: sliceType$5, tag: ""}, {prop: "matched", name: "matched", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "matchcap", name: "matchcap", anonymous: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "inputBytes", name: "inputBytes", anonymous: false, exported: false, typ: inputBytes, tag: ""}, {prop: "inputString", name: "inputString", anonymous: false, exported: false, typ: inputString, tag: ""}, {prop: "inputReader", name: "inputReader", anonymous: false, exported: false, typ: inputReader, tag: ""}]);
	onePassProg.init("", [{prop: "Inst", name: "Inst", anonymous: false, exported: true, typ: sliceType$7, tag: ""}, {prop: "Start", name: "Start", anonymous: false, exported: true, typ: $Int, tag: ""}, {prop: "NumCap", name: "NumCap", anonymous: false, exported: true, typ: $Int, tag: ""}]);
	onePassInst.init("", [{prop: "Inst", name: "Inst", anonymous: true, exported: true, typ: syntax.Inst, tag: ""}, {prop: "Next", name: "Next", anonymous: false, exported: true, typ: sliceType$1, tag: ""}]);
	queueOnePass.init("regexp", [{prop: "sparse", name: "sparse", anonymous: false, exported: false, typ: sliceType$1, tag: ""}, {prop: "dense", name: "dense", anonymous: false, exported: false, typ: sliceType$1, tag: ""}, {prop: "size", name: "size", anonymous: false, exported: false, typ: $Uint32, tag: ""}, {prop: "nextIndex", name: "nextIndex", anonymous: false, exported: false, typ: $Uint32, tag: ""}]);
	runeSlice.init($Int32);
	Regexp.init("regexp", [{prop: "regexpRO", name: "regexpRO", anonymous: true, exported: false, typ: regexpRO, tag: ""}, {prop: "mu", name: "mu", anonymous: false, exported: false, typ: nosync.Mutex, tag: ""}, {prop: "machine", name: "machine", anonymous: false, exported: false, typ: sliceType$11, tag: ""}]);
	regexpRO.init("regexp", [{prop: "expr", name: "expr", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "prog", name: "prog", anonymous: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "onepass", name: "onepass", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "prefix", name: "prefix", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "prefixBytes", name: "prefixBytes", anonymous: false, exported: false, typ: sliceType$6, tag: ""}, {prop: "prefixComplete", name: "prefixComplete", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "prefixRune", name: "prefixRune", anonymous: false, exported: false, typ: $Int32, tag: ""}, {prop: "prefixEnd", name: "prefixEnd", anonymous: false, exported: false, typ: $Uint32, tag: ""}, {prop: "cond", name: "cond", anonymous: false, exported: false, typ: syntax.EmptyOp, tag: ""}, {prop: "numSubexp", name: "numSubexp", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "subexpNames", name: "subexpNames", anonymous: false, exported: false, typ: sliceType$10, tag: ""}, {prop: "longest", name: "longest", anonymous: false, exported: false, typ: $Bool, tag: ""}]);
	input.init([{prop: "canCheckPrefix", name: "canCheckPrefix", pkg: "regexp", typ: $funcType([], [$Bool], false)}, {prop: "context", name: "context", pkg: "regexp", typ: $funcType([$Int], [syntax.EmptyOp], false)}, {prop: "hasPrefix", name: "hasPrefix", pkg: "regexp", typ: $funcType([ptrType$3], [$Bool], false)}, {prop: "index", name: "index", pkg: "regexp", typ: $funcType([ptrType$3, $Int], [$Int], false)}, {prop: "step", name: "step", pkg: "regexp", typ: $funcType([$Int], [$Int32, $Int], false)}]);
	inputString.init("regexp", [{prop: "str", name: "str", anonymous: false, exported: false, typ: $String, tag: ""}]);
	inputBytes.init("regexp", [{prop: "str", name: "str", anonymous: false, exported: false, typ: sliceType$6, tag: ""}]);
	inputReader.init("regexp", [{prop: "r", name: "r", anonymous: false, exported: false, typ: io.RuneReader, tag: ""}, {prop: "atEOT", name: "atEOT", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "pos", name: "pos", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = nosync.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = syntax.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sort.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		arrayNoInts = arrayType.zero();
		specialBytes = arrayType$1.zero();
		notBacktrack = ptrType.nil;
		noRune = new sliceType([]);
		noNext = new sliceType$1([4294967295]);
		anyRuneNotNL = new sliceType([0, 9, 11, 1114111]);
		anyRune = new sliceType([0, 1114111]);
		notOnePass = ptrType$1.nil;
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/empijei/identigen/identities"] = (function() {
	var $pkg = {}, $init, bytes, csv, json, xml, fmt, lists, io, math, big, rand, regexp, strconv, strings, time, unicode, CartaCredito, ccSeed, Credentials, DrivingLicense, printer, Iban, Person, DateFormat, sliceType, sliceType$1, sliceType$2, ptrType, sliceType$3, sliceType$4, ptrType$1, sliceType$5, ptrType$2, ptrType$3, structType, sliceType$6, ptrType$4, sliceType$7, ptrType$5, ptrType$6, structType$1, arrayType, mapType, sliceType$8, funcType, ptrType$7, ccData, printers, printerMap, fields, ccBuilder, ccformatter, luhn, threePad, checksum, getVowels, getConsonants, fixFirstNameConsonants, birthDayStringCalc, normalize, padding, MarshalCSV, generateFilters, SetFilter, MainModule, printFormatted, uniqSlice, RandomPeople, piCheckDigit, init, NewPerson, NewDateFormat, init$1, nthdigit, randString;
	bytes = $packages["bytes"];
	csv = $packages["encoding/csv"];
	json = $packages["encoding/json"];
	xml = $packages["encoding/xml"];
	fmt = $packages["fmt"];
	lists = $packages["github.com/empijei/identigen/identities/lists"];
	io = $packages["io"];
	math = $packages["math"];
	big = $packages["math/big"];
	rand = $packages["math/rand"];
	regexp = $packages["regexp"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	time = $packages["time"];
	unicode = $packages["unicode"];
	CartaCredito = $pkg.CartaCredito = $newType(0, $kindStruct, "identities.CartaCredito", true, "github.com/empijei/identigen/identities", true, function(Number_, Cvv_, Issuer_, ExpDate_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Number = "";
			this.Cvv = "";
			this.Issuer = "";
			this.ExpDate = "";
			return;
		}
		this.Number = Number_;
		this.Cvv = Cvv_;
		this.Issuer = Issuer_;
		this.ExpDate = ExpDate_;
	});
	ccSeed = $pkg.ccSeed = $newType(0, $kindStruct, "identities.ccSeed", true, "github.com/empijei/identigen/identities", false, function(issuer_, base_, delta_, bodylength_, cvvlength_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.issuer = "";
			this.base = 0;
			this.delta = 0;
			this.bodylength = 0;
			this.cvvlength = 0;
			return;
		}
		this.issuer = issuer_;
		this.base = base_;
		this.delta = delta_;
		this.bodylength = bodylength_;
		this.cvvlength = cvvlength_;
	});
	Credentials = $pkg.Credentials = $newType(0, $kindStruct, "identities.Credentials", true, "github.com/empijei/identigen/identities", true, function(Username_, Password_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Username = "";
			this.Password = "";
			return;
		}
		this.Username = Username_;
		this.Password = Password_;
	});
	DrivingLicense = $pkg.DrivingLicense = $newType(0, $kindStruct, "identities.DrivingLicense", true, "github.com/empijei/identigen/identities", true, function(Number_, Issuer_, ExpDate_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Number = "";
			this.Issuer = "";
			this.ExpDate = "";
			return;
		}
		this.Number = Number_;
		this.Issuer = Issuer_;
		this.ExpDate = ExpDate_;
	});
	printer = $pkg.printer = $newType(0, $kindStruct, "identities.printer", true, "github.com/empijei/identigen/identities", false, function(fieldName_, function$1_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.fieldName = "";
			this.function$1 = $throwNilPointerError;
			return;
		}
		this.fieldName = fieldName_;
		this.function$1 = function$1_;
	});
	Iban = $pkg.Iban = $newType(0, $kindStruct, "identities.Iban", true, "github.com/empijei/identigen/identities", true, function(BankName_, Iban_, abi_, cab_, cc_, cinCache_, bbanCache_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.BankName = "";
			this.Iban = "";
			this.abi = "";
			this.cab = "";
			this.cc = "";
			this.cinCache = "";
			this.bbanCache = "";
			return;
		}
		this.BankName = BankName_;
		this.Iban = Iban_;
		this.abi = abi_;
		this.cab = cab_;
		this.cc = cc_;
		this.cinCache = cinCache_;
		this.bbanCache = bbanCache_;
	});
	Person = $pkg.Person = $newType(0, $kindStruct, "identities.Person", true, "github.com/empijei/identigen/identities", true, function(firstName_, lastName_, genderIsFemale_, birthDate_, town_, townCode_, birthDistrict_, residence_, drv_, fiscalCode_, partitaIva_, locationCode_, partitaIvaCounty_, cc_, mobilePhone_, id_, iban_, up_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.firstName = "";
			this.lastName = "";
			this.genderIsFemale = false;
			this.birthDate = new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$6.nil);
			this.town = "";
			this.townCode = "";
			this.birthDistrict = "";
			this.residence = "";
			this.drv = ptrType$3.nil;
			this.fiscalCode = "";
			this.partitaIva = "";
			this.locationCode = 0;
			this.partitaIvaCounty = "";
			this.cc = ptrType$1.nil;
			this.mobilePhone = "";
			this.id = "";
			this.iban = ptrType$5.nil;
			this.up = ptrType$2.nil;
			return;
		}
		this.firstName = firstName_;
		this.lastName = lastName_;
		this.genderIsFemale = genderIsFemale_;
		this.birthDate = birthDate_;
		this.town = town_;
		this.townCode = townCode_;
		this.birthDistrict = birthDistrict_;
		this.residence = residence_;
		this.drv = drv_;
		this.fiscalCode = fiscalCode_;
		this.partitaIva = partitaIva_;
		this.locationCode = locationCode_;
		this.partitaIvaCounty = partitaIvaCounty_;
		this.cc = cc_;
		this.mobilePhone = mobilePhone_;
		this.id = id_;
		this.iban = iban_;
		this.up = up_;
	});
	DateFormat = $pkg.DateFormat = $newType(4, $kindInt, "identities.DateFormat", true, "github.com/empijei/identigen/identities", true, null);
	sliceType = $sliceType($String);
	sliceType$1 = $sliceType(ccSeed);
	sliceType$2 = $sliceType(printer);
	ptrType = $ptrType(Person);
	sliceType$3 = $sliceType($emptyInterface);
	sliceType$4 = $sliceType($Int32);
	ptrType$1 = $ptrType(CartaCredito);
	sliceType$5 = $sliceType($Uint8);
	ptrType$2 = $ptrType(Credentials);
	ptrType$3 = $ptrType(DrivingLicense);
	structType = $structType("", []);
	sliceType$6 = $sliceType(Person);
	ptrType$4 = $ptrType(sliceType$6);
	sliceType$7 = $sliceType($Int);
	ptrType$5 = $ptrType(Iban);
	ptrType$6 = $ptrType(time.Location);
	structType$1 = $structType("", [{prop: "CodiceCatasto", name: "CodiceCatasto", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Paese", name: "Paese", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Provincia", name: "Provincia", anonymous: false, exported: true, typ: $String, tag: ""}]);
	arrayType = $arrayType($Uint8, 64);
	mapType = $mapType($String, $String);
	sliceType$8 = $sliceType(xml.Attr);
	funcType = $funcType([ptrType], [$String], false);
	ptrType$7 = $ptrType(xml.Encoder);
	CartaCredito.ptr.prototype.String = function() {
		var cc;
		cc = this;
		return cc.Issuer + " " + cc.Number + ", " + cc.Cvv + ", " + cc.ExpDate;
	};
	CartaCredito.prototype.String = function() { return this.$val.String(); };
	ccBuilder = function(seed) {
		var _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, body, cc, checkSum, prefix, prefixShift, seed, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; body = $f.body; cc = $f.cc; checkSum = $f.checkSum; prefix = $f.prefix; prefixShift = $f.prefixShift; seed = $f.seed; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		cc = new CartaCredito.ptr("", "", "", "");
		_r = rand.Int63n((new $Int64(0, seed.delta))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		prefix = (x = _r, x$1 = (new $Int64(0, seed.base)), new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));
		_r$1 = fmt.Sprintf("%d", new sliceType$3([prefix])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = math.Pow10((seed.bodylength - _r$1.length >> 0) - 1 >> 0); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		prefixShift = (new $Int64(0, _r$2));
		_r$3 = rand.Int63n(prefixShift); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		body = _r$3;
		body = (x$2 = $mul64(prefix, prefixShift), new $Int64(body.$high + x$2.$high, body.$low + x$2.$low));
		_r$4 = luhn(body); /* */ $s = 5; case 5: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		checkSum = _r$4;
		_r$5 = fmt.Sprintf("%0" + strconv.Itoa(seed.bodylength - 1 >> 0) + "d%d", new sliceType$3([body, new $Int(checkSum)])); /* */ $s = 6; case 6: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		cc.Number = _r$5;
		cc.Number = ccformatter(cc.Number);
		cc.Issuer = seed.issuer;
		_r$6 = randString((new sliceType$4($stringToRunes("0123456789"))), seed.cvvlength); /* */ $s = 7; case 7: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		cc.Cvv = _r$6;
		_r$7 = $clone(time.Now(), time.Time).AddDate(6, 6, 6); /* */ $s = 8; case 8: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_r$8 = $clone(_r$7, time.Time).Format("01/06"); /* */ $s = 9; case 9: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		cc.ExpDate = _r$8;
		$s = -1; return cc;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ccBuilder }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f.body = body; $f.cc = cc; $f.checkSum = checkSum; $f.prefix = prefix; $f.prefixShift = prefixShift; $f.seed = seed; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	ccformatter = function(cc) {
		var _1, cc;
		_1 = cc.length;
		if (_1 === (16)) {
			cc = strings.Join(new sliceType([$substring(cc, 0, 4), $substring(cc, 4, 8), $substring(cc, 8, 12), $substring(cc, 12, 16)]), "-");
		} else if (_1 === (15)) {
			cc = strings.Join(new sliceType([$substring(cc, 0, 5), $substring(cc, 5, 10), $substring(cc, 10, 15)]), "-");
		}
		return cc;
	};
	Person.ptr.prototype.CartaCredito = function() {
		var _r, _r$1, p, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; p = $f.p; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!(p.cc === ptrType$1.nil)) {
			$s = -1; return p.cc;
		}
		_r = rand.Intn(ccData.$length); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = ccBuilder($clone((x = _r, ((x < 0 || x >= ccData.$length) ? ($throwRuntimeError("index out of range"), undefined) : ccData.$array[ccData.$offset + x])), ccSeed)); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		p.cc = _r$1;
		$s = -1; return p.cc;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.CartaCredito }; } $f._r = _r; $f._r$1 = _r$1; $f.p = p; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.CartaCredito = function() { return this.$val.CartaCredito(); };
	luhn = function(num) {
		var _r, _r$1, _r$2, cclen, dig, i, multiplied, num, summed, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; cclen = $f.cclen; dig = $f.dig; i = $f.i; multiplied = $f.multiplied; num = $f.num; summed = $f.summed; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = fmt.Sprintf("%d", new sliceType$3([num])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		cclen = _r;
		summed = 0;
		multiplied = 0;
		i = 0;
		while (true) {
			if (!(i < cclen.length)) { break; }
			dig = nthdigit(num, i);
			multiplied = dig;
			if ((_r$1 = i % 2, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0) {
				multiplied = $imul(dig, 2);
				if (multiplied >= 10) {
					multiplied = multiplied - 9 >> 0;
				}
			}
			summed = summed + multiplied >> 0;
			i = i + (1) >> 0;
		}
		if (!(((_r$2 = summed % 10, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero")) === 0))) {
			$s = -1; return 10 - nthdigit((new $Int64(0, summed)), 0) >> 0;
		}
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: luhn }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.cclen = cclen; $f.dig = dig; $f.i = i; $f.multiplied = multiplied; $f.num = num; $f.summed = summed; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.ptr.prototype.CodiceFiscale = function() {
		var _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, cf, composer, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; cf = $f.cf; composer = $f.composer; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		cf = "";
		p = this;
		if (!(p.fiscalCode === "")) {
			cf = p.fiscalCode;
			$s = -1; return cf;
		}
		composer = bytes.NewBuffer($makeSlice(sliceType$5, 0, 16));
		_r = getConsonants(p.lastName); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = threePad(_r, p.lastName); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = composer.WriteString(_r$1); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		_r$3 = getConsonants(p.firstName); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$4 = fixFirstNameConsonants(_r$3); /* */ $s = 5; case 5: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_r$5 = threePad(_r$4, p.firstName); /* */ $s = 6; case 6: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_r$6 = composer.WriteString(_r$5); /* */ $s = 7; case 7: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_r$6;
		_r$7 = birthDayStringCalc(p); /* */ $s = 8; case 8: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_r$8 = composer.WriteString(_r$7); /* */ $s = 9; case 9: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		_r$8;
		composer.WriteString(p.townCode);
		composer.WriteString(checksum(composer.String()));
		p.fiscalCode = composer.String();
		cf = p.fiscalCode;
		$s = -1; return cf;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.CodiceFiscale }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f.cf = cf; $f.composer = composer; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.CodiceFiscale = function() { return this.$val.CodiceFiscale(); };
	threePad = function(tmp, name) {
		var _r, delta, name, tmp, vow, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; delta = $f.delta; name = $f.name; tmp = $f.tmp; vow = $f.vow; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		delta = tmp.length - 3 >> 0;
		/* */ if (!((delta === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((delta === 0))) { */ case 1:
			if (delta > 0) {
				tmp = $substring(tmp, 0, 3);
			}
			/* */ if (delta < 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (delta < 0) { */ case 3:
				_r = getVowels(name); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				vow = _r;
				if (-delta <= vow.length) {
					tmp = tmp + ($substring(vow, 0, -delta));
				} else {
					tmp = tmp + (vow);
				}
			/* } */ case 4:
			while (true) {
				if (!(tmp.length < 3)) { break; }
				tmp = tmp + ("X");
			}
		/* } */ case 2:
		$s = -1; return tmp;
		/* */ } return; } if ($f === undefined) { $f = { $blk: threePad }; } $f._r = _r; $f.delta = delta; $f.name = name; $f.tmp = tmp; $f.vow = vow; $f.$s = $s; $f.$r = $r; return $f;
	};
	checksum = function(cf) {
		var _entry, _entry$1, _i, _i$1, _i$2, _key, _key$1, _r, _r$1, _ref, _ref$1, _ref$2, _rune, _rune$1, _rune$2, c, c$1, c$2, cf, chech, evencheck, i, i$1, i$2, oddcheck, remainder, sum;
		chech = "";
		oddcheck = $makeMap($String.keyFor, [{ k: "0", v: 1 }, { k: "9", v: 21 }, { k: "I", v: 19 }, { k: "R", v: 8 }, { k: "1", v: 0 }, { k: "A", v: 1 }, { k: "J", v: 21 }, { k: "S", v: 12 }, { k: "2", v: 5 }, { k: "B", v: 0 }, { k: "K", v: 2 }, { k: "T", v: 14 }, { k: "3", v: 7 }, { k: "C", v: 5 }, { k: "L", v: 4 }, { k: "U", v: 16 }, { k: "4", v: 9 }, { k: "D", v: 7 }, { k: "M", v: 18 }, { k: "V", v: 10 }, { k: "5", v: 13 }, { k: "E", v: 9 }, { k: "N", v: 20 }, { k: "W", v: 22 }, { k: "6", v: 15 }, { k: "F", v: 13 }, { k: "O", v: 11 }, { k: "X", v: 25 }, { k: "7", v: 17 }, { k: "G", v: 15 }, { k: "P", v: 3 }, { k: "Y", v: 24 }, { k: "8", v: 19 }, { k: "H", v: 17 }, { k: "Q", v: 6 }, { k: "Z", v: 23 }]);
		evencheck = {};
		_ref = "0123456789";
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			i = _i;
			c = _rune[0];
			_key = ($encodeRune(c)); (evencheck || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: i };
			_i += _rune[1];
		}
		_ref$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.length)) { break; }
			_rune$1 = $decodeRune(_ref$1, _i$1);
			i$1 = _i$1;
			c$1 = _rune$1[0];
			_key$1 = ($encodeRune(c$1)); (evencheck || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key$1)] = { k: _key$1, v: i$1 };
			_i$1 += _rune$1[1];
		}
		sum = 0;
		_ref$2 = cf;
		_i$2 = 0;
		while (true) {
			if (!(_i$2 < _ref$2.length)) { break; }
			_rune$2 = $decodeRune(_ref$2, _i$2);
			i$2 = _i$2;
			c$2 = _rune$2[0];
			if ((_r = ((i$2 + 1 >> 0)) % 2, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0) {
				sum = sum + ((_entry = evencheck[$String.keyFor(($encodeRune(c$2)))], _entry !== undefined ? _entry.v : 0)) >> 0;
			} else {
				sum = sum + ((_entry$1 = oddcheck[$String.keyFor(($encodeRune(c$2)))], _entry$1 !== undefined ? _entry$1.v : 0)) >> 0;
			}
			_i$2 += _rune$2[1];
		}
		remainder = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		chech = ($encodeRune(remainder.charCodeAt((_r$1 = sum % 26, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")))));
		return chech;
	};
	getVowels = function(input) {
		var _1, _i, _r, _ref, _rune, c, c$1, i, input, output, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _r = $f._r; _ref = $f._ref; _rune = $f._rune; c = $f.c; c$1 = $f.c$1; i = $f.i; input = $f.input; output = $f.output; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		output = "";
		_r = strings.ToUpper(input); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		input = _r;
		_ref = input;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			c = _rune[0];
			c$1 = ($encodeRune(c));
			if (strings.ContainsAny(c$1, "AEIOU")) {
				output = output + (c$1);
			}
			i = strings.Index("\xC3\x80\xC3\x8C\xC3\x88\xC3\x89\xC3\x92\xC3\x99", c$1);
			if (i >= 0) {
				_1 = c$1;
				if (_1 === ("\xC3\x80")) {
					output = output + ("A");
				} else if (_1 === ("\xC3\x8C")) {
					output = output + ("I");
				} else if (_1 === ("\xC3\x88")) {
					output = output + ("E");
				} else if (_1 === ("\xC3\x89")) {
					output = output + ("E");
				} else if (_1 === ("\xC3\x92")) {
					output = output + ("O");
				} else if (_1 === ("\xC3\x99")) {
					output = output + ("U");
				}
			}
			_i += _rune[1];
		}
		$s = -1; return output;
		/* */ } return; } if ($f === undefined) { $f = { $blk: getVowels }; } $f._1 = _1; $f._i = _i; $f._r = _r; $f._ref = _ref; $f._rune = _rune; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.input = input; $f.output = output; $f.$s = $s; $f.$r = $r; return $f;
	};
	getConsonants = function(input) {
		var _i, _r, _ref, _rune, c, c$1, input, output, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _rune = $f._rune; c = $f.c; c$1 = $f.c$1; input = $f.input; output = $f.output; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		output = "";
		_r = strings.ToUpper(input); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		input = _r;
		_ref = input;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			c = _rune[0];
			c$1 = ($encodeRune(c));
			if (strings.ContainsAny(c$1, "QWRTYPSDFGHJKLZXCVBNM")) {
				output = output + (c$1);
			}
			_i += _rune[1];
		}
		$s = -1; return output;
		/* */ } return; } if ($f === undefined) { $f = { $blk: getConsonants }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._rune = _rune; $f.c = c; $f.c$1 = c$1; $f.input = input; $f.output = output; $f.$s = $s; $f.$r = $r; return $f;
	};
	fixFirstNameConsonants = function(seq) {
		var seq;
		if (seq.length > 3) {
			seq = $substring(seq, 0, 1) + $substring(seq, 2);
		}
		return seq;
	};
	birthDayStringCalc = function(p) {
		var _r, _r$1, _r$2, _r$3, _r$4, p, seq, tmp, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; p = $f.p; seq = $f.seq; tmp = $f.tmp; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		seq = "";
		_r = $clone(p.birthDate, time.Time).Year(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = strconv.Itoa(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		seq = seq + (_r$1);
		seq = $substring(seq, 2);
		_r$2 = $clone(p.birthDate, time.Time).Month(); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		seq = seq + (($encodeRune("ABCDEHLMPRST".charCodeAt((_r$2 - 1 >> 0)))));
		_r$3 = $clone(p.birthDate, time.Time).Day(); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		tmp = _r$3;
		if (p.genderIsFemale) {
			tmp = tmp + (40) >> 0;
		}
		_r$4 = fmt.Sprintf("%02d", new sliceType$3([new $Int(tmp)])); /* */ $s = 5; case 5: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		seq = seq + (_r$4);
		$s = -1; return seq;
		/* */ } return; } if ($f === undefined) { $f = { $blk: birthDayStringCalc }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.p = p; $f.seq = seq; $f.tmp = tmp; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.ptr.prototype.Credentials = function() {
		var _arg, _arg$1, _arg$2, _r, _r$1, _r$2, _r$3, _r$4, _r$5, lastName, name, p, up, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; lastName = $f.lastName; name = $f.name; p = $f.p; up = $f.up; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!(p.up === ptrType$2.nil)) {
			$s = -1; return p.up;
		}
		_r = normalize(p.firstName); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		name = _r;
		if (name.length < 3) {
			name = padding(p.firstName);
		}
		_r$1 = normalize(p.lastName); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		lastName = _r$1;
		if (lastName.length < 3) {
			lastName = padding(p.lastName);
		}
		_arg = new $String($substring(name, 0, 3));
		_arg$1 = new $String($substring(lastName, 0, 3));
		_r$2 = $clone(p.birthDate, time.Time).Year(); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_arg$2 = new $Int(_r$2);
		_r$3 = fmt.Sprintf("%s%s%d", new sliceType$3([_arg, _arg$1, _arg$2])); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$4 = randString((new sliceType$4($stringToRunes("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"))), 6); /* */ $s = 5; case 5: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_r$5 = randString((new sliceType$4($stringToRunes(".-!"))), 2); /* */ $s = 6; case 6: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		up = new Credentials.ptr(_r$3, _r$4 + _r$5);
		p.up = up;
		$s = -1; return up;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.Credentials }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f.lastName = lastName; $f.name = name; $f.p = p; $f.up = up; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.Credentials = function() { return this.$val.Credentials(); };
	normalize = function(name) {
		var _r, _r$1, name, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; name = $f.name; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = regexp.MustCompile("('| )"); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		re = _r;
		_r$1 = re.ReplaceAll((new sliceType$5($stringToBytes(name))), (new sliceType$5($stringToBytes("X")))); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return ($bytesToString(_r$1));
		/* */ } return; } if ($f === undefined) { $f = { $blk: normalize }; } $f._r = _r; $f._r$1 = _r$1; $f.name = name; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	padding = function(name) {
		var name;
		while (true) {
			if (!(name.length < 3)) { break; }
			name = name + ("X");
		}
		return name;
	};
	MarshalCSV = function(people, out) {
		var _i, _r, _r$1, _r$2, _r$3, _ref, err, err$1, err$2, err$3, out, people, person, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; out = $f.out; people = $f.people; person = $f.person; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		err = $ifaceNil;
		w = csv.NewWriter(out);
		_r = w.Write(fields); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err$1 = _r;
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			err = err$1;
			$s = -1; return err;
		}
		_ref = people;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			person = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Person);
			_r$1 = $clone(person, Person).MarshalCSV(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$2 = w.Write(_r$1); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			err$2 = _r$2;
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				err = err$2;
				$s = -1; return err;
			}
			_i++;
		/* } */ $s = 2; continue; case 3:
		$r = w.Flush(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$3 = w.Error(); /* */ $s = 7; case 7: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		err$3 = _r$3;
		if (!($interfaceIsEqual(err$3, $ifaceNil))) {
			err = err$3;
			$s = -1; return err;
		}
		err = $ifaceNil;
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MarshalCSV }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.out = out; $f.people = people; $f.person = person; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MarshalCSV = MarshalCSV;
	Person.ptr.prototype.DrivingLicense = function() {
		var _r, _r$1, _r$2, _r$3, _r$4, location, p, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; location = $f.location; p = $f.p; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!(p.drv === ptrType$3.nil)) {
			$s = -1; return p.drv;
		}
		location = $substring((x = strings.Split(p.birthDistrict, "("), (1 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 1])), 0, 2);
		_r = randString((new sliceType$4($stringToRunes("0123456789"))), 7); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = randString((new sliceType$4($stringToRunes("ABCDEFGHIJKLMNOPQRSTUVWXYZ"))), 1); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = $clone(p.birthDate, time.Time).Format("02/01/"); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$3 = $clone(time.Now(), time.Time).AddDate(5, 0, 0); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$4 = $clone(_r$3, time.Time).Format("2006"); /* */ $s = 5; case 5: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		p.drv = new DrivingLicense.ptr(location + _r + _r$1, "MCTC-" + location, _r$2 + _r$4);
		$s = -1; return p.drv;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.DrivingLicense }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.location = location; $f.p = p; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.DrivingLicense = function() { return this.$val.DrivingLicense(); };
	DrivingLicense.ptr.prototype.String = function() {
		var drv;
		drv = this;
		return drv.Number + " " + drv.Issuer + " " + drv.ExpDate;
	};
	DrivingLicense.prototype.String = function() { return this.$val.String(); };
	generateFilters = function() {
		var _i, _key, _ref, val;
		$pkg.AllFields = $makeSlice(sliceType, 0, (printers.$length - 1 >> 0));
		printerMap = {};
		_ref = printers;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			val = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), printer);
			$pkg.AllFields = $append($pkg.AllFields, val.fieldName);
			_key = val.fieldName; (printerMap || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: val.function$1 };
			_i++;
		}
		return $pkg.AllFields;
	};
	SetFilter = function(newFields) {
		var _entry, _i, _i$1, _key, _r, _ref, _ref$1, _tuple, allowedField, field, newFields, ok, set, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _i$1 = $f._i$1; _key = $f._key; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; _tuple = $f._tuple; allowedField = $f.allowedField; field = $f.field; newFields = $f.newFields; ok = $f.ok; set = $f.set; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		set = {};
		_ref = $pkg.AllFields;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			allowedField = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_key = allowedField; (set || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: new structType.ptr() };
			_i++;
		}
		_ref$1 = newFields;
		_i$1 = 0;
		/* while (true) { */ case 1:
			/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 2; continue; }
			field = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			_tuple = (_entry = set[$String.keyFor(field)], _entry !== undefined ? [_entry.v, true] : [new structType.ptr(), false]);
			ok = _tuple[1];
			/* */ if (!ok) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!ok) { */ case 3:
				_r = fmt.Errorf("Unknown Field: %s", new sliceType$3([new $String(field)])); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } */ case 4:
			_i$1++;
		/* } */ $s = 1; continue; case 2:
		fields = newFields;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: SetFilter }; } $f._entry = _entry; $f._i = _i; $f._i$1 = _i$1; $f._key = _key; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tuple = _tuple; $f.allowedField = allowedField; $f.field = field; $f.newFields = newFields; $f.ok = ok; $f.set = set; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.SetFilter = SetFilter;
	MainModule = function(args, out) {
		var _entry, _entry$1, _entry$2, _entry$3, _entry$4, _entry$5, _i, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _ref, _tuple, args, clamp, dtFmt, err, err$1, err$2, f, fields$1, format, formats, maxage, minage, number, out, people, tmp, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _entry$4 = $f._entry$4; _entry$5 = $f._entry$5; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _ref = $f._ref; _tuple = $f._tuple; args = $f.args; clamp = $f.clamp; dtFmt = $f.dtFmt; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; f = $f.f; fields$1 = $f.fields$1; format = $f.format; formats = $f.formats; maxage = $f.maxage; minage = $f.minage; number = $f.number; out = $f.out; people = $f.people; tmp = $f.tmp; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		err = $ifaceNil;
		clamp = (function(val, min, max) {
			var max, min, val;
			if (val < min) {
				return min;
			}
			if (val > max) {
				return max;
			}
			return val;
		});
		dtFmt = $assertType((_entry = args[$String.keyFor("dt_fmt")], _entry !== undefined ? _entry.v : $ifaceNil), $String);
		_r = clamp($assertType((_entry$1 = args[$String.keyFor("minage")], _entry$1 !== undefined ? _entry$1.v : $ifaceNil), $Int), 1, 200); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		minage = _r;
		_r$1 = clamp($assertType((_entry$2 = args[$String.keyFor("maxage")], _entry$2 !== undefined ? _entry$2.v : $ifaceNil), $Int), 1, 200); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		maxage = _r$1;
		number = $assertType((_entry$3 = args[$String.keyFor("number")], _entry$3 !== undefined ? _entry$3.v : $ifaceNil), $Int);
		format = $assertType((_entry$4 = args[$String.keyFor("format")], _entry$4 !== undefined ? _entry$4.v : $ifaceNil), $String);
		fields$1 = $assertType((_entry$5 = args[$String.keyFor("fields")], _entry$5 !== undefined ? _entry$5.v : $ifaceNil), $String);
		/* */ if (number <= 0) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (number <= 0) { */ case 3:
			_r$2 = fmt.Errorf("'number' should be positive", new sliceType$3([])); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			err = _r$2;
			$s = -1; return err;
		/* } */ case 4:
		/* */ if (!(fields$1 === "all")) { $s = 6; continue; }
		/* */ $s = 7; continue;
		/* if (!(fields$1 === "all")) { */ case 6:
			tmp = uniqSlice(strings.Split(fields$1, ","));
			_r$3 = SetFilter(tmp); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			err$1 = _r$3;
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				err = err$1;
				$s = -1; return err;
			}
		/* } */ case 7:
		$pkg.LocalizDate = NewDateFormat(dtFmt);
		_r$4 = RandomPeople(minage, maxage, number); /* */ $s = 9; case 9: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_tuple = _r$4;
		people = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			err = err;
			$s = -1; return err;
		}
		formats = uniqSlice(strings.Split(format, ","));
		_ref = formats;
		_i = 0;
		/* while (true) { */ case 10:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 11; continue; }
			f = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r$5 = printFormatted(f, people, out); /* */ $s = 12; case 12: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			err$2 = _r$5;
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				err = err$2;
				$s = -1; return err;
			}
			_i++;
		/* } */ $s = 10; continue; case 11:
		err = $ifaceNil;
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MainModule }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._entry$4 = _entry$4; $f._entry$5 = _entry$5; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._ref = _ref; $f._tuple = _tuple; $f.args = args; $f.clamp = clamp; $f.dtFmt = dtFmt; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.f = f; $f.fields$1 = fields$1; $f.format = format; $f.formats = formats; $f.maxage = maxage; $f.minage = minage; $f.number = number; $f.out = out; $f.people = people; $f.tmp = tmp; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MainModule = MainModule;
	printFormatted = function(format, people, out) {
		var _1, _i, _r, _r$1, _r$10, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, b, b$1, err, err$1, err$2, format, out, people, person, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; b = $f.b; b$1 = $f.b$1; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; format = $f.format; out = $f.out; people = $f.people; person = $f.person; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		people = [people];
			_1 = format;
			/* */ if (_1 === ("json")) { $s = 2; continue; }
			/* */ if (_1 === ("xml")) { $s = 3; continue; }
			/* */ if (_1 === ("csv")) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_1 === ("json")) { */ case 2:
				_r = json.MarshalIndent((people.$ptr || (people.$ptr = new ptrType$4(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, people))), "", "\t"); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				b = _tuple[0];
				err = _tuple[1];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					$s = -1; return err;
				}
				_r$1 = out.Write(b); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tuple$1 = _r$1;
				_r$2 = fmt.Fprintln(out, new sliceType$3([])); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$2;
				$s = 6; continue;
			/* } else if (_1 === ("xml")) { */ case 3:
				_r$3 = out.Write((new sliceType$5($stringToBytes("<People>\n")))); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				_tuple$2 = _r$3;
				_r$4 = xml.MarshalIndent((people.$ptr || (people.$ptr = new ptrType$4(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, people))), "\t", "\t"); /* */ $s = 11; case 11: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				_tuple$3 = _r$4;
				b$1 = _tuple$3[0];
				err$1 = _tuple$3[1];
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					$s = -1; return err$1;
				}
				_r$5 = out.Write(b$1); /* */ $s = 12; case 12: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				_tuple$4 = _r$5;
				_r$6 = out.Write((new sliceType$5($stringToBytes("\n</People>")))); /* */ $s = 13; case 13: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_tuple$5 = _r$6;
				_r$7 = fmt.Fprintln(out, new sliceType$3([])); /* */ $s = 14; case 14: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				_r$7;
				$s = 6; continue;
			/* } else if (_1 === ("csv")) { */ case 4:
				_r$8 = MarshalCSV(people[0], out); /* */ $s = 15; case 15: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				err$2 = _r$8;
				if (!($interfaceIsEqual(err$2, $ifaceNil))) {
					$s = -1; return err$2;
				}
				_r$9 = fmt.Fprintln(out, new sliceType$3([])); /* */ $s = 16; case 16: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				_r$9;
				$s = 6; continue;
			/* } else { */ case 5:
				_ref = people[0];
				_i = 0;
				/* while (true) { */ case 17:
					/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 18; continue; }
					person = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Person);
					_r$10 = fmt.Fprintln(out, new sliceType$3([new person.constructor.elem(person)])); /* */ $s = 19; case 19: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
					_r$10;
					_i++;
				/* } */ $s = 17; continue; case 18:
			/* } */ case 6:
		case 1:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: printFormatted }; } $f._1 = _1; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.b = b; $f.b$1 = b$1; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.format = format; $f.out = out; $f.people = people; $f.person = person; $f.$s = $s; $f.$r = $r; return $f;
	};
	uniqSlice = function(in$1) {
		var _entry, _i, _key, _ref, _tuple, f, in$1, ok, out, supportMap;
		out = $makeSlice(sliceType, 0, in$1.$length);
		supportMap = {};
		_ref = in$1;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			f = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_tuple = (_entry = supportMap[$String.keyFor(f)], _entry !== undefined ? [_entry.v, true] : [new structType.ptr(), false]);
			ok = _tuple[1];
			if (!ok) {
				out = $append(out, f);
				_key = f; (supportMap || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: new structType.ptr() };
			}
			_i++;
		}
		return out;
	};
	RandomPeople = function(minage, maxage, count) {
		var _r, _r$1, _tmp, _tmp$1, count, err, maxage, minage, people, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; count = $f.count; err = $f.err; maxage = $f.maxage; minage = $f.minage; people = $f.people; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		people = sliceType$6.nil;
		err = $ifaceNil;
		/* */ if (minage > maxage) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (minage > maxage) { */ case 1:
			_tmp = sliceType$6.nil;
			_r = fmt.Errorf("maxage(%d) should not be less than minage(%d)", new sliceType$3([new $Int(maxage), new $Int(minage)])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tmp$1 = _r;
			people = _tmp;
			err = _tmp$1;
			$s = -1; return [people, err];
		/* } */ case 2:
		/* while (true) { */ case 4:
			/* if (!(count > 0)) { break; } */ if(!(count > 0)) { $s = 5; continue; }
			_r$1 = NewPerson(minage, maxage); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			people = $append(people, _r$1);
			count = count - (1) >> 0;
		/* } */ $s = 4; continue; case 5:
		$s = -1; return [people, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: RandomPeople }; } $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.count = count; $f.err = err; $f.maxage = maxage; $f.minage = minage; $f.people = people; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.RandomPeople = RandomPeople;
	Iban.ptr.prototype.cin = function() {
		var _i, _r, _r$1, _ref, _rune, _tuple, elem, i, i$1, ibanTmp, p, sb, totalWeight, wOdd;
		i = this;
		if (!(i.cinCache === "")) {
			return i.cinCache;
		}
		wOdd = new sliceType$7([1, 0, 5, 7, 9, 13, 15, 17, 19, 21, 2, 4, 18, 20, 11, 3, 6, 8, 12, 14, 16, 10, 22, 25, 24, 23, 27, 28, 26]);
		sb = bytes.NewBuffer($makeSlice(sliceType$5, 0, 22));
		sb.WriteString(i.abi);
		sb.WriteString(i.cab);
		sb.WriteString(i.cc);
		ibanTmp = sb.String();
		totalWeight = 0;
		_ref = ibanTmp;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			i$1 = _i;
			elem = _rune[0];
			_tuple = strconv.Atoi(($encodeRune(elem)));
			p = _tuple[0];
			if (((_r = i$1 % 2, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))) === 0) {
				totalWeight = totalWeight + (((p < 0 || p >= wOdd.$length) ? ($throwRuntimeError("index out of range"), undefined) : wOdd.$array[wOdd.$offset + p])) >> 0;
			} else {
				totalWeight = totalWeight + (p) >> 0;
			}
			_i += _rune[1];
		}
		i.cinCache = ($encodeRune((((_r$1 = totalWeight % 26, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"))) + 65 >> 0)));
		return i.cinCache;
	};
	Iban.prototype.cin = function() { return this.$val.cin(); };
	Iban.ptr.prototype.bban = function() {
		var i, sb;
		i = this;
		if (!(i.bbanCache === "")) {
			return i.bbanCache;
		}
		sb = bytes.NewBuffer($makeSlice(sliceType$5, 0, 23));
		sb.WriteString(i.cin());
		sb.WriteString(i.abi);
		sb.WriteString(i.cab);
		sb.WriteString(i.cc);
		i.bbanCache = sb.String();
		return i.bbanCache;
	};
	Iban.prototype.bban = function() { return this.$val.bban(); };
	Iban.ptr.prototype.String = function() {
		var i;
		i = this;
		return i.Iban + ", " + i.BankName;
	};
	Iban.prototype.String = function() { return this.$val.String(); };
	Person.ptr.prototype.IBAN = function() {
		var _r, _r$1, _r$2, _r$3, _r$4, _r$5, bank, branch, i, p, sb, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; bank = $f.bank; branch = $f.branch; i = $f.i; p = $f.p; sb = $f.sb; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!(p.iban === ptrType$5.nil)) {
			$s = -1; return p.iban;
		}
		_r = rand.Intn(lists.Banks.$length); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		bank = $clone((x = lists.Banks, x$1 = _r, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])), lists.Bank);
		_r$1 = rand.Intn(bank.Branches.$length); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		branch = $clone((x$2 = bank.Branches, x$3 = _r$1, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])), lists.Branch);
		_r$2 = rand.Intn(branch.CAB.$length); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$3 = randString((new sliceType$4($stringToRunes("1234567890"))), 12); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		i = new Iban.ptr(bank.Name, "", branch.ABI, (x$4 = branch.CAB, x$5 = _r$2, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])), _r$3, "", "");
		sb = bytes.NewBuffer($makeSlice(sliceType$5, 0, 31));
		sb.WriteString("IT");
		_r$4 = i.cd(); /* */ $s = 5; case 5: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_r$5 = sb.WriteString(_r$4); /* */ $s = 6; case 6: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_r$5;
		sb.WriteString(" ");
		sb.WriteString(i.cin());
		sb.WriteString(" ");
		sb.WriteString(i.abi);
		sb.WriteString(" ");
		sb.WriteString(i.cab);
		sb.WriteString(" ");
		sb.WriteString(i.cc);
		i.Iban = sb.String();
		p.iban = i;
		$s = -1; return p.iban;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.IBAN }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f.bank = bank; $f.branch = branch; $f.i = i; $f.p = p; $f.sb = sb; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.IBAN = function() { return this.$val.IBAN(); };
	Iban.ptr.prototype.cd = function() {
		var _i, _r, _r$1, _r$2, _ref, _rune, aux, bfNumber, div, elem, i, ibanTmp, mod, result, ret, sub, tmp, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _rune = $f._rune; aux = $f.aux; bfNumber = $f.bfNumber; div = $f.div; elem = $f.elem; i = $f.i; ibanTmp = $f.ibanTmp; mod = $f.mod; result = $f.result; ret = $f.ret; sub = $f.sub; tmp = $f.tmp; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		ibanTmp = i.bban() + "IT" + "00";
		ret = "";
		aux = "";
		_ref = ibanTmp;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			elem = _rune[0];
			if (unicode.IsLetter(elem)) {
				tmp = "";
				tmp = strconv.Itoa(((((elem - 65 >> 0) + 10 >> 0) >> 0)));
				if (tmp.length === 1) {
					tmp = "0" + tmp;
				}
				aux = aux + (tmp);
			} else {
				aux = aux + (($encodeRune(elem)));
			}
			_i += _rune[1];
		}
		bfNumber = new big.Int.ptr(false, big.nat.nil);
		mod = new big.Int.ptr(false, big.nat.nil);
		result = new big.Int.ptr(false, big.nat.nil);
		div = big.NewInt(new $Int64(0, 97));
		sub = big.NewInt(new $Int64(0, 98));
		_r = bfNumber.SetString(aux, 10); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		_r$1 = mod.Mod(bfNumber, div); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		result.Sub(sub, mod);
		_r$2 = result.String(); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		ret = _r$2;
		if (ret.length === 1) {
			ret = "0" + ret;
		}
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Iban.ptr.prototype.cd }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._rune = _rune; $f.aux = aux; $f.bfNumber = bfNumber; $f.div = div; $f.elem = elem; $f.i = i; $f.ibanTmp = ibanTmp; $f.mod = mod; $f.result = result; $f.ret = ret; $f.sub = sub; $f.tmp = tmp; $f.$s = $s; $f.$r = $r; return $f;
	};
	Iban.prototype.cd = function() { return this.$val.cd(); };
	Person.ptr.prototype.PartitaIva = function() {
		var _arg, _arg$1, _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, county, lastDigit, p, pi, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; county = $f.county; lastDigit = $f.lastDigit; p = $f.p; pi = $f.pi; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		pi = "";
		county = "";
		p = this;
		/* */ if ((p.locationCode === 0) || p.partitaIvaCounty === "") { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((p.locationCode === 0) || p.partitaIvaCounty === "") { */ case 1:
			_r = p.Address(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$unused(_r);
		/* } */ case 2:
		if (!(p.partitaIva === "")) {
			_tmp = p.partitaIva;
			_tmp$1 = p.partitaIvaCounty;
			pi = _tmp;
			county = _tmp$1;
			$s = -1; return [pi, county];
		}
		county = p.partitaIvaCounty;
		_r$1 = rand.Intn(10000000); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_arg = new $Int(_r$1);
		_arg$1 = new $Int(p.locationCode);
		_r$2 = fmt.Sprintf("%07d%03d", new sliceType$3([_arg, _arg$1])); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		pi = _r$2;
		lastDigit = piCheckDigit(pi);
		_r$3 = fmt.Sprintf("IT%s%d", new sliceType$3([new $String(pi), new $Int(lastDigit)])); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		pi = _r$3;
		p.partitaIva = pi;
		$s = -1; return [pi, county];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.PartitaIva }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.county = county; $f.lastDigit = lastDigit; $f.p = p; $f.pi = pi; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.PartitaIva = function() { return this.$val.PartitaIva(); };
	piCheckDigit = function(num) {
		var T, _r, _r$1, _r$2, _tmp, _tmp$1, _tmp$2, _tuple, digit, evenSum, num, oddSum, pos, tmp;
		_tmp = 0;
		_tmp$1 = 0;
		_tmp$2 = 0;
		digit = _tmp;
		evenSum = _tmp$1;
		oddSum = _tmp$2;
		pos = 0;
		while (true) {
			if (!(pos < num.length)) { break; }
			_tuple = strconv.Atoi(($encodeRune(num.charCodeAt(pos))));
			digit = _tuple[0];
			if (!(((_r = pos % 2, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0))) {
				tmp = $imul(digit, 2);
				if (tmp > 9) {
					tmp = tmp - (9) >> 0;
				}
				evenSum = evenSum + (tmp) >> 0;
			} else {
				oddSum = oddSum + (digit) >> 0;
			}
			pos = pos + (1) >> 0;
		}
		T = (_r$1 = ((evenSum + oddSum >> 0)) % 10, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"));
		return (_r$2 = ((10 - T >> 0)) % 10, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero"));
	};
	init = function() {
		var $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = rand.Seed($clone(time.Now(), time.Time).UnixNano()); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	NewPerson = function(minage, maxage) {
		var _arg, _arg$1, _arg$2, _arg$3, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, age, birthInfo, maxage, minage, names, person, x, x$1, x$2, x$3, x$4, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _arg$3 = $f._arg$3; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; age = $f.age; birthInfo = $f.birthInfo; maxage = $f.maxage; minage = $f.minage; names = $f.names; person = $f.person; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		person = new Person.ptr("", "", false, new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$6.nil), "", "", "", "", ptrType$3.nil, "", "", 0, "", ptrType$1.nil, "", "", ptrType$5.nil, ptrType$2.nil);
		_r$1 = rand.Int(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		person.genderIsFemale = (_r = _r$1 % 2, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0;
		names = sliceType.nil;
		if (person.genderIsFemale) {
			names = lists.ItalianFemaleNames;
		} else {
			names = lists.ItalianMaleNames;
		}
		_r$3 = rand.Int(); /* */ $s = 2; case 2: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		person.firstName = (x = (_r$2 = _r$3 % names.$length, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero")), ((x < 0 || x >= names.$length) ? ($throwRuntimeError("index out of range"), undefined) : names.$array[names.$offset + x]));
		age = 0;
		/* */ if (minage === maxage) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (minage === maxage) { */ case 3:
			age = minage;
			$s = 5; continue;
		/* } else { */ case 4:
			_r$5 = rand.Int(); /* */ $s = 6; case 6: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			age = (_r$4 = _r$5 % ((maxage - minage >> 0)), _r$4 === _r$4 ? _r$4 : $throwRuntimeError("integer divide by zero")) + minage >> 0;
		/* } */ case 5:
		_r$6 = $clone(time.Now(), time.Time).Year(); /* */ $s = 7; case 7: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_arg = _r$6 - age >> 0;
		_r$8 = rand.Int(); /* */ $s = 8; case 8: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		_arg$1 = ((((_r$7 = _r$8 % 12, _r$7 === _r$7 ? _r$7 : $throwRuntimeError("integer divide by zero")) + 1 >> 0) >> 0));
		_r$10 = rand.Int(); /* */ $s = 9; case 9: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
		_arg$2 = (_r$9 = _r$10 % 28, _r$9 === _r$9 ? _r$9 : $throwRuntimeError("integer divide by zero")) + 1 >> 0;
		_arg$3 = time.UTC;
		_r$11 = time.Date(_arg, _arg$1, _arg$2, 12, 0, 0, 0, _arg$3); /* */ $s = 10; case 10: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
		time.Time.copy(person.birthDate, _r$11);
		_r$13 = rand.Int(); /* */ $s = 11; case 11: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
		person.lastName = (x$1 = lists.ItalianSurnames, x$2 = (_r$12 = _r$13 % lists.ItalianSurnames.$length, _r$12 === _r$12 ? _r$12 : $throwRuntimeError("integer divide by zero")), ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2]));
		_r$15 = rand.Int(); /* */ $s = 12; case 12: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
		birthInfo = $clone((x$3 = lists.BirthInfo, x$4 = (_r$14 = _r$15 % lists.BirthInfo.$length, _r$14 === _r$14 ? _r$14 : $throwRuntimeError("integer divide by zero")), ((x$4 < 0 || x$4 >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + x$4])), structType$1);
		person.town = birthInfo.Paese;
		person.townCode = birthInfo.CodiceCatasto;
		person.birthDistrict = birthInfo.Provincia;
		_r$16 = randString((new sliceType$4($stringToRunes("1234567890"))), 9); /* */ $s = 13; case 13: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
		person.mobilePhone = "3" + _r$16;
		$s = -1; return person;
		/* */ } return; } if ($f === undefined) { $f = { $blk: NewPerson }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._arg$3 = _arg$3; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f.age = age; $f.birthInfo = birthInfo; $f.maxage = maxage; $f.minage = minage; $f.names = names; $f.person = person; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.NewPerson = NewPerson;
	Person.ptr.prototype.FirstName = function() {
		var p;
		p = this;
		return p.firstName;
	};
	Person.prototype.FirstName = function() { return this.$val.FirstName(); };
	Person.ptr.prototype.LastName = function() {
		var p;
		p = this;
		return p.lastName;
	};
	Person.prototype.LastName = function() { return this.$val.LastName(); };
	Person.ptr.prototype.Gender = function() {
		var p;
		p = this;
		if (p.genderIsFemale) {
			return "Donna";
		}
		return "Uomo";
	};
	Person.prototype.Gender = function() { return this.$val.Gender(); };
	Person.ptr.prototype.BirthDate = function() {
		var _r, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_r = $clone(p.birthDate, time.Time).Format(new DateFormat($pkg.LocalizDate).Format()); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.BirthDate }; } $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.BirthDate = function() { return this.$val.BirthDate(); };
	Person.ptr.prototype.BirthTown = function() {
		var p;
		p = this;
		return p.town;
	};
	Person.prototype.BirthTown = function() { return this.$val.BirthTown(); };
	Person.ptr.prototype.BirthDistrict = function() {
		var p;
		p = this;
		return p.birthDistrict;
	};
	Person.prototype.BirthDistrict = function() { return this.$val.BirthDistrict(); };
	Person.ptr.prototype.Phone = function() {
		var p;
		p = this;
		return p.mobilePhone;
	};
	Person.prototype.Phone = function() { return this.$val.Phone(); };
	Person.ptr.prototype.ID = function() {
		var _arg, _arg$1, _r, _r$1, _r$2, _r$3, _r$4, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!(p.id === "")) {
			$s = -1; return p.id;
		}
		_r$1 = rand.Int(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_arg = new $String(($encodeRune("QWERTYUIOPASDFGHJKLZXCVBNM".charCodeAt((_r = _r$1 % 26, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))))));
		_r$3 = rand.Int(); /* */ $s = 2; case 2: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_arg$1 = new $Int((_r$2 = _r$3 % 10000000, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero")));
		_r$4 = fmt.Sprintf("A%s%d", new sliceType$3([_arg, _arg$1])); /* */ $s = 3; case 3: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		p.id = _r$4;
		$s = -1; return p.id;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.ID }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.ID = function() { return this.$val.ID(); };
	Person.ptr.prototype.String = function() {
		var _entry, _i, _r, _r$1, _r$2, _r$3, _ref, _tuple, _tuple$1, _tuple$2, _tuple$3, buf, field, m, p, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; buf = $f.buf; field = $f.field; m = $f.m; p = $f.p; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_r = p.toMap(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		m = _r;
		_r$1 = regexp.MustCompile("([a-z])([A-Z]+)"); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		re = _r$1;
		buf = new bytes.Buffer.ptr(sliceType$5.nil, 0, 0, arrayType.zero());
		_ref = fields;
		_i = 0;
		/* while (true) { */ case 3:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 4; continue; }
			field = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r$2 = re.ReplaceAllString(field, "$1 $2"); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_r$3 = buf.WriteString(_r$2); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			_tuple = _r$3;
			_tuple$1 = buf.WriteString(": ");
			_tuple$2 = buf.WriteString((_entry = m[$String.keyFor(field)], _entry !== undefined ? _entry.v : ""));
			_tuple$3 = buf.WriteString(",\n");
			_i++;
		/* } */ $s = 3; continue; case 4:
		$s = -1; return buf.String();
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.String }; } $f._entry = _entry; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.buf = buf; $f.field = field; $f.m = m; $f.p = p; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.String = function() { return this.$val.String(); };
	Person.ptr.prototype.MarshalJSON = function() {
		var _r, _r$1, _tuple, b, err, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; b = $f.b; err = $f.err; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = sliceType$5.nil;
		err = $ifaceNil;
		p = this;
		_r = p.toMap(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = json.Marshal(new mapType(_r)); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		b = _tuple[0];
		err = _tuple[1];
		$s = -1; return [b, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.MarshalJSON }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.MarshalJSON = function() { return this.$val.MarshalJSON(); };
	Person.ptr.prototype.MarshalXML = function(e, start) {
		var _entry, _i, _keys, _panic, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _ref, e, err, key, p, start, value, x, x$1, x$2, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _panic = $f._panic; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _ref = $f._ref; e = $f.e; err = $f.err; key = $f.key; p = $f.p; start = $f.start; value = $f.value; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		err = [err];
		err[0] = $ifaceNil;
		p = this;
		$deferred.push([(function(err) { return function $b() {
			var _r, r, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			r = $recover();
			/* */ if (!($interfaceIsEqual(r, $ifaceNil))) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!($interfaceIsEqual(r, $ifaceNil))) { */ case 1:
				_r = fmt.Errorf("%v", new sliceType$3([r])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				err[0] = _r;
			/* } */ case 2:
			$s = -1; return;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
		}; })(err), []]);
		_panic = (function(err) { return function(e$1) {
			var e$1;
			if (!($interfaceIsEqual(err[0], $ifaceNil))) {
				$panic(err[0]);
			}
		}; })(err);
		_r = e.EncodeToken(new start.constructor.elem(start)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$r = _panic(_r); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$1 = p.toMap(); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_ref = _r$1;
		_i = 0;
		_keys = $keys(_ref);
		/* while (true) { */ case 4:
			/* if (!(_i < _keys.length)) { break; } */ if(!(_i < _keys.length)) { $s = 5; continue; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				/* continue; */ $s = 4; continue;
			}
			key = _entry.k;
			value = _entry.v;
			_r$2 = e.EncodeToken((x = new xml.StartElement.ptr(new xml.Name.ptr("", key), sliceType$8.nil), new x.constructor.elem(x))); /* */ $s = 6; case 6: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			$r = _panic(_r$2); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$3 = e.EncodeToken((new xml.CharData($stringToBytes(value)))); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			$r = _panic(_r$3); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$4 = e.EncodeToken((x$1 = new xml.EndElement.ptr(new xml.Name.ptr("", key)), new x$1.constructor.elem(x$1))); /* */ $s = 10; case 10: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			$r = _panic(_r$4); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 4; continue; case 5:
		_r$5 = e.EncodeToken((x$2 = new xml.EndElement.ptr($clone(start.Name, xml.Name)), new x$2.constructor.elem(x$2))); /* */ $s = 12; case 12: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		$r = _panic(_r$5); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$6 = e.Flush(); /* */ $s = 14; case 14: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		err[0] = _r$6;
		$s = -1; return err[0];
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  err[0]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Person.ptr.prototype.MarshalXML }; } $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._panic = _panic; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._ref = _ref; $f.e = e; $f.err = err; $f.key = key; $f.p = p; $f.start = start; $f.value = value; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Person.prototype.MarshalXML = function(e, start) { return this.$val.MarshalXML(e, start); };
	Person.ptr.prototype.MarshalCSV = function() {
		var _entry, _i, _r, _ref, f, m, out, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _r = $f._r; _ref = $f._ref; f = $f.f; m = $f.m; out = $f.out; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_r = p.toMap(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		m = _r;
		out = sliceType.nil;
		_ref = fields;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			f = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			out = $append(out, (_entry = m[$String.keyFor(f)], _entry !== undefined ? _entry.v : ""));
			_i++;
		}
		$s = -1; return out;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.MarshalCSV }; } $f._entry = _entry; $f._i = _i; $f._r = _r; $f._ref = _ref; $f.f = f; $f.m = m; $f.out = out; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.MarshalCSV = function() { return this.$val.MarshalCSV(); };
	Person.ptr.prototype.toMap = function() {
		var _entry, _i, _key, _r, _ref, f, p, toret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _key = $f._key; _r = $f._r; _ref = $f._ref; f = $f.f; p = $f.p; toret = $f.toret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		toret = {};
		_ref = fields;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			f = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r = (_entry = printerMap[$String.keyFor(f)], _entry !== undefined ? _entry.v : $throwNilPointerError)(p); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_key = f; (toret || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: _r };
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return toret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.toMap }; } $f._entry = _entry; $f._i = _i; $f._key = _key; $f._r = _r; $f._ref = _ref; $f.f = f; $f.p = p; $f.toret = toret; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.toMap = function() { return this.$val.toMap(); };
	Person.ptr.prototype.Address = function() {
		var _entry, _r, p, randCity, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; p = $f.p; randCity = $f.randCity; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_r = rand.Intn(lists.Cities.$length); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		randCity = $clone((x = lists.Cities, x$1 = _r, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])), lists.City);
		p.locationCode = randCity.Code;
		p.partitaIvaCounty = randCity.Name;
		p.residence = (_entry = lists.Addresses[$String.keyFor(p.partitaIvaCounty)], _entry !== undefined ? _entry.v : "");
		$s = -1; return p.residence;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Person.ptr.prototype.Address }; } $f._entry = _entry; $f._r = _r; $f.p = p; $f.randCity = randCity; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Person.prototype.Address = function() { return this.$val.Address(); };
	DateFormat.prototype.Format = function() {
		var _1, d;
		d = this.$val;
		_1 = ((d >> 0));
		if (_1 === (1)) {
			return "01/02/2006";
		} else if (_1 === (2)) {
			return "2006/01/02";
		} else {
			return "02/01/2006";
		}
	};
	$ptrType(DateFormat).prototype.Format = function() { return new DateFormat(this.$get()).Format(); };
	NewDateFormat = function(fmt$1) {
		var _1, fmt$1;
		_1 = fmt$1;
		if (_1 === ("us")) {
			return 1;
		} else if (_1 === ("ja")) {
			return 2;
		} else {
			return 0;
		}
	};
	$pkg.NewDateFormat = NewDateFormat;
	init$1 = function() {
		var $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = rand.Seed($clone(time.Now(), time.Time).UnixNano()); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init$1 }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	nthdigit = function(num, pos) {
		var _r, num, pos;
		return (_r = ((($flatten64(num)) / math.Pow10(pos) >> 0)) % 10, _r === _r ? _r : $throwRuntimeError("integer divide by zero"));
	};
	randString = function(charSet, length) {
		var _i, _r, _ref, b, charSet, i, length, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; b = $f.b; charSet = $f.charSet; i = $f.i; length = $f.length; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = $makeSlice(sliceType$4, length);
		_ref = b;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			_r = rand.Intn(charSet.$length); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i] = (x = _r, ((x < 0 || x >= charSet.$length) ? ($throwRuntimeError("index out of range"), undefined) : charSet.$array[charSet.$offset + x])));
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return ($runesToString(b));
		/* */ } return; } if ($f === undefined) { $f = { $blk: randString }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.b = b; $f.charSet = charSet; $f.i = i; $f.length = length; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	ptrType$1.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$3.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$5.methods = [{prop: "cin", name: "cin", pkg: "github.com/empijei/identigen/identities", typ: $funcType([], [$String], false)}, {prop: "bban", name: "bban", pkg: "github.com/empijei/identigen/identities", typ: $funcType([], [$String], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "cd", name: "cd", pkg: "github.com/empijei/identigen/identities", typ: $funcType([], [$String], false)}];
	Person.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "MarshalCSV", name: "MarshalCSV", pkg: "", typ: $funcType([], [sliceType], false)}];
	ptrType.methods = [{prop: "CartaCredito", name: "CartaCredito", pkg: "", typ: $funcType([], [ptrType$1], false)}, {prop: "CodiceFiscale", name: "CodiceFiscale", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Credentials", name: "Credentials", pkg: "", typ: $funcType([], [ptrType$2], false)}, {prop: "DrivingLicense", name: "DrivingLicense", pkg: "", typ: $funcType([], [ptrType$3], false)}, {prop: "IBAN", name: "IBAN", pkg: "", typ: $funcType([], [ptrType$5], false)}, {prop: "PartitaIva", name: "PartitaIva", pkg: "", typ: $funcType([], [$String, $String], false)}, {prop: "FirstName", name: "FirstName", pkg: "", typ: $funcType([], [$String], false)}, {prop: "LastName", name: "LastName", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Gender", name: "Gender", pkg: "", typ: $funcType([], [$String], false)}, {prop: "BirthDate", name: "BirthDate", pkg: "", typ: $funcType([], [$String], false)}, {prop: "BirthTown", name: "BirthTown", pkg: "", typ: $funcType([], [$String], false)}, {prop: "BirthDistrict", name: "BirthDistrict", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Phone", name: "Phone", pkg: "", typ: $funcType([], [$String], false)}, {prop: "ID", name: "ID", pkg: "", typ: $funcType([], [$String], false)}, {prop: "MarshalJSON", name: "MarshalJSON", pkg: "", typ: $funcType([], [sliceType$5, $error], false)}, {prop: "MarshalXML", name: "MarshalXML", pkg: "", typ: $funcType([ptrType$7, xml.StartElement], [$error], false)}, {prop: "toMap", name: "toMap", pkg: "github.com/empijei/identigen/identities", typ: $funcType([], [mapType], false)}, {prop: "Address", name: "Address", pkg: "", typ: $funcType([], [$String], false)}];
	DateFormat.methods = [{prop: "Format", name: "Format", pkg: "", typ: $funcType([], [$String], false)}];
	CartaCredito.init("", [{prop: "Number", name: "Number", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Cvv", name: "Cvv", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Issuer", name: "Issuer", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "ExpDate", name: "ExpDate", anonymous: false, exported: true, typ: $String, tag: ""}]);
	ccSeed.init("github.com/empijei/identigen/identities", [{prop: "issuer", name: "issuer", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "base", name: "base", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "delta", name: "delta", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "bodylength", name: "bodylength", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "cvvlength", name: "cvvlength", anonymous: false, exported: false, typ: $Int, tag: ""}]);
	Credentials.init("", [{prop: "Username", name: "Username", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Password", name: "Password", anonymous: false, exported: true, typ: $String, tag: ""}]);
	DrivingLicense.init("", [{prop: "Number", name: "Number", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Issuer", name: "Issuer", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "ExpDate", name: "ExpDate", anonymous: false, exported: true, typ: $String, tag: ""}]);
	printer.init("github.com/empijei/identigen/identities", [{prop: "fieldName", name: "fieldName", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "function$1", name: "function", anonymous: false, exported: false, typ: funcType, tag: ""}]);
	Iban.init("github.com/empijei/identigen/identities", [{prop: "BankName", name: "BankName", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "Iban", name: "Iban", anonymous: false, exported: true, typ: $String, tag: ""}, {prop: "abi", name: "abi", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "cab", name: "cab", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "cc", name: "cc", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "cinCache", name: "cinCache", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "bbanCache", name: "bbanCache", anonymous: false, exported: false, typ: $String, tag: ""}]);
	Person.init("github.com/empijei/identigen/identities", [{prop: "firstName", name: "firstName", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "lastName", name: "lastName", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "genderIsFemale", name: "genderIsFemale", anonymous: false, exported: false, typ: $Bool, tag: ""}, {prop: "birthDate", name: "birthDate", anonymous: false, exported: false, typ: time.Time, tag: ""}, {prop: "town", name: "town", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "townCode", name: "townCode", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "birthDistrict", name: "birthDistrict", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "residence", name: "residence", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "drv", name: "drv", anonymous: false, exported: false, typ: ptrType$3, tag: ""}, {prop: "fiscalCode", name: "fiscalCode", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "partitaIva", name: "partitaIva", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "locationCode", name: "locationCode", anonymous: false, exported: false, typ: $Int, tag: ""}, {prop: "partitaIvaCounty", name: "partitaIvaCounty", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "cc", name: "cc", anonymous: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "mobilePhone", name: "mobilePhone", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "id", name: "id", anonymous: false, exported: false, typ: $String, tag: ""}, {prop: "iban", name: "iban", anonymous: false, exported: false, typ: ptrType$5, tag: ""}, {prop: "up", name: "up", anonymous: false, exported: false, typ: ptrType$2, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = csv.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = json.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = xml.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmt.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = lists.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = big.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = rand.$init(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = regexp.$init(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = time.$init(); /* */ $s = 14; case 14: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.AllFields = sliceType.nil;
		printerMap = false;
		$pkg.LocalizDate = 0;
		ccData = new sliceType$1([new ccSeed.ptr("American Express", 3400, 300, 15, 4), new ccSeed.ptr("Maestro", 6000, 1000, 16, 3), new ccSeed.ptr("MasterCard", 5100, 400, 16, 3), new ccSeed.ptr("Visa", 4000, 1000, 16, 3)]);
		printers = new sliceType$2([new printer.ptr("Nome", $methodExpr(ptrType, "FirstName")), new printer.ptr("Cognome", $methodExpr(ptrType, "LastName")), new printer.ptr("Gender", $methodExpr(ptrType, "Gender")), new printer.ptr("PaeseDiNascita", $methodExpr(ptrType, "BirthTown")), new printer.ptr("ProvinciaDiNascita", $methodExpr(ptrType, "BirthDistrict")), new printer.ptr("Indirizzo", $methodExpr(ptrType, "Address")), new printer.ptr("NumeroDiTelefono", $methodExpr(ptrType, "Phone")), new printer.ptr("DataDiNascita", $methodExpr(ptrType, "BirthDate")), new printer.ptr("CodiceFiscale", $methodExpr(ptrType, "CodiceFiscale")), new printer.ptr("PartitaIva", (function $b(p) {
			var _r, _tuple, p, pi, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; p = $f.p; pi = $f.pi; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r = p.PartitaIva(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			pi = _tuple[0];
			$s = -1; return pi;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._tuple = _tuple; $f.p = p; $f.pi = pi; $f.$s = $s; $f.$r = $r; return $f;
		})), new printer.ptr("ComunePartitaIva", (function $b(p) {
			var _r, _tuple, cpi, p, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; cpi = $f.cpi; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r = p.PartitaIva(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			cpi = _tuple[1];
			$s = -1; return cpi;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._tuple = _tuple; $f.cpi = cpi; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
		})), new printer.ptr("Documento", $methodExpr(ptrType, "ID")), new printer.ptr("Patente", (function $b(p) {
			var _r, _r$1, p, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r = p.DrivingLicense(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r$1 = _r.String(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._r$1 = _r$1; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
		})), new printer.ptr("CartaDiCredito", (function $b(p) {
			var _r, _r$1, p, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r = p.CartaCredito(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r$1 = _r.String(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._r$1 = _r$1; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
		})), new printer.ptr("Iban", (function $b(p) {
			var _r, _r$1, p, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r = p.IBAN(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r$1 = _r.String(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._r$1 = _r$1; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
		})), new printer.ptr("Username", (function $b(p) {
			var _r, p, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r = p.Credentials(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r.Username;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
		})), new printer.ptr("Password", (function $b(p) {
			var _r, p, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r = p.Credentials(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r.Password;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
		}))]);
		fields = generateFilters();
		$r = init(); /* */ $s = 16; case 16: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = init$1(); /* */ $s = 17; case 17: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/empijei/identigen"] = (function() {
	var $pkg = {}, $init, bytes, identities, js, ptrType, funcType, mapType, funcType$1, sliceType, main, RandomPeopleJS, MainModuleJS;
	bytes = $packages["bytes"];
	identities = $packages["github.com/empijei/identigen/identities"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	ptrType = $ptrType(js.Object);
	funcType = $funcType([$Int, $Int, $Int], [ptrType], false);
	mapType = $mapType($String, $emptyInterface);
	funcType$1 = $funcType([mapType], [$String], false);
	sliceType = $sliceType($Uint8);
	main = function() {
		$global.identigen = $externalize($makeMap($String.keyFor, [{ k: "RandomPeople", v: new funcType(RandomPeopleJS) }, { k: "MainModule", v: new funcType$1(MainModuleJS) }]), mapType);
	};
	RandomPeopleJS = function(minage, maxage, count) {
		var _r, _tuple, count, err, maxage, minage, ppl, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; count = $f.count; err = $f.err; maxage = $f.maxage; minage = $f.minage; ppl = $f.ppl; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = identities.RandomPeople(minage, maxage, count); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		ppl = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$panic(err);
		}
		$s = -1; return js.MakeWrapper(ppl);
		/* */ } return; } if ($f === undefined) { $f = { $blk: RandomPeopleJS }; } $f._r = _r; $f._tuple = _tuple; $f.count = count; $f.err = err; $f.maxage = maxage; $f.minage = minage; $f.ppl = ppl; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.RandomPeopleJS = RandomPeopleJS;
	MainModuleJS = function(args) {
		var _entry, _i, _key, _keys, _r, _ref, _ref$1, args, err, key, out, value, value$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _key = $f._key; _keys = $f._keys; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; args = $f.args; err = $f.err; key = $f.key; out = $f.out; value = $f.value; value$1 = $f.value$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		out = bytes.NewBuffer(sliceType.nil);
		_ref = args;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			key = _entry.k;
			value = _entry.v;
			_ref$1 = value;
			if ($assertType(_ref$1, $Float64, true)[1]) {
				value$1 = _ref$1.$val;
				_key = key; (args || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: new $Int(((value$1 >> 0))) };
			}
			_i++;
		}
		_r = identities.MainModule(args, out); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$panic(err);
		}
		$s = -1; return ($bytesToString(out.Bytes()));
		/* */ } return; } if ($f === undefined) { $f = { $blk: MainModuleJS }; } $f._entry = _entry; $f._i = _i; $f._key = _key; $f._keys = _keys; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f.args = args; $f.err = err; $f.key = key; $f.out = out; $f.value = value; $f.value$1 = value$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MainModuleJS = MainModuleJS;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = identities.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if ($pkg === $mainPkg) {
			main();
			$mainFinished = true;
		}
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$synthesizeMethods();
var $mainPkg = $packages["github.com/empijei/identigen"];
$packages["runtime"].$init();
$go($mainPkg.$init, []);
$flushConsole();

}).call(this);
//# sourceMappingURL=identigen.js.map
